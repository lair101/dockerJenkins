<T-all>.<boolean>.cardinality = SINGLE
<T-all>.<boolean>.label = boolean
<T-all>.<boolean>.placeHolder.text = booleano
<T-all>.<boolean>.type = ilog.rules.brl.Boolean
<T-all>.<objects>.label = objects
<T-all>.<objects>.placeHolder.text = oggetti
<T-all>.<objects>.separator = ,
<T-all>.cardinality = SINGLE
<T-all>.documentation = 'tutti' significa che tutte le istanze degli oggetti valutati devono soddisfare la condizione (per esempio, se ci sono cinque istanze, le cinque istanze devono soddisfare la condizione). Tutte le istanze degli oggetti saranno passate in quanto oggetti di tipo azione
<T-all>.expression = true
<T-all>.placeHolder = $usePlaceHolder
<T-all>.placeHolder.text = all
<T-all>.style = separator
<T-all>.syntax = bel_array.all
<T-all>.syntaxCode = 17
<T-all>.text = tutti <objects> tali che ( <boolean> )
<T-all>.type = ilog.rules.brl.Boolean
<T-all>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-any>.<boolean>.cardinality = SINGLE
<T-any>.<boolean>.label = boolean
<T-any>.<boolean>.placeHolder.text = booleano
<T-any>.<boolean>.type = ilog.rules.brl.Boolean
<T-any>.<object>.label = object
<T-any>.<object>.placeHolder.text = oggetto
<T-any>.<object>.separator = ,
<T-any>.cardinality = SINGLE
<T-any>.documentation = 'qualsiasi' significa che al meno una delle istanze degli oggetti valutate deve soddisfare la condizione. Tutte le istanze, comprese quelle che non soddisfano la condizione, sono passate in quanto oggetti di tipo azione (ossia, se due delle cinque istanze soddisfano la condizione, allora tutte e cinque saranno passate in quanto oggetti di tipo azione)
<T-any>.expression = true
<T-any>.placeHolder = $usePlaceHolder
<T-any>.placeHolder.text = any
<T-any>.style = separator
<T-any>.syntax = bel_array.any
<T-any>.syntaxCode = 18
<T-any>.text = qualsiasi <object> tale che ( <boolean> )
<T-any>.type = ilog.rules.brl.Boolean
<T-any>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-arrayPluralTarget>.<target>.cardinality = MULTIPLE
<T-arrayPluralTarget>.<target>.label = target
<T-arrayPluralTarget>.<target>.placeHolder.text = bersaglio
<T-arrayPluralTarget>.<target>.semanticFilter = com.ibm.bdsl.runtime.DSLSemanticCheckerHandler(ArrayTargetChecker)
<T-arrayPluralTarget>.<target>.type = ilog.rules.brl.Object
<T-arrayPluralTarget>.<target>.verbalization.article = DEFINITE_ARTICLE
<T-arrayPluralTarget>.placeHolder = $usePlaceHolder
<T-arrayPluralTarget>.placeHolder.text = arrayPluralTarget
<T-arrayPluralTarget>.syntax = bel_array.arrayPluralTarget
<T-arrayPluralTarget>.text = <target>
<T-arraySingularTarget>.<target>.cardinality = SINGLE
<T-arraySingularTarget>.<target>.label = target
<T-arraySingularTarget>.<target>.placeHolder.text = bersaglio
<T-arraySingularTarget>.<target>.semanticFilter = com.ibm.bdsl.runtime.DSLSemanticCheckerHandler(ArrayTargetChecker)
<T-arraySingularTarget>.<target>.type = ilog.rules.brl.Object
<T-arraySingularTarget>.<target>.verbalization.article = NO_ARTICLE
<T-arraySingularTarget>.placeHolder = $usePlaceHolder
<T-arraySingularTarget>.placeHolder.text = arraySingularTarget
<T-arraySingularTarget>.syntax = bel_array.arraySingularTarget
<T-arraySingularTarget>.text = <target>
<T-average>.<number>.cardinality = SINGLE
<T-average>.<number>.label = number
<T-average>.<number>.placeHolder.text = numero
<T-average>.<number>.type = ilog.rules.brl.Number
<T-average>.<objects>.label = objects
<T-average>.<objects>.placeHolder.text = oggetti
<T-average>.<objects>.separator = ,
<T-average>.cardinality = SINGLE
<T-average>.documentation = Restituisce la media tra i valori di un'espressione numerica
<T-average>.expression = true
<T-average>.placeHolder = $usePlaceHolder
<T-average>.placeHolder.text = average
<T-average>.style = separator
<T-average>.syntax = bel_array.average
<T-average>.syntaxCode = 20
<T-average>.text = la media, percorrendo <objects> , tra i valori di ( <number> )
<T-average>.type = ilog.rules.brl.Number
<T-average>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-durationAcross>.<date>.cardinality = SINGLE
<T-durationAcross>.<date>.label = date
<T-durationAcross>.<date>.placeHolder.text = data
<T-durationAcross>.<date>.type = bel_date.date
<T-durationAcross>.<objects>.label = objects
<T-durationAcross>.<objects>.placeHolder.text = oggetti
<T-durationAcross>.<objects>.separator = ,
<T-durationAcross>.cardinality = SINGLE
<T-durationAcross>.documentation = Restituisce il numero di giorni tra il più precoce e il più tardo dei valori di un'espressione di tipo data
<T-durationAcross>.expression = true
<T-durationAcross>.placeHolder = $usePlaceHolder
<T-durationAcross>.placeHolder.text = durationAcross
<T-durationAcross>.style = separator
<T-durationAcross>.syntax = bel_array.durationAcross
<T-durationAcross>.syntaxCode = 21
<T-durationAcross>.text = il numero di giorni, percorrendo <objects> , tra i valori di ( <date> )
<T-durationAcross>.type = ilog.rules.brl.Number
<T-durationAcross>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-expression-Concepts>.<concept>.choices = concepts
<T-expression-Concepts>.<concept>.style = target
<T-expression-Concepts>.placeHolder = $usePlaceHolder
<T-expression-navigation-sentence>.<sentence>.overrideSemanticAction = true
<T-expression-navigation-sentence>.<sentence>.semanticAction = ilog.rules.brl.IlrBRL$CheckNavigationSentence
<T-expression-navigation-sentence>.postProcessor = ilog.rules.brl.IlrBRL$PostProcessor_Sentence
<T-expression-navigation-sentence>.sentence = true
<T-expression-navigation-sentence>.sentence.category = NAVIGATION
<T-expression-navigation-sentence>.typeInfoGetter = ilog.rules.brl.IlrBRL$TypeInfoGetter_Index_0
<T-expression-navigation-sentence>.valueInfoGetter = ilog.rules.brl.IlrBRL$ValueInfoGetter_Sentence
<T-expression-navigation-sentence>.verbalization.article = definite
<T-expression>.placeHolder = $usePlaceHolder
<T-firstB>.<boolean>.cardinality = SINGLE
<T-firstB>.<boolean>.label = boolean
<T-firstB>.<boolean>.placeHolder.text = booleano
<T-firstB>.<boolean>.type = ilog.rules.brl.Boolean
<T-firstB>.<objects>.label = objects
<T-firstB>.<objects>.placeHolder.text = oggetti
<T-firstB>.<objects>.separator = ,
<T-firstB>.cardinality = SINGLE
<T-firstB>.documentation = Restituisce il primo tra i valori di un'espressione di tipo booleano
<T-firstB>.expression = true
<T-firstB>.placeHolder = $usePlaceHolder
<T-firstB>.placeHolder.text = firstB
<T-firstB>.style = separator
<T-firstB>.syntax = bel_array.firstB
<T-firstB>.syntaxCode = 23
<T-firstB>.text = il primo booleano, percorrendo <objects> , tra i valori di ( <boolean> )
<T-firstB>.type = ilog.rules.brl.Boolean
<T-firstB>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-firstD>.<date>.cardinality = SINGLE
<T-firstD>.<date>.label = date
<T-firstD>.<date>.placeHolder.text = data
<T-firstD>.<date>.type = bel_date.date
<T-firstD>.<objects>.label = objects
<T-firstD>.<objects>.placeHolder.text = oggetti
<T-firstD>.<objects>.separator = ,
<T-firstD>.cardinality = SINGLE
<T-firstD>.documentation = Restituisce il primo tra i valori di un'espressione di tipo data
<T-firstD>.expression = true
<T-firstD>.placeHolder = $usePlaceHolder
<T-firstD>.placeHolder.text = firstD
<T-firstD>.style = separator
<T-firstD>.syntax = bel_array.firstD
<T-firstD>.syntaxCode = 24
<T-firstD>.text = la prima data, percorrendo <objects> , tra i valori di ( <date> )
<T-firstD>.type = bel_date.date
<T-firstD>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-firstR>.<number>.cardinality = SINGLE
<T-firstR>.<number>.label = number
<T-firstR>.<number>.placeHolder.text = numero
<T-firstR>.<number>.type = ilog.rules.brl.Number
<T-firstR>.<objects>.label = objects
<T-firstR>.<objects>.placeHolder.text = oggetti
<T-firstR>.<objects>.separator = ,
<T-firstR>.cardinality = SINGLE
<T-firstR>.documentation = Restituisce il primo tra i valori di un'espressione numerica
<T-firstR>.expression = true
<T-firstR>.placeHolder = $usePlaceHolder
<T-firstR>.placeHolder.text = firstR
<T-firstR>.style = separator
<T-firstR>.syntax = bel_array.firstR
<T-firstR>.syntaxCode = 26
<T-firstR>.text = il primo numero, percorrendo <objects> , tra i valori di ( <number> )
<T-firstR>.type = ilog.rules.brl.Number
<T-firstR>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-firstS>.<objects>.label = objects
<T-firstS>.<objects>.placeHolder.text = oggetti
<T-firstS>.<objects>.separator = ,
<T-firstS>.<string>.cardinality = SINGLE
<T-firstS>.<string>.label = string
<T-firstS>.<string>.placeHolder.text = stringa
<T-firstS>.<string>.type = ilog.rules.brl.String
<T-firstS>.cardinality = SINGLE
<T-firstS>.documentation = Restituisce il primo tra i valori di un'espressione di tipo stringa
<T-firstS>.expression = true
<T-firstS>.placeHolder = $usePlaceHolder
<T-firstS>.placeHolder.text = firstS
<T-firstS>.style = separator
<T-firstS>.syntax = bel_array.firstS
<T-firstS>.syntaxCode = 25
<T-firstS>.text = la prima stringa, percorrendo <objects> , tra i valori di ( <string> )
<T-firstS>.type = ilog.rules.brl.String
<T-firstS>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-lastB>.<boolean>.cardinality = SINGLE
<T-lastB>.<boolean>.label = boolean
<T-lastB>.<boolean>.placeHolder.text = booleano
<T-lastB>.<boolean>.type = ilog.rules.brl.Boolean
<T-lastB>.<objects>.label = objects
<T-lastB>.<objects>.placeHolder.text = oggetti
<T-lastB>.<objects>.separator = ,
<T-lastB>.cardinality = SINGLE
<T-lastB>.documentation = Restituisce l'ultimo tra i valori di un'espressione booleana
<T-lastB>.expression = true
<T-lastB>.placeHolder = $usePlaceHolder
<T-lastB>.placeHolder.text = lastB
<T-lastB>.style = separator
<T-lastB>.syntax = bel_array.lastB
<T-lastB>.syntaxCode = 27
<T-lastB>.text = l'ultimo booleano, percorrendo <objects> , tra i valori di ( <boolean> )
<T-lastB>.type = ilog.rules.brl.Boolean
<T-lastB>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-lastD>.<date>.cardinality = SINGLE
<T-lastD>.<date>.label = date
<T-lastD>.<date>.placeHolder.text = data
<T-lastD>.<date>.type = bel_date.date
<T-lastD>.<objects>.label = objects
<T-lastD>.<objects>.placeHolder.text = oggetti
<T-lastD>.<objects>.separator = ,
<T-lastD>.cardinality = SINGLE
<T-lastD>.documentation = Restituisce l'ultimo tra i valori di un'espressione di tipo data
<T-lastD>.expression = true
<T-lastD>.placeHolder = $usePlaceHolder
<T-lastD>.placeHolder.text = lastD
<T-lastD>.style = separator
<T-lastD>.syntax = bel_array.lastD
<T-lastD>.syntaxCode = 28
<T-lastD>.text = l'ultima data, percorrendo <objects> , tra i valori di ( <date> )
<T-lastD>.type = bel_date.date
<T-lastD>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-lastR>.<number>.cardinality = SINGLE
<T-lastR>.<number>.label = number
<T-lastR>.<number>.placeHolder.text = numero
<T-lastR>.<number>.type = ilog.rules.brl.Number
<T-lastR>.<objects>.label = objects
<T-lastR>.<objects>.placeHolder.text = oggetti
<T-lastR>.<objects>.separator = ,
<T-lastR>.cardinality = SINGLE
<T-lastR>.documentation = Restituisce l'ultimo tra i valori di un'espressione numerica
<T-lastR>.expression = true
<T-lastR>.placeHolder = $usePlaceHolder
<T-lastR>.placeHolder.text = lastR
<T-lastR>.style = separator
<T-lastR>.syntax = bel_array.lastR
<T-lastR>.syntaxCode = 30
<T-lastR>.text = l'ultimo numero, percorrendo <objects> , tra i valori di ( <number> )
<T-lastR>.type = ilog.rules.brl.Number
<T-lastR>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-lastS>.<objects>.label = objects
<T-lastS>.<objects>.placeHolder.text = oggetti
<T-lastS>.<objects>.separator = ,
<T-lastS>.<string>.cardinality = SINGLE
<T-lastS>.<string>.label = string
<T-lastS>.<string>.placeHolder.text = stringa
<T-lastS>.<string>.type = ilog.rules.brl.String
<T-lastS>.cardinality = SINGLE
<T-lastS>.documentation = Restituisce l'ultimo tra i valori di un'espressione di tipo stringa
<T-lastS>.expression = true
<T-lastS>.placeHolder = $usePlaceHolder
<T-lastS>.placeHolder.text = lastS
<T-lastS>.style = separator
<T-lastS>.syntax = bel_array.lastS
<T-lastS>.syntaxCode = 29
<T-lastS>.text = l'ultima stringa, percorrendo <objects> , tra i valori di ( <string> )
<T-lastS>.type = ilog.rules.brl.String
<T-lastS>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-maximum>.<date>.cardinality = SINGLE
<T-maximum>.<date>.label = date
<T-maximum>.<date>.placeHolder.text = data
<T-maximum>.<date>.type = bel_date.date
<T-maximum>.<objects>.label = objects
<T-maximum>.<objects>.placeHolder.text = oggetti
<T-maximum>.<objects>.separator = ,
<T-maximum>.cardinality = SINGLE
<T-maximum>.documentation = Restituisce il più tardo tra i valori di un'espressione di tipo data
<T-maximum>.expression = true
<T-maximum>.placeHolder = $usePlaceHolder
<T-maximum>.placeHolder.text = maximum
<T-maximum>.style = separator
<T-maximum>.syntax = bel_array.maximum
<T-maximum>.syntaxCode = 31
<T-maximum>.text = la data più tarda, percorrendo <objects> , tra i valori di ( <date> )
<T-maximum>.type = bel_date.date
<T-maximum>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-maximumR>.<number>.cardinality = SINGLE
<T-maximumR>.<number>.label = number
<T-maximumR>.<number>.placeHolder.text = numero
<T-maximumR>.<number>.type = ilog.rules.brl.Number
<T-maximumR>.<objects>.label = objects
<T-maximumR>.<objects>.placeHolder.text = oggetti
<T-maximumR>.<objects>.separator = ,
<T-maximumR>.cardinality = SINGLE
<T-maximumR>.documentation = Restituisce il massimo tra i valori di un'espressione numerica
<T-maximumR>.expression = true
<T-maximumR>.placeHolder = $usePlaceHolder
<T-maximumR>.placeHolder.text = maximumR
<T-maximumR>.style = separator
<T-maximumR>.syntax = bel_array.maximumR
<T-maximumR>.syntaxCode = 32
<T-maximumR>.text = il massimo, percorrendo <objects> , tra i valori di ( <number> )
<T-maximumR>.type = ilog.rules.brl.Number
<T-maximumR>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-minimum>.<date>.cardinality = SINGLE
<T-minimum>.<date>.label = date
<T-minimum>.<date>.placeHolder.text = data
<T-minimum>.<date>.type = bel_date.date
<T-minimum>.<objects>.label = objects
<T-minimum>.<objects>.placeHolder.text = oggetti
<T-minimum>.<objects>.separator = ,
<T-minimum>.cardinality = SINGLE
<T-minimum>.documentation = Restituisce il più precoce tra i valori di un'espressione di tipo data
<T-minimum>.expression = true
<T-minimum>.placeHolder = $usePlaceHolder
<T-minimum>.placeHolder.text = minimum
<T-minimum>.style = separator
<T-minimum>.syntax = bel_array.minimum
<T-minimum>.syntaxCode = 22
<T-minimum>.text = la data più precoce, percorrendo <objects> , tra i valori di ( <date> )
<T-minimum>.type = bel_date.date
<T-minimum>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-minimumR>.<number>.cardinality = SINGLE
<T-minimumR>.<number>.label = number
<T-minimumR>.<number>.placeHolder.text = numero
<T-minimumR>.<number>.type = ilog.rules.brl.Number
<T-minimumR>.<objects>.label = objects
<T-minimumR>.<objects>.placeHolder.text = oggetti
<T-minimumR>.<objects>.separator = ,
<T-minimumR>.cardinality = SINGLE
<T-minimumR>.documentation = Restituisce il minimo tra i valori di un'espressione numerica
<T-minimumR>.expression = true
<T-minimumR>.placeHolder = $usePlaceHolder
<T-minimumR>.placeHolder.text = minimumR
<T-minimumR>.style = separator
<T-minimumR>.syntax = bel_array.minimumR
<T-minimumR>.syntaxCode = 33
<T-minimumR>.text = il minimo, percorrendo <objects> , tra i valori di ( <number> )
<T-minimumR>.type = ilog.rules.brl.Number
<T-minimumR>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-select>.<boolean>.cardinality = SINGLE
<T-select>.<boolean>.label = boolean
<T-select>.<boolean>.placeHolder.text = booleano
<T-select>.<boolean>.type = ilog.rules.brl.Boolean
<T-select>.<object>.label = object
<T-select>.<object>.placeHolder.text = oggetto
<T-select>.<object>.separator = ,
<T-select>.cardinality = SINGLE
<T-select>.documentation = 'scegli qualsiasi' significa che al meno una delle istanze degli oggetti valutate deve soddisfare la condizione. Solo le istanze che soddisfano la condizione sono passate in quanto oggetti di tipo azione (ossia, se due delle cinque istanze soddisfano la condizione, allora tutte e cinque saranno passate in quanto oggetti di tipo azione)
<T-select>.expression = true
<T-select>.placeHolder = $usePlaceHolder
<T-select>.placeHolder.text = select
<T-select>.style = separator
<T-select>.syntax = bel_array.select
<T-select>.syntaxCode = 19
<T-select>.text = scegli qualsiasi <object> tale che ( <boolean> )
<T-select>.type = ilog.rules.brl.Boolean
<T-select>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
<T-sum>.<number>.cardinality = SINGLE
<T-sum>.<number>.label = number
<T-sum>.<number>.placeHolder.text = numero
<T-sum>.<number>.type = ilog.rules.brl.Number
<T-sum>.<objects>.label = objects
<T-sum>.<objects>.placeHolder.text = oggetti
<T-sum>.<objects>.separator = ,
<T-sum>.cardinality = SINGLE
<T-sum>.documentation = Restituisce la somma tra i valori di un'espressione numerica
<T-sum>.expression = true
<T-sum>.placeHolder = $usePlaceHolder
<T-sum>.placeHolder.text = sum
<T-sum>.style = separator
<T-sum>.syntax = bel_array.sum
<T-sum>.syntaxCode = 34
<T-sum>.text = la somma, percorrendo <objects> , tra i valori di ( <number> )
<T-sum>.type = ilog.rules.brl.Number
<T-sum>.typeInfoGetter = com.ibm.bdsl.runtime.DSLSemanticExtension$TypeInfoGetter_Expression
