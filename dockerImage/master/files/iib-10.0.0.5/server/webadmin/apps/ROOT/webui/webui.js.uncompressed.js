/*
*  <copyright 
*  notice="lm-source" 
*  pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
*  years="2011,2016" 
*  crc="2547500599" > 
*  Licensed Materials - Property of IBM  
*   
*  5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
*   
*  (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
*  </copyright> 
*/
require({cache:{
'webui/config/Resources':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="2048966076" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define({
	
	
	logout:{
		url:"/apiv1/logout"
	},
	
	help:{
		url:"http://www.ibm.com/support/knowledgecenter/SSMKHH_10.0.0/com.ibm.etools.msgbroker.helphome.doc/help_home_msgbroker.htm",
		businessTransactionInWebUI: "http://www.ibm.com/support/knowledgecenter/SSMKHH_10.0.0/com.ibm.etools.mft.doc/bj23075_.htm",
		businessTransactionConcept: "http://www.ibm.com/support/knowledgecenter/SSMKHH_10.0.0/com.ibm.etools.mft.doc/bj23085_.htm",
		monitoringEventsUrl: "http://www.ibm.com/support/knowledgecenter/SSMKHH_10.0.0/com.ibm.etools.mft.doc/ac37850_.htm",
		eventCorrelationUrl: "http://www.ibm.com/support/knowledgecenter/SSMKHH_10.0.0/com.ibm.etools.mft.doc/ac60389_.htm"
	},
	
	currentUser:{
		url:"/apiv1/security/currentuser",
		profile:"/webui/profile.html"
	},
	
	REST:{		
		// ROOT FOR THE TREE
		root:"/apiv1",
			
		// HOME PAGE
		nodeHome: "broker/0",

		//SERVER (previously known as execution group)
		executionGroupType  : "executionGroup",
		executionGroupsType : "executionGroups",
		executionGroupsTypeUri : "executiongroups",
		
		//APPLICATIONS
		applicationType  : "application",
		applicationsType : "applications",
		
		//SERVICES
		serviceType  : "service",
		servicesType : "services",
    
    //RESTAPIS
    restApiType  : "restApi",
    restApisType : "restApis",
    restApisTypeUri : "restapis",
	
		//LIBRARIES
		libraryType   : "library",
		librariesType : "libraries",
		
		//SHARED LIBRARIES
		sharedLibraryType   : "sharedLibrary",
		sharedLibrariesType : "sharedLibraries",
		
		//flows
		messageFlowType  : "messageFlow",
		messageFlowsType : "messageFlows",
		messageFlowsTypeUri : "messageflows",
		
		// DATA VIEWER
		dataCaptureStore : "/apiv1/data/datacapture/",
		dataPageNumber : "pageNumber=",		
		dataEntriesReturned : "numberOfEntriesPerPage=",
		comboBoxReplayDestinations : "/apiv1/policy/configurableservices/DataDestination",
		
		// MESSAGE FLOWS
		messageFlowProperties: "properties",
		messageFlowLongDesc: "longDesc",
		
		// MONITORING
		adminLog : "/apiv1/monitoring/adminlog",
		
		// ACTIVITY LOG
		activityLog : "/activitylog",
		
		// STATISTICS
		allFlowsURI: "/apiv1/executiongroups",
		allFlowsDepth: "?depth=10",
		
		// BUSINESS TRANSACTION
		businessTransactionsHome: "businessTransactions/0/business/businesstransactions",
		businessTransactionDefinition: "businessTransaction/0/business/businesstransactions/",
		businessTransactionDefinitionConfig: "businessTransaction/1/business/businesstransactions/",
		monitoringEventsURI: "/apiv1/monitoring/events/?",
		monitoringEventsFlow: "publisherURI=",
		allEventDetails: "depth=2",
		businessTransactions: "/apiv1/business/businesstransactions/",
		allBTDDetails: "?depth=2",
		businessTransactionRecorderPolicies: "/apiv1/policy/businesstransactionrecorders/",
		businessTransactionRecorderPoliciesFilter: "?businessTransactionName=",
		businessTransactionRecorderServers: "/apiv1/executiongroups",
		businessType: "business",
	  businessRecordersType: "businessTransactionRecorders",
    businessRecorderType: "businessTransactionRecorder",
  	businessTransactionType: "businessTransaction",
		businessTransactionsType: "businessTransactions",
    businessTransactionInstance: "businessTransaction/0",
    businessRecorderInstance: "businessTransactionRecorder/0",
		businessEvents: {
		  "progress":"progressBusinessEvents",
		  "start":"startBusinessEvents",
		  "end": "endBusinessEvents",
		  "fail": "failBusinessEvents"
		},
    businesstransactionrecorders: "/apiv1/policy/businesstransactionrecorders/",
		// BUSINESS DATA CAPTURE RESULTS
		businessStoreResults: "/apiv1/data/businessdata/",
    businessResults: "/Results/",
    businessResultsEvents: "/Events/",
    
		businessTransactionMonitoringResults: {
		  definitionId : "definitionId",
		  pageNumber : "pageNumber",
		  entriesPerPage : "numberOfEntriesPerPage"
		},
		
		businessTransactionResultParameter: {
		  id: "id",
		  startTimestamp: "startTimestamp",
		  lastUpdateTimestamp: "lastUpdateTimestamp",
		  elapsedTimestamp: "elapsedTimestamp",
		  status: "status"
		},
		
		businessTransactionResultsPageSize : 1000,
		
		configurableService: "configurableService",
		configurableServiceTypes: "configurableServiceTypes",
		
		// POLICY
		policy: "policy",
		dataCapturePolicyType: "DataCapture",
		dataCapturePolicy: "/apiv1/policy/DataCapture/",
		defaultDCP: "default",
		
		securityIdentities: "/apiv1/policy/securityidentities/",
		identityType: "type=",
		typeOdbc: "odbc",
		  
		// REST Apis
		egRESTApis: "restapis",
		  
		// PushApis
		pushApisNoStageId : "_DO_NOT_STAGE_",
		pushApisAuthenticate: "pushapis/authenticate",
		pushApisCatalogs: "pushapis/catalogs",
		pushApisProducts: "pushapis/products",
		pushApisPush: "pushapis/pushapi",
		pushApisStage: "pushapis/stageproduct"
	},
	
	websocket:{
	  topicRoot:"IBM/IntegrationBus/",
	  statsTopic:"/Statistics/JSON/SnapShot",
	  resourceStatsTopic:"/Statistics/JSON/Resource",
	  adminNotificationsTopic: "/AdminNotifications"
	},
	
	pageLinks:{
		recordAndReplayPage : "/",
		profilePage : "/webui/profile.html"
	},
	
	regexp:{
	  businessTransactionName : "^[_A-Za-z][_A-Za-z0-9]*$",
	  restApiPushHost: "^[-.A-Za-z0-9]*$",
	  restApiPushPort: "^[0-9]*$",
	  restApiPushVersion: "^[0-9.]*$",
	  restApiProductName: "^[-_0-9a-zA-Z]*$"
	},
	
	businessTransaction:{
		btElementTypeNamespace: "http://www.ibm.com/iib/btm/element#",
		btElementTypeFlow: "flow",
		btEventDoNotFlag: "DoNotFlag",
		btEventProgress: "Progress",
		btEventStart: "Start",
		btEventEnd: "End",
		btEventFailure: "Failure",
		
		// Add flow artifact types
		btAddFlow: "bt_flows",
		btAddApp: "bt_apps",
		btAddService: "bt_services",
		btAddRestApi: "bt_restApis"
	},
  
  // tooltip constants
  btValidation:{
    businessEventsType: "BusinessEvents",
    flowValidationType: "FlowValidation",    
    btValidationType: "BusinessValidation",
    btError: "Error",
    btWarning: "Warning",
    btInfo: "Info"
  },
  
  pubSubTopic:{
    businessTransaction: "bt/currentBT",
    businessTransactionNew: "bt/currentNewBT",
    businessTransactionEvent: "bt/currentBT/event",
    businessTransactionObjectDNDDrop: "/dnd/drop",
    businessTransactionFlowAdd: "bt/currentBT/flowAdded",
    businessTransactionsUpdated: "/bt/btTransactionUpdated",
    businessRecorders: "businessTransactionRecorders",   
    btDetails: "businessTransactionDetails", 
    businessTransactionFilters:
      {
        flows: "bt/flows"
      },
    configurableServiceDeleted: "cs/currentCS/deleted",
    configurableServiceCreated: "cs/currentCS/created",
    configurableServiceUpdated: "cs/currentCS/updated",
    configurableServiceAddCancelled: "cs/currentCS/addCancelled",
    configurableServiceEditCancelled: "cs/currentCS/editCancelled",
    egPropertiesUpdated: "eg/currentEG/updated",
    egPropertiesEditCancelled: "eg/currentEG/editCancelled",
    brokerPropertiesUpdated: "broker/currentBroker/updated",
    brokerPropertiesEditCancelled: "broker/currentBroker/editCancelled",
    messageFlowPropertiesUpdated: "broker/currentMessageFlow/updated",
    messageFlowPropertiesEditCancelled: "broker/currentMessageFlow/editCancelled"	
  },
  
  flowDiagram: {
    businessTransaction: "businessTransactionFlowDiagram",
    policy: "policyFlowDiagram"
  },
  
  // Width sizes track svg widths for rendering the main sprite for D3
  icons: {
    iconsLocation: "/webui/widgets/common/images/",
    icons16px: "16px.png",
    icons16pxWidth: 736,
    icons32px: "32px.png",
    icons32pxWidth: 608
  },
  
  // Empty JSON structures of artifacts
  artifactTemplates: {
    businessTransaction : {
      name: "",
      description: "",
      elements: [],
      links: [],
      businessEvents: {
        progressBusinessEvents: [],
        startBusinessEvents: [],
        endBusinessEvents: [],
        failBusinessEvents: []
      }
    }
  }
	
});

},
'webui/widgets/policy/PolicySaveAsDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63" 
 * years="2014, 2015" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63 
 *  
 * (C) Copyright IBM Corp. 2014, 2015 All Rights Reserved.  
 * </copyright> 
 *
 * 
 * PolicySaveAsDialog widget - widget with a Policy Name attributes
 * 
 */
define(
  "webui/widgets/policy/PolicySaveAsDialog",
  [
    "dojo/text!webui/widgets/policy/templates/PolicySaveAsDialog.html", 
    "dojo/i18n!webui/nls/web", 
    "dojo/_base/declare", 
    "dojox/html/entities",
    "dijit/Dialog",
    "dijit/_TemplatedMixin", 
    "dijit/_WidgetsInTemplateMixin",
    "webui/widgets/common/Trace", 
    "dojo/dom-attr",
    "dojo/keys",
    "dojo/_base/event",
    "dojo/on",
    "dojo/_base/lang",
    "dojo/dom-class"
  ], 
  function( 
    template, 
    NLS, 
    declare,
    entities,
    Dialog,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    Trace,
    attr,
    keys,
    event,
    on,
    lang,
    domClass
  ) {

  var policySaveAsDialog = declare("webui.widgets.policy.PolicySaveAsDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {    
    templateString : template,
    _namesInUse : [],
    _firstTimeValidation : false,
    _nameChangedEventHandle : null,
    _policyOKLabel: NLS.okButtonLabel,
    _policyCancelLabel: NLS.cancelButtonLabel,
    _buttonCancel: NLS.cancelButtonLabel,
    _policyNameLabel: NLS.policyNameLabel,    
    
    _onKey : function(evt) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onKey");
      this.inherited(arguments);
      if (evt.charOrCode) {
        if (evt.charOrCode === keys.ENTER) {
          if ( !this._okButton.get("disabled" ) ) {
            event.stop(evt);
            this.onExecute();
          }
        }
      }
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onKey");
    },

    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      this.titleNode.setAttribute("tabIndex", -1);
      this.instructionNode.setAttribute("tabIndex", -1);
            
      this._policyNameText.set("value", "");
      
      on(this, "execute", lang.hitch(this, function() {
         // Xhr put
         if (this.createCallback){
           this.createCallback.apply();
         }
         this._nameChangedEventHandle.remove();
         this.hide();
      }));
      on(this._cancelButton, "click", lang.hitch(this, function() {
        this._nameChangedEventHandle.remove();
        this.hide();
      }));

      this._nameChangedEventHandle = on(this._policyNameText, "change", lang.hitch(this, this.nameChanged));
        
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },
        
    refresh : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "refresh");

      this._nameChangedEventHandle.remove();
      
      if (this._value != null) {
       //Set the flag value to detect if the dialog has been just opened.
        this._firstTimeValidation = true; 
      }
      this._policyNameText.focus();
      this._okButton.set("disabled", true);
      this._firstTimeValidation = true;
      this._nameChangedEventHandle = on(this._policyNameText, "change", lang.hitch(this, this.nameChanged));
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "refresh");
    },
    
    // This gets called every time the content of the name box changes, i.e. whenever a keystroke is pressed
    nameChanged : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "nameChanged");
    
      var value = this._policyNameText.get("value");

      if (!value || value === "") {
        if ( !this._firstTimeValidation) {
          this._okButton.set("disabled", true);
          //Only set the error message when the dialog is not displayed for the first time
          attr.set(this.instructionNode, "innerHTML", entities.encode(NLS.policyNameEmptyErrorMsg));
          domClass.add(this.instructionDiv, "policyDialogWarningText");   
        }
      } else {
        
        // Check that the name is valid in terms of allowed characters
   	    var charsNotAllowed = /[\u0020\u0022\u0027\u003B\u007B\u0060\u007D\u005B-\u005E?:@&=$,<>~#()|^=+-.*!%'"\/\\]+/;
  	  	var isValid = true;
        
  	  	var i;
  	  	if ((value.length > 0) && (value!= '')) {
            i = 0;

            while (i < value.length) {
        	  if (value.charAt(i).match(charsNotAllowed)) {
                  isValid = false;
                  break;
        	  }
        	  i++;
            }
        }
    	  
   	    if (isValid){    	  
          var inUse = false;
          i = 0;
          while((!inUse) && (i < this._namesInUse.length)) {
            if (value === this._namesInUse[i]) {
              inUse = true;
            }
            i++;
          }

          this._okButton.set("disabled", inUse);
          if (inUse) 
          {
            if (!this._firstTimeValidation)
            {
              //Only set the error message when the dialog is not displayed for the first time
              attr.set(this.instructionNode, "innerHTML", entities.encode(NLS.policyNameDuplicateErrorMsg));
              domClass.add(this.instructionDiv, "policyDialogWarningText");
            }
          } else {
            // The name is valid
        	attr.set(this.instructionNode, "innerHTML", entities.encode(NLS.policySaveAsDescription));
            domClass.remove(this.instructionDiv, "policyDialogWarningText");
          }
        } else {
          this._okButton.set("disabled", true);
          domClass.add(this.instructionDiv, "policyDialogWarningText");
          attr.set(this.instructionNode, "innerHTML", entities.encode(NLS.policyNameInvalidCharacterErrorMsg));
        }
      }
      
      //reset the variable that was set from refresh so that the nameChanged would work
      this._firstTimeValidation = false; 

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "nameChanged");
    }

  });
	return policySaveAsDialog;
});

},
'webui/widgets/executiongroup/ResourceStatisticsGrid':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2013,2016" 
 * crc="1195428145" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/_base/array",
  "dojo/_base/lang",
  "dojo/_base/declare", 
  "dojo/data/ItemFileWriteStore",
  "dojo/string",  
  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase", 
  "dijit/_WidgetsInTemplateMixin",
  "dojox/grid/DataGrid",
  "webui/widgets/common/Trace", 
  "dojo/text!webui/widgets/executiongroup/templates/ResourceStatisticsGrid.html",
  "dojo/i18n!webui/nls/web",
  "dojo/text!webui/config/ResourceTypeGridLayouts.json",
  "dojo/domReady!"
], function(
  array,
  lang,
  declare,
  ItemFileWriteStore,
  string,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,  
  DataGrid,
  Trace,
  template,
  NLS,
  gridLayoutsJson) {
    
  return declare("webui.widgets.executiongroup.ResourceStatisticsGrid", [ _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin  ], {
    templateString : template,
    _currentResourceType: "JVM",
    _currentResourceIds: ["Summary"],
    _legendColorMap: {},
    _backgroundColorStyleTemplate: "background-color: ${color};",

    /**
     * The constructor initializes the grid layout configuration for the dojo
     * data grid widget.  It adds the relevant translations to each field
     */
    constructor: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");

      /*
       * Parse the JSON blob that defines the grid layout for each of the 
       * resource types.
       */ 
      this._gridLayouts = JSON.parse(gridLayoutsJson);
      Object.keys(this._gridLayouts).forEach(lang.hitch(this, function(resourceTypeKey) {
        // Add the translated name for each field into the config 
        var fields = this._gridLayouts[resourceTypeKey][0];
        array.forEach(fields, lang.hitch(this, function(fieldConfig) {
          fieldConfig.name = NLS[fieldConfig.field];
        })); // FOREACH

        // Add a legend field as the first entry the config 
        var legendFieldConfig = {
          field: "legend",
          width: "1%",
          name: " ",
          formatter: lang.hitch(this, function(value, rowIndex, cell) {
            return this._formatLegendCell(value, rowIndex, cell);
          })
        };
        fields.splice(0, 0, legendFieldConfig);
      })); // FOREACH
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
    },
    
    /**
     * The postCreate function creates and initializes the dojo data grid. 
     */
    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      /*
       * Iterate over grid layouts for each resource type and create a Dojo data
       * store for each one.  We use the "name" attribute for each 
       * resourceIdentifier to uniquely identify each entry in the store.
       */
      this._gridDataStores = {};
      for (var resourceTypeKey in this._gridLayouts) {
        if(!this._gridLayouts.hasOwnProperty(resourceTypeKey)) {
          continue;
        }
        var gridData = {identifier: "name", items: []};
        var gridDataStore = new ItemFileWriteStore({data : gridData});
        this._gridDataStores[resourceTypeKey] = gridDataStore;
      } // FOR

      /* 
       * Now create the data grid.  We use the currentResourceType attribute
       * to determine the initial layout and data store to use.  This defaults
       * to "JVM".
       */
      this.resourceStatsGrid = new DataGrid({
        store : this._gridDataStores[this._currentResourceType],
        "id" : "resourceStatsGrid",
        structure : this._gridLayouts[this._currentResourceType],
        autoHeight: true,
        className: "statisticsTable",
        columnReordering : false,
        escapeHTMLInData : true,
        selectable : true,
        selectionMode: "multiple",
        keepSelection: true,
        sortInfo : -2,
        canSort: function(columnIndex) {
          return (Math.abs(columnIndex) !== 1);
        },
        onSelectionChanged: lang.hitch(this, function() {
          this.onResourceSelected(this.getCurrentResourceIds());
          this.resourceStatsGrid.render();
        }),
        onSelected: lang.hitch(this, function(rowIndex) {
          // Prevent the user from selecting more than 20 rows
          if (   this.resourceStatsGrid.rowCount > 0 &&
              this.resourceStatsGrid.selection.getSelectedCount() > 20
              ) {
            window.smallMessage.displayMessage("warning", "StatisticsMaxSelected_XX", "", NLS.messages.StatisticsMaxSelectedDescription);
            this.resourceStatsGrid.selection.setSelected(rowIndex, false);
          }
        }),
        onDeselected: lang.hitch(this, function(rowIndex) {
          // Prevent the user from deselecting the final row
          if (   this.resourceStatsGrid.rowCount > 0 &&
              this.resourceStatsGrid.selection.getSelectedCount() == 0
              ) {
            this.resourceStatsGrid.selection.setSelected(rowIndex, true);
          }
        }),
        onRowMouseOver: lang.hitch(this, function(event) {
          if (this.resourceStatsGrid.selection.isSelected(event.rowIndex)) {
            var item = this.resourceStatsGrid.getItem(event.rowIndex);
            var resourceId = this.resourceStatsGrid.store.getValue(item, "name");          
            this.onResourceMouseOver(resourceId);
          }
        }),
        onRowMouseOut: lang.hitch(this, function(event) {
          if (this.resourceStatsGrid.selection.isSelected(event.rowIndex)) {
            var item = this.resourceStatsGrid.getItem(event.rowIndex);
            var resourceId = this.resourceStatsGrid.store.getValue(item, "name");          
            this.onResourceMouseOut(resourceId);          
          }
        })
      }, this._resourceStatsGridDiv);
      this.resourceStatsGrid.startup();
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },

    /**
     * The removeNodesFromTable function removes all of the ndoes from the grid
     * widget.  It does this by creating a clean data store for use by
     * the grid widget, setting this as the store for the widget and forcing the
     * widget to render.
     */
    removeNodesFromTable: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "removeNodesFromTable");

      /*
       * Iterate over all of the resource types that we currently have data
       * stores for and reset each one.
       */
      for (var resourceTypeKey in this._gridDataStores) {
        if(!this._gridDataStores.hasOwnProperty(resourceTypeKey)) {
          continue;
        }
        var gridData = {identifier: "name", items: []};
        var gridDataStore = new ItemFileWriteStore({data : gridData});
        this._gridDataStores[resourceTypeKey] = gridDataStore;
      } // FOR

      // Now update the data grid
      this.resourceStatsGrid.setStore(this._gridDataStores[this._currentResourceType]);
      this.resourceStatsGrid.render();
                        
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "removeNodesFromTable");
    },

    /**
     * The resize function forces the grid widget to resize.
     */
    resize: function(){
      // Resize the grid widget
      this.resourceStatsGrid.resize();
    },

    /**
     * The updateResourceStatsData function updates the data that is currently
     * being displayed by the grid widget with the values passed in. 
     */
    updateResourceStatsData: function(resourceStatsData) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "updateResourceStatsData");

      /*
       * Iterate over the resource statistics for each resource type.  For each
       * resource type update the type specific data store. 
       */ 
      array.forEach(resourceStatsData.ResourceStatistics.ResourceType, lang.hitch(this, function(resourceTypeData){
        var dataStore = this._gridDataStores[resourceTypeData.name];
        var layout = this._gridLayouts[resourceTypeData.name];
        if (dataStore && layout) {
          array.forEach(resourceTypeData.resourceIdentifier, lang.hitch(this, function(data) {
            dataStore.fetchItemByIdentity({identity: data.name,
              onItem: lang.hitch(this, function(item) {
                if(item) {
                  /*
                   * An item with the specified name already exists in the data
                   * store.  We need to update the fields for the item... except
                   * for the name, which cannot be changed in data store.
                   */
                  for (var fieldName in data) {
                    if (fieldName != "name") {
                      dataStore.setValue(item, fieldName,  data[fieldName]);
                    }
                  } // FOR
                } else {
                  /*
                   * An item with the specified name has not been found in the
                   * data store.  Simply create a new item using the current
                   * data.
                   */
                  dataStore.newItem(data);
                }
              }),
              onError: lang.hitch(this, function() {
                Trace.trace(this.declaredClass, Trace.levels.ERROR, "Unable to update resource statistic data");
              })
            });            
          }));
          
          /*
           * The data store should always have been updated, either with a new
           * item or an update to an existing item.  Make sure that the changes
           * are saved.
           */ 
          dataStore.save();
        } // IF - dataStore && layout
      })); 

      /*
       * Because we will always get new resource statistics for every resource
       * type in the execution group, we know that the data currently being
       * displayed will have been updated.  Refresh the data grid to ensure that
       * it displays the latest data. 
       */
      this._refresh();

      /*
       * The first time that this method gets invoked, none of the rows in the 
       * grid will be selected.  Select the summary by default.
       */
      if (  this.resourceStatsGrid.rowCount > 0 &&
         this.resourceStatsGrid.selection.getSelectedCount() == 0
         ) {
        this._selectSummaryRow();
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "updateResourceStatsData");
    },

    /**
     * The getResourceTypes function returns an array of the resource types that
     * the ResourceStatisticsGrid widget is currently configured to display.
     *
     * @return String
     *           The current resource type being displayed.
     */
    getResourceTypes: function() {
      return Object.keys(this._gridLayouts);
    },

    /**
     * The getCurrentResourceType function returns the resource type that is
     * currently being displayed by the data grid. 
     *
     * @return String
     *           The name of the resource type.
     */
    getCurrentResourceType: function() {
      return this._currentResourceType;
    },
    
    /**
     * The setCurrentResourceType function sets the resource type that is
     * displayed by the data grid. 
     *
     * @param resourceType
     *           The name of the resource type.
     */
    setCurrentResourceType: function(/* String */ resourceType) {

      /*
       * Make sure that the specified resource type is different to the current
       * resource type and that it maps to valid resource type, i.e., there is
       * grid layout defined for it.
       */
      if (  this._currentResourceType != resourceType &&
         this._gridLayouts[resourceType]) {
        // Clear the current selection
        this.resourceStatsGrid.selection.clear();

        /*
         * Set the current resource type to the specified.  Reset the list of
         * selected resources ids to just the summary data set.  Update the grid
         * with the correct layout and store for the specified resource type
         * and force a redraw.
         */
        this._currentResourceType = resourceType;
        this._currentResourceIds  = ["summary"]; // Reset the default resource id
        this.resourceStatsGrid.set("structure", this._gridLayouts[this._currentResourceType]);
        this.resourceStatsGrid.setStore(this._gridDataStores[this._currentResourceType]);
        this.resourceStatsGrid.render();
        
        /*
         * Now we need to select the summary row in the grid.  If we cannot find
         * the summary row, simply select the first row in the grid.
         */
        this._selectSummaryRow();
        
        // Finally, fire our "onResourceSelected" event
        this.onResourceSelected(this._currentResourceIds);        
      }
    },
    
    /**
     * The getCurrentResourceIds function returns an array of resource names
     * that identify the items that are currently selected in the data grid.
     *
     * @return Array
     *           An array containing the names of the selected resources.
     */
    getCurrentResourceIds: function() {
      var resourceIds = [];
      if (this.resourceStatsGrid.selection.getSelectedCount() > 0) {
        var selectedItems = this.resourceStatsGrid.selection.getSelected();
        array.forEach(selectedItems, lang.hitch(this, function(selectedItem) {
          if (selectedItem) {
            var name = this.resourceStatsGrid.store.getValue(selectedItem, "name");
            resourceIds.push(name);
          }
        }));
        
        array.forEach(this._currentResourceIds, lang.hitch(this, function(resourceId) {
          if (resourceIds.indexOf(resourceId) == -1) {
            delete this._legendColorMap[resourceId];
          }
        }));
      }
      
      this._currentResourceIds = resourceIds;

      return this._currentResourceIds;
    },

    /**
     * The setResourceLegendColor function sets the background color of the
     * legend cell for the specified resource to the specified color.
     *
     * @param resourceType
     *           The name of the resource type.
     */
    setResourceLegendColor: function(/* String */ resourceId, /* String */ color ) {
      this._legendColorMap[resourceId] = color;
      this.resourceStatsGrid.render();
    },
    
    /**
     * The onResourceSelected function is a callback that can be used by other
     * widgets in order to be notified when the selected resources in the data
     * grid have changed. 
     *
     * @param resourceIds
     *           An array containing the names of the selected resources.
     */
    onResourceSelected: function() {
    },

    /**
     * The onResourceMouseOver function is a callback that can be used by other
     * widgets in order to be notified when the user moves the mouse over a
     * resource (grid row). 
     *
     * @param resourceId
     *           The name of the resource that the mouse has moved over.
     */
    onResourceMouseOver: function() {
    },

    /**
     * The onResourceMouseOut function is a callback that can be used by other
     * widgets in order to be notified when the user moves the mouse away from a
     * resource (grid row). 
     *
     * @param resourceId
     *           The name of the resource that the mouse has moved away from
     */
    onResourceMouseOut: function() {
    },
    
    /**
     * The refresh function refreshes the contents of the grid widget.
     */
    _refresh : function() {
      this.resourceStatsGrid.set("structure", this._gridLayouts[this._currentResourceType]);
      this.resourceStatsGrid.startup();
    },
    
    /**
     * The _selectSummaryRow function attempts to select the summary row in the
     * grid.  If it cannot find the summary row, it defaults to selecting the 
     * first row in the grid instead.
     *  
     */
    _selectSummaryRow: function() {
      // Attempt to fetch the summary row by name
      this.resourceStatsGrid.store.fetchItemByIdentity({identity: "summary",
        onItem: lang.hitch(this, function(item) {
          // Check to see if we found the item
          if(item) {
            // Select the item
            var index = this.resourceStatsGrid.getItemIndex(item);
            this.resourceStatsGrid.selection.setSelected(index, true);
          } else {
            // Could not find the summary row... select the first row
            this.resourceStatsGrid.selection.setSelected(0, true);
          }
        })
      });
    },
    
    /**
     * The _formatLegendCell function formats the content of the legend cell
     * within the grid.  It sets the background color of the cell depending on
     * whether the row containing the cell is selected.  If it is selected, it
     * sets the background color to the color of the corresponding line in the
     * chart.  If it is not selected, it sets the background color to white. 
     */
    _formatLegendCell: function(value, rowIndex, cell) {
      var substitutionArgs = {color: "#FFFFFF"};
      if (this.resourceStatsGrid.selection.isSelected(rowIndex)) {
        var item = this.resourceStatsGrid.getItem(rowIndex);
        var resourceId = this.resourceStatsGrid.store.getValue(item, "name");
        if (this._legendColorMap[resourceId]) {
          substitutionArgs.color = this._legendColorMap[resourceId]; 
        }
      }
      cell.customStyles.push(string.substitute(this._backgroundColorStyleTemplate, substitutionArgs));
      return value;
    }
  });// end declare
});// end define

},
'webui/widgets/msgflows/MessageFlowStatisticsChart':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2013,2016" 
 * crc="1195428145" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/_base/lang",
  "dojo/_base/declare", 
  "dojo/dom-style", 
  "dojo/number",
  "dojo/on",
  "dojo/string",  
  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase", 
  "dijit/_WidgetsInTemplateMixin",
  "dijit/Tooltip",
  "webui/utils/StatsUtils",
  "webui/widgets/common/Trace", 
  "dojo/text!webui/widgets/msgflows/templates/MessageFlowStatisticsChart.html",
  "dojo/i18n!webui/nls/web",

  // Extras
  "d3js",
  "dojo/domReady!"
], function(
  lang,
  declare,
  domStyle,
  number,
  on,
  string,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  Tooltip,
  StatsUtils,
  Trace,
  template,
  NLS
) {
    
  return declare("webui.widgets.msgflows.MessageFlowStatisticsChart", [ _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin  ], {
    templateString : template,
    _defaultMetricIndex: 0,
    _sessionData: null,
    _chartMargins: {top: 5, right: 5, bottom: 20, left: 65},
    _height: 150, 
    _width: 1000,
    _sessionStartTime: null,
    _numberOfSeconds: 0,
    _dataPointTooltipTemplate: "<div class='dataPointTooltipContainer'><div class='dataPointTooltipValue'>${dataSetValue}</div></div>",
    _metricSelectOptions: [
      {label: NLS.statistics.MessagesPerSecond, value: "AverageMessageRate"},
      {label: NLS.statistics.TimePerMessage, value: "AverageElapsedTimePerMessage"},
      {label: NLS.statistics.CPU, value: "AverageCPUTimePerMessage"},
      {label: NLS.statistics.CPUTimeWaitingForInputMessage, value: "CPUTimeWaitingForInputMessage"},
      {label: NLS.statistics.ElapsedTimeWaitingForInputMessage, value: "ElapsedTimeWaitingForInputMessage"},
      {label: NLS.statistics.MaximumCPUTime, value: "MaximumCPUTime"},
      {label: NLS.statistics.MaximumElapsedTime, value: "MaximumElapsedTime"},
      {label: NLS.statistics.MaximumSizeOfInputMessages, value: "MaximumSizeOfInputMessages"},
      {label: NLS.statistics.MinimumCPUTime, value: "MinimumCPUTime"},
      {label: NLS.statistics.MinimumElapsedTime, value: "MinimumElapsedTime"},
      {label: NLS.statistics.MinimumSizeOfInputMessages, value: "MinimumSizeOfInputMessages"},
      {label: NLS.statistics.NumberOfThreadsInPool, value: "NumberOfThreadsInPool"},
      {label: NLS.statistics.TimesMaximumNumberOfThreadsReached, value: "TimesMaximumNumberOfThreadsReached"},
      {label: NLS.statistics.TotalCPUTime, value: "TotalCPUTime"}, //TODO: duplicate of AverageCPUTimePerMessage ?
      {label: NLS.statistics.TotalElapsedTime, value: "TotalElapsedTime"}, // TODO: duplicate of AverageElapsedTimePerMessage?
      {label: NLS.statistics.TotalInputMessages, value: "TotalInputMessages"},// TODO: duplicate of AverageMessageRate?
      {label: NLS.statistics.TotalNumberOfBackouts, value: "TotalNumberOfBackouts"},
      {label: NLS.statistics.TotalNumberOfCommits, value: "TotalNumberOfCommits"},
      {label: NLS.statistics.TotalNumberOfErrorsProcessingMessages, value: "TotalNumberOfErrorsProcessingMessages"},// TODO: duplicate of the to below?
      {label: NLS.statistics.TotalNumberOfMessagesWithErrors, value: "TotalNumberOfMessagesWithErrors"},// TODO: duplicate of above/below?
      {label: NLS.statistics.TotalNumberOfMQErrors, value: "TotalNumberOfMQErrors"},// TODO: duplicate of two above?
      {label: NLS.statistics.TotalNumberOfTimeOutsWaitingForRepliesToAggregateMessages, value: "TotalNumberOfTimeOutsWaitingForRepliesToAggregateMessages"},
      {label: NLS.statistics.TotalSizeOfInputMessages, value: "TotalSizeOfInputMessages"}// TODO: convert to average? 
    ], 
    
    /**
     * The constructor initializes various non-visual components of the
     * widget.
     */
    constructor: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");

      /*
       * Associate the NLS resources with this widget so that we can
       * declaratively reference resources in the template markup. 
       */
      this.NLS = NLS;
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
    },
    
    /**
     * The postCreate function initializes the various visual components of the
     * widget, most notably the SVG canvas for the chart widget. 
     */
    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      // Add the options (metrics) to the select widget
      this._metricSelect.addOption(this._sortOptions(this._metricSelectOptions));
      this._metricSelect.set("value", this._metricSelectOptions[this._defaultMetricIndex].value);
      this._messageFlowStatsChartTitle.innerHTML = this._getSelectedMetricLabel();
      
      this.own(on(this._metricSelect, "change", lang.hitch(this, function() {
        // Set the title for the chart
        this._messageFlowStatsChartTitle.innerHTML = this._getSelectedMetricLabel();
        
        // Remove any existing data points for the old metric
        this._chart.selectAll("circle").remove();

        // Refresh the chart to draw the lines for the new metric
        this.refresh();
      }))); 
      
      /*
       * Now create the D3 chart.  Start by calculating the size of the chart
       * using the placeholder width and height.  This will change once the
       * tab gets focus and the widget is resized... but we need some non-zero
       * values to start with.
       */
      var chartWidth  = this._width  - this._chartMargins.left - this._chartMargins.right;
      var chartHeight = this._height - this._chartMargins.top  - this._chartMargins.bottom;
      
      /*
       * Now define the the scales and axes.  We want to scale the axes so that
       * they fit the width and height of the chart.
       */
      this._xRange = d3.time.scale().range([0, chartWidth]);
      this._yRange = d3.scale.linear().range([chartHeight, 0]);
      this._xAxis = d3.svg.axis().scale(this._xRange)
        .orient("bottom")
        .ticks(5)
        .tickFormat(d3.time.format("%X"))
        .tickSize(-chartHeight)
        .tickSubdivide(true);
      this._yAxis = d3.svg.axis().scale(this._yRange)
        .orient("left")
        .ticks(5)
        .tickSize(-chartWidth)
        .tickSubdivide(true);

      // A line generator, for the dark stroke.
      this._line = d3.svg.line()
//        .interpolate("cardinal") // Smooth the line
        .interpolate("monotone") // Smooth the line
        .x(function(d) { return this._xRange(d.GMTEndTime); })
        .y(function(d) { return this._yRange(this._getMetricValue(d, this._metricSelect.get("value")));});
      
      // An area generator for the fill        
      this._area = d3.svg.area()
//        .interpolate("cardinal") // Smooth the line
        .interpolate("monotone") // Smooth the area      
        .x(function(d) {return this._xRange(d.GMTEndTime);})
        .y0(chartHeight)
        .y1(function(d) {return this._yRange(this._getMetricValue(d, this._metricSelect.get("value")));});
      
      /*
       * Now create the actual chart.  This is actually an SVG element that 
       * fills the space available for the chart.  A g element is then appended
       * as a child of the SVG element and is used to group all of the remaining
       * SVG elements for the chart.  This g element is, in effect, the chart. 
       */
      this._chart = d3.select(this._messageFlowStatsChart).append("svg")
          .attr("id", this.id + "_svg")
          .attr("width", this._width)
          .attr("height", this._height)
        .append("g")
          .attr("transform", "translate(" + this._chartMargins.left + "," + this._chartMargins.top + ")")
          .attr("width", this._width)
          .attr("height", this._height)
          .attr("pointer-events", "all")
          .on("mouseenter", lang.hitch(this, function() {
            this._renderDataPoints();
           }))
           .on("mouseleave", lang.hitch(this, function() {
             this._removeDataPoints();
           }));
      
      // Add the clip path
      this._chart.append("clipPath")
          .attr("id", this.id + "_clip")
        .append("rect")
          .attr("id", this.id + "_clip-rect")
          .attr("width", chartWidth)
          .attr("height", chartHeight);
      
      /*
       * Now create the actual x and y axes for the chart.  If there is no data
       * then simply define some dummy domains to ensure that something sensible
       * is rendered.
       */
      var endTime = this._getDomainEndTime();
      var startTime = this._getDomainStartTime(endTime);
      this._xRange.domain([startTime, endTime]);
      this._yRange.domain([0, 10]).nice();
      this._chartLayer = this._chart.append("g");
      this._chartLayer.append("g")
        .attr("class", "x MessageFlowStatsAxis")
        .attr("transform", "translate(0," + chartHeight + ")")
        .call(this._xAxis)
          .selectAll("text")  
          .attr("y", "10");
      this._chartLayer.append("g")
        .attr("class", "y MessageFlowStatsAxis")
        .call(this._yAxis);

      // Add the line path
      this._chart.append("path")
        .attr("class", "line")
        .attr("clip-path", "url(#" + this.id + "_clip)")
        .attr("d", this._line([]));

      // Add the area with empty data to begin with
      this._chart.append("path")
        .attr("class", "area")
        .attr("clip-path", "url(#" + this.id + "_clip)")
        .attr("d", this._area([]));
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },

    /**
     * The resize function resizes the d3 chart within the widget, taking into
     * account the overall size of the container div and the size of the right
     * hand table.  As part of the resizing, it needs to update the domains for
     * the x and y axes and resize the clipping rect. 
     */
    resize: function(){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");

      // Calculate the width available for use by the d3 chart
      var totalWidth = parseInt(domStyle.getComputedStyle(this._messageFlowStatsChartWidgetContainer).width);
      var tableWidth = parseInt(domStyle.getComputedStyle(this._messageFlowStatsChartRightTable).width);
      this._width = totalWidth - tableWidth - 20;
      var chartWidth  = this._width  - this._chartMargins.left - this._chartMargins.right;
      var chartHeight = this._height - this._chartMargins.top  - this._chartMargins.bottom;

      if(chartWidth >= 0) {
     // Resize the chart
        this._xRange.range([0, chartWidth]);
        d3.select(this._chart.node().parentNode)
          .attr("width", this._width);
        
        // Redraw the x axis
        this._chart.call(this._xAxis.orient("bottom"))
          .selectAll("text")  
          .attr("y", "10");

        /* 
         * Redraw the y axis.  This is a little trickier because the we need to
         * resize the ticks and this is all tied into _yAxis function.  The only
         * way this appears to work is by removing the existing SVG element for
         * the y axis, defining a new _yAxis function and then adding a new SVG
         * element in.
         * 
         */
        this._chart.select(".y.MessageFlowStatsAxis").remove();
        this._yAxis = d3.svg.axis().scale(this._yRange)
          .orient("left")
          .ticks(5)
          .tickSize(-chartWidth)
          .tickSubdivide(true);
        this._chartLayer.append("g")
          .attr("class", "y MessageFlowStatsAxis")
          .call(this._yAxis);
        
        // Resize the clip area
        this._chart.select("#" + this.id + "_clip-rect")
          .attr("width", chartWidth)
          .attr("height", chartHeight);
        
        this.refresh();
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
    },

    /**
     * The refresh function refreshes the chart on the glass using the most
     * recent data available for the session.
     */
    refresh : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "refresh");

      /*
       * Make sure that we have a reference to the session data and that the
       * array actually contains some elements. 
       */
      var startTime;
      var endTime;
      if (this._sessionData && this._sessionData.length > 0) {
        /*
         * Check to see if we are currently showing any data points on the
         * chart and, if we are, add in any new data points that are required
         * for the resource data.
         */
        var circle = this._chart.select("circle");
        if (!circle.empty()) {
          this._renderDataPoints();
        }

        // Animate the changes using a transition
        var t = this._chart.transition().duration(750).ease("linear");

        /*
         * The x axis represents time and is not affected by which resource
         * ids are selected.  Calculate the new extent of the x domain and
         * update the x axis.
         */
        endTime = this._getDomainEndTime();
        startTime = this._getDomainStartTime(endTime);
        this._xRange.domain([startTime, endTime]);
        
        // Calculate the new extent of the y domain
        var metric = this._metricSelect.get("value");
        var dataMax = d3.max(this._sessionData, lang.hitch(this, function(d) {
          return this._getMetricValue(d, metric);
        }));
        var domainMax = dataMax * 1.1; // Add on 10%
        this._yRange.domain([0, domainMax]).nice();
        t.select(".y.MessageFlowStatsAxis").call(this._yAxis);
        
        // Modify the area path
        t.select(".area")
          .attr("d", this._area(this._sessionData))
          .attr("transform", "translate(" + this._xRange(startTime) + ")");
          
        // Modify the line path
        t.select(".line")
          .attr("d", this._line(this._sessionData))
          .attr("transform", "translate(" + this._xRange(startTime) + ")");
        
        t.select(".x.MessageFlowStatsAxis").call(this._xAxis)
          .selectAll("text")
          .attr("y", "10");
        

        /*
         * Check to see if there are any circles drawn for the data points on 
         * the line and, if there are, transform these as part of the same
         * transition.
         */
        var idPrefix = this.id + "_" + this._metricSelect.get("value");
        t.selectAll("circle[id^='" + idPrefix + "']")
          .attr("cx", lang.hitch(this, function(d) {
            return this._xRange(d.GMTEndTime);
          }))
          .attr("cy", lang.hitch(this, function(d) {
            return this._yRange(this._getMetricValue(d, this._metricSelect.get("value")));
          }))
          .attr("transform", "translate(" + this._xRange(startTime) + ")");
        
        /*
         * Update the latest, max, avg and min values in the side table.  For 
         * the min and average values, strip off the dummy element at the start
         * of the data set.
         */
        var slicedData = this._sessionData.slice(1);
        var min = d3.min(slicedData, lang.hitch(this, function(d) {
          return this._getMetricValue(d, metric);
        }));
        var mean = d3.mean(slicedData, lang.hitch(this, function(d) {
          return this._getMetricValue(d, metric);
        })); 
        
        /*
         * Round number up to next decimal place, then force the number 
         * formatting to the desired precision (produces strings)
         */  
        var precision = (metric == "AverageMessageRate") ? 2 : 1;
        var latest = this._sessionData[this._sessionData.length - 1][metric];
        this._latestValue.innerHTML = this._formatNumber(StatsUtils.roundUpToNearest(latest, precision), precision);
        this._highestValue.innerHTML = this._formatNumber(StatsUtils.roundUpToNearest(dataMax, precision), precision);
        this._averageValue.innerHTML = this._formatNumber(StatsUtils.roundUpToNearest(mean, precision), precision);
        this._lowestValue.innerHTML = this._formatNumber(StatsUtils.roundUpToNearest(min, precision), precision);
      } else { // IF - this._sessionData && ...
        /*
         * We have no reference to the session data, or the session data object
         * does not contain any data yet. Remove any existing data points from 
         * the chart, if any.
         */
        this._chart.selectAll("circle").remove();
        
        // Modify the area path
        this._chart.select(".area")
          .attr("d", this._area([]));
          
        // Modify the line path
        this._chart.select(".line")
          .attr("d", this._line([]));

        // Reset the axes
        endTime = this._getDomainEndTime();
        startTime = this._getDomainStartTime(endTime);
        this._xRange.domain([startTime, endTime]);
        this._chart.select(".x.MessageFlowStatsAxis")
          .call(this._xAxis)
          .selectAll("text")
          .attr("y", "10");
        this._yRange.domain([0, 10]).nice();
        this._chart.select(".y.MessageFlowStatsAxis")
          .call(this._yAxis);
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "refresh");
    },

    /**
     * The _renderDataPoints function adds circle elements to the chart to
     * represent each of the pieces of snapshot data for the lines that are
     * being displayed.
     */
    _renderDataPoints: function() {
      /*
       * Make sure that we have a reference to the session data and then 
       * retrieve the resource statistics data for the current selected resource
       * type.
       */
      if (this._sessionData) {
        /*
         * Create a circle to represent each data point in the session data. Add
         * event handlers to the line to handle the mouse enter and leave 
         * events.  These handlers will highlight the data point that the mouse
         * is over and show a tooltip displaying the value the the data point
         * represents. 
         */
        var idPrefix = this.id + "_" + this._metricSelect.get("value");
        var dataPoints = this._chart.selectAll("circle[id^='" + idPrefix + "']")
          .data(this._sessionData)
          .enter()
          .append("circle")
            .attr("r", 3)
            .attr("clip-path", "url(#" + this.id + "_clip)")
            .attr("id", lang.hitch(this, function(d) {
              return idPrefix + "_" + d.GMTEndTime;
            }));
            
        dataPoints.attr("cx", lang.hitch(this, function(d) {
            return this._xRange(d.GMTEndTime);
          }))                
          .attr("cy", lang.hitch(this, function(d) {
            return this._yRange(this._getMetricValue(d, this._metricSelect.get("value")));
          }))
          .on("mouseenter", lang.hitch(this, function(d) {
            var id = idPrefix + "_" + d.GMTEndTime;
            var value = this._getMetricValue(d, this._metricSelect.get("value"));
//            var precision = (this._metricSelect.get("value") == "AverageMessageRate") ? 2 : 2;
            /*
             * Rounding is a little weird when the value is less than 0.1...
             * always round the datapoint hover help values to 2 decimal places.
             */ 
            var formattedValue = this._formatNumber(StatsUtils.roundUpToNearest(value, 2), 2);
            this._chart.select("#" + id).attr("r", 10);
            var substitutionArgs = {dataSetValue: formattedValue};
            Tooltip.show(string.substitute(this._dataPointTooltipTemplate, substitutionArgs), id);
          }))
          .on("mouseleave", lang.hitch(this, function(d) {
            var id = idPrefix + "_" + d.GMTEndTime;
            this._chart.select("#" + id).attr("r", 3);
            Tooltip.hide(id);
          }));
      } // IF - this._sessionData
    },

    /**
     * The _removeDataPoints function removes all of the circle elements that
     * are currently being displayed in the chart.
     */
    _removeDataPoints: function() {
      this._chart.selectAll("circle").remove();
    },
    
    /**
     * The setSessionData function passes a reference to the resource statistics
     * data for the current session.  This widget stores the reference so that
     * it has easy access whenever it needs to refresh.
     *
     * @param sessionData
     *           The resource statistics data for the current session.
     */
    setSessionData: function(/* Object */ sessionData, /* Date */ startTime) {
      this._sessionData = sessionData;
      this._sessionStartTime = startTime;
      this.refresh();
    },
    
    /**
     * The setChartTimeRange function sets the time span over which the chart
     * should display statistics.  The number of seconds specified is how long
     * into the past the graph should display statistics.  The overall time
     * range will be:
     * 
     *   now - numberOfSeconds    
     *
     * @param numberOfSeconds
     *          The number of seconds in the past to display statistics for. 
     */
    setChartTimeRange: function(/* Number */ numberOfSeconds) {

      /*
       * Update the number of seconds attribute in the widget and then refresh
       * the chart.
       */
      this._numberOfSeconds = numberOfSeconds;
      this.refresh();
    },

    /**
     * The setDefaultMetricIndex function sets the index of the metric that will
     * be selected by default whenever the resource type changes. 
     * 
     * @param index
     *          The index of the default metric. 
     */
    setDefaultMetricIndex: function(/* Number */ index) {
      
      /*
       * Make sure that the specified index is different to the index and that
       * it is valid.
       */
      if (this._metricSelectOptions.length > index) {
        this._defaultMetricIndex = index;
        this._metricSelect.set("value", this._metricSelectOptions[this._defaultMetricIndex].value);
        this._messageFlowStatsChartTitle.innerHTML = this._getSelectedMetricLabel();
      }
    },

    /**
     * The _getDomainStartTime function calculates the start time that should
     * be used when defining the domain of the x axis.  If the "time range" is
     * set to session this will be the session start time.  If "time range" is
     * set to a specific time period, e.g., 5 minutes, the value returned is
     * the time of the last update in the data set minus the number of seconds
     * for that time period.
     * 
     * @param endTime
     *          The time of the last update in the data set.
     *          
     * @return startTime
     *           The start time to be used when rendering the x axis... format
     *           is the number of millis since epoch.
     */
    _getDomainStartTime: function(endTime) {
      var startTime = this._sessionStartTime;
      if (this._numberOfSeconds > 0) {
        startTime = endTime - (this._numberOfSeconds * 1000);
      }
      
      return startTime;
    },

    /**
     * The _getDomainEndTime function calculates the end time that should
     * be used when defining the domain of the x axis.  Typically, the value
     * returned is the time of the last update in the data set.  It defaults
     * to the session start time if the data set is empty or the relevant entry
     * cannot be found.
     *          
     * @return endTime
     *           The end time to be used when rendering the x axis... format
     *           is the number of millis since epoch.
     */
    _getDomainEndTime: function() {
      var endTime = this._sessionStartTime;
      if (this._sessionData && this._sessionData.length > 0) {
        var item = this._sessionData[this._sessionData.length - 1];
        endTime = item.GMTEndTime;
      } // IF - this._sessionData && etc...
      
      return endTime;
    },

    /**
     * The _sortOptions function sorts the array of options for the current 
     * resource type based on the current locale of the browser. 
     */
    _sortOptions: function(/* Array */ options) {
      var optionsCopy = lang.clone(options);
      optionsCopy.sort(function(option1, option2) {
        return option1.label.localeCompare(option2.label);
      });
      return optionsCopy;
    },

    /**
     * The _getSelectedMetricLabel function returns the label (as opposed to
     * value) of the currently selected metric in the dijit select widget. 
     */
    _getSelectedMetricLabel: function() {
      // Create the variable to return
      var label = null;
      var selectedMetric = this._metricSelect.get("value");
      for (var i = 0; i < this._metricSelectOptions.length; i++) {
        if (selectedMetric == this._metricSelectOptions[i].value) {
          label = this._metricSelectOptions[i].label;
          break;
        }
      } // FOR
      
      return label;
    },

    /**
     * The _formatNumber function formats numbers (statistics) for display in
     * the side table.
     */
    _formatNumber: function(n, precision){
      return number.format(n, {places: precision});
    },
    
    /**
     * The _getMetricValue function retrieves the value of the specified metric
     * from the item.  If the value is not a valid number it returns 0. 
     */
    _getMetricValue: function(item, metric) {
      // Create the variable to return
      var value = 0;
      
      if (item[metric] && !isNaN(item[metric])) {
        value = item[metric];
      }
      
      return parseFloat(value);
    }
  });// end declare
});// end define

},
'webui/widgets/business/businesstransaction_summary':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63" 
 * years="2013, 2014" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63 
 *  
 * (C) Copyright IBM Corp. 2011, 2012 All Rights Reserved.  
 * </copyright> 
 */

define(
  "webui/widgets/business/businesstransaction_summary",
  [
    "dojo/text!webui/widgets/business/templates/businesstransaction_summary.html",
	  "dojo/i18n!webui/nls/web",
	  "dojo/_base/declare", 
	  "dijit/_WidgetBase", 
	  "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
	  "dojo/_base/lang",
	  "webui/widgets/common/Trace",
	  "webui/config/Resources",
    "dojo/dom",
	  "dojo/dom-construct",
	  "dojo/dom-class",
	  "dojo/_base/array",
	  "dojo/topic",
	
	  // For the HTML template only
    "dijit/form/Textarea"
	],
	function(
	  template, 
	  NLS,
	  declare,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
	  lang,
	  Trace,
	  Resources,
	  dom,
	  construct,
	  domClass,
	  array,
	  Topic
	) {
	    
  var businesstransaction_summary = declare("webui.widgets.business.businesstransaction_summary", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
    templateString: template,
    _eventsArray: null,
    _btName: null,
    _eventHandle: null,
    _businessTransactionNameLabel: NLS.btNameLabel,
    _businessTransactionDescriptionLabel: NLS.btDescriptionLabel,
    _businessTransactionSummaryLabel: NLS.btSummary,
    
  constructor: function(/*Object*/ args){
 	  this._btName = args.name;
    this._businessTransactionNameInput = args.name;
    this._businessTransactionDescriptionInput = args.description;
		this._eventsArray = [];
	  	this._eventHandle = Topic.subscribe(Resources.pubSubTopic.businessTransaction, lang.hitch(this, function(args) {
			if (args.businessEvent) {
			  this.onBusinessEventChanged(args);
  		}
 		}));
 	},
 		            
  postCreate: function() {
		Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
		this.inherited(arguments);
		this._businessTransactionName_Input.attr('regExp', Resources.regexp.businessTransactionName);
	 	Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
	},
	
	destroy: function() {
		Trace.trace(this.declaredClass, Trace.levels.ENTRY, "destroy");
    this.inherited(arguments);
		if (this._eventHandle) {
			this._eventHandle.remove();
		}
		this.widgetContainer.removeChild(this._btxSummaryWidget);		
		
		// Empty the summary content
		this._businessTransactionName_Input.attr('value', null);
		this._businessTransactionDescription_Input.attr('value', null);
		
		Trace.trace(this.declaredClass, Trace.levels.EXIT, "destroy");		
	},
		
	place: function(targetId){
		Trace.trace(this.declaredClass, Trace.levels.ENTRY, "place");
		this.widgetContainer = dom.byId(targetId);
		if (this.widgetContainer) {
		  this._eventsTp.set('title', NLS.btEvents);
		  domClass.add(this._eventsTp.focusNode, "btEventSummaryTitlePane");
		  domClass.add(this._eventsTp.titleBarNode, "btOverviewSectionTitlePane_titleBarNode");
      domClass.add(this._eventsTp.containerNode, "btOverviewSectionTitlePane_containerNode");
      this._correlationTp.set('title', NLS.btCorrelation);
      domClass.add(this._correlationTp.focusNode, "btEventSummaryTitlePane");
      domClass.add(this._correlationTp.titleBarNode, "btOverviewSectionTitlePane_titleBarNode");
      domClass.add(this._correlationTp.containerNode, "btOverviewSectionTitlePane_containerNode");
      this._dataTp.set('title', NLS.btData);
      domClass.add(this._dataTp.focusNode, "btEventSummaryTitlePane");
      domClass.add(this._dataTp.titleBarNode, "btOverviewSectionTitlePane_titleBarNode");
      domClass.add(this._dataTp.containerNode, "btOverviewSectionTitlePane_containerNode");

		  /*
		  this._descriptionTp = new TitlePane({
          title : NLS.btDescription,
          open: false
      });
      attr.set(this._descriptionTp.domNode, "data-test-attrName", "businessDescriptionSection");
      this.widgetContainer.appendChild(this._descriptionTp.domNode);
      */

      this.formatEventsInfo(true);
      
			// temporary
			this.formatCorrelationInfo();	

      // Append the summary widget to the content pane target
      this.widgetContainer.appendChild(this._btxSummaryWidget);
		}
		Trace.trace(this.declaredClass, Trace.levels.EXIT, "place");
	},
	
	populate: function(btName) {
	  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "populate");
	  
	  this._btName = btName;
	  
	  this._businessTransactionName_Input.attr('value', btName);
	  
	  Trace.trace(this.declaredClass, Trace.levels.EXIT, "populate");
	},
	
	onBusinessEventChanged: function (args){
		Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onBusinessEventChanged");
		var be = args.businessEvent;
		var modifiedArray;
		if (be instanceof Array) {
			var btEvent = {"type": be[0], "flow": be[4].uri[0], 
				"event": be[3].eventSourceAddress[0]};
    	
      	modifiedArray = array.filter(this._eventsArray, function(item){
      	  if ((item.flow === btEvent.flow) && (item.event === btEvent.event)) {
      	    return true; 
          }
          else {return false;}
      	});
			
      	array.forEach(modifiedArray, lang.hitch(this,function(item){
				if ((item.flow === btEvent.flow) &&(item.event === btEvent.event)) {
				  var index = this._eventsArray.indexOf(item);
				  // remove the event 
				  this._eventsArray.splice(index, 1);	
				}
	    	}));

        if ((btEvent.type === NLS.btStartRole) ||
      			(btEvent.type === NLS.btEndRole) ||
      			(btEvent.type === NLS.btFailureRole)) {			
  				    this._eventsArray.push(btEvent);
  			}
  		} else { // argument is the uri of the deleted floe
  			  var deletedFlow = be;
  			  modifiedArray = array.filter(this._eventsArray, function(item){
            if (item.flow === deletedFlow) {
              return true; 
            }
            else {return false;}
          });
          array.forEach(modifiedArray, lang.hitch(this,function(item){
            var index = this._eventsArray.indexOf(item);
               // remove the event 
            this._eventsArray.splice(index, 1);  
          }));  			  
  		}
		
		this.formatEventsInfo();
		Trace.trace(this.declaredClass, Trace.levels.EXIT, "onBusinessEventChanged");
	},
		
	formatCorrelationInfo: function() {
		Trace.trace(this.declaredClass, Trace.levels.ENTRY, "formatCorrelationInfo");			
		var text = construct.create("div");
		var t = "Sample Info: Events from the flows in this business transaction definition with the same values for the following fields will be part of the same business transaction instance";
		t = t.concat("<li> $Root/XMLNSC/PO:purchaseOrder[1]/PO:salesNumber from InputOrder.TransactionStart from flow TotalPurchaseOrderFlow</li>");
		t = t.concat("<li> $Root/XMLNSC/orderNumber from InputOrder.TransactionStart from flow CheckStock</li>");
		text.innerHTML = t;		
		this._correlationTp.set("content", text);
		Trace.trace(this.declaredClass, Trace.levels.EXIT, "formatCorrelationInfo");			
	},
		
	formatEventsInfo : function(firstTime) {
		Trace.trace(this.declaredClass, Trace.levels.ENTRY, "formatEventsInfo");						
		var text = construct.create("div", {className: "btEvents"});
		
		if (firstTime || (this._eventsArray.length ==0)) {
		  text.innerHTML= NLS.btEventHint;
      text.className="btEventSummaryHint";
      this._eventsTp.set("content", text);
      return;
		}
		
		var start ="<span style=\"font-weight: bold\">"+ NLS.btStartRole+": </span>";
		var end = "<span style=\"font-weight: bold\">"+ NLS.btEndRole+": </span>";
		var fail = "<span style=\"font-weight: bold\">"+ NLS.btFailureRole+": </span>";
		array.forEach(this._eventsArray, function(item){
			var i = item.flow.lastIndexOf('/');
			var flowName =item.flow.substring(i+1);
			if (item.type === NLS.btStartRole) {
				start = start.concat(item.event+" from flow "+ flowName+"<br>");
			}
			if (item.type === NLS.btEndRole) {
				end = end.concat(item.event+" from flow "+ flowName+"<br>");
			}	
			if (item.type === NLS.btFailureRole) {
				fail = fail.concat(item.event+" from flow "+ flowName+"<br>");
			}
		});
		text.innerHTML = start+"<br>"+ end+"<br>"+fail; 
		this._eventsTp.set("content", text);
		Trace.trace(this.declaredClass, Trace.levels.EXIT, "formatEventsInfo");
	},
	
	// Get name and description values for the business transaction
	getBTXName : function() {
	  return this._businessTransactionName_Input.attr('value').trim();
	},
	
	//Get name and description values for the business transaction
  getBTXDescription : function() {
    return this._businessTransactionDescription_Input.attr('value').trim();
  },

	resize: function() {
    
	}
	    
	});
	return businesstransaction_summary;
});

},
'webui/nls/web':function(){
// NLS_CHARSET=UTF-8
/*
 * <copyright
 * notice="lm-source"
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2"
 * years="2011,2016"
 * crc="3390837844" >
 * Licensed Materials - Property of IBM
 *
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2
 *
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.
 * </copyright>
 */
define({
  //begin v1.x content
  root: {
    // START NON-TRANSLATABLE
    productName: "IBM Integration",
    // END NON-TRANSLATABLE

    // HEADER
    headerUserNameText: "Welcome back",
    headerUserWelcome: "Welcome, ",
    headerHelpText: "Help",
    headerHelpTooltip: "IBM Integration Information Center",
    headerProfile: "Edit Profile",
    headerLogOut: "Log Out",
    realtimeDisconnected: "Real-time updates disabled",
    realtimeConnected: "Real-time updates enabled",
    realtimeDisconnectedDescription: "The connection to the integration node has been lost",

    // TREE
    treeLabel: {
      activity: "Activity",
      adminLog: "Admin Log",
      applications: "Applications",
      restApis: "REST APIs",
      api: "API",
      businessDataCaptureStores : "Business Data Capture Stores",
      currentUser : "My Profile",
      configurableServices : "Configurable Services",
      data: "Data",
      dataCaptureStores: "Data Capture Stores",
      executionGroups: "Servers",
      services: "Services",
      "interface": "Interface",
      operation: "Operation",
      libraries: "Libraries",
      sharedLibraries: "Shared Libraries",
      messageFlows: "Message Flows",
      subFlows: "Subflows",
      resources: "Resources",
      references: "References",
      referents: "Referenced By",
      monitoring: "Monitoring",
      business: "Business",
      businessTransactions: "Business Transactions",
      policy: "Operational Policy",
      security: "Security",
      users : "Users",
      businessTransactionRecorders: "Business Recorders"
    },

    treeContextMenu_actions : "Actions",

    messages: {
      NoPermissions: "The logged-on user ID does not have the required permissions to access data or broker resources in the web user interface. See your broker administrator to set up the required permissions.",
      Password_200 : "Your password has been successfully updated",
      Password_5XX : "Your password could not be updated",
      DataViewer_5XX : "Data Capture Store could not be accessed",
      DataViewerCustomisation_2XX : "Data viewer changes have been successfully updated",
      DataViewerCustomisation_5XX : "Data viewer changes were not updated",
      egstart_5XX : "The integration server could not be started",
      egstop_5XX : "The integration server could not be stopped",
      egdelete_5XX : "The integration server could not be deleted",
      BusinessTransactionViewer_5XX : "Business transaction results could not be accessed",

      eg_all_contents_delete_5XX : "The contents of the integration server could not be deleted",
      eg_all_application_types_stopped_5XX : "The application types on the integration server could not be stopped",
      eg_all_application_types_started_5XX : "The application types on the integration server could not be started",
      eg_all_flows_stopped_5XX : "All the flows on the integration server could not be stopped",
      eg_all_flows_started_5XX : "All the flows on the integration server could not be started",
      egcreate_5XX : "The integration server could not be created",
      retrieveBTDInstanceEvents_5XX : "Failed to load monitoring events of ${0} instance with global correlation id ${1}",
      egUnchangedstart_5XX : "The integration server has already started",
      egUnchangedstop_5XX : "The integration server has already stopped",
      appstart_5XX : "The application could not be started",
      appstop_5XX : "The application could not be stopped",
      appdelete_5XX : "The application could not be deleted",
      libdelete_5XX : "The library could not be deleted",
      shlibdelete_5XX : "The shared library could not be deleted",
      appUnchangedstart_5XX : "The application has already started",
      appUnchangedstop_5XX : "The application has already stopped",
      msgflowstart_5XX : "The message flow could not be started",
      msgflowstop_5XX : "The message flow could not be stopped",
      msgflowdelete_5XX : "The message flow could not be deleted",
      subflowdelete_5XX : "The subflow could not be deleted",
      resourcedelete_5XX : "The resource could not be deleted",
      msgflowUnchangedstart_5XX : "The message flow has already started",
      msgflowUnchangedstop_5XX : "The message flow has already stopped",
      Adminlog_XXX : "Unable to read messages from the admin log",
      Activitylog_XXX : "Unable to read messages from the activity log",
      ReplayViewer_5XX : "Unable to replay an item from the replay list",
      ReplayViewer_000 : "Rows that do not contain data cannot be sent for replay",
      svcstart_5XX : "The service could not be started",
      svcstop_5XX : "The service could not be stopped",
      restapidelete_5XX : "The REST API could not be deleted",
      restapistart_5XX : "The REST API could not be started",
      restapistop_5XX : "The REST API could not be stopped",
      WebSocket_unsupported : "The statistics monitoring capability is not available through your current web browser. ",
      WebSocket_unsupportedDescription : "For more information about supported web browsers, see the IBM Integration Requirements web page. ",

      PubSub_unavailable : "Publication and subscription engine not available. No statistics collection possible. ",
      PubSub_unavailableDescription : "For more information about publication and subscription, see the IBM Integration web page. ",

      DeleteEGAction_successEGDeleted : "Integration server '${0}' has been deleted successfully.",
      DeleteEGAction_confirmation : "The integration server '${0}' and all its deployed contents will be deleted.  Are you sure you wish to delete the integration server?",

      CreateEGAction_successEGCreated : "Integration server '${0}' has been created successfully.",

      DeleteEGContentsAllAction_confirmation : "All deployed contents will be deleted from integration server '${0}'. Are you sure you wish to continue?",
      DeleteEGContentsAllAction_success : "All deployed contents were successfully deleted from integration server '${0}'.",

      StopAllApplicationTypes_confirmation : "All application types on integration server '${0}' will be stopped. Are you sure you wish to continue?",
      StopAllApplicationTypes_success : "All application types were successfully stopped on integration server '${0}'.",

      StartAllApplicationTypes_confirmation : "All application types on integration server '${0}' will be started. Are you sure you wish to continue?",
      StartAllApplicationTypes_success : "All application types were successfully started on integration server '${0}'.",

      StopAllFlows_confirmation : "All the message flows on integration server '${0}' will be stopped. Are you sure you wish to continue?",
      StopAllFlows_success : "All the message flows were successfully stopped on integration server '${0}'.",

      StartAllFlows_confirmation : "All the message flows on integration server '${0}' will be started. Are you sure you wish to continue?",
      StartAllFlows_success : "All the message flows were successfully started on integration server '${0}'.",

      DeleteFlowAction_confirmation : "Are you sure you wish to delete message flow '${0}' ?",
      DeleteFlowAction_successFlowDeleted : "Message flow '${0}' has been deleted successfully.",

      DeleteSubFlowAction_confirmation : "Are you sure you wish to delete subflow '${0}' ?",
      DeleteSubFlowAction_successFlowDeleted : "Subflow '${0}' has been deleted successfully.",

      DeleteResourceAction_confirmation : "Are you sure you wish to delete resource '${0}' ?",
      DeleteResourceAction_successResourceDeleted : "Resource '${0}' has been deleted successfully.",

      DeleteApplicationAction_confirmation : "Are you sure you wish to delete application '${0}' ?",
      DeleteApplicationAction_successApplicationDeleted : "Application '${0}' has been deleted successfully.",

      DeleteServiceAction_confirmation : "Are you sure you wish to delete service '${0}' ?",
      DeleteServiceAction_successServiceDeleted : "Service '${0}' has been deleted successfully.",

      DeleteRestApiAction_confirmation : "Are you sure you wish to delete REST API '${0}' ?",
      DeleteRestApiAction_successRestApiDeleted : "REST API '${0}' has been deleted successfully.",

      DeleteLibraryAction_confirmation : "Are you sure you wish to delete library '${0}' ?",
      DeleteLibraryAction_successLibraryDeleted : "Library '${0}' has been deleted successfully.",

      DeleteSharedLibraryAction_confirmation : "Are you sure you wish to delete shared library '${0}' ?",
      DeleteSharedLibraryAction_successSharedLibraryDeleted : "Shared library '${0}' has been deleted successfully.",

      btBTDNotYetSavedSoNoResults:"The business transaction '${0}' has not been saved yet, so there are no results to display.",
      btBTDNotAttachedToPolicy:"The business transaction '${0}' is not associated with a data capture policy, so there are no results to display.",

      FlowStatsAction_successstatsOn : "Flow statistics successfully turned on",
      FlowStatsAction_successstatsOff : "Flow statistics successfully turned off",
      FlowStatsAction_failurestatsOn : "Flow statistics could not be turned on",
      FlowStatsAction_failurestatsOff : "Flow statistics could not be turned off",
      msgflowstatsOn_5XX : "Flow statistics could not be turned on",
      msgflowstatsOff_5XX : "Flow statistics could not be turned off",
      StatsOff_XX: "Statistics collection for the flow is turned off",
      StatsOffMultiple_XX: "Statistics collection for all flows is turned off",
      NodeStatsOffSingleFlow_XX: "Click the arrow next to the message flow and click 'Statistics on' to start statistics collection for this flow.",
      NodeStatsOffMultipleFlows_XX: "Collection of node statistics for one or more of the flows is turned off",
      NodeStatsOffAllFlows_XX: "Click the arrow next to the required integration node, integration server, or application and click 'Statistics on' to start statistics collection for all flows in that entity.",
      AllStatsOff_XX: "No message flow deployed",
      StopFlowRestartEGConfirmation: "Are you sure you want to force the message flow to stop?  This action will also restart the integration server.",
      StopFlowRestartEGInfo: "This action forces the message flow to stop and restarts the integration server. When the integration server is restarted, all applications, libraries, and other message flows in the integration server are also restarted but this message flow remains stopped.",

      MessageFlowStopRecording_success: "Message flow '${0}' is no longer recording messages",
      MessageFlowStopRecording_confirmation: "Are you sure you want to stop the message flow from recording messages?",

      FlowMonitoringStartedSuccessfully_EG: "Flow monitoring successfully started for all message flows on integration server '${0}'",
      FlowMonitoringStoppedSuccessfully_EG: "Flow monitoring successfully stopped for all message flows on integration server '${0}'",
      FlowMonitoringStartedSuccessfully_App: "Flow monitoring successfully started for all message flows in application '${0}'",
      FlowMonitoringStoppedSuccessfully_App: "Flow monitoring successfully stopped for all message flows in application '${0}'",
      FlowMonitoringStartedSuccessfully_Service: "Flow monitoring successfully started for all message flows in integration service '${0}'",
      FlowMonitoringStoppedSuccessfully_Service: "Flow monitoring successfully stopped for all message flows in integration service '${0}'",
      FlowMonitoringStartedSuccessfully_RestApi: "Flow monitoring successfully started for all message flows in REST API '${0}'",
      FlowMonitoringStoppedSuccessfully_RestApi: "Flow monitoring successfully stopped for all message flows in REST API '${0}'",
      FlowMonitoringStartedSuccessfully_Flow: "Flow monitoring successfully started for message flow '${0}'",
      FlowMonitoringStoppedSuccessfully_Flow: "Flow monitoring successfully stopped for message flow '${0}'",
      FlowMonitoringFailedToStart: "Flow monitoring could not be started",
      FlowMonitoringFailedToStop: "Flow monitoring could not be stopped",

      EGResourceStatsAction_successresourceStatsOn  : "Resource statistics successfully turned on",
      EGResourceStatsAction_successresourceStatsOff : "Resource statistics successfully turned off",
      EGResourceStatsAction_failureresourceStatsOn  : "Resource statistics could not be turned on",
      EGResourceStatsAction_failureresourceStatsOff : "Resource statistics could not be turned off",
      EGResourceStatsActionresourceStatsOn_5XX      : "Resource statistics could not be turned on",
      EGResourceStatsActionresourceStatsOff_5XX     : "Resource statistics could not be turned off",
      EGResourceStatsOff_XX: "Resource statistics collection for the integration server is turned off",
      EGResourceStatsOffDesc_XX: "Click the arrow next to the integration server and click 'Resource statistics on' to start resource statistics collection for the integration server.",
      EGNotRunning_XX: "The integration server is not running",
      EGNotRunningDescription: "The integration server is not running.  Resource statistics data will not be produced.",

      NotJson_XX: "The snapshot statistics format is not json",
      FlowNotRunning_XX: "The message flow is not running",
      FlowsNotRunning_XX: "All the message flows are not running",
      NoDataYet_XX: "Waiting for data, this could take up to 20 seconds",
      NoData_XX: "No data available, statistics are disabled or the message flow is not running.",

      policyattach_successAttach : "The policy was successfully attached",
      policyattach_successDetach : "The policy was successfully detached",

      policysave_successUpdate : "The policy was successfully updated",
      policysave_successDelete : "The policy was successfully deleted",

      policysave_5XX: "The policy could not be created",
      policyupdate_5XX: "The policy could not be updated",
      policydelete_5XX: "The policy could not be deleted",
      policyget_5XX: "The policy could not be found",
      policyattach_5XX: "The policy could not be attached or detached",

      policysave_alreadyExists: "The policy cannot be created because a policy of the same name '${0}' already exists.",
      policysave_successCreate: "The policy '${0}' was created successfully.",
      policyupdate_notExists: "The policy '${0}' was not updated for the policy cannot be found. It is possible that the policy was already deleted by another user.",
      policyupdate_success : "The policy '${0}' was updated successfully.",
      policydelete_success : "The policy '${0}' was deleted successfully.",
      nodepolicyget_failed : "The policy cannot be found in the Integration Registry. Either recreate the policy, or attach another policy to the node from Integration Toolkit and redeploy.",

      retrievePolicyInformation_5XX : "Failed to retrieve information on data capture policy ${0}",
      retrievePolicyODBC_5XX : "Failed to retrieve policy security identities of type ${0}",
      policyinvalidproperty_000: "One or more properties in the policy is invalid",
      policyinvalidname_000: "Invalid policy name",

      policyDataCapture_saveSuccess : "Data source configuration saved successfully.",
      policyDataCapture_saveSuccessDescription : "The data source configuration has been saved successfully. All business transactions will use data source '${0}'.",
      policyDataCapture_saveFailure : "Data source configuration save was unsuccessful.",

      policyattachinvalid_000: "The policy attached to the message flow does not exist",

      StatsOffDescription: "There is no message flow deployed. Deploy a flow and turn the statistics on.",
      NodeStatsOffDescription: "Message flow statistics are turned on for flow ${0} but node statistics are turned off. To view node information for this flow turn node statistics on.",
      NodeStatsMultipleOffDescription: "Message flow statistics are turned on but node statistics for all flows are turned off. To view node information for a flow turn node statistics on.",
      NotJsonDescription: "Turn the statistics on from the context menu of the flow to enable JSON format",
      NoDataYetDescription: "Statistics data is updated every 20 seconds.",
      FlowNotRunningDescription: "The Message Flow is not running.  Data will not be produced.",
      FlowMultipleNotRunningDescription: "All of the Message Flows are not running.  Statistics data will not be produced.",

      ItemDoesNotExist_404: "Selected item does not exist. Press F5 to refresh.",
      ItemDoesNotExist_5XX: "Data could not be retrieved for this item. Press F5 to refresh.",

      DeployedObjectDoesNotExist_404: "Deployed resource does not exist. Press F5 to refresh data.",
      DeployedObjectDoesNotExist_5XX: "Could not retrieve information for deployed resource. Press F5 to refresh data.",

      EGDoesNotExist_404: "Integration server does not exist. Press F5 to refresh data.",
      EGDoesNotExist_5XX: "Could not retrieve information for integration server. Press F5 to refresh data.",

      TreeError_5XX: "Unable to access tree node due to error. If the problem persists, contact the IBM Support Center.",

      BusinessTransaction_insufficientPermissions : "Unable to access Business Transaction resources.",
      BusinessTransaction_insufficientPermissionsDescription : "The logged-on user ID does not have the required permissions to access business transaction resources in the web user interface. See your broker administrator to set up the required permissions.",

      BusinessEvent_promoted : "Monitoring event has been succesfully promoted. ",
      BusinessEvent_promotedDescription: "Monitoring event ${0} has been promoted to the role ${1}",

      BusinessEvent_demoted : "Monitoring event has been succesfully demoted. ",
      BusinessEvent_demotedDescription: "Monitoring event ${0} has been demoted to the role ${1}",

      CreateBusinessTransactionAction_successBTCreated : "Business transaction '${0}' has been created successfully.",
      btdcreate_5XX : "The business transaction could not be created",

      BusinessTransaction_MaxRowsReached : "The ${0} instances table has reached its maximum. Please specify a filter to reduce the number of rows.",
      BusinessTransaction_saveSuccess : "Business transaction saved successfully.",
      BusinessTransaction_saveSuccessDescription : "The business transaction definition ${0} has been saved successfully.",
      BusinessTransaction_saveFailure : "Business transaction save was unsuccessful.",

      BusinessTransaction_noMonitoringEvents: "The flows in the business transaction have no monitoring events defined.",
      BusinessTransaction_noMonitoringEventsDescription: "No monitoring events have been defined for the flows in business transaction definition ${0}.",

      BusinessTransaction_noStartEvent: "No start event has been defined for the business transaction.",
      BusinessTransaction_noEndEvent: "No end event has been defined for the business transaction.",
      BusinessTransaction_neitherStartNotEndEvent: "No start or end events have been defined for the business transaction.",
      BusinessTransaction_IncompleteDescription: "Business transaction definition ${0} must have one start event and one or more end events defined. Ensure that you have flagged one monitoring event as a 'start' event, and at least one as an 'end' event.",

      BusinessTransaction_noCorrelation: "Global transaction IDs are missing from all flagged events in the business transaction definition, so no events can be correlated. No business transactions will be recorded.",
      BusinessTransaction_noCorrelationDescription:"No global transaction IDs have been set for flagged events in business transaction definition ${0}, so no business transactions can be recorded. Modify all flagged monitoring events to include a global transaction ID.",

      BusinessTransaction_DisabledEvents: "Some flagged monitoring events are not enabled. These monitoring events will not form part of the business transaction.",
      BusinessTransaction_DisabledEventsDescription: "Business transaction definition ${0} includes the following flagged monitoring events that are set to disabled: ${1}. A disabled monitoring event will not be emitted and will not be included in the business transaction",

      BusinessTransaction_MissingCorrelation: "Some flagged monitoring events have no global transaction ID defined. The missing ID will be derived from previous events.",
      BusinessTransaction_MissingCorrelationDescription: "Business transaction definition ${0} includes the following flagged monitoring events with no global transaction ID defined: ${1}. If this ID cannot be derived from previous events, the events with the missing ID cannot be correlated and will not be included in the business transaction",

      BusinessTransaction_flowNoBusinessEvents: "The business transaction definition includes flows that contain no flagged monitoring events. These flows will not be monitored in this business transaction.",
      BusinessTransaction_flowNoBusinessEventsDescription: "Business transaction definition ${0} includes the following flows that contain no flagged monitoring events: ${1}.  To monitor these flows in the business transaction, flag the monitoring events from these flows.",

      BusinessTransaction_flowsNotFoundValidation: "The business transaction contains flows that cannot be found. Consider removing these flows from the business transaction.",
      BusinessTransaction_flowsNotFoundValidationDescription: "Business transaction definition ${0} has the following flows ${1} that cannot be found.",

      BusinessTransaction_nothingToDelete : "Unable to remove message flow.",
      BusinessTransaction_nothingToDeleteDescription : "To remove a flow from this business transaction, select the flow, then click Remove flow.",

      BusinessTransaction_flowsNotFound : "The following flows were not found: ${0}.",
      BusinessTransaction_deleteFlowsNotFound : "Do you want to delete the flows?",

      BusinessTransaction_btEventsNotFound : "The folowing flows have events that no longer exist: ${0}",
      BusinessTransaction_btEventsNotFoundDelete : "Do you want to delete the events?",


      BusinessTransactionResults_resultsRetrievalFailure : "Failed to retrieve business transaction results.",

      BusinessTransactionResults_recorderPolicyRetrievalFailure : "Failed to retrieve business transaction recorder policies.",

      BusinessTransactionResults_recorderSinglePolicyRetrievalFailure : "Failed to retrieve business transaction recorder policy.",
      BusinessTransactionResults_recorderSinglePolicyRetrievalFailureDescription : "Failed to retrieve the business transaction recorder policy {0}.",

      BusinessRecorder_nothingToDelete : "Unable to remove business transactions from business recorder.",
      BusinessRecorder_nothingToDeleteDescription : "To remove a business transaction from this business recorder, select the business transaction(s), then click Remove flow.",

      BusinessRecorder_removeSuccess : "Business transactions have been successfully removed.",
      BusinessRecorder_removeSuccessDescription : "Business transactions ${0} have been successfully removed from the business recorder.",


      BusinessTransaction_deleteSuccess : "Business transaction deleted successfully.",
      BusinessTransaction_deleteSuccessDescription : "The business transaction definition ${0} has been deleted successfully from the RDF store.",
      BusinessTransaction_deleteFailure : "Business transaction delete was unsuccessful.",

      ConfigurableService_deleteSuccess : "Configurable service ${0} was successfully deleted.",
      ConfigurableService_deleteFailure : "Configurable service ${0} could not be deleted. It is possible that the configurable service was already deleted by another user.",

      ConfigurableService_emptyName: "Configurable service name cannot be empty.",
      ConfigurableService_nameCanNotStartWithDigit: "Configurable service name can not start with a digit.",
      ConfigurableService_nameContainsInvalidCharacter: "Configurable service name contains an invalid character: ${0}",
      ConfigurableService_nameAlreadyExists: "A configurable service with name ${0} and type ${1} already exists. Choose another name.",
      ConfigurableService_emptyPropertyName : "A property name cannot be empty.",
      ConfigurableService_propertyNameCanNotStartWithDigit: "Property name ${0} is invalid as it starts with a digit.",
      ConfigurableService_propertyNameCanNotStartWithXML: "Property name ${0} is invalid as it starts with the string 'xml'.",
      ConfigurableService_propertyNameContainsInvalidCharacter: "Property name ${0} contains an invalid character: ${1}",
      ConfigurableService_duplicatePropertyName : "A property with name ${0} exists more than once. Property names must be unique.",
      ConfigurableService_preCreation: "Configurable service ${0} is being created.",
      ConfigurableService_creationSuccess: "Configurable service ${0} was successfully created.",
      ConfigurableService_creationFailure: "Configurable service ${0} could not be created. It is possible that the configurable service name or one or more property names contain invalid characters. See the Admin Log for more information.",
      ConfigurableService_preUpdate: "Configurable service ${0} is being updated.",
      ConfigurableService_updateSuccess: "Configurable service ${0} was successfully updated.",
      ConfigurableService_updateFailure: "Configurable service ${0} could not be updated. It is possible that one or more property names contain invalid characters. See the Admin Log for more information.",
      ConfigurableService_errorGettingConfigurableServiceTypes: "A problem occurred trying to obtain the list of available configurable service types from the server. It is possible that the connection with the server was lost.",
      ConfigurableService_errorGettingConfigurableServiceTemplates: "A problem occurred trying to obtain the list of available configurable service templates from the server. It is possible that the connection with the server was lost.",
      ConfigurableService_errorGettingConfigurableServiceProperties: "A problem occurred trying to obtain the properties of template ${0} from the server. It is possible that the template no longer exists on the server or that the connection with the server was lost.",
      ConfigurableService_creationConfirmNavigateAwayFromEditorConfirmationMessage: "The configurable service has not been created yet. Are you sure that you want navigate away from this page and lose your changes?",
      ConfigurableService_updateConfirmNavigateAwayFromEditorConfirmationMessage: "The configurable service has not been updated yet. Are you sure that you want navigate away from this page and lose your changes?",
      ConfigurableService_importing: "Importing the ${0} configurable service file",
      ConfigurableService_importCSFileSuccess: "Import of the ${0} configurable service file was successful",
      ConfigurableService_importCSFileFailure: "Import of the ${0} configurable service file failed: ${1}",

      PropertiesUpdate_ConfirmNavigateAwayFromEditorConfirmationMessage: "The properties have not been updated yet. Are you sure that you want navigate away from this page and lose your changes?",
      PropertiesUpdate_SavingProperties: "Saving new property values ... ",
      PropertiesUpdate_SaveSuccess: "Properties have been successfully saved.",
      PropertiesUpdate_SaveError: "A problem occured while trying to save the properties to the server. It is possible that the connection with the server was lost.",
      _errorGettingProperties: "A problem occured while trying to obtain the properties from the server. It is possible that the connection with the server was lost.",

      BTDrop_AlreadyPresent: "Message flow ${0} already part of the business transaction",
      BTDropAlreadyPresentDescription: "A message flow can only be added once to the business transaction",
      BTDelete_DeleteFailed: "Unable to delete message flow from the business transaction",
      BTDeleteFailedDescription: "A problem occured when trying to delete the message flow from the business transaction",
      StatisticsMaxSelected_XX: "No more selections allowed.",
      StatisticsMaxSelectedDescription: "A maximum of 20 entries can be selected in the resource statistics table.",
      BARDeploySuccessful_2XX: "The deployment of the BAR file '${0}' was successful.",
      BARDeploySubmitted_2XX: "Deploying BAR file '${0}' to '${1}'.",
      BARDeployFailed_5XX: "The deployment of the BAR file '${0}' to '${1}' has failed.",

      propertyValueContainsInvalidCharacter: "Property value ${0} contains an invalid character: ${1}",
    },

    // COMMON WIDGET STRINGS
    overviewTabTitle: "Overview",
    propertiesTabTitle: "Properties",
    actionsTabTitle: "Actions",
    activityLogTabTitle: "Activity Log",
    viewTitle: {
      basicProperties: "Quick View",
      advancedProperties: "Advanced Properties",
      deployedProperties: "Deployed Properties",
      userDefinedProperties: "User-Defined Properties",
      componentProperties: "Component Properties",
      resourceManagerProperties: "Resource Manager Properties",
      properties: "Properties",
    },
    monitoringTabTitle: "Monitoring",
    resourceStatisticsTabTitle: "Resource Statistics",
    statisticsTabTitle: "Statistics",
    toolbar_minimise: "Minimise",
    toolbar_restore: "Split view",
    toolbar_maximise: "Maximise",
    nameLabel: "Name",
    valueLabel: "Value",
    typeLabel: "Type",
    templateLabel: "Template",
    editValueLabel: "Edit Value",
    editValueDialogColumnHeaderText: "Launch Edit Value dialog",
    editValueDialogButtonText: "Contains a ... button that will open the Edit Value dialog where the value of a property in the row can be edited. Press F2 to select the ... button and then press enter to open the dialog.",

    // ADMIN LOG
    adminlogTitle: "Admin Log",
    adminlogNoMessages: "No Messages",
    message: "Message",
    source: "Source",
    timestamp: "Timestamp",
    messageDetail: "Message Detail",

    // ACTIVITY LOG:
    threadID: "Thread ID",
    resourceManager: "Resource Manager",
    filteringOnThreadID: "Currently filtering on thread ID",

    // APPLICATION WIDGETS
    applicationTitle: "Application",
    appQuickViewTitle: "Quick View",
    appStatusRunning: "Running",
    appStatusStopped: "Stopped",
    application: {
      version: "Version",
      label: "Application Name",
      runState: "Application Status",
      startMode: "Start Mode",
      javaIsolation: "Java Isolation",
      testRecordMode: "Test Record Mode",
      uuid: "UUID",
      shortDesc: "Short Description",
      longDesc: "Long Description",
      userTraceLevel: "User Trace Level",
      traceLevel: "Service Trace Level",
      traceNodeLevel: "Trace Node Level",
      modifyTime: "Modified Time",
      deployTime: "Deployed Time",
      barFileName: "BAR File Name",
      runMode:"Run Mode",
      isRunning:"Running",
      defaultDotNetAppDomain: "Default .NET Application Domain"
    },

    // REST API WIDGETS
    restApi_apiTabTitle: "API",
    restApiTitle: "REST API",
    restApiQuickViewTitle: "Quick View",
    restApiStatusRunning: "Running",
    restApiStatusStopped: "Stopped",
    restApi: {
      version: "Version",
      label: "REST API Name",
      runState: "REST API Status",
      startMode: "Start Mode",
      javaIsolation: "Java Isolation",
      testRecordMode: "Test Record Mode",
      uuid: "UUID",
      shortDesc: "Short Description",
      longDesc: "Long Description",
      userTraceLevel: "User Trace Level",
      restapiDescriptor: "REST API Descriptor",
      traceLevel: "Service Trace Level",
      traceNodeLevel: "Trace Node Level",
      modifyTime: "Modified Time",
      deployTime: "Deployed Time",
      barFileName: "BAR File Name",
      runMode:"Run Mode",
      isRunning:"Running",
      defaultDotNetAppDomain: "Default .NET Application Domain",
      baseURL: "REST API Base URL",
      definitionsURL: "REST API Definitions URL"
    },

    // SERVICE WIDGETS
    serviceTitle: "Integration Service",
    svcStatusRunning: "Running",
    svcStatusStopped: "Stopped",
    service: {
      label: "Service Name",
      version: "Version",
      runState: "Service Status",
      startMode: "Start Mode",
      javaIsolation: "Java Isolation",
      testRecordMode: "Test Record Mode",
      uuid: "UUID",
      soapHTTPURL: "Service SOAP/HTTP URL",
      soapHTTPQueryURL: "Service ?WSDL URL",
      shortDesc: "Short Description",
      longDesc: "Long Description",
      userTraceLevel: "User Trace Level",
      serviceDescriptor: "Service Descriptor",
      traceLevel: "Service Trace Level",
      traceNodeLevel: "Trace Node Level",
      modifyTime: "Modified Time",
      deployTime: "Deployed Time",
      barFileName: "BAR File Name",
      runMode:"Run Mode",
      isRunning:"Running",
      defaultDotNetAppDomain: "Default .NET Application Domain"
    },

    serviceNoFlowProfileData: "A flow profile cannot be viewed for an Integration Service.",

    // INTERFACE WIDGETS
    interfaceTitle: "Interface",
    interfaceQuickViewTitle: "Quick View",
    interfaceNameTitle: "Interface Name",
    interfaceStatusTitle: "Interface Status",
    interfaceDescShortTitle: "Short Description",
    interfaceDescLongTitle: "Long Description",
    interfaceStatusRunning: "Running",
    interfaceStatusStopped: "Stopped",

    // OPERATION WIDGETS
    operationTitle: "Operation",
    operation: {
      version: "Version",
      shortDesc: "Short Description",
      longDesc: "Long Description",
      label: "Operation Name",
      operationType: "Operation Type"
    },

    // BROKER WIDGETS
    brokerTitle: "Integration Node",
    brokerSecurityHelpText: "Administration security is currently inactive, which means that any web user can access all Integration Node resources by default.  To activate, use the mqsichangeauthmode command; for information on how to do this, see the IBM Integration Information Center.",
    brokerQuickViewTitle: "QuickView",
    brokerNameTitle: "Node Name",
    brokerQMrgTitle: "Queue Manager",
    brokerDescShortTitle: "Short Description",
    brokerDescLongTitle: "Long Description",
    brokerEnvQuickViewTitle: "Environment QuickView",
    brokerOSNameTitle: "OS Name",
    brokerOSVersionTitle: "OS Version",
    brokerOSArchitectureTitle: "OS Architecture",
    brokerVersionTitle: "Version",
    brokerBuildLevelTitle: "Build Level",
    brokerStatusRunning: "Running",
    brokerStatusStopped: "Stopped",
    brokerSecureText: "Admin security inactive",

    broker: {
      runState: "Broker Status",
      name: "Node Name",
      queueManager: "Queue Manager",
      version: "Version",
      operationMode: "Operation Mode",
      platformName: "Platform Name",
      platformVersion: "Platform Version",
      platformArchitecture: "Platform Architecture",
      longDesc: "Long Description",
      shortDesc: "Short Description",
      FixpackCapability: "Fixpack Capability",
      AdminAgentPID: "Admin Agent Process ID",
      buildLevel: "Build Level",
      AdminSecurity: "Admin Security",
      runMode: "Run Mode",
      isRunning:"Running",
      uuid:"UUID",

      // Component properties
      cacheSweepInterval : "Security Cache - Cache Sweep Interval",
      cacheTimeout : "Security Cache - Cache Timeout",
      policy : "Cache Manager - Policy",
      portRange : "Cache Manager - Port Range",
      listenerHost : "Cache Manager - Listener Host"
    },

    // CONFIGURABLE SERVICE WIDGETS
    configurableserviceTitle: "Configurable Service",
    configurableserviceConfirmDeleteMessage: "Are you sure you wish to delete configurable service ${0}?",
    configurableserviceYesLabel: "Yes",
    configurableserviceNoLabel: "No",
    configurableserviceTitleNew: "New Configurable Service",
    configurableservicePropertiesLabel: "Properties",
    configurableserviceCommandLabel: "Associated Command",
    configurableserviceCommandDescriptionForCreate: "Command to create the configurable service and that can be used in scripts:",
    configurableserviceCommandDescriptionForEdit: "Command to edit the configurable service and that can used in scripts:",
    configurableserviceLoadingWatermark: "<Loading...>",
    configurableservicePolicySetEditDescription: "Note that Policy Sets and Policy Set Bindings can be created and edited on an integration node in the Integration Nodes view of the IBM Integration Toolkit.",
    configurableserviceImportCSFileDialogTitle: "Import Configurable Service",
    configurableserviceImportCSFileDialogDescription: "Select a *.configurableservice file to import",
    configurableserviceImportCSFileDialogInvalidFileExtensionError: "Selected file does not have a *.configurableservice file extension",
    configurableserviceBrowseLabel: "Browse....",

    // EXECUTION GROUP WIDGETS
    executionGroupTitle: "Integration Server",
    egStatusRunning: "Running",
    egStatusStopped: "Stopped",
    executionGroup: {
      label: "Integration Server Name",
      runMode:"Run Mode",
      isRunning:"Running",
      uuid:"UUID",
      shortDesc:"Short Description",
      longDesc:"Long Description",
      testRecordMode: "Test Record Mode",
      processId:"Process ID",
      UserTraceLevel:"User Trace Level",
      traceLevel:"Trace Level",
      soapNodesUseEmbeddedListener:"Soap Nodes Use Embedded Listener",
      consoleMode:"Console Mode",
      unnamedTraceLevel:"Service Trace Level",
      httpNodesUseEmbeddedListener:"HTTP Nodes Use Embedded Listener",
      businessTransactionPolicyUri:"Business Transaction Policy URI",
      dataCapturePolicyUriForRecording: "Data Capture Policy URI For Recording",
      dataCapturePolicyUriForViewing: "DataCapture Policy URI For Viewing",
      inactiveUserExitList:"Inactive User Exit List",
      activeUserExitList:"Active User Exit List",
      traceNodeLevel:"Trace Node Level",
      userTraceLevel:"User Trace Level",
      modifyTime: "Modified Time",
      deployTime: "Deployed Time",
      barFileName: "BAR File Name",
      injectionMode: "Injection Mode",
      threadLocalProxyNameManagers: "Thread Local Proxy Name Managers",

      // Resource manager properties
      jvmDebugPort : "JVM Manager - JVM Debug Port",
      jvmMinHeapSize : "JVM Manager - JVM Min Heap Size",
      jvmMaxHeapSize : "JVM Manager - JVM Max Heap Size",
      jvmNativeStackSize : "JVM Manager - JVM Native Stack Size",
      jvmVerboseOption : "JVM Manager - JVM Verbose Option",
      jvmSystemProperty : "JVM Manager - JVM System Property",
      cbfEnabled : "Content Based Filtering - Enabled",
      validationThreads : "Content Based Filtering - Validation Threads",
      evaluationThreads : "Content Based Filtering - Evaluation Threads",
      coordinationQMgr : "FTE Agent - Coordination Queue Manager",
      EISProviders : "Siebel Manager - EIS Providers",
      enabled : "Data Capture Manager - Enabled",
      enableCatalogService : "Cache Manager - Enable Catalog Service",
      enableContainerService : "Cache Manager - Enable Container Service",
      enableJMX : "Cache Manager - Enable JMX",
      listenerPort : "Cache Manager - Listener Port",
      listenerHost : "Cache Manager - Listener Host",
      haManagerPort : "Cache Manager - HA Manager Port",
      jmxServicePort : "Cache Manager - JMX Service Port",
      connectionEndPoints : "Cache Manager - Connection Endpoints",
      catalogClusterEndPoints : "Cache Manager - Catalog Cluster Endpoints",
      domainName : "Cache Manager - Domain Name",
      clientsDefaultToSSL : "Cache Manager - Clients Default To SSL",
      sslProtocol : "Cache Manager - SSL Protocol",
      sslAlias : "Cache Manager - SSL Alias"
    },

    // BUTTON ACTIONS
    action: {
      apply: "Apply",
      cancel: "Cancel",
      cancelFilter: "Cancel Filter",
      clear: "Clear",
      copy: "Copy",
      customiseColumns: "Customize",
      create: "Create",
      "delete": "Delete",
      exportPortConfigurationAsWASPlugin: "Export Port Configuration as Websphere Application Server Plugin",
      exportPortConfigurationAsModProxyModule: "Export Port Configuration as mod_proxy Module",
      confirm: "Confirm",
      deploy: "Deploy",
      install: "Install",
      uninstall: "Uninstall",
      download: "Download",
      edit: "Edit",
      expandAll: "Expand all",
      collapseAll: "Collapse all",
      find: "Find",
      filter: "Filter",
      sendToReplayViewer: "Mark for replay",
      "new": "New",
      refresh: "Refresh",
      revert: "Revert",
      replay: "Replay All",
      save: "Save",
      saveAs: "Save As",
      start: "Start",
      stop: "Stop",
      attachPolicy: "Attach policy",
      detachPolicy: "Detach policy",
      statsOn: "Statistics on",
      startFlowMonitoring: "Start flow monitoring",
      stopFlowMonitoring: "Stop flow monitoring",
      deleteAll : "Delete All Content",
      stopAllApplicationTypes : "Stop All Application Types",
      stopAllMessageFlows : "Stop All Message Flows",
      startAllApplicationTypes : "Start All Application Types",
      startAllMessageFlows : "Start All Message Flows",
      statsOff: "Statistics off",
      saveInterfaceFiles: "Save Interface Files",
      stopReplay: "Stop replay",
      upload: "Import ...",
      localTime: "Display Time",
      view: "View",
      flowView: "Go to Flow analysis view",
      noFlowView: "No Flow analysis view. Turn the statistics on for the flow.",
      stopWithRestartExecutionGroup: "Force stop",
      exportConfigurableService: "Export *.configurableservice",
      importConfigurableService: "Import *.configurableservice",
      enableTestRecordMode: "Start recording",
      disableTestRecordMode: "Stop recording",
      resourceStatsOn: "Resource statistics on",
      resourceStatsOff: "Resource statistics off",
      downloadData: "Download data",
      createNewInstance: "Create new instance",
      pushRESTApis: "Push REST APIs to IBM API Connect"
    },

    actionDescription: {
      "delete": "Delete this resource",
      start: "Start this resource",
      stop: "Stop this resource",
      deleteAll : "Delete all resources deployed to this server",
      attachPolicy: "Attach a policy to this resource",
      detachPolicy: "Detach a policy to this resource",
      statsOn: "Turn the statistics on for this resource",
      statsOff: "Turn the statistics off for this resource",
      resourceStatsOn: "Turn resource statistics on for this resource",
      resourceStatsOff: "Turn resource statistics off for this resource",
      downloadData: "Download the data for this session",
      startFlowMonitoring: "Turn on flow monitoring for this resource",
      stopFlowMonitoring: "Turn off flow monitoring for this resource"
    },

    filterOptions_label: "Filter Options...",
    filterOptions_showAllResources: "Show all resources",
    filterOptions_showOnlyFlows: "Show only message flows",
    filterOptions_config_services_showIBMTemplates: "Show IBM predefined templates",
    filterOptions_DeployedResourcesTitlePaneLabel : "Deployed Resources on Integration Server",
    filterOptions_ConfigurableServicesTitlePaneLabel : "Configurable Services",
    filterOptions_Dialog_Title : "Filter Options",
    filterOptions_Dialog_Msg : "Specify some filtering options",
    statisticsFlow:"Flow name",
    statisticsFlowTotal: "Flow total",
    statisticsNodeType: "Node type",
    statisticsFlowAnalysis: "Flow analysis",
    statisticsFlowInfo: "Statistics details for the flow",
    statisticsFlowDetails: "Last updated: ${0}.",
    statisticsNoThreads: "Disabled",
    statisticsNoThreadsInfo: "The number of active threads cannot be determined because thread statistics are disabled.",

    okButtonLabel : "OK",
    cancelButtonLabel : "Cancel",
    previousButtonLabel : "Back",
    nextButtonLabel : "Next",
    finishButtonLabel : "Finish",
    closeButtonLabel : "Close",

    // INTEGRATION SERVERS
    nameExecutionGroupNameMsg : "Enter a new name for the integration server.",
    executionGroupNameEmptyErrorMsg : "The integration server name cannot be empty!",
    executionGroupNameDuplicateErrorMsg : "The name is already in use!",
    executionGroupNameInvalidErrorMsg : "The name contains invalid characters.",
    newExecutionGroupTitle : "New Integration Server",
    newExecutionGroupMsg : "Create an Integration Server.",
    newExecutionGroupLbl : "Integration Server Name:",

    // POLICY WIDGET
    policyTitle : "Operational Policy",
    flowPolicyTitle : "Flow Policy",
    flowPolicyNotApplicable : "Flow Policy is not applicable to a subflow",
    flowDiagramInformationalMsg : "To view any policies that are used in a subflow, first hover over the subflow node icon to see the subflow file name. Then open the subflow using the navigator, and select the Operational Policy tab.",
    policyTabTitle : "Overview",
    policyAttachTabTitle : "Operational Policy",
    availPolicies : "Available policies",
    attachedPolicy : "Attach policy",
    noAttachedPolicy : "No attached policy",
    noDefinedPolicies : "No policies are defined on this integration node.",
    _unspecifiedPropertiesTooltip_title: "Use a policy to control the operational behavior of a message flow at run time. [ More... ]",
    _unspecifiedPropertiesTooltip_desc: "If this policy is attached to a message flow, the property values that are specified in this policy are used at run time. Any values that are not defined in this policy will be inherited from the message flow, if they are defined there.",
    _unspecifiedNodePolicyPropertiesTooltip: "Use a policy to control the operational behavior of a message flow node at run time.",
    _unspecifiedNodePolicyPropertiesTooltip_title: "Use a policy to control the operational behavior of a message flow node at run time. [ More... ]",
    _unspecifiedNodePolicyPropertiesTooltip_desc: "If this policy is attached to a node in a message flow, the property values that are specified in this policy are used at run time. Any values that are not defined in this policy will be inherited from the message flow node, if they are defined there.",
    nodePolicyPropertiesTooltip: "Shows the effective operational properties of a message flow node with a policy associated with it at run time.",

    // Node Policy
    nodePoliciesTitle : "Node Policies",
    policyNoFlowProfileData: "A flow profile cannot be viewed.",
    policy_nodeAttachPolicySelectGraphView : "Graph view",
    policy_nodeAttachPolicySelectTableView : "Table view",
    functionNotImplemented : "Function not implemented in the driver",
    policy_noPolicyAttachedToNode : "A policy can be attached to the node",
    policy_policyAttachedToNode : "A policy is attached to the node",
    policy_policyNotAttachedToNode : "A policy is not attached to the node",
    policy_actionDialogTitle : "Policy Actions",
    policy_actionDialogSelect: "Select an action...",
    policy_actionShowProperties : "Show runtime properties",
    policy_actionShowEffectiveProperties : "Show effective properties",
    policy_actionAttachPolicy : "Attach operational policy",
    policy_actionDetachPolicy : "Detach operational policy",
    policy_actionEditPolicy : "Edit operational policy",
    policy_actionViewPolicy : "View operational policy",
    policy_actionGeneratePolicy : "Generate and attach",
    policy_editorTitle : "Operational Policy",
    policy_editorPolicyUrl : "Policy URL: ",
    policy_shortDesc : "Short description:",
    policy_longDesc : "Long description:",
    policy_clientID : "Client ID:",
    policy_topicName : "Topic name:",
    policy_hostName : "Host name:",
    policy_port : "Port:",
    policy_qos : "Quality of service:",
    policy_qos0 : "0 - At most once",
    policy_qos1 : "1 - At lease once",
    policy_qos2 : "2 - Exactly once",
    policyConfirmDelete: "Are you sure you want to delete policy '${0}'?",
    policyYes: "Yes",
    policyNo: "No",
    policySaveAsDescription: "Save policy with a new name",
    policyNameLabel: "Policy name:",
    policyNameEmptyErrorMsg : "Policy name cannot be empty.",
    policyNameDuplicateErrorMsg : "Policy name is already in use.",
    policyNameInvalidCharacterErrorMsg : "Policy name can only contain alphanumeric and underscore characters.",
    policy_EditPolicyTitle : "Edit Operational Policy",
    policy_ViewPolicyTitle : "View Operational Policy",
    policy_EffectivePropertiesTitle: "Effective Operational Properties",
    policy_EffectivePropertiesDescription: "View the runtime effective operational properties",
    policy_creatingNewPolicy : "Creating new policy...",
    policy_saveAsDialogTitle: "Save As",

    // MQTT NODE PROPERTIES
    nodePropertiesName : "Properties",
    nodePropertiesValue : "Values",
    hostName : "Host Name",
    messageFormatProperty : "Message Format",
    traceLevel : "Trace Level",
    messageCodedCharSetIdProperty : "Message CCSID",
    messageSetProperty : "Message Set",
    messageDomainProperty : "Message Domain",
    port : "Port",
    firstParserClassName : "First Parsr Class Name",
    validateMaster : "Validate Master",
    dataLocation: "Data Location",
    messageEncodingProperty : "Message Encoding",
    userTraceLevel : "User Trace",
    topicProperty : "Topic",
    messageTypeProperty : "Message Type",
    longRetryInterval : "Long Retry Interval",
    shortRetryInterval : "Short Retry Interval",
    rootParserClassName : "Root Parser Class Name",
    additionalInstances : "Additional Instances",
    retryThreshold : "Retry Threshold",
    waitInterval: "Wait Interval",
    componentLevel : "Component Level",
    validate : "Validate",
    retryMechanism : "Retry Mechanism",
    transactionMode : "Transaction Mode",

    // MYPROFILE WIDGET
    profileTitle: "My Profile",
    profilePropertiesTabTitle: "Properties",
    profilePermissionsTabTitle: "Permissions",
    profilePreferencesTabTitle: "Preferences",
    profileTabSave: "Save",
    profileTabCancel: "Cancel",
    profileTabChange: "Change...",
    profileTabSaveSuccess: "Account profile has been updated",
    profilePropertiesTitle: "Properties",
    profilePropertiesUsernameTitle: "User ID",
    profilePropertiesRoleTitle: "Role",
    profilePropertiesUsernameText: "This is the unique User ID that is used to identify you",
    profilePropertiesPasswordTitle: "Password",
    profilePropertiesPasswordText: "",
    profilePropertiesCurrentPasswordText: "Current password:",
    profilePropertiesNewPasswordText: "New password:",
    profilePropertiesConfirmPasswordText: "Confirm new password:",
    profilePropertiesPasswordErrorText: "Passwords do not match",
    profilePropertiesNameTitle: "Name",
    profilePropertiesNameText: "You can specify a user-friendly nickname",
    profilePropertiesHistoryTitle: "Login history",
    profilePropertiesHistoryText: "View...",
    profilePermissionsTitle: "Permissions",
    profilePreferencesTitle: "Preferences",


    // EXPLORER TAB
    explorerTabTitle: "Explorer",
    explorerTreeTitle: "Broker explorer",
    explorerInfoPaneWelcomeTitle: "Welcome to IBM Integration",
    explorerInfoPaneWelcomeText1: "Use this Administration tab to view your broker resources.  Select elements in the broker tree to view details.<br>Select the Data Viewer tab to view your recorded data.",
    explorerInfoPaneWelcomeSubTitle: "Message Broker icons",
    explorerInfoPaneWelcomeText2: "The following icons are used in the navigation pane in the Administration view to show the current status of broker components:",
    explorerInfoPaneWelcomeLocalBrokerText: "Local broker running and connected",
    explorerInfoPaneWelcomeExGrpStartedText: "Integration server started",
    explorerInfoPaneWelcomeExGrpStoppedText: "Integration server stopped",
    explorerInfoPaneWelcomeFlowStartedText: "Flow started",
    explorerInfoPaneWelcomeFlowStoppedText: "Flow stopped",
    explorerInfoPaneWelcomeAppStartedText: "Application started",
    explorerInfoPaneWelcomeAppStoppedText: "Application stopped",
    explorerInfoPaneWelcomeSvcStartedText: "Service started",
    explorerInfoPaneWelcomeSvcStoppedText: "Service stopped",
    explorerInfoPaneWelcomeInterfaceStartedText: "Interface started",
    explorerInfoPaneWelcomeInterfaceStoppedText: "Interface stopped",
    explorerInfoPaneWelcomeOperationStartedText: "Operation started",
    explorerInfoPaneWelcomeOperationStoppedText: "Operation stopped",
    explorerInfoPaneTitleTypeExecutionGroup: "Integration Server",
    explorerInfoPaneTitleTypeMessageFlow: "Message Flow",
    explorerInfoPaneTitleTypeApplication: "Application",
    explorerInfoPaneTitleTypeService: "Service",
    explorerInfoPaneTitleTypeLibrary: "Library",
    explorerInfoPaneTitleTypeSharedLibrary: "Shared Library",
    explorerInfoPaneTitleTypeLog: "Log",
    explorerInfoPaneTitleTypeAdministrationQueue: "Administration Queue",
    explorerInfoPaneGridNoMessages: "No Messages",
    explorerInfoPaneGridNoResourceFound: "No Resource Found",
    explorerInfoPaneRunState: "Run State",
    explorerInfoPaneRunning: "Running",
    explorerInfoPaneStart: "Start",
    explorerInfoPaneStopped: "Stopped",
    explorerInfoPaneStop: "Stop",
    explorerInfoPaneEnable: "Enable",
    explorerInfoPaneEnabled: "Enabled",
    explorerInfoPaneDisable: "Disable",
    explorerInfoPaneDisabled: "Disabled",
    explorerInfoPaneTraceNone: "None",
    explorerInfoPaneTraceNormal: "Normal",
    explorerInfoPaneTraceDebug: "Debug",
    explorerInfoPanePropertyShortDescription: "Short Description",
    explorerInfoPanePropertyLongDescription: "Long Description",
    explorerInfoPanePropertyFlowDebugPort: "Flow Debug Port",
    explorerInfoPanePropertyFlowTraceNodes: "Flow Trace Nodes",
    explorerInfoPaneBarFileName: "BAR File Name",
    explorerInfoPaneDeployTime: "Deploy Time",
    explorerInfoPaneModificationTime: "Modification Time",
    explorerInfoPaneAdditionalInstances: "Additional Instances",
    explorerInfoPaneCommitCount: "Commit Count",
    explorerInfoPaneCommitInterval: "Commit Interval",
    explorerInfoPaneCoordinatedTransaction: "Coordinated Transaction",
    explorerInfoPaneLastUpdatedUser: "Last Updated User",
    explorerInfoPaneVersion: "Version",
    explorerInfoPaneUserTrace: "User Trace",
    explorerInfoPaneNone: "None",
    explorerInfoPaneAdminQueueColumnStatus: "Status",
    explorerInfoPaneAdminQueueColumnUsername: "Username",
    explorerInfoPaneAdminQueueColumnOperationType: "Operation Type",
    explorerInfoPaneAdminQueueColumnObjectName: "Object Name",
    explorerInfoPaneAdminQueueColumnObjectType: "Object Type",
    explorerInfoPaneAdminQueueColumnCreationTime: "Creation Time",


    // DATA CAPTURE STORE TAB
    dataViewComboDefaultValue: "Select store",
    dataViewComboTitle: "Data Capture Store",
    replayComboDefaultValue: "Select destination",
    replayComboNoValues: "No configured destination",
    replayComboTitle: "Data Destination",
    replayStatusColumn: "Replay Status",
    dataLoading: "Loading...",
    dataCaptureStoreTitle: "Data Capture Store",
    dataviewerTabTitle: "Data viewer",
    replayTabTitle: "Replay list",
    replayColumnSelect: "Unmark all for replay",
    replayRowCheckboxMark: "Mark",
    replayRowCheckboxUnMark: "Unmark",
    replayRowCheckbox: "Unmark for replay",
    replayRow: "Replay",
    replayRowDisabled: "Select a destination to enable replay",
    replayRowFailed: "Failed to send for replay",
    replayRowSuccess: "Successfully sent for replay",
    replayRowWarning: "This row does not contain any data and so cannot be sent for replay",
    replayDownload: "Download data",
    replayDownloadDisabled: "This row does not contain any data",
    replayDownloadLocked: "You are not authorized to download this data",

    bitStreamDownloadBTM: "Download bitstream data",
    exceptionListDownloadBTM: "Download exception list",
    buildFilter: "Build Filter",
    filterRules: "Rules",
    filterContains: "contains",
    filterStartsWith: "starts with",
    filterEndsWith: "ends with",
    filterMatches: "equals",
    filterWithBitstream: "with data",
    filterWithoutBitstream: "without data",
    filterWithExceptions: "with errors",
    filterWithoutExceptions: "without errors",
    filterEventTimestampFrom: "after",
    filterEventTimestampTo: "before",
    filterAnd: "and",
    filterSelectColumnName: "Select a column name",
    filterSelectFilteringMode: "Select filtering mode",
    filterEnterFilterValue: "Enter a filter term",
    filterConfirmationText: "This will remove the filter and show all available data",
    filterClearFilter: "Clear Filter",
    filterAddRow: "Add another filter rule",
    filterSubtractRow: "Delete this filter rule",
    filterNoFilterApplied: "No filter applied",
    filterResults: "${0} of ${1} items shown",
    customiseColumnsTitle: "Customize Columns",
    customiseColumnsSubText: "Select the columns to display in the Data viewer. Double-click a name or width that you want to edit. You can sort the order by clicking the header. You can also reorder the columns and change their widths by using the header in the main Data viewer and saving your changes here. The saved changes apply only to the current data capture store; other data capture stores retain their current settings.",
    fieldID: "Field ID",
    displayName: "Display Name",
    widthPX: "Width (px)",
    customiseReorderToolTip: "Select this row and then drag and drop to reorder it",
    rrrDataViewerFilterTitle: "Filter data",
    rrrDataViewerToolTipRefreshLink: "Refresh",
    rrrDataViewerToolTipPrintLink: "Print",
    rrrDataViewerToolTipFilterLink: "Filter",
    rrrDataViewerToolTipReplayInactiveLink: "Select one or more rows to replay",
    rrrDataViewerToolTipReplayActiveLink: "Replay selected row or rows",
    rrrDataViewerToopTipReplaySubmit: "Replay",
    rrrDataViewerToolTipReplayInactive: "Select data destination before you click Replay",
    rrrDataViewerReplayTitle: "Replay data",
    rrrDataViewerReplaySingleReplay: "Single Replay",
    rrrDataViewerReplayStatus: "Status",
    rrrDataViewerReplayBatchTitle: "Replay as batch",
    rrrDataViewerReplayCloseSuccessTitle: "Close on success",
    rrrGridStandbyNoStoreSelected: "Select a Data Capture Store",
    rrrGridStandbyNoDataReturned: "No data to display",
    rrrPaginationTotal: "Total",
    rrrPaginationSelected: "Marked",
    rrrPaginationFooterCentrePage: "Page ",
    dataViewerColumnSelect: "Select",
    dataViewerColumn: {
      hasBitstream: "Data",
      hasException: "Errors",
      eventType: "Event type",
      eventName: "Event name",
      eventSourceAddress: "Event source",
      brokerName: "Broker",
      brokerUuid: "Broker UUID",
      executionGroupName: "Integration server",
      executionGroupUuid: "Integration server UUID",
      messageFlowName: "Flow name",
      messageFlowUuid: "Flow UUID",
      nodeName: "Node",
      nodeType: "Node type",
      terminalName: "Terminal",
      detail: "Detail",
      eventTimestamp: "Event time",
      localTransactionId: "Local Transaction ID",
      parentTransactionId: "Parent Transaction ID",
      globalTransactionId: "Global Transaction ID"
    },
    paginationNextPage: "Next page",
    paginationPreviousPage: "Previous page",
    paginationGoToPage: "Go to page",
    paginationAll: "All",
    replayStatusTextSuccess: "Success",
    replayStatusTextWarning: "Warning",
    replayStatusTextError: "Error: ",
    replayStatusTextUnknown: "Unknown",
    replayListNoDestinationSelected: "Select a data destination",
    replayListNoDestinationAndReplayItemsSelected: "Select and mark items for replay in the Data viewer and then select a data destination",
    replayListNoReplayItemsSelected: "Select and mark items for replay in the data viewer.",
    replayListFooterTotal: "Total",
    replayListFooterSuccess: "Successes",
    replayListFooterWarning: "Warnings",
    replayListFooterError: "Errors",
    replayListStatusHelp: "Click the Replay Status for a row to display more information",

    localTimeUTC: "Switch to UTC",
    localTimeBrowser: "Switch to Browser local time",

    // Libraries
    libTitle: "Library",
    library: {
      version: "Version",
      label: "Library Name",
      uuid: "UUID",
      shortDesc: "Short Description",
      longDesc: "Long Description",
      traceLevel: "Service Trace Level",
      traceNodeLevel: "Trace Node Level",
      userTraceLevel: "User Trace Level",
      modifyTime: "Modified Time",
      deployTime: "Deployed Time",
      barFileName: "BAR File Name",
      defaultDotNetAppDomain: "Default .NET Application Domain"
    },


    // Shared Libraries
    shlibTitle: "Shared Library",
    sharedLibrary: {
      version: "Version",
      label: "Shared Library Name",
      uuid: "UUID",
      shortDesc: "Short Description",
      longDesc: "Long Description",
      traceLevel: "Service Trace Level",
      traceNodeLevel: "Trace Node Level",
      userTraceLevel: "User Trace Level",
      modifyTime: "Modified Time",
      deployTime: "Deployed Time",
      barFileName: "BAR File Name",
      defaultDotNetAppDomain: "Default .NET Application Domain"
    },

    // Configurable service properties
    configurableService: {},

    //BUSINESS TRANSACTIONS
    businessTransactionsRootTitle: "Business Transactions",
    businessTransactionsRootConfigTitle: "Configuration",
    businessTransactionsRootConfigPanel: "Data source configuration",

    businessTransactionTitle: "Business Transaction",
    businessConfigurationTitle: "Define",
    businessConfigurationDataTitle: "Data Configuration",
    businessConfigurationPolicyTitle: "Configure",
    businessResultsTitle: "View",
    businessTransactionProfileTitle: "Business Transaction Profile",
    businessTransactionNewName: "NewBusinessTransaction",
    btNoFlowSelected:"No flow selected",
    btFlowProfileTitle: "Message flow: ${0}",
    btFlowProfileTitleError: "Message flow: ${0} cannot be found",
    btFlowProfileNoVisualTitle: "The visualization of message flow ${0} is unsupported for artefacts of type ${1}",
    btFlowEventTitle: "Event Definitions for flow ${0}",
    btFlowEventTitleService: "Event Definitions for integration service ${0}",
    btFlowEventTitleRestApi: "Event Definitions for REST API ${0}",
    btFlowEventIn: "in",
    btTxnEventTitle: "Business Transaction Event Definitions",
    btTxnEventDescription: "This section shows the monitoring events that are defined for the selected flow or for all flows in the business transaction.  Select the monitoring events that signify the start, end, and failure of your business transaction.",
    btMessageFlow: "Message Flow",
    btMonitoringEvent: "Monitoring Event",
    btAddRecorderLabel: "Add",
    btRemoveRecorderLabel: "Remove",
    btNewRecorderODBCLabel: "ODBC Name",
    btNewRecorderSchemaLabel: "Schema Name",
    btNewRecorderServerLabel: "Integration Server",
    btConfirmRecorderDelete: "Are you sure you want to remove business recorder ${0} ?",

    btRecorderTitle: "Business Recorder",
    btRecorderDescription: "Create a new business recorder",
    btRecorderCreateNewOption: "Create recorder",
    btRecorderAddOption: "Add recorder",
    btRecorderNameInvalidErrorMsg: "Recorder Name Invalid",
    businessRecorderTitle: "Overview",
    btAddBTDTitle: "Add Business Transactions",
    btAddBTDDescription: "Add more business transactions for the recorder to monitor",
    btMonitoringTitle: "Business Recorders",
    btSelectRecorder: "Select business recorder:",
    btSeeDetailsRecorder: "See business recorder details:",
    btRecorderNone: "[None]",
    btRecorderNoneWarning: "Warning: No business transactions will be recorded.",
    btStartMonitoring: "Start monitoring",

    // New BTD Dialog
    btNewBTDDialogTitle: "New Business Transaction Definition",
    btNewBTDDialogDesc: "Create a Business Transaction Definition.",
    btNewBTDName: "Business Transaction Name:",
    btNewBTDNewNameMsg: "Enter a new name for the business transaction definition.",

    // Monitoring Event Table Column Headings
    btEventTableMessageFlowEvent: "Message Flow - Monitor Event",
    btEventTableEventName: "Event Name",
    btEventTableEventSourceAddress: "Event Source Address",
    btEventTableEventDetailsCell: "More details",

    // Monitoring Events fields
    btMEName: "Name:",
    btMEEventName: "Event Name:",
    btMESourceAdress: "Source Address:",
    btMESource: "Source:",
    btMEFilter: "Filter:",
    btMEEnabled: "Enabled:",
    btMEIsTxnEvent: "Transaction event:",
    btMEisData: "Bitstream Data Included",
    btMEEnc: "Bitstream Content Encoding:",
    btMEType: "Bitstream Content Type",
    btMEData: "Data Locations:",
    btMEDataNone: "None",
    btMECorrelation: "Correlation:",
    btMELocal: "Local:",
    btMEParent: "Parent:",
    btMEGlobal: "Global:",
    btMEUnitOfWork: "Unit of work",
    btMEIntegrationNode: "Integration Node Name:",
    btMEIntegrationServer: "Integration Server Name:",
    btMEFlowName: "Message Flow Name:",
    btMEEventSourceAddress: "Event Source Address:",
    btMEEventNodeName: "Node Name:",
    btMEEventNodeType: "Node Type:",
    btMEEventNodeTerminalName: "Node Terminal Name:",
    btMEEventLocalCorrelationID: "Local Correlation ID:",
    btMEEventParentCorrelationID: "Parent Correlation ID:",
    btMEEventGlobalCorrelationID: "Global Correlation ID:",

    //btFlowRemovalDialog
    btRemoveFlowsButton: "Remove flows",
    btRemoveListOfFlows: "List of flows from the business transaction:",
    btRemoveSummary: "The following flows will be removed:  ${0}.",
    btRemoveFlowInfo: "Select one or more flows to remove from the business transaction definition.",
    btRemoveFlowTitle: "Remove flows from business transaction ${0}",

    btSelectFlow: "Select message flow:",
    btAppSelection: "Select application:",
    btAddingFlows: "Adding message flows:",
    btNoAvailableFlowsToAdd: "All available message flows have already been added",
    btFlowsAlreadyAdded: "Message flows already added:",

    btNoAppFlowsToAdd: "All available message flows in application ${0} have already been added",
    btNoServiceFlowsToAdd: "All available message flows in integration service ${0} have already been added",
    btNoRestApiFlowsToAdd: "All available message flows in REST API ${0} have already been added",

    btServiceSelection: "Select service:",
    btRestApiSelection: "Select REST API:",

    btNoFlowsToAdd: "No message flows available to add",
    btNoAppsToAdd: "No applications available to add",
    btNoServicesToAdd: "No integration services available to add",
    btNoRestApisToAdd: "No REST APIs available to add",

    btOneMonitoringEvent: "${0} Monitoring Event",
    btMonitoringEvents: "${0} Monitoring Events",
    btEnabled: "Enabled",
    btNode: "Node",
    btFlowName: "Flow Name",
    btEventSource: "Event Source",
    btEventSourceAddress: "Event Source Address",
    btEventName: "Event Name",
    btEventFilter: "Event Filter",
    btGlobalTran: "Global Transaction Correlator",
    btResults: "Transaction Results",
    btResultsInstanceAll: "All instances of ${0}",
    btRowsTotalCount : "Total : ${0}",
    btResultsInstanceFiltered: "Filtered instances of ${0}",
    btResultsEvent: "Events",
    btResultsEventInstance: "Events of ${0} instance ${1}",
    btColumnTxnId: "Transaction ID",
    btColumnStartTime: "Start Time",
    btColumnEndTime: "End Time/Time of Last Update",
    btColumnElapsedTime: "Elapsed Time",
    btColumnStatus: "Status",
    btColumnEventType: "Event Type",
    btColumnLocalTxn: "Local Txn ID",
    btColumnGlobalTxn: "Global Txn ID",
    btColumnFlowName: "Flow Name",
    btColumnTimestamp: "Timestamp",
    btColumnBusinessData: "Business Data ${0}",
    btSummaryButton: "Summary",
    btAddFlowButtonDesc: "Add message flows to this business transaction definition",
    btAddFlowTitle: "Add message flows to ${0}",
    btDeleteFlowButtonDesc: "Remove message flow from the business transaction",
    btDetailsButtonDesc: "See details for the business transaction",
    btAddFlowButton: "Add flow ",
    btDeleteFlowButton: "Remove flow",
    btDetailsButton: "Details",
    btValidateButton: "Validate",
    btNoStartEvent: "No start event defined.",
    btNoEndEvent: "No end event defined.",
    btNoFailureEvent: "No failure event defined.",
    btFlowFrom: "Deployed on ${0}",
    btAddFlowAction: "Add",
    btAddFlowClose: "Close",


    btAdd: "Add Event",
    btEdit: "Edit Event",
    btStartHint: "Add individual message flows or whole applications by clicking on the Add flow button.",
    btEventHint: "To promote a monitoring event to a business event, set the type of that business event in the event definition table.  You can set the type of business event to start, end, or failure.",
    btResultsViews: "Views",
    btHelp: "Help",
    btLeaveOrStay: "You have unsaved changes to the business transaction.",
    btRecLeaveOrStay: "You have unsaved changes to the business recorder.",
    btRecAttachLeaveOrStay: "You have unsaved changes related to attaching of the business recorder.",
    btLeaveSave: "Leave page",
    btReloadLastSaved: "Reload last saved",
    btStayOnPage: "Stay on the page",
    btMakeEnd: "Make End",
    btMakeFailure: "Make Failure",
    btMakeStart: "Make Start",
    btRole: "Flag as",
    btDoNotFlagRole: "Do not flag",
    btProgressRole: "Progress",
    btStartRole: "Start",
    btEndRole:"End",
    btFailureRole: "Failure",
    btEvents: "Business Events:",
    btType: "Type",
    btEventsForFlow: "Business Events for flow ${0}",
    btEventFromFlow: "${0} with events ${1}",


    btData: "Business Data",
    btStartEvent: "Start Event: ${0}",
    btEndEvent: "End Event: ${0}",
    btFailureEvent: "Fail Event: ${0}",
    btYes: "Yes",
    btCancel: "Cancel",
    btRemove: "Remove",
    btConfirmDeleteFlow: "Are you sure you want to remove flow ${0} from the business transaction?",
    btConfirmDeleteBTDs: "Are you sure you want to remove business transactions ${0} from the business recorder ${1}?",
    btConfirmDeleteBTX: "Are you sure you want to delete business transaction ${0}?",
    btConfirmDeleteYes: "Yes",
    btConfirmDeleteNo: "No",
    btDescription: "Description: ",
    btNameLabel: "Name: ",
    btDescriptionLabel: "Description:",
    btFlowValidation: "Flow Validation",
    btCorrelation: "Correlation information:",
    btCorrelationParent: "Parent ID:",
    btCorrelationGlobal: "Global ID:",
    btEvent: "Event:",
    btValue: "Source:",
    btNoCorrelation: "No correlation information.",
    btNoMonitoringEvent: "No monitoring events specified.",
    btdCreateTitle: "Create a Business Transaction Definition",
    btdCreateDescription: "Enter the name and description for the business transaction definition.",
    btdUpdateTitle: "Business Transaction Details",
    btdUpdateDescription: "Here are the business transaction details.",
    btdRenameTitle: "Enter a new name for the Business Transaction definition",
    btdRenameDescripton: "Rename the business transaction",

    btOdbcNameLabel: "ODBC Name:",
    btSchemaLabel: "Schema Name:",
    dbAttributesLabel: "Database Attributes",
    btTableLabel: "Business Transactions",
    btTableHint:"Select the business transactions that the recorder will monitor",
    btColumnName: "Name",
    btColumnDescription: "Description",
    btEgName: "Integration server name:",
    btGenRecorder: "Generated Business Recorder:",
    btPolicyNameHint: "A business recorder with the name ${0} will be generated and attached to integration server ${1}",

    btStartMonitoringTitle: "Start Monitoring Business Transactions",
    btStartMonitoringDescription: "Specify the configuration data for monitoring business transactions",

    btLinkToEditPolicySet: "Click here to specify a data source name",
    btLinkToEditPolicyChange: "Click here to modify the data source name",
    btPolicyDataSourceNameEmpty: "WARNING: The current data source name value is empty. Please choose an existing data source name to enable business transaction monitoring.",
    btPolicyDataSourceNameWarning: "WARNING: The current data source name value \"${0}\" is not available, please choose an existing data source name.",
    btLinkToResumeBTEdit: "Resume editing of business transaction ${0}",
    btDataSourceName: "Data source name:",
    btPolicyDataSourceNameLabel: "Resource: ${0}   Uri: ${1}",
    btConfigPolicyValueNotFound: "Unable to retrieve",
    btConfigPolicyValueNone: "Not set",
    btConfigMonitoringTitle: "Message flow monitoring status",
    btConfigMonitoringFalse: "Message flow(s) with monitoring disabled:",
    btConfigMonitoringUnknown: "Message flow(s) not found:",
    btConfigMonitoringValid: "All message flows that reference a business transaction event have monitoring enabled.",
    btConfigMonitoringUserAction: "Enable monitoring on the message flows so that events in your business transaction definition can be recorded.",
    btConfigMonitoringNoFlows: "The business transaction definition does not include any message flows with flagged monitoring events. No message flows will be monitored in this business transaction.",

    btdEmptyNameErrorMsg : "The business transaction definition name cannot be empty.",
    btdInvalidNameErrorMsg : "The business transaction definition name is not valid.",
    btdNameDuplicateErrorMsg : "The business transaction definition name is already in use.",
    btdNameInvalidErrorMsg : "The name can only contain number, letter and '_' characters.",
    btdNoEventsPromoted: "No business events have been promoted.",

    btExistingViews: "Existing views",
    btNewView: "Create new view",
    btSummary: "Business Transaction Details",
    btMoreInfo: "More information",
    btValidationTitle: "Business Transaction Validation",
    btValidationGoodMsg: "Business transaction ${0} is valid.",

    btBusinessDataViewComboDefaultValue: "Select business store",
    btBusinessDataViewComboNone: "No stores available",

    btResultsTableBtxIdEmptyMsg: "The transaction id cannot be empty!",
    btResultsTableBtxId: "Transaction ID",
    btResultsTableStartTime: "Start Time",
    btResultsTableLastUpdate: "Last Update",
    btResultsTableElapsedTime: "Elapsed Time",
    btResultsTableStatus: "Status",
    btResultsTableResultsMessageRange: "Range",
    btResultsTableResultsMessageTotal: "Total",
    btResultsTableResultsNoPolicySelected: "To view business transaction results for the definition ${0}, select a business transaction recorder policy from the list",
    btResultsTableResultsNoResults: "No business transaction instances to display for the definition ${0}",
    btResultsTableOnEntry: "Click Refresh to display all the latest recorded business transactions, or click Filter to display a subset of business transactions based on their status or global transaction ID.",
    btResultsTableResultsNoRecorderPoliciesAssociated: "No business transaction recorder policies are associated for the business transaction definition ${0}. Create a business transaction recorder policy and add the business transaction to enable monitoring of results for this business transaction definition.",
    btResultsTableResultsFail: "Failed to load business transaction results for the defintion ${0}",
    btResultsTableResultsLoading: "Loading business transaction results...",
    btResultsTableFilterDialogTitle: "Filter",
    btResultsTableFilterDialogDescription: "Specify some filtering criteria",
    btResultsTableClearFilter: "Clear Filter",
    btResultsTableFilterDotDotDot: "Filter...",
    btResultsTableRefresh: "Refresh",
    btResultsTableRunningFilter: "In progress",
    btResultsTableSucceededFilter: "Ended",
    btResultsTableFailedFilter: "Failed",
    btResultsTableInconsistentFilter: "Inconsistent",
    btEventResultTablePleaseSelectBTDInstance : "Please select a business transaction instance",
    btEventResultsTableEventDetailsDialogTitle : "View Event Details",
    btEventResultsTableEventDetailsDialogDesc  : "View the details of the '${0}' event of '${1}' instance '${2}'",
    btEventResultsTableEventName: "Event Name",
    btEventResultsTableSourceAddress: "Event Source Address",
    btEventResultsTableType: "Event Type",
    btEventResultsTableLocalId: "Local Correlation ID",
    btEventResultsTableBitStream: "BitStream",
    btEventResultsTableException: "Exception",
    btEventResultsTableDetails: "Details",
    btEventResultsTableFlowName: "Flow Name",
    btEventResultsTableTimestamp: "Timestamp",
    btEventResultsTableResultsLoading: "Loading...",
    btEventResultsTableResultsNoEvents: "No monitoring events to display",
    btEventResultsTableNoFlows: "No message flows added to business transaction",
    btEventResultsTableNoMonitoringEvents: "No monitoring events defined for message flow",

    btEventsTableMessageFlowsRange: "Range",
    btEventsTableMessageFlowsTotal: "Total Message Flows",

    flowSlideLabel: "Zoom level",
    nodeTooltip: "Node type: ${0}",

    btEventTooltipTitleEvents: "Event Policy: ${0}",
    btEventTooltipTitleMonitoringEvents: "Monitoring events defined on node ${0}",

    // Names for node types
    nodeType: {
      ComIbmAggregateControlNode: "AggregateControl",
      ComIbmAggregateReplyNode: "AggregateReply",
      ComIbmAggregateRequestNode: "AggregateRequest",
      ComIbmCDInputNode: "CDInput",
      ComIbmCDOutputNode: "CDOutput",
      ComIbmCICSIPICRequestNode: "CICSIPICRequest",
      ComIbmCollectorNode: "Collector",
      ComIbmComputeNode: "Compute",
      ComIbmCORBARequestNode: "CORBARequest",
      ComIbmDatabaseInputNode: "DatabaseInput",
      ComIbmDatabaseNode: "Database",
      ComIbmDatabaseRetrieveNode: "DatabaseRetrieve",
      ComIbmDatabaseRouteNode: "DatabaseRoute",
      ComIbmDecisionServiceNode: "DecisionService",
      ComIbmDotNetComputeNode: "DotNetCompute",
      ComIbmDotNetInputNode:"DotNetInput",
      ComIbmEmailInputNode: "EmailInput",
      ComIbmEmailOutputNode: "EmailOutput",
      ComIbmFileInputNode: "FileInput",
      ComIbmFileOutputNode: "FileOutput",
      ComIbmFileReadNode: "FileRead",
      ComIbmFilterReadNode: "FilterRead",
      ComIbmFlowOrderNode: "FlowOrder",
      ComIbmFTEInputNode: "FTEInput",
      ComIbmFTEOutputNode: "FTEOutput",
      ComIbmHTTPAsyncRequestNode: "HTTPAsyncRequest",
      ComIbmHTTPAsyncResponseNode: "HTTPAsyncResponse",
      ComIbmHTTPHeaderNode: "HTTPHeader",
      ComIbmIMSRequestNode: "IMSRequest",
      ComIbmJavaComputeNode: "JavaCompute",
      ComIbmJDEdwardsInputNode: "JDEdwardsInput",
      ComIbmJDEdwardsOutputNode: "JDEdwardsOutput",
      ComIbmJMSClientInputNode: "JMSClientInput",
      ComIbmJMSClientOutputNode: "JMSClientOutput",
      ComIbmJMSClientReceiveNode: "JMSClientReceive",
      ComIbmJMSClientReplyNode: "JMSClientReply",
      ComIbmJMSHeaderNode: "JMSHeader",
      ComIbmJMSMQTransformNode: "JMSMQTransform",
      ComIbmLabelNode: "Label",
      ComIbmMQGetNode: "MQGet",
      ComIbmMQHeaderNode: "MQHeader",
      ComIbmMQInputNode: "MQInput",
      ComIbmMQJMSTransformNode: "MQJMSTransform",
      ComIbmMQOutputNode: "MQOutput",
      ComIbmMQReplyNode: "MQReply",
      ComIbmMSLMappingNode: "MSLMapping",
      ComIbmPassthruNode: "Passthru",
      ComIbmPeopleSoftInputNode: "PeopleSoftInput",
      ComIbmPeopleSoftOutputNode: "PeopleSoftOutput",
      ComIbmPhpComputeNode: "PhpCompute",
      ComIbmPSServiceNode: "PSService",
      ComIbmReSequenceNode: "ReSequence",
      ComIbmResetContentDescriptorNode: "ResetContentDescriptor",
      ComIbmRouteNode: "Route",
      ComIbmRouteToLabelNode: "RouteToLabel",
      ComIbmSAPInputNode: "SAPInput",
      ComIbmSAPReplyNode: "SAPReply",
      ComIbmSAPRequestNode: "SAPRequest",
      ComIbmSCAAsyncRequestNode: "SCAAsyncRequest",
      ComIbmSCAAsyncResponseNode: "SCAAsyncResponse",
      ComIbmSCAInputNode: "SCAInput",
      ComIbmSCAReplyNode: "SCAReply",
      ComIbmSCARequestNode: "SCARequest",
      ComIbmSecurityPEPNode: "SecurityPEP",
      ComIbmSequenceNode: "Sequence",
      ComIbmSiebelInputNode: "SiebelInput",
      ComIbmSiebelRequestNode: "SiebelRequest",
      ComIbmSOAPAsyncRequestNode: "SOAPAsyncRequest",
      ComIbmSOAPAsyncResponseNode: "SOAPAsyncResponse",
      ComIbmSOAPEnvelopeNode: "SOAPEnvelope",
      ComIbmSOAPExtractNode: "SOAPExtract",
      ComIbmSOAPInputNode: "SOAPInput",
      ComIbmSOAPReplyNode: "SOAPReply",
      ComIbmSOAPRequestNode: "SOAPRequest",
      ComIbmTCPIPClientInputNode: "TCPIPClientInput",
      ComIbmTCPIPClientOutputNode: "TCPIPClientOutput",
      ComIbmTCPIPClientReceiveNode: "TCPIPClientReceive",
      ComIbmTCPIPServerInputNode: "TCPIPServerInput",
      ComIbmTCPIPServerOutputNode: "TCPIPServerOutput",
      ComIbmTCPIPServerReceiveNode: "TCPIPServerReceive",
      ComIbmThrowNode: "Throw",
      ComIbmTimeoutControlNode: "TimeoutControl",
      ComIbmTraceNode: "Trace",
      ComIbmTryCatchNode: "TryCatch",
      ComIbmTwineBallInputnode: "TwineBallInput",
      ComIbmTwineBallRequestNode: "TwineBallRequest",
      ComIbmValidateNode: "Validate",
      ComIbmWSInputNode: "WSInput",
      ComIbmWSReplyNode: "WSReply",
      ComIbmWSRequestNode: "WSRequest",
      ComIbmXslMqsiNode: "XslMqsi"
    },

    //Resources
    resourceTitle: "Resource",
    resource: {
      label: "Name",
      version: "Version",
      uuid: "UUID",
      modifyTime: "Modified Time",
      deployTime: "Deployed Time",
      barFileName: "BAR File Name",
      calculated_type: "Type"
    },

    //Sub Flows
    subflowTitle: "Sub Flow",
    subFlow: {
      label: "Sub Flow Name",
      uuid: "UUID",
      modifyTime: "Modified Time",
      deployTime: "Deployed Time",
      barFileName: "BAR File Name",
      calculated_type: "Type",
      version: "Version",
      inactiveUserExitList:"Inactive User Exit List",
      activeUserExitList:"Active User Exit List"
    },

    // resource file type
    resource_file_generic_Type_Description: "${0} File",
    resource_file_subflow_Type_Description: "Subflow",
    resource_file_xsd_Type_Description: "Schema",
    resource_file_xsdzip_Type_Description: "Schema Zip",
    resource_file_appdomainzip_Type_Description: "App Domain Zip",
    resource_file_dictionary_Type_Description: "Dictionary",
    resource_file_txt_Type_Description: "Text Document",
    resource_file_rules_Type_Description: "Decision Service",

    // Message Flows
    msgflowTitle: "Message Flow",
    messageFlow: {
      uuid: "UUID",
      commitCount: "Commit Count",
      traceLevel: "Service Trace Level",
      monitoringProfile: "Monitoring Profile",
      monitoring: "Monitoring",
      additionalInstances: "Additional Instances",
      startMode: "Start Mode",
      coordinatedTransaction: "Coordinated Transaction",
      commitInterval: "Commit Interval",
      runState: "Message Flow Status",
      label: "Message Flow Name",
      userTraceLevel: "User Trace Level",
      modifyTime: "Modified Time",
      deployTime: "Deployed Time",
      barFileName: "BAR File Name",
      shortDesc: "Short Description",
      longDesc: "Long Description",
      noUserDefinedPropertiesDefined: "None defined",
      StatsSnapPublicationOn: "Snapshot Statistics",
      StatsSnapThreadDataLevel: "Snapshot Statistics Thread Data",
      StatsSnapNodeDataLevel: "Snapshot Statistics Node Data",
      StatsSnapOutputFormat: "Snapshot Statistics Format",
      StatsSnapAccountingOrigin: "Snapshot Statistics Accounting Origin",
      StatsArchivalOn: "Archive Statistics",
      StatsArchiveOutputFormat: "Archive Statistics Format",
      StatsArchiveThreadDataLevel: "Archive Statistics Thread Data",
      StatsArchiveNodeDataLevel: "Archive Statistics Node Data",
      StatsArchiveAccountingOrigin: "Archive Statistics Accounting Origin",
      version: "Version",
      isRunning: "Running",
      runMode: "Run Mode",
      testRecordMode: "Test Record Mode",
      inactiveUserExitList:"Inactive User Exit List",
      activeUserExitList:"Active User Exit List"
    },

    messageFlow_monitoring_node: "Node",
    messageFlow_monitoring_from: "From",
    messageFlow_monitoring_to: "To",
    messageFlow_monitoring_currentcputime: "Current Total CPU Time (&micro;s)",
    messageFlow_monitoring_cputime: "Total CPU Time (ms)",
    messageFlow_monitoring_elapsedtime: "Total Elapsed Time (ms)",
    messageFlow_monitoring_maximum: "Maximum",
    messageFlow_monitoring_average: "Average",
    messageFlow_monitoring_minimum: "Minimum",
    messageFlow_monitoring_graphtitle: "Message Flow Statistics: ",
    messageFlow_monitoring_totalcputime: "Total CPU Time",
    messageFlow_monitoring_flowName: "Flow Name",
    messageFlow_monitoring_threadNumber: "Thread Number",
    messageFlow_monitoring_value: "Value",
    messageFlow_monitoring_time: "Time",
    messageFlow_monitoring_interval: "Interval",
    messageFlow_monitoring_session: "Session",
    messageFlowUnits_TotalCPUTime: "&micro;s",

    messageFlow_monitoring_cputime_min: "Minimum CPU Time (ms)",
    messageFlow_monitoring_elapsedtime_min: "Minimum Elapsed Time (ms)",
    messageFlow_monitoring_cputime_max: "Maximum CPU Time (ms)",
    messageFlow_monitoring_elapsedtime_max: "Maximum Elapsed Time (ms)",
    messageFlow_monitoring_cputime_avg: "Average CPU Time (ms)",
    messageFlow_monitoring_elapsedtime_avg: "Average Elapsed Time (ms)",

    // Statistics
    statistics: {
      ms: "ms", //milliseconds
      InvocationCount: "Invocations",
      chartTitle: "Chart",
      gridTitle: "Table",
      MessageFlow: "Flow Summary",
      Nodes: "Nodes",
      Applications: "Applications",
      MessageFlows: "Message Flows",
      MessagesPerSecond: "Message Rate (messages/s)",
      TimePerMessage: "Average Elapsed Time/ Invocation (ms)",
      MessageCount: "Total Input Messages",
      CPU: "Average CPU Time/ Invocation (ms)",
      ThreadCount: "Active Threads",
      ThreadStatistics: "Threads",
      Backouts: "Backouts",
      TotalElapsedTime: "Total Elapsed Time (ms)",
      MaximumElapsedTime: "Maximum Elapsed Time (ms)",
      MinimumElapsedTime: "Minimum Elapsed Time (ms)",
      TotalCPUTime: "Total CPU Time (ms)",
      MaximumCPUTime: "Maximum CPU Time (ms)",
      MinimumCPUTime: "Minimum CPU Time (ms)",
      CPUTimeWaitingForInputMessage: "Total CPU Time Waiting for Input Message (ms)",
      ElapsedTimeWaitingForInputMessage: "Total Elapsed Time Waiting for Input Message (ms)",
      TotalInputMessages: "Total Input Messages",
      TotalSizeOfInputMessages: "Total Size of Input Messages (Kb)",
      MaximumSizeOfInputMessages: "Maximum Size of Input Messages (Kb)",
      MinimumSizeOfInputMessages: "Minimum Size of Input Messages (Kb)",
      NumberOfThreadsInPool: "Number of Threads in Pool",
      TimesMaximumNumberOfThreadsReached: "Times Maximum Number of Threads Reached",
      TotalNumberOfMQErrors: "Total Number of MQ Errors",
      TotalNumberOfMessagesWithErrors: "Total Number of Messages with Errors",
      TotalNumberOfErrorsProcessingMessages: "Total Number of Errors Processing Messages",
      TotalNumberOfTimeOutsWaitingForRepliesToAggregateMessages: "Total Aggregation Timeouts",
      TotalNumberOfCommits: "Total Number of Commits",
      TotalNumberOfBackouts: "Total Number of Backouts",
      time: "Time",
      flowNone: "...",
      nodesNone: "...",
      threadsNone: "...",
      show: "Show",
      metric: "Metric",
      duration_180: "3 minutes of data",
      duration_300: "5 minutes of data",
      duration_600: "10 minutes of data",
      colSelection: "Column selection",
      gridIcon: "Tabular Statistics",
      chartIcon: "Charted Statistics",
      parentFlow: "Parent Flow",
      goTo: "Go to",
      latestTitle: "Latest",
      highTitle: "Highest",
      averageTitle: "Average",
      lowTitle: "Lowest",
      per_message_description: "Session data",
      minute: "minute",
      minutes: "minutes",
      statsTrend_session_description: " Updates from ${startTime} (${minutes} ${minString} ago). Last updated at ${nowTime}",
      messageFlow_trendToolbar_setX_Label: "Time range:",
      messageFlow_trendToolbar_range_Session: "Session",
      messageFlow_trendToolbar_range_5mins: "5 mins",
      messageFlow_trendToolbar_range_15mins: "15 mins",
      messageFlow_trendToolbar_range_30mins: "30 mins",
      messageFlow_trendToolbar_range_60mins: "60 mins",
      messageFlow_trendToolbar_show_split_graph: "Split graph",
      messageFlow_trendToolbar_show_Min_Max: "Min/Max",
      maxNodesReached: "A maximum of ${0} nodes can be displayed. This number has been exceeded. Node table will not be shown."
    },

    statisticsDiagnosticsTitle: "Diagnostics Advice",
    statisticsThroughputTitle: "Throughput by Flows for last ${0} seconds",
    statisticsThroughputFlowsTitle: "Throughput per message flow for last ${0} seconds. Last updated at ${1}.",
    statisticsTimePerNodeTitle: "Nodes for all flows in ${0}",
    statisticsSummary: "Flow comparison",
    statisticsFlowProfile: "Flow profile",
    statisticsNodesInFlow: "Latest data per node",
    statisticsNode: "Node",
    statisticsContainer:"Container",

    // Resource Statistics
    resourceStatisticsAnalysis: "Resource analysis",
    egResourceStatistics: "Resource statistics",
    resource_statistics_file_prefix: "ResourceStatistics",
    resource_statistics_snapshot_time: "Snapshot Time",
    resource_statistics_resource_type: "Resource Type",
    resource_statistics_resource_identifier: "Resource Identifier",
    resource_statistics_resource_type_Label: "Resource type:",
    JVM: "Java Virtual Machine (JVM)",
    Parsers: "Parsers",
    SOAPInput: "SOAP Input",
    GlobalCache: "Global Cache",
    DecisionServices: "Decision Services",
    FTEAgent: "FTE Agent",
    FTP: "FTP",
    File: "File",
    JDBCConnectionPools: "JDBC Connection Pools",
    JMS: "JMS",
    ODBC: "ODBC",
    Security: "Security",
    Sockets: "Sockets",
    TCPIPClientNodes: "TCPIP Client Nodes",
    TCPIPServerNodes: "TCPIP Server Nodes",
    CORBA: "CORBA",
    CICS: "CICS",
    ConnectDirect: "Connect Direct",
    MQTT: "MQTT",
    "DotNet GC": ".NET Garbage Collection", // Attribute name must be quoted
    "DotNet App Domains": ".NET Application Domains", // Attribute name must be quoted
    name: "Name",
    InitialMemoryInMB: "Initial Memory (MB)",
    UsedMemoryInMB: "Used Memory (MB)",
    CommittedMemoryInMB: "Committed Memory (MB)",
    MaxMemoryInMB: "Maximum Memory (MB)",
    CumulativeGCTimeInSeconds: "Cumulative GC Time (Seconds)",
    CumulativeNumberOfGCCollections: "Cumulative Number Of Garbage Collections",
    Threads: "Threads",
    ApproxMemKB: "Approximate Memory (KB)",
    MaxReadKB: "Maximum Read (KB)",
    MaxWrittenKB: "Maximum Written (KB)",
    Fields: "Fields",
    Reads: "Reads",
    FailedReads: "Failed Reads",
    Writes: "Writes",
    FailedWrites: "Failed Writes",
    InboundMessagesTotal: "Total Inbound Messages",
    RepliesSentTotal: "Total Replies Sent",
    InboundMessagesMadeFlow: "Inbound Messages Made Flow",
    InboundMessagesFaultedBeforeFlow: "Inbound Messages Faulted Before Flow",
    SuccessfulRepliesSent: "Successful Replies Sent",
    FaultRepliesSent: "Fault Replies Sent",
    PolicySetApplied: "Policy Set Applied",
    TotalMapActions: "Total Map Actions",
    MapReads: "Map Reads",
    MapWrites: "Map Writes",
    MapRemoves: "Map Removes",
    FailedActions: "Failed Actions",
    MapsUsed: "Maps Used",
    ConnectionFailures: "Connection Failures",
    Connects: "Connects",
    SuccessfulDecisions: "Successful Decisions",
    FailedDecisions: "Failed Decisions",
    RulesMatched: "Rules Matched",
    InboundTransfers: "Inbound Transfers",
    InboundBytes: "Inbound Bytes",
    OutboundTransfers: "Outbound Transfers",
    OutboundBytes: "Outbound Bytes",
    FTPGets: "FTP Gets",
    BytesReceived: "Bytes Received",
    FTPPuts: "FTP Puts",
    BytesSent: "Bytes Sent",
    Protocol: "Protocol",
    FilesRead: "Files Read",
    RecordsRead: "Records Read",
    BytesRead: "Bytes Read",
    FilesCreated: "Files Created",
    RecordsWritten: "Records Written",
    BytesWritten: "Bytes Written",
    NameOfJDBCProvider: "Name Of JDBC Provider",
    MaxSizeOfPool: "Maximum Size Of Pool",
    ActualSizeOfPool: "Actual Size Of Pool",
    CumulativeRequests: "Cumulative Requests",
    CumulativeDelayedRequests: "Cumulative Delayed Requests",
    CumulativeTimedOutRequests: "Cumulative Timed Out Requests",
    MaxDelayInMilliseconds: "Maximum Delay (ms)",
    NumberOfOpenJMSConnections: "Number Of Open JMS Connections",
    NumberOfClosedJMSConnections: "Number Of Closed JMS Connections",
    NumberOfOpenJMSSessions: "Number Of Open JMS Sessions",
    NumberOfClosedJMSSessions: "Number Of Closed JMS Sessions",
    NumberOfMessagesReceived: "Number Of Messages Received",
    NumberOfMessagesSent: "Number Of Messages Sent",
    NumberOfMessagesBrowsed: "Number Of Messages Browsed",
    NumberOfJMSConnectionFailures: "Number Of JMS Connection Failures",
    ExecuteSuccess: "Execute Success",
    ExecuteFailure: "Execute Failure",
    ActiveConnections: "Active Connections",
    ClosedConnections: "Closed Connections",
    ConnectionErrors: "Connection Errors",
    TotalCacheEntries: "Total Cache Entries",
    TotalOperations: "Total Operations",
    TotalSuccessfulOperations: "Total Successful Operations",
    TotalOperationsServicedByCache: "Total Operations Serviced By Cache",
    TotalSockets: "Total Sockets",
    TotalMessages: "Total Messages",
    TotalDataSent_KB: "Total Data Sent (KB)",
    TotalDataReceived_KB: "Total Data Received (KB)",
    "SentMessageSize_0-1KB": "Sent Message Size 0-1KB", // Attribute name must be quoted
    "SentMessageSize_1KB-10KB": "Sent Message Size 1KB-10KB", // Attribute name must be quoted
    "SentMessageSize_10KB-100KB": "Sent Message Size 10KB-100KB", // Attribute name must be quoted
    "SentMessageSize_100KB-1MB": "Sent Message Size 100KB-1MB", // Attribute name must be quoted
    "SentMessageSize_1MB-10MB": "Sent Message Size 1MB-10MB", // Attribute name must be quoted
    SentMessageSize_Over10MB: "Sent Message Size Over10MB",
    "ReceivedMessageSize_0-1KB": "Received Message Size 0-1KB", // Attribute name must be quoted
    "ReceivedMessageSize_1KB-10KB": "Received Message Size 1KB-10KB", // Attribute name must be quoted
    "ReceivedMessageSize_10KB-100KB": "Received Message Size 10KB-100KB", // Attribute name must be quoted
    "ReceivedMessageSize_100KB-1MB": "Received Message Size 100KB-1MB", // Attribute name must be quoted
    "ReceivedMessageSize_1MB-10MB": "Received Message Size 1MB-10MB", // Attribute name must be quoted
    "ReceivedMessageSize_Over10MB": "Received Message Size Over10MB", // Attribute name must be quoted
    OpenConnections: "Open Connections",
    MessagesReceived: "Messages Received",
    MessagesSent: "Messages Sent",
    FailedConnections: "Failed Connections",
    FailedSSLConnections: "Failed SSL Connections",
    OutboundInvocations: "Outbound Invocations",
    OutboundSuccessfulInvocations: "Outbound Successful Invocations",
    OutboundCorbaExceptions: "Outbound CORBA Exceptions",
    RequestSuccess: "Request Success",
    RequestFailures: "Request Failures",
    RequestSecurityFailures: "Request Security Failures",
    ConnectionAttemptFailures: "Connection Attempt Failures",
    NoHitTransfers: "No Hit Transfers",
    ExplicitGCCount: "Explicit GC Count",
    Gen0CollectionsTaken: "Generation 0 Collections Taken",
    Gen1CollectionsTaken: "Generation 1 Collections Taken",
    Gen2CollectionsTaken: "Generation 2 Collections Taken",
    CommittedInMB: "Committed (MB)",
    ReservedInMB: "Reserved (MB)",
    Gen0HeapSizeInMB: "Generation 0 Heap Size (MB)",
    Gen1HeapSizeInMB: "Generation 1 Heap Size (MB)",
    Gen2HeapSizeInMB: "Generation 2 Heap Size (MB)",
    LargeObjectHeapSizeInMB: "Large Object Heap Size (MB)",
    PromotedFromGen0InMB: "Promoted From Generation 0 (MB)",
    PromotedFromGen1InMB: "Promoted From Generation 1 (MB)",
    CurrentlyInUseInMB: "Currently In Use (MB)",
    TotalAllocatedInMB: "Total Allocated (MB)",
    Id: "ID",
    ApplicationBase: "Application Base",

    // Monitoring
    monitoringTitle: "Monitoring",

    // REST APIs
    restApis_parameterName: "Parameter",
    restApis_parameterType: "Type",
    restApis_parameterRequired: "Required?",
    restApis_parameterDescription: "Description",
    restApis_parameterTypes: {
      FORM: "Form encoded",
      HEADER: "Header",
      PATH: "Path",
      QUERY: "Query string"
    },
    restApis_parameterRequired_answer: {
      "true": "Yes",
      "false": "No"
    },
    restApis_implemented: "Implemented",
    restApis_notImplemented: "Not implemented",
    restApis_noParameters: "There are no parameters defined for this operation",

    restApis_open: "Open",
    restApis_closed: "Closed",

    // ${0} = resource name, ${1} = description, ${2} = open or closed
    restApis_resourceWithDescription: "Resource ${0}, ${2}, expandable, ${1}",
    // ${0} = resource name, ${1} = open or closed
    restApis_resourceWithoutDescription: "Resource ${0}, expandable, ${1}",

    // ${0} = operation name, ${1} = HTTP method, ${4} = description, ${2} = implemented or not implemented, ${3} = open or closed
    restApis_operationWithDescription: "Operation ${0}, HTTP ${1}, ${4}, ${2}, expandable, ${3}",
    // ${0} = operation name, ${1} = HTTP method, ${2} = implemented or not implemented, ${3} = open or closed
    restApis_operationWithoutDescription: "Operation ${0}, HTTP ${1}, ${2}, expandable, ${3}",

    // ${0} = parameter type, ${1} = parameter name, ${2} = description
    restApis_requiredParameterWithDescription: "Required ${0} parameter ${1}, ${2}",
    // ${0} = parameter type, ${1} = parameter name
    restApis_requiredParameterWithoutDescription: "Required ${0} parameter ${1}",

    // ${0} = parameter type, ${1} = parameter name, ${2} = description
    restApis_optionalParameterWithDescription: "Optional ${0} parameter ${1}, ${2}",
    // ${0} = parameter type, ${1} = parameter name
    restApis_optionalParameterWithoutDescription: "Optional ${0} parameter ${1}",

    // Bulk RESTApi Push
    pushApisTitle: "Push REST APIs to IBM API Connect",
    pushApisConnectionDesc: "Define a connection to the IBM API Connect system",
    pushApisServerDesc: "Management Cluster / Server Address",
    pushApisHost: "Host",
    pushApisPort: "Port",
    pushApisAuthenticationDesc: "Authentication",
    pushApisUser: "UserID",
    pushApisPassword: "Password",
    pushApisCatalog: "Catalog",
    pushApisCatalogDesc: "Select the catalog where the product will be staged",
    pushApisTestConnection: "Connect to IBM API Connect",
    pushApisOrganization: "Organization",
    pushApisOrganizationDesc: "Select the target organization",
    pushApisProductTitle: "Title",
    pushApisProductName: "Name",
    pushApisProductVersion: "Version",
    pushApisProductDesc: "Specify the product title, name, and version",
    pushApisSelectDesc: "Select the REST APIs to push to IBM API Connect",
    pushApisAdvancedDesc: "Advanced configuration options",
    pushApisOverrideHTTPTitle: "Override the host and port used by IBM API Connect to invoke the APIs",
    pushApisOverrideHTTPDesc: "When access to IBM Integration Bus from IBM API Connect is via a proxy or gateway, provide details of the host name and port that IBM API Connect must use to invoke the APIs. To use the value from the integration server, leave the field blank.",
    pushApisAPIHostTitle: "Host name",
    pushApisAPIPortTitle: "Port",
    pushApisTableName: "REST API Name",
    pushApisTableTitle: "Title",
    pushApisTableVersion: "Version",
    pushApisPush: "Push to IBM API Connect",
    pushApisRetry: "Retry",
    pushApisNoStageInCatalog: "Do not stage in catalog",
    pushApiTestConnectionLoading: "Connecting to IBM API Connect...",
    pushApiTestConnectionSuccess: "Successfully connected to IBM API Connect",
    pushApiTestConnectionFailure: "Unable to connect to IBM API Connect.",
    pushApiTestConnectionFailureReason: "Unable to connect to IBM API Connect. Reason '${0}'",
    pushApiConnectionRefused: "Unable to connect to IBM API Connect at host '${0}' port '${1}'",
    pushApiAPIConnectVersionError: "The selected installation of IBM API Connect is not supported by this command. The minimum supported version of IBM API Connect is version '${0}'",
    pushApiTestConnectionRequiredField: "Field '${0}' is a required parameter for connecting to IBM API Connect",
    pushApiTestConnectionInvalidField: "Field '${0}' is not a valid parameter value for connecting to IBM API Connect",
    pushApiTestConnectionFieldsChanged: "Connection parameters have changed since testing the connection. Retry the connection or revert to the previous values",
    pushApiTargetValuesLoading: "Fetching IBM API Connect organization information",
    pushApiTargetValuesNoOrgs: "The current user credentials have no organizations to select",
    pushApiTargetValuesProductTitleNonEmpty: "A title for the product must be specified",
    pushApiTargetValuesProductNameNonEmpty: "A name for the product must be specified",
    pushApiTargetValuesProductVersionNonEmpty: "A valid version for the product must be specified",
    pushApiTargetValuesProductWillBeCreated: "The draft product '${0}' with version '${1}' will be created",
    pushApiTargetValuesProductWillBeUpdated: "The existing draft product '${0}' with version '${1}' will be updated",
    pushApiTargetValuesProductTitleMismatch: "The product name '${0}' with version '${1}' is already used by a product with the title '${2}'",
    pushApiTargetValuesCatalogProductWillBeCreated:"The product '${0}' with version '${1}' will be created in catalog '${2}'",
    pushApiTargetValuesCatalogProductNotStage:"The product '${0}' with version '${1}' will not be staged.",
    pushApiTargetValuesCatalogProductWillBeReplaced:"The existing product '${0}' with version '${1}' will be replaced in catalog '${2}'",
    pushApiGridNoRestApis: "No REST APIs are available to push to IBM API Connect",
    pushApiGridNoRestApisSelected: "No REST APIs have been selected to push to IBM API Connect",
    pushApisInvalidHostErrorMsg : "The host can contain only numbers, letters, '.' and '-' characters",
    pushApisInvalidPortErrorMsg : "The port can contain only numbers",
    pushApisInvalidVersionErrorMsg : "The version can contain only numbers and '.' characters",
    pushApisInvalidProductNameErrorMsg : "The product name can contain only numbers, letters, '-' and '_' characters",

    pushApiFeedbackTitle: "Pushing REST APIs to IBM API Connect...",
    pushApiFeedbackPushApiProgress: "Pushing REST API '${0}' to IBM API Connect",
    pushApiFeedbackPushApiComplete: "Successfully pushed REST API '${0}' to IBM API Connect",
    pushApiFeedbackPushApiFail: "Failed to push REST API '${0}' to IBM API Connect. Reason '${1}'",
    pushApiFeedbackAssociateApiProgress: "Adding REST API '${0}' to product '${1}' in IBM API Connect",
    pushApiFeedbackCreateProductApiComplete: "Successfully created product '${0}' and added REST API '${1}' in IBM API Connect",
    pushApiFeedbackUpdateProductApiComplete: "Successfully added REST API '${1}' to product '${0}' in IBM API Connect",
    pushApiFeedbackCreateProductApiFail: "Failed to create product '${0}' in IBM API Connect. Reason '${1}'",
    pushApiFeedbackUpdateProductApiFail: "Failed to add REST API '${1}' to product '${0}' in IBM API Connect. Reason '${2}'",
    pushApiFeedbackStageProductProgress: "Staging product '${0}' to catalog '${1}' in IBM API Connect",
    pushApiFeedbackStageProductComplete: "Successfully staged product '${0}' to catalog '${1}' in IBM API Connect",
    pushApiFeedbackStageProductFail: "Failed to stage product '${0}' to catalog '${1}' in IBM API Connect. Reason '${2}'",
    pushApiFeedbackApiNotDeployed: "The REST API '${0}' is not deployed on the integration server",

    pushApiFeedbackSummaryStageSuccess: "Summary: SUCCESS - added '${0}' REST APIs to the product '${1}', which was staged in catalog '${2}'",
    pushApiFeedbackSummarySuccess: "Summary: SUCCESS - added '${0}' REST APIs to the draft product '${1}'",
    pushApiFeedbackSummaryAllFail: "Summary: FAIL - No APIs were added to the product '${0}'",
    pushApiFeedbackSummaryStageFail: "Summary: PARTIAL - added '${0}' REST APIs to the product '${1}' but staging of the product in '${2}' failed",
    pushApiFeedbackSummaryPartial: "Summary: PARTIAL - '${0}' APIs were added to the product '${1}'. '${2}' APIs could not be pushed or added to the product",
    pushApiFeedbackSummaryStagePartial: "Summary: PARTIAL - '${0}' APIs were added to the product '${1}', which was staged in catalog '${2}'. '${3}' APIs could not be pushed or added to the product",
    pushApiFeedbackSummaryPartialStageFail: "Summary: FAIL - '${0}' APIs were added to the product '${1}' but staging of the product in '${2}' failed. '${3}' APIs could not be pushed or added to added to the product",

    // BAR deployment
    deployBARDialogTitle: "Deploy BAR File",
    deployBARInstruction: "Select a BAR file to deploy. Optionally, provide an overrides file.",
    labelBAR: "BAR file:",
    labelOverrides: "Overrides file:",
    buttonChoose: "Browse",
    buttonClear: "Clear",
    buttonDeploy: "Deploy",
    buttonOverrides: "Overrides",
    menuSelectOverrides: "Select overrides file",
    menuClearOverrides: "Clear overrides",
    deployPreviewContentColumn: "Content",
    deployPreviewValueColumn: "Value",
    labelConfiguredProperties: "Deploy preview:",
    UploadError_UploadFailed : "Upload failed : ",
    readBARError_invalidBAR: "The selected file is not a valid BAR.",
    readBARError_errorReadingBAR: "Error reading the BAR file.",
    readBARInfo_noConfigPropertiesInBAR: "No configurable properties are found in ${0}.",
    readOverridesError_errorReadingOverrides: "Error reading the overrides file.",
    appliedOverridesSuccess: "${0} has been successfully applied to ${1}.",
    clearOverridesSuccess: "${0} has been successfully cleared."
  },

  // If you change this, you MUST change the build config to package them correctly!
  "de": true,
  "es": true,
  "fr": true,
  "it": true,
  "ja": true,
  "ko": true,
  "pl": true,
  "pt": true,
  "ru": true,
  "tr": true,
  "zh-cn": true,
  "zh-tw": true
});

},
'webui/widgets/restapi/Api':function(){
/*
 * <copyright
 * notice="lm-source"
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2"
 * years="2015,2016"
 * crc="857113219" >
 * Licensed Materials - Property of IBM
 *
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2
 *
 * (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.
 * </copyright>
 */

define([
  "dojo/i18n!webui/nls/web",
  "dojo/text!./templates/Api.html",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/dom-construct",
  "dojo/hash",
  "dojo/request/xhr",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase",
  "dijit/_WidgetsInTemplateMixin",
  "webui/utils/RestUri",
  "webui/utils/WebUiHash",
  "webui/widgets/common/AttributesStore",
  "webui/widgets/common/Toolbar",
  "webui/widgets/common/Trace",
  "webui/widgets/restapi/Resource",
  "webui/widgets/common/PropertiesStore"
], function(
  NLS,
  template,
  declare,
  lang,
  domAttr,
  domConstruct,
  hash,
  xhr,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  RestUri,
  WebUiHash,
  AttributesStore,
  Toolbar,
  Trace,
  Resource,
  PropertiesStore
) {
  return declare("webui.widgets.restapi.Api", [ _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin ], {

    templateString : template,
    toolbar : null,
    api : null,
    NLS : null,
    resources : [],
    _propertiesStore: new PropertiesStore(),

    constructor : function() {

      // We need the NLS messages for the template.
      this.NLS = NLS;

    },

    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      // Create the toolbar.
      this.toolbar = new Toolbar();
      domConstruct.place(this.toolbar.domNode, this._toolbar);
      this.toolbar.addLeftAlignButtons("title");
      var buttons = [ "expandAll", "collapseAll" ];
      this.toolbar.addRightAlignButtons(buttons);
      this.toolbar.setButtonState("enable", buttons);
      this.toolbar.connectButtons("expandAll", "click", this, "expandAll");
      this.toolbar.connectButtons("collapseAll", "click", this, "collapseAll");

      this._attributesStore = new AttributesStore();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },

    resize : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");
      this.inherited(arguments);
      this._borderContainer.resize();
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
    },

    tabBlur : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
      this.inherited(arguments);
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
    },

    tabFocus : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");
      this.inherited(arguments);

      // Depending on where we are loaded from, the hash will end in /<restApiName>
      // or /api. We need the URI of the API definitions, which is /<restApiName>/api,
      // so look to see if we need to add it on.
      var apiRestUri = new WebUiHash(hash()).getRestUri();
      var apiComponents = apiRestUri.getComponents();
      if (apiComponents[apiComponents.length - 2] === 'restapis') {
        apiComponents.push('api');
      }
      apiRestUri = new RestUri({components: apiComponents});
      var apiURI = apiRestUri.toString();

      // Then, for the properties store, we need the URI of the REST API. Now we know
      // that the components array ends with /<restApiName>/api, remove the /api.
      apiComponents.pop();
      var parentRestUri = new RestUri({components: apiComponents});
      var parentURI = parentRestUri.toString();

      // Get REST API name and add to the toolbar title
      this.toolbar.setAttribute("title", "innerHTML", "");
      var populate = this._attributesStore.populateAttributesStore(parentURI);
      populate.then(lang.hitch(this, function() {
        domAttr.set("_infoPaneTitleID", "innerHTML", this._attributesStore.getAttribute("name") + " - " + NLS.restApiTitle);
      }));
      var populate2 = this._propertiesStore.populatePropertiesStore(parentURI);
      populate2.then(lang.hitch(this, function() {
        var baseURL = this._propertiesStore.getProperty("basic", "localBaseURL");
        baseURL = baseURL.replace("//localhost", "//" + window.location.hostname);
        this._baseURL.innerHTML = baseURL;
        this._baseURL.href = baseURL;

        var definitionsURL = this._propertiesStore.getProperty("basic", "localDefinitionsURL");
        definitionsURL = definitionsURL.replace("//localhost", "//" + window.location.hostname);
        this._definitionsURL.innerHTML = definitionsURL;
        this._definitionsURL.href = definitionsURL;
      }));

      // Clear out the API content we do have.
      domConstruct.empty(this._container);

      // Download the API.
      xhr.get(apiURI, {
        handleAs : 'json',
        headers : {
          Accept : 'application/json'
        }
      }).then(lang.hitch(this, 'displayApi'), function(error) {
        alert(error);
      });

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
    },

    tabRemove : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
      this.inherited(arguments);
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
    },

    displayApi : function(api) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "displayApi");

      // Save the API for later.
      this.api = api;

      // Sort the resources depending on their path.
      api.resources.sort(function(a, b) {
        return a.path < b.path ? -1 : a.path > b.path ? 1 : 0;
      });

      // For each resource ...
      api.resources.forEach(lang.hitch(this, function(resource) {

        // ... add a new resource widget.
        var newResource = new Resource({
          resource : resource
        });
        this.resources.push(newResource);
        domConstruct.place(newResource.domNode, this._container);

      }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "displayApi");
    },

    expandAll : function() {
      this.resources.forEach(function(resource) {
        resource.expandAll();
      });
    },

    collapseAll : function() {
      this.resources.forEach(function(resource) {
        resource.collapseAll();
      });
    }

  });
});

},
'webui/widgets/adminlog/adminlog':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="3683196010" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/adminlog/templates/adminlog.html",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/array",
  "dojo/_base/declare",
  "dojo/_base/fx",
  "dojo/_base/lang",
  "dojo/data/ObjectStore",
  "dojo/date/locale",
  "dojo/dom-attr",
  "dojo/dom-class",
  "dojo/dom-construct",
  "dojo/on",
  "dojo/query",
  "dojo/request/xhr",
  "dojo/store/Memory",
  "dojo/topic",
  "dijit/_WidgetBase",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetsInTemplateMixin",
  "dojox/grid/DataGrid",
  "webui/config/Resources",
  "webui/utils/RestUri",
  "webui/widgets/common/Toolbar",
  "webui/widgets/common/Trace"
], function(
  template,
  NLS,
  array,
  declare,
  fx,
  lang,
  ObjectStore,
  locale,
  domAttr,
  domClass,
  domConstruct,
  on,
  query,
  xhr,
  Memory,
  topic,
  _WidgetBase,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  DataGrid,
  Resources,
  RestUri,
  Toolbar,
  Trace
) {
  var adminLog = declare("webui.widgets.adminlog.adminlog", [ _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin ], {
    templateString : template,
    widgetName : "webui.widgets.adminlog.adminlog",
    _layout : null,
    _grid : null,
    toolbar : null,
    _timeFormat : null,
    _topicHandle: null,

    postCreate : function() {
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      // Create toolbar
      this.toolbar = new Toolbar();
      domConstruct.place(this.toolbar.domNode, this._toolbar);
      this.toolbar.addLeftAlignButtons("title");

      var buttons = [ "refresh" ];
      this.toolbar.addRightAlignButtons(buttons);
      this.toolbar.connectButtons("refresh", "click", this, "_updateGrid");

      // DATA GRID
      this._layout = [ [ {
        field : 'bipNumber',
        name : NLS.message,
        width : '90px',
        formatter : lang.hitch(this, this._insertIcon)
      }, {
        field : 'source',
        name : NLS.source,
        width : '140px',
        formatter : lang.hitch(this, this._insertSource)
      }, {
        field : 'timestamp',
        name : NLS.timestamp,
        width : '135px',
        formatter : lang.hitch(this, this._insertTime)
      }, {
        field : 'value',
        name : NLS.messageDetail,
        width : "auto",
        formatter : lang.hitch(this, this._insertMessageDetail)
      } ] ];

      this._grid = new DataGrid({
        store : new ObjectStore({
          objectStore : new Memory({
            data : []
          })
        }),
        structure : this._layout,
        escapeHTMLInData : false,
        selectable : true,
        sortInfo : "-3"
      }, document.createElement('div'));

      /* append the new grid to the div */
      this._adminlog_grid.appendChild(this._grid.domNode);

      /* Call startup() to render the grid */
      this._grid.startup();

      // NLS Strings
      domAttr.set(this.adminlogLoading, "innerHTML", NLS.dataLoading);
      domAttr.set(this.adminlogNoData, "innerHTML", NLS.adminlogNoMessages);

      // Subscribe for updates if the websocket is available.
      if (window.WebSocket) {
        var topicName = RestUri.forAdminLog().getNotificationTopic();

        // Subscribe to the topic topicName
        this._topicHandle = topic.subscribe(topicName, lang.hitch(this, this._updateGridWithoutRefresh));
      }

      Trace.trace(this.widgetName, Trace.levels.EXIT, "postCreate");
    },

    startup : function() {
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "startup");
      this.inherited(arguments);

      this._updateGrid();

      Trace.trace(this.widgetName, Trace.levels.EXIT, "startup");
    },

    resize : function() {
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "resize");

      this._adminlog_borderContainer.resize();

      Trace.trace(this.widgetName, Trace.levels.EXIT, "resize");
    },

    // Update the grid.
    _updateGrid : function() {
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "_updateGrid");
      domAttr.set(this.adminlogLoading, "innerHTML", NLS.dataLoading);
      // Disable the refresh button
      this.toolbar.setButtonState("disable", "refresh");

      // Clear the table so it's obvious that a refresh has occurred
      var _gridStore = new ObjectStore({
        objectStore : new Memory({
          data : null
        })
      });
      this._grid.setStore(_gridStore);

      // Show the loading icon
      var fadeArgs = {
        node : "adminlogLoading_ID",
        duration : 100,
        onBegin : function() {
          domClass.remove("adminlogLoading_ID", "_common_hideDiv");
        }
      };
      fx.fadeIn(fadeArgs).play();

      this._grid.startup();
      this._grid.store.close();

      // Now actually update the grid
      this._updateGridWithoutRefresh();

      Trace.trace(this.widgetName, Trace.levels.EXIT, "_updateGrid");
    },

    _updateGridWithoutRefresh : function() {
      // _updateGridWithoutRefresh is called in 2 ways - from _updateGrid (via
      // either page load or refresh button) or when a pub-sub
      // message that notifies us of a change. As this 2nd case is an update, we
      // don't clear out and redraw the log, we just update it.
      Trace.trace(this.widgetName, Trace.levels.ENTRY,
          "_updateGridWithoutRefresh");
      domClass.add(this.adminlogLoading, "logLoading");
      xhr(Resources.REST.adminLog, {
        handleAs : "json",
        headers : {
          "Accept" : "application/json"
        }
      }).then(
        lang.hitch(this, function(data) {
          // Enable the refresh button
          this.toolbar.setButtonState("enable", "refresh");

          this._timeFormat = data.timestampFormat;

          domAttr.set(this.adminlogLoading, "innerHTML", NLS.rrrPaginationTotal + ": " +
              data.numberOfLogEvents);

          if (data.numberOfLogEvents > 0) {
            // Hide the "No Messages" message
            if (!domClass.contains(this.adminlogNoData, "_common_hideDiv")) {
              fadeArgs = {
                node : "adminlogNoData_ID",
                duration : 300,
                onEnd : function() {
                  domClass.add("adminlogNoData_ID", "_common_hideDiv");
                }
              };
              fx.fadeOut(fadeArgs).play();
            }
            _gridData = {
              items : data.adminLogEntry
            };

          } else {
            // Show the "No Messages" message
            if (domClass.contains(this.adminlogNoData, "_common_hideDiv")) {
              fadeArgs = {
                node : "adminlogNoData_ID",
                duration : 300,
                onBegin : function() {
                  domClass.remove("adminlogNoData_ID", "_common_hideDiv");
                }
              };
              fx.fadeIn(fadeArgs).play();
            }
            _gridData = {
              items : null
            };
          }
          domClass.remove(this.adminlogLoading, "logLoading");
          var _gridStore = new ObjectStore({
            objectStore : new Memory({
              data : _gridData
            })
          });
          this._grid.setStore(_gridStore);

          // Clicking on message detail turns wrapping on (so the whole
          // message can be easily seen)
          on(document, "._adminLog_nowrap:click", lang.hitch(this, function(node) {
            // First turn wrapping off for all items
            query('._adminLog_wrap').replaceClass("_adminLog_nowrap",
            "_adminLog_wrap");

            // Turn wrapping on for all the nodes in the same row as the
            // selected one.
            array.forEach(node.target.parentNode.parentNode.children,
              function(item) {
              domClass.replace(item.children[0], "_adminLog_wrap",
              "_adminLog_nowrap");
            });
          }));
        }),
        lang.hitch(this, function() {
          // Enable the refresh button
          this.toolbar.setButtonState("enable", "refresh");

          // Display an error
          window.smallMessage.displayMessage("error", "Adminlog_XXX");

          // Show the "No Messages" message
          if (domClass.contains(this.adminlogNoData, "_common_hideDiv")) {
            fadeArgs = {
              node : "adminlogNoData_ID",
              duration : 300,
              onBegin : function() {
                domClass.remove("adminlogNoData_ID", "_common_hideDiv");
              }
            };
            fx.fadeIn(fadeArgs).play();
          }
        })
      );

      Trace.trace(this.widgetName, Trace.levels.EXIT,
          "_updateGridWithoutRefresh");
    },

    tabRemove : function() {
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "tabRemove");

      // Remove the subscribe handle
      if (this._topicHandle) {
        this._topicHandle.remove();
      }

      Trace.trace(this.widgetName, Trace.levels.EXIT, "tabRemove");
    },

    _insertIcon : function(name, rowIndex) { // jshint ignore:line
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "_insertIcon");

      var bipNumber = this._grid.getItem(rowIndex).bipNumber;
      var messageType = bipNumber.charAt(bipNumber.length - 1);

      var result;
      if (messageType == "I") {
        result = "<div class='adminLogInfo'>" + bipNumber + "</div>";
      } else if (messageType == "W") {
        result = "<div class='adminLogWarning'>" + bipNumber + "</div>";
      } else if (messageType == "E") {
        result = "<div class='adminLogException'>" + bipNumber + "</div>";
      } else {
        result = bipNumber;
      }

      Trace.trace(this.widgetName, Trace.levels.EXIT, "_insertIcon");
      return result;
    },

    _insertSource : function(name) {
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "_insertSource");

      var result = "<a class='_adminLog_nowrap'>" + name + "</a>";

      Trace.trace(this.widgetName, Trace.levels.EXIT, "_insertSource");
      return result;
    },

    _insertTime : function(name) {
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "_insertTime");

      var x = new Date(name);
      x = locale.format(x, {
        datePattern : this._timeFormat,
        selector : "date"
      });

      var time = "<a class='_adminLog_nowrap'>" + x + "</a>";

      Trace.trace(this.widgetName, Trace.levels.EXIT, "_insertTime");
      return time;
    },

    _insertMessageDetail : function(name) {
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "_insertMessageDetail");

      var delimiterPos = name.indexOf(": ") + ": ".length;
      var messageDetail = "<a class='_adminLog_nowrap'>" +
          name.substring(delimiterPos) + "</a>";

      Trace.trace(this.widgetName, Trace.levels.EXIT, "_insertMessageDetail");
      return messageDetail;
    },

    tabFocus : function() {
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "tabFocus");

      Trace.trace(this.widgetName, Trace.levels.EXIT, "tabFocus");
    },

    tabBlur : function() {
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "tabBlur");

      Trace.trace(this.widgetName, Trace.levels.EXIT, "tabBlur");
    }

  });
  return adminLog;
});

},
'webui/widgets/business/BTDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 *
 * 
 * BTDialog widget - displays information about a single business transaction definition.
 * 
 */
define(
  "webui/widgets/business/BTDialog",
  [
    "dojo/text!webui/widgets/business/templates/BTDialog.html", 
    "dojo/i18n!webui/nls/web", 
    "dojo/_base/declare", 
    "dijit/registry",
    "dijit/Dialog",
    "webui/config/Resources",
    "dijit/_TemplatedMixin", 
    "dijit/_WidgetsInTemplateMixin",
    "webui/widgets/common/Trace", 
    "dojo/dom",
    "dojo/dom-attr",
    "dojo/_base/array",
    "dojo/hash",
    "dojo/keys",
    "dojo/_base/event",
    "dojo/on",
    "dojo/_base/lang",
    "dojo/dom-class",
    "dojo/dom-construct",
    "dojo/request/xhr",
    "dijit/TitlePane",
    "dojo/topic",    
    "webui/widgets/business/BTPermissionsModel",
    // For the HTML template only
    "dijit/form/Textarea"
  ], 
  function( 
    template, 
    NLS, 
    declare,
    registry,
    Dialog,
    Resources,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    Trace,
    dom,
    attr,
    array,
    hash,
    keys,
    event,
    on,
    lang,
    domClass,
    construct,
    xhr,
    TitlePane,
    Topic,
    BTPermissionsModel
  ) {

  var btDialog = declare("webui.widgets.business.BTDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
    
    templateString : template,
    
    // list of BTDs currently defined
    _namesInUse : [],
    
    _firstTimeValidation : false,
    
    _nameChangedEventHandle : null,
    
    btNew : true,
    
    _btOKLabel:NLS.okButtonLabel,
    
    _btCancelLabel: NLS.cancelButtonLabel,
    
    _buttonCancel: NLS.cancelButtonLabel,
    
    _btdNameLabel: NLS.btNameLabel,
    
    _btdDescriptionLabel: NLS.btDescriptionLabel,
    
    _animation: true,
    
    _onKey : function(evt) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onKey");
      this.inherited(arguments);
      if (evt.charOrCode) {
        if (evt.charOrCode === keys.ENTER) {
          if ( !this._okButton.get("disabled" ) ) {
            event.stop(evt);
            this.onExecute();
          }
        }
      }
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onKey");
    },

    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      this.titleNode.setAttribute("tabIndex", -1);
      this.instructionNode.setAttribute("tabIndex", -1);
      this._btdNameText.attr('regExp', Resources.regexp.businessTransactionName);
      this._btdNameText.attr('invalidMessage', NLS.btdNameInvalidErrorMsg);

      this._btdNameText.set("value", "");
      this._btdDescriptionText.set("value", "");
      
      on(this, "execute", lang.hitch(this, function() {
        var btName = this._btdNameText.get("value");
        var btDescription = this._btdDescriptionText.get("value");
        
        if (this.btNew) {
          Topic.publish(Resources.pubSubTopic.businessTransactionNew, {"newBTD": btName, "description": btDescription, "shadow": this.computeShadowCoordinates()});          
        }
        else {
          if (this._animation) {
            Topic.publish(Resources.pubSubTopic.businessTransaction, 
              {"update": true, "name": btName, "description": btDescription,"shadow": this.computeShadowCoordinates(), "callingHash": hash()});  
          }
          else {
            Topic.publish(Resources.pubSubTopic.businessTransaction, 
              {"update": true, "name": btName, "description": btDescription, "callingHash": hash()});
          }
          
        }
        if (registry.byId("btCorrelationSection") && this._btdCorrelationSection) {
          construct.empty(this._btdCorrelationSection);
        }
        this.hide();
      }));

      on(this._cancelButton, "click", lang.hitch(this, function() {
        // If a new BT had been requested to be created, and a user no longer wants to do this, redirect back to previous hash/URL
        if(this.btNew && this.previousHash) {
          hash(this.previousHash);
        }
        this.hide();
        // if the dialog is cancelled straight away, 
        // the correlation section has not been created yet
        if (this._btdCorrelationSection) {        
          construct.empty(this._btdCorrelationSection);
        }        
      }));

      this._nameChangedEventHandle = on(this._btdNameText, "change", lang.hitch(this, this.nameChanged));
      this._descChangedEventHandle = on(this._btdDescriptionText, "change", lang.hitch(this, this.descriptionChanged));
        
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },
        
    setInitialValues: function(args) {
      if (args.btName) {
        this.btName = args.btName;
      }
      if (args.btDescription) {
        this.btDescription = args.btDescription;
      }
      // clear out any previous error messages
      attr.set(this.instructionNode, "innerHTML", NLS.btdCreateDescription);
      
      // recompute the list of BTDs when the dialog is opened the first time or reopened
      this.computeBTDList();
      var btCorr;
      if (args.btNew) {
        this.btNew = args.btNew;
        this.btName =  "";
        this.btDescription = "";
        this._btdNameText.attr('readonly', false);
        btCorr = registry.byId("btCorrelationSection");
        if (btCorr) {
          btCorr.destroyRecursive();
        }

        
        
      } else {
        this.btNew = false;
        // Don't allow editing of name if it is not first time create
        this._btdNameText.attr('readonly', true);
        
        btCorr = registry.byId("btCorrelationSection");
        if (btCorr) {
          btCorr.destroyRecursive();
        }
        this._btdCorrelationSection = new TitlePane({
          title : NLS.btCorrelation,
          id: "btCorrelationSection",
          "class" :"common_infoPane"
        });
        attr.set(this._btdCorrelationSection.domNode, "data-test-attrName", "businessTxnProfile");
        // Layout improvements
        domClass.add(this._btdCorrelationSection.focusNode, "btSectionTitlePane");
        domClass.add(this._btdCorrelationSection.titleBarNode, "btSectionTitlePane_titleBarNode");
        domClass.add(this._btdCorrelationSection.containerNode, "btSectionTitlePane_containerNode");
        this._btdDialogPane.appendChild(this._btdCorrelationSection.domNode);



      }
      if (args.btModel) {
        this.btModel = args.btModel;
      }
      if(args.previousHash) {
        this.previousHash = args.previousHash;
      }
      if (args.animation){
        if (args.animation === "none") {
         this._animation = false; 
        }        
      }
    },
    
    setGeomAttributes: function(canvasGeom, dialogGeom){
      this.canvasGeom = canvasGeom;
      this.dialogGeom = dialogGeom;  
    },
    
    computeShadowCoordinates: function (){
      
      var x= Math.max(0, this.dialogGeom.x - this.canvasGeom.x);
      var y= Math.max(0, this.dialogGeom.y - this.canvasGeom.y);
      var w = Math.min(20, this.canvasGeom.x + this.canvasGeom.w -this.dialogGeom.x);
      var h = Math.min(20,this.canvasGeom.y + this.canvasGeom.h -this.dialogGeom.y);
      return {"x":x, "y": y, "w":w, "h":h};
    },
    
    refresh : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "refresh");

      this._nameChangedEventHandle.remove();
      this._descChangedEventHandle.remove();
      
      if (this._value != null) {
       //Set the flag value to detect if the dialog has been just opened.
        this._firstTimeValidation = true; 
        this._btdNameText.set("value", this._value);
        attr.set(this.titleNode, "innerHTML", NLS.btdRenameTitle);
        attr.set(this.instructionNode, "innerHTML", NLS.btdRenameDescription);
      }
      this._btdNameText.focus();
      this._okButton.set("disabled", true);
      this._firstTimeValidation = true;
      this._nameChangedEventHandle = on(this._btdNameText, "change", lang.hitch(this, this.nameChanged));
      this._descChangedEventHandle = on(this._btdDescriptionText, "change", lang.hitch(this, this.descriptionChanged));
      if (this.btNew){
        attr.set(this.titleNode, "innerHTML", NLS.btdCreateTitle);
        attr.set(this.instructionNode, "innerHTML", NLS.btdCreateDescription);
        construct.empty("additionalInfo");
        construct.empty("additionalInfo");
        if (registry.byId("btCorrelationSection")) {
           construct.empty("btCorrelationSection");
        }
      }
      else{
        attr.set(this.titleNode, "innerHTML", NLS.btdUpdateTitle);
        attr.set(this.instructionNode, "innerHTML", NLS.btdUpdateDescription);        
        construct.empty("btCorrelationSection");
      }
      if (this.btName) {
        this._btdNameText.set("value", this.btName);
      }
      else {
        this._btdNameText.set("value", "");
      }
      if (this.btDescription) {
        this._btdDescriptionText.set("value", this.btDescription);
      }
      else {
        this._btdDescriptionText.set("value", "");
      }
      var moreDiv = dom.byId("additionalInfo");
      if (!this.btNew && moreDiv){
       construct.empty("additionalInfo");
       
       this._btdCorrelationSection.set("content", construct.create("div", {innerHTML: ""}));
       
       // Don't call this as we don't show it.
       // also prevents race issue when events haven't finished bein returned but BTD dialog wants to be shown.
       //this.formatCorrelationInfo();
       this.formatEventsInfo(moreDiv);
      }     

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "refresh");
    },
    formatCorrelationInfo: function(){
       
       
        var table = "<table class='event_tooltip_table'>";
        table += "<tr><td class='btDialogColumnHeader'> "+ NLS.statisticsFlow +
          "<td class='btDialogColumnHeader'>"+ NLS.btCorrelationGlobal + 
          "<td class='btDialogColumnHeader'>"+NLS.btCorrelationParent+"</td><tr>";
        var btModel = this.btModel;
          array.forEach(btModel.elementsArray, function(item, index){
            index = item.uri.lastIndexOf("/");
            table+="<td> "+item.uri.substring(index+1);       
            
            var events = btModel.getFlowElementMonitoringEvents(item.uri);
            for (var i=0; i<events.length;i++) {
              var nodeEvents = events[i].nodeMonitoringEvents;
              for (var j=0; j<nodeEvents.length;j++) {        
                var hasGlobal = nodeEvents[j].transactionCorrelation.global !="automatic";
                var hasParent = nodeEvents[j].transactionCorrelation.parent !="automatic";
                if (hasGlobal || hasParent) {
                  if (hasGlobal) {               
                      table+="</td><td>"+ nodeEvents[j].transactionCorrelation.global+"</td>";                
                  }
                  else {
                    table+="<td/>";
                  }
                  if (hasParent) {
                      table+="</td><td>"+ nodeEvents[j].transactionCorrelation.parent + "</td>";                
                  }
                  else {
                    table+="<td/>";
                  }
                  
                } 
              }  
            }
            table += "</tr>";
          });        
       
        table += "</table>";
       var text = construct.create("div", {className: "btEvents", innerHTML: table});
       
       this._btdCorrelationSection.set("content", text);
       
       
       
       //this._btdCorrelationSection.set('title', NLS.btCorrelation);
  
    },
    
    
    // Called to populate the list of existing BTD names, such that it is a latest snapshot of the BTDs under this Broker, and such the same name can't be used twice.
    computeBTDList : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "computeBTDList");

      xhr(
        Resources.REST.businessTransactions,
        {
          handleAs : "json",
          headers : {
            "Accept" : "application/json",
            "Content-type" : "application/json"
          }
        }
      ).then(
        lang.hitch(this, function(response) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Get business transaction definitions success");
  
          // Extract out the BTD names
          if(typeof response.businessTransactionName !== "undefined") {
            // Only clear out the names if we have received a response
            this._namesInUse = [];
            array.forEach(response.businessTransactionName, lang.hitch(this, function(nextBTD) {
              this._namesInUse.push(nextBTD.name);
            }));
          }
        }),
        lang.hitch(this, function(error) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Response: " + error.response.response);            
        })
      );

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "computeBTDList");
    },

  formatEventsInfo : function(parentDiv) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "formatEventsInfo");            
      var text = construct.create("div", {className: "btEvents"});

      // Show all flagged events
      var start =[];
      var end = [];
      var fail =[];
      var progress =[];
      
      array.forEach(this.btModel.businessEvents, function(item){
        var flowUri = item.parentFlow;
        var i = flowUri.lastIndexOf('/');
        var flowName = flowUri.substring(i+1);
        
        if (item.role === Resources.businessTransaction.btEventStart) {
          start.push({"src" : item.monitorEvent.eventSourceAddress, "flow":flowName});
        }
        if (item.role === Resources.businessTransaction.btEventEnd) {
          end.push({"src" : item.monitorEvent.eventSourceAddress, "flow":flowName});
        } 
        if (item.role === Resources.businessTransaction.btEventFailure) {
          fail.push({"src" : item.monitorEvent.eventSourceAddress, "flow":flowName});
        }
        if (item.role === Resources.businessTransaction.btEventProgress) {
          progress.push({"src" : item.monitorEvent.eventSourceAddress, "flow":flowName});
        }                
        
      });
      var anyPromotedEvents = ((start.length>0) || (end.length>0) || (fail.length>0) || (progress.length>0));
      var table;
      if (anyPromotedEvents) {
        table = "<br>"+NLS.btEvents+"<br><table class='event_tooltip_table'>";
        table += "<tr><td class='btDialogColumnHeader'>";
        table += NLS.btType +"</td><td class='btDialogColumnHeader'> "+ NLS.btFlowName+ 
            "</td><td class='btDialogColumnHeader'> "+NLS.btEventSource+ "</td><tr>";
        if (start.length>0) {
          table += "<tr><td>" +NLS.btStartRole+ "</td>";
          array.forEach(start, function(item, index){
            if (index>0){
              table+= "<td/>";
            }
            table+="<td>"+item.flow+"</td><td>"+item.src+"</td></tr>";
          });        
        }
        if (end.length>0) {
          table += "<tr><td>" +NLS.btEndRole+ "</td>";
          array.forEach(end, function(item, index){
            if (index>0){
              table+= "<td/>";
            }
            table+="<td>"+item.flow+"</td><td>"+item.src+"</td></tr>";
          });        
        }
        if (fail.length>0) {
          table += "<tr><td>" +NLS.btFailureRole+ "</td>";
          array.forEach(fail, function(item, index){
            if (index>0){
              table+= "<td/>";
            }
            table+="<td>"+item.flow+"</td><td>"+item.src+"</td></tr>";
          });        
        }
        if (progress.length>0) {
          table += "<tr><td>" +NLS.btProgressRole+ "</td>";
          array.forEach(progress, function(item, index){
            if (index>0){
              table+= "<td/>";
            }
            table+="<td>"+item.flow+"</td><td>"+item.src+"</td></tr>";
          });        
        }
        table += "</table>";
      }
      else {
        table =NLS.btdNoEventsPromoted;
      }
      
      text.innerHTML = table;  
      parentDiv.appendChild(text);
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "formatEventsInfo");
    },
    
    
    descriptionChanged : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "descriptionChanged");
      
      // If we aren't in the first time specifying of BTD values, then we can only change the description so enable the ok button.
      if (this._okButton.disabled &&  !this.btNew) {
        this._okButton.set("disabled", false);          
      }
      if (BTPermissionsModel.readOnlyModeForBTD()) {
        this._okButton.set("disabled", true);
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "descriptionChanged");
    },

    // This gets called every time the content of the name box changes, i.e. whenever a keystroke is pressed
    nameChanged : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "nameChanged");
    
      // Get whitespaced removed name value
      var value = this._btdNameText.get("value").trim();

      if (!value || value === "") {
        if ( !this._firstTimeValidation ) {
          this._okButton.set("disabled", true);
          //Only set the error message when the dialog is not displayed for the first time
          attr.set(this.instructionNode, "innerHTML", NLS.btdEmptyNameErrorMsg);
          domClass.add(this.instructionDiv, "btDialogWarningText");   
        }
      } else {
        
        // Check that the name is valid in terms of allowed characters
        if(this._btdNameText.isValid()) {
          var inUse = false;
          var i = 0;
          while((!inUse) && (i < this._namesInUse.length)) {
            if (value === this._namesInUse[i]) {
              inUse = true;
            }
            i++;
          }

          this._okButton.set("disabled", inUse);
          if (inUse) 
          {
            if (!this._firstTimeValidation)
            {
              //Only set the error message when the dialog is not displayed for the first time
              attr.set(this.instructionNode, "innerHTML", NLS.btdNameDuplicateErrorMsg);
              domClass.add(this.instructionDiv, "btDialogWarningText");
            }
          } else {
            // The name is valid
            domClass.remove(this.instructionDiv, "btDialogWarningText");
            attr.set(this.instructionNode, "innerHTML", NLS.btdCreateDescription);
          }
        } else {
          this._okButton.set("disabled", true);
          domClass.add(this.instructionDiv, "btDialogWarningText");
          attr.set(this.instructionNode, "innerHTML", NLS.btdInvalidNameErrorMsg);
        }
      }
      
      //reset the variable that was set from refresh so that the nameChanged would work
      this._firstTimeValidation = false; 

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "nameChanged");
   },

  // sets the x and y coordinates of the dialog based on computations in the overview class 
  setDialogCoordinates: function (x, y) {
    Trace.trace(this.declaredClass, Trace.levels.ENTRY, "setDialogCoordinates");
    this._setStyleAttr('left:' + x + 'px !important;');
    this._setStyleAttr('top:' + y + 'px !important;'); 
    Trace.trace(this.declaredClass, Trace.levels.EXIT, "setDialogCoordinates");
  }  
  });
  
	return btDialog;
});

},
'webui/widgets/configurableservice/ConfigurableServiceEditor':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 */

/* 
 * This widget represents an editor for a Configurable Service.
 *
 * The widget has:
 * - A Save and Cancel button at the top right.
 * - A text widget that allows the user to specify the name of the configurable service
 *   (validation is performed on the value in this widget to ensure it is set).
 * - A choice widget that allows the user to pick the type of configurable service that
 *   they want to create.
 * - A choice widget that allows the user to pick a type to base their configurable service
 *   on.
 * - A property table widget that is filled in based on the template chosen, and allows
 *   the user to change the values either directly in the table or by using a dialog.
 * - Add and Remove buttons under the property table that allow the user to add and
 *   remove properties if the type of configurable service is UserDefined. These properties
 *   can also have their names changed, and the widget will validate that property names
 *   are set and are unique.
 * - A section at the bottom that shows a command that represents the choices made above.
 *
 * This widget supports two different modes of operation:
 * 1. A default "add" mode in which all the above widget are available.
 * 2. An "edit" mode in which the name, type, and template widgets are not visible and
 *    whose values have to be passed in. See the constructor below for more details.
 * 
 * Most of the widget is internal (private). The only public method provided is the isDirty
 * method.
 */

define(
  "webui/widgets/configurableservice/ConfigurableServiceEditor",
  [
    "dojo/text!webui/widgets/configurableservice/templates/ConfigurableServiceEditor.html",
    "dojo/i18n!webui/nls/web",
    "dojo/_base/declare",
    "dijit/_WidgetBase", 
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/registry",
    "webui/widgets/common/Trace",
    "dojo/dom",
    "dojo/dom-attr",
    "dojo/dom-construct",
    "dojo/store/Memory",
    "dojo/_base/lang",
    "dojo/request/xhr",
    "webui/config/Resources",
    "webui/utils/RestUri",
    "webui/widgets/common/AttributesStore",
    "webui/widgets/common/EditPropertyValueDialog",
    "webui/widgets/common/Toolbar",
    "dojo/dom-attr",
    "dojo/string",
    "dojo/topic",
    "dojo/query",
    "dojo/on",
    "dojox/html/entities",
    
    // Grid X
    "gridx/Grid",
    "gridx/core/model/cache/Sync",
    "gridx/modules/select/Row",
    "gridx/modules/ColumnResizer",
    "gridx/modules/CellWidget",
    "gridx/modules/Edit",
    
    // For template
    "dijit/form/Textarea",
    "dijit/form/FilteringSelect"
  ], 
  function(
    template,
    NLS,
    declare,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    registry,
    Trace,
    dom,
    domAttr,
    construct,
    Memory,
    lang,
    xhr,
    Resources,
    RestUri,
    AttributesStore,
    EditPropertyValueDialog,
    Toolbar,
    attr,
    string,
    topic,
    query,
    on,
    HTMLEntities,
    
    // GridX
    Grid,
    Cache,
    SelectRow,
    ColumnResizer,
    CellWidget,
    Edit
  ) {
    var configurableServiceEditor = declare("webui.widgets.configurableservice.ConfigurableServiceEditor", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
      templateString: template, // points js to the html template to use
      declaredClass: "webui.widgets.configurableservice.ConfigurableServiceEditor",
      _configurableserviceNameLabel: NLS.nameLabel,
      _configurableserviceTypeLabel: NLS.typeLabel,
      _configurableserviceTemplateLabel: NLS.templateLabel,
      _configurableservicePropertiesLabel: NLS.configurableservicePropertiesLabel,
      _configurableserviceCommandLabel: NLS.configurableserviceCommandLabel,
      _attributesStore : new AttributesStore(),
      
      /**
       * Constructor supports passing in an object with the following properties:
       * - mode: currently only "edit" supported which indicates that the editor should
       *         be put in edit mode instead of add mode. Edit mode does not show the
       *         name, type, and template fields.
       * - configurableServiceName: default name; required if mode = "edit" and should
       *                            not be passed in if mode != "edit"
       * - configurableServiceType: default type; required if mode = "edit" and should
       *                            not be passed in if mode != "edit"
       * - configurableServiceTemplate: default template; required if mode = "edit"
       *                                and should not be passed in if mode != "edit"
       */
      constructor: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");
        this.inherited(arguments);
      	if (arguments.length > 0) {
      	  this._mode = arguments[0].mode;
      	  this._configurableServiceName = arguments[0].configurableServiceName;
      	  this._configurableServiceType = arguments[0].configurableServiceType;
      	  this._configurableServiceTemplate = arguments[0].configurableServiceTemplate;
      	}
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
      },
      
      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
        
        // Call postCreate on _TemplatedMixin:
        this.inherited(arguments);
        
        // Create the toolbar at the top of the UI:
        this.toolbar = new Toolbar();
        construct.place(this.toolbar.domNode, this._toolbar);
        this.toolbar.addLeftAlignButtons("title");
        
        // Add Save and Cancel button to the right side of the toolbar:
        var buttons = ["save", "cancel"];
        this.toolbar.addRightAlignButtons(buttons);
      	this.toolbar.addRightAlignButtons("spacer");
      	this.toolbar.getButton("save").set("disabled", true);
        this.toolbar.getButton("cancel").set("disabled", false);
        
        // Add button event handlers:
        this.toolbar.connectButtons("save", "click", this, "_onSaveClick");
        this.toolbar.connectButtons("cancel", "click", this, "_onCancelClick");
        
        // Create the store for the properties table:
        var propertiesTableStore = new Memory({data: [], idProperty: "id"});
        var propertiesTableStructure = [
          { id: 'name', field: 'name', name: NLS.nameLabel, width: '20%', editable: true,
             decorator: function(cellData) {
              // Encode name before showing it in the table to prevent code injection:
              return HTMLEntities.encode(cellData);
            }
          },
          { id: 'value', field: 'value', name: NLS.valueLabel, width: '70%', editable: true,
             decorator: function(cellData) {
              // Encode value before showing it in the table to prevent code injection:
              return HTMLEntities.encode(cellData);
            }
          },
          { id: 'valueDialog', field: '', name: '', width: '10%', widgetsInCell: true,
            decorator: function() {
              // Embed a button in the value column (label for screen reader also provided so more information can be provided other than just '...'):
              return "<div data-dojo-type='dijit.form.Button' type='button' data-dojo-attach-point='csEditValueButton' aria-label='" + NLS.editValueDialogButtonText + "'>...</div>";
            },
            getCellWidgetConnects: function(cellWidget, cell) {
              // Add a handler for when the embedded button is pressed:
              return [[
                cellWidget.csEditValueButton,
                'onClick',
                function() {
                  var confirmCallback = lang.hitch(this, function() {
                    // Set value from dialog into the table (need to begin and apply edit so an onApply event is fired):
                    editPropertyValueDialog.cell.beginEdit();
                    editPropertyValueDialog.cell.setRawData(editPropertyValueDialog.editPropertyValueArea.get("value"));
                    editPropertyValueDialog.cell.applyEdit();
                  });
    		      
                  // Create the dialog:
                  var editPropertyValueDialog = registry.byId("editPropertyValueDialog");
                  if (!editPropertyValueDialog) {
                    editPropertyValueDialog = new EditPropertyValueDialog( {
                      id : "editPropertyValueDialog",
                      createCallback : confirmCallback
                    });
                    editPropertyValueDialog.startup();
                  }
                
                  // Set appropriate values on the dialog and then open it:
                  attr.set(editPropertyValueDialog.titleNode, "innerHTML", NLS.editValueLabel);
                  var valueCell = cell.grid.cell(cell.row.id, "value");
                  editPropertyValueDialog.cell =  valueCell; // pass in the value cell; needed above when setting the value in the table
                  editPropertyValueDialog.currentValue = valueCell.rawData(); // pass in the value text
                  editPropertyValueDialog.refresh();
                  editPropertyValueDialog.show();
                }
              ]];
            }
          }
        ];
        
        // Create the property table widget:
        this._propertiesTable = Grid({
          id: 'csEditorPropertiesTable',
          cacheClass: Cache,
          store: propertiesTableStore,
          // Select a row when any cell in that row is clicked:
          selectRowTriggerOnCell: true,
          structure: propertiesTableStructure,
          autoHeight: true,
          modules: [
            SelectRow,
            CellWidget,
            Edit,
            ColumnResizer
          ],
          editLazySave: false // Needs to be set to false because using query on the store
        });
        
        // Put the property table widget into the DOM tree:
        this._propertiesTable.placeAt(this._csProperties);
        
        // Start up the property table widget:
        this._propertiesTable.startup();
        
        // Populate store and then initialize values when store is populated:
        var populate = this._attributesStore.populateAttributesStore();
        populate.then(lang.hitch(this, function() {
       		// have to wait until to initialize until after the populate completes
       		// as we will need the URI from the properties store:
        	this._initialize();
      	}));
      	
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
     },
     
     // Called after the properties store is initialized:
     _initialize: function() {
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_initialize");
        
        // Show the name, type, and template if the editor is not in "edit" mode:
        if (!this._isInEditMode()) {
          dom.byId("csEditorTable").style.display = "";
        }
        
        // Set the configurable service name if one was passed in:
        if (this._configurableServiceName !== undefined) {
          this._getNameWidget().set("value", this._configurableServiceName);
        }
        
        // If the editor is not in "edit" mode, move the focus to the name widget by default
        // and add a name listener:
        if (!this._isInEditMode()) {
  	      // Move focus to the name field by default:
      	  this._getNameWidget().focus();
      	  
      	  // Add a handler for when the name is changed in the UI:
          on(this._getNameWidget(), "change", lang.hitch(this, this._handleNameChange));
        }
        
        // Flag to indicate that the user has made a change:
        this._hasUserMadeAChange = false;
        
        // Only listen to name focus lost events and type changes if the editor is not in "edit" mode:
        if (!this._isInEditMode()) {
          // Add a handler for when the focus is lost on name in the UI:
          on(this._getNameWidget(), "blur", lang.hitch(this, this._handleFocusLostOffNameWidget));
        
          // Add a handler for when the type is changed in the UI:
          on(this._getTypeWidget(), "change", lang.hitch(this, this._handleTypeChange));
        }
        
        // Add a handler for when the template is changed in the UI:
        on(this._getTemplateWidget(), "change", lang.hitch(this, this._handleTemplateChange));
        
        // Add a handler for when a property value is changed in the property table (it is
        // preferred to use the event handling of the grid control so using that here):
        this._getPropertiesTable().edit.connect(this._getPropertiesTable().edit, "onApply", lang.hitch(this, this._handlePropertyValueChanged));
        
        // Add a handler for when the selection changes in the property table (it is
        // preferred to use the event handling of the grid control so using that here):
        this._getPropertiesTable().select.row.connect(this._getPropertiesTable().select.row, "onSelected", lang.hitch(this, this._handleRowSelectionChanged));
        this._getPropertiesTable().select.row.connect(this._getPropertiesTable().select.row, "onDeselected", lang.hitch(this, this._handleRowSelectionChanged));

        // Add handlers for the add and remove property buttons for the property table:
        on(this._csAddPropertyButton, "click", lang.hitch(this, this._handleAddPropertyButtonPressed));
        on(this._csRemovePropertyButton, "click", lang.hitch(this, this._handleRemovePropertyButtonPressed));
        
        // Set the configurable service type if one was passed in:
        if (this._configurableServiceType !== undefined) {
          this._setWidgetTo(this._getTypeWidget(), this._configurableServiceType);
          
          // Only enable the Add and Remove property buttons if the configurable service type is UserDefined:
      	  var isTypeUserDefined = this._configurableServiceType === 'UserDefined';
      	  this._csAddPropertyButton.set("disabled", !isTypeUserDefined);
      	  this._csRemovePropertyButton.set("disabled", !isTypeUserDefined);
        }
        
        // Set the configurable service template if one was passed in:
        if (this._configurableServiceTemplate !== undefined) {
          this._setWidgetTo(this._getTemplateWidget(), this._configurableServiceTemplate);
        }
        
        // Only populate the type and template widgets if the editor is not in "edit" mode:
        if (!this._isInEditMode()) {
          // Populate the type widget which will automatically populate the template widget and the property table widget:
          this._populateWidgetWithConfigureServiceTypes(this._getTypeWidget());
        }
        
        // Update the command description if we are in edit mode:
        if (!this._isInEditMode()) {
          domAttr.set("csCommandDescription", "innerHTML", NLS.configurableserviceCommandDescriptionForCreate);
        }
        else {
          domAttr.set("csCommandDescription", "innerHTML", NLS.configurableserviceCommandDescriptionForEdit);
        }
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_initialize");
      },
      
      _isInEditMode: function() {
      	return this._mode === "edit";
      },
      
      _getName: function() {
      	return this._getNameWidget().get("value");
      },
      
      _getNameWidget: function() {
      	return this._csName;
      },
      
      _getType: function() {
      	return this._getTypeWidget().get("displayedValue");
      },
      
      _getTypeWidget: function() {
      	return this._csTypeName;
      },
      
      _getTemplate: function() {
      	return this._getTemplateWidget().get("displayedValue");
      },
      
      _getTemplateWidget: function() {
      	return this._csTemplateName;
      },
      
      _getPropertiesTable: function() {
      	return this._propertiesTable;
      },
      
      resize: function() {
         Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");
         this._csEditor_borderContainer.resize();
         Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
      },
      
      // Called when the user clicks the Save button:
      _onSaveClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onSaveClick");
        
        // First need to check if a configurable service with the same name and type already exists, a REST call
        // is used for this (example URI = /apiv1/policy/configurableservices/ActivityLog/ActivityLogTemplate)
    		if (this._isInEditMode()) {
    		  // If is in "edit" mode, bypass the duplicate check:
    		  this._createOrUpdateConfigurableService();
    		}
    		else {
    		  // Not running in "edit" mode, so perform the duplicate check:
    		  var uri = RestUri.forConfigurableService(this._getType(), this._getName()).toString();
          xhr.get(
            uri,
            {
              handleAs : "json",
              headers : {
                "Accept" : "application/json"
              }
            }
          ).then( lang.hitch(this, function() {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Call to get the configurable service " + this._getName() + " under service type " + this._getType() + " was successful.");
            // Found an existing configurable service, we are NOT OK to go ahead with the creation, tell the user:
            window.smallMessage.displayPlainMessage("error", "ConfigurableService_nameAlreadyExists", [this._getName(), this._getType()]);
          }),
          lang.hitch(this, function(error) {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Response: " + error.response.response);
            // Did not find an existing configurable service, so we are OK to go ahead with the creation:
            this._createOrUpdateConfigurableService();
          }));
    		}
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onSaveClick");
      },
  
      // Called after the user clicks the Save button and after an initial check on the configurable service name and type is done:
      _createOrUpdateConfigurableService: function() {
        
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createOrUpdateConfigurableService");
        
        // Example URI = /apiv1/policy/configurableservices/ActivityLog/ActivityLogTemplate
        var uri = RestUri.forConfigurableService(this._getType(), this._getName()).toString();
        
        // Create an object that will be used to create the configurable service:
        var configurableServiceObject = {};
        configurableServiceObject.type = "configurableService";
        configurableServiceObject.uri = uri;
        configurableServiceObject.configurableServiceType = this._getType();
        configurableServiceObject.name = this._getName();
        configurableServiceObject.ibmDefined = "false";
        
        // Add the properties to the object:
        var numberOfRows = this._getPropertiesTable().rowCount();
      	if (numberOfRows > 0) {
      	  configurableServiceObject.properties = [];
      	  for (var i = 0; i < numberOfRows; i++) {
      	    var property = {};
      	    property.name = this._getPropertiesTable().cell(i, 0).rawData();
      	    property.value = this._getPropertiesTable().cell(i, 1).rawData();
      	    configurableServiceObject.properties.push(property);
          }
        }
        
        // Add loading icon to tree:
        var tree = registry.byId('_explorerTree_ID');
        var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
        var oldIcon = attr.get(treeImgs[0],"class");
        attr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");
        
        // Display a message that the configurable service is being created:
        var messageId = "ConfigurableService_preCreation";
        if (this._isInEditMode()) {
          messageId = "ConfigurableService_preUpdate";
        }
        window.smallMessage.displayPlainMessage("information", messageId, [configurableServiceObject.name]);
        
        // Change the modified flag to false (as we are going to save the changes and we do not want isDirty() to return true):
        this._hasUserMadeAChange = false;
        
        // Disable the save and cancel buttons (to prevent the user from pressing them again while saving):
        this.toolbar.getButton("save").set("disabled", true);
        this.toolbar.getButton("cancel").set("disabled", true);
        
        // Call PUT to create the new configurable service using the uri and object from above:
        xhr.put(
          uri,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json",
              "Content-type" : "application/json"
            },
            data : JSON.stringify(configurableServiceObject)
          }
        ).then( lang.hitch(this, function() {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Call to create new configurable service was successful.");
          
          // Disable the save button (since the editor is no longer dirty):
          this.toolbar.getButton("save").set("disabled", true);
          
          // Reset old icon (to remove loading icon):
          attr.set(treeImgs[0],"class",oldIcon);
          
          // Display a message that the creation was successful:
         	var messageId = "ConfigurableService_creationSuccess";
          if (this._isInEditMode()) {
            messageId = "ConfigurableService_updateSuccess";
          }
        	window.smallMessage.displayPlainMessage("success", messageId, [configurableServiceObject.name]);
          	
          	if (this._isInEditMode()) {
          	  // Publish that the configurable service has been updated:
              topic.publish(Resources.pubSubTopic.configurableServiceUpdated, {uri: uri});
          	}
            else {
              // Publish that the configurable service has been created:
              topic.publish(Resources.pubSubTopic.configurableServiceCreated, {uri: uri});
            }
          }),
          lang.hitch(this, function(error) {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Response: " + error.response.response);
            
            // Reset old icon (to remove loading icon):
            attr.set(treeImgs[0],"class",oldIcon);
           
            // Display a message that the creation was unsuccessful:
            var errorMessageId = "ConfigurableService_creationFailure";
            if (this._isInEditMode()) {
              errorMessageId = "ConfigurableService_updateFailure";          
            }
            window.smallMessage.displayPlainMessage("error", errorMessageId, [configurableServiceObject.name]);
            
            // Re-enable the modify flag, and re-enable the save and cancel buttons (as the user may want to continue working in the editor):
            this._hasUserMadeAChange = true;
            this.toolbar.getButton("save").set("disabled", false);
            this.toolbar.getButton("cancel").set("disabled", false);
          })
        );
        // end put
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createOrUpdateConfigurableService");
      },
      
      // Called when the user clicks the Cancel button:
      _onCancelClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onCancelClick");
        
        // Publish that the editor has been cancelled:
       	if (this._isInEditMode()) {
       	  topic.publish(Resources.pubSubTopic.configurableServiceEditCancelled, {editor: this});
       	}
       	else {
       	  topic.publish(Resources.pubSubTopic.configurableServiceAddCancelled, {editor: this});
       	}
       	
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onCancelClick");
      },
      
      // Sets the provided widget to the provided value. Called when the editor is in "edit" mode:
      _setWidgetTo: function(widget, value) {
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setWidgetTo");
      	
      	var initialData = [];
        var store = new Memory({data: initialData});
        var item = {name:value, id:1};
        store.put(item);
        widget.set("store", store);
        widget.set("item", item);
      	
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setWidgetTo");
      },
      
      // Populates the provided widget with the list of configure service types available on the server:
      _populateWidgetWithConfigureServiceTypes: function(widget) {
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_populateWidgetWithConfigureServiceTypes");
      	
      	// Show loading message in the widget while the REST call is made below:
        this._setWidgetToLoadingWatermark(widget);
      	
      	// REST call to get the configurable service types
      	
      	// /apiv1/policy/configurableservices
      	var uri = this._attributesStore.getAttribute("uri");
        xhr.get(
          uri,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json"
            }
          }
        ).then( lang.hitch(this, function(response) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Call to get configurable service types was successful.");
          
          // Remove the current selection (if this is not done, and the same id is selected below, a change event will not fire):
          widget.set("value", "");
          
          // Place the types in a store:
          var initialData = [];
          var csTypeStore = new Memory({data: initialData});
          
          var wasUserDefinedFound = false;
          var i = 0;
          var firstItem;
          if (response !== undefined && response.configurableServiceType !== undefined) {
            while (i < response.configurableServiceType.length) {
              var type = response.configurableServiceType[i].configurableServiceType;
              if (type === 'UserDefined') {
              	wasUserDefinedFound = true;
              }
              if (i === 0) {
              	firstItem = {name:type, id:i+1};
              }
              csTypeStore.put({name:type, id:i+1});
              i++;
            }
          }
          
          // UserDefined type is not returned from the server if no templates exist in it,
          // therefore add if needed:
          if (!wasUserDefinedFound) {
          	csTypeStore.put({name:'UserDefined', id:i+1});
          }
          
          // Provide the store to the widget:
          widget.set("store", csTypeStore);
          
          // Select the first item in the widget by default:
         	if (firstItem !== undefined) {
          	widget.set("item", firstItem);
          }
        }), lang.hitch(this, function(error) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Response: " + error.response.response);
          
          // Display a message that the configurable service types could not be obtained:
          window.smallMessage.displayPlainMessage("error", "ConfigurableService_errorGettingConfigurableServiceTypes");
        }));
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_populateWidgetWithConfigureServiceTypes");
      },
      
      // Sets the provided widget to the loading water mark. Called when loading types and
      // templates in the UI since the data is obtained from the server and may be
      // delayed:
      _setWidgetToLoadingWatermark: function(widget) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setWidgetToLoadingWatermark");
        this._loadingWaterMark = NLS.configurableserviceLoadingWatermark;
        var loadingItem = {name:this._loadingWaterMark, id:this._loadingWaterMark};
        var data = [loadingItem];
        var store = new Memory({data: data});
        widget.set("store", store);
        widget.set("item", loadingItem);
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setWidgetToLoadingWatermark");
      },
      
      // Returns true if the provided text is the loading watermark; false otherwise:
      _isLoadingWatermark: function(text) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_isLoadingWatermark");
      	var result = this._loadingWaterMark && this._loadingWaterMark !== undefined && this._loadingWaterMark === text;
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_isLoadingWatermark");
      	return result;
      },
      
      // Called when the user makes a change to the configurable service name:
      _handleNameChange: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handleNameChange");
      	
      	// Validate (but do not check for duplicate names as the display of
      	// error messages can be incorrect if the user types quickly):
      	this._validate(true);
      	
      	// Update the command:
      	this._populateTextAreaWithCommand();
      	
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handleNameChange");
      },
      
      // Called when the user removes focus from the configurable service name widget:
      _handleFocusLostOffNameWidget: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handleFocusLostOffNameWidget");
      	
      	// If the user moves focus away from the name widget, this is considered a change,
      	// so set the change flag:
      	if (!this._hasUserMadeAChange) {
      	  this._hasUserMadeAChange = true;
      	}
      	
        this._validate();
      	
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_handleFocusLostOffNameWidget");
      },
      
      // Called when the user selects another configurable service type:
      _handleTypeChange: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handleTypeChange");
      
        var configurableServiceType = this._getType();
        
        // Type has changed, so the list of the templates need to be updated:
        this._populateWidgetWithConfigureServiceTemplates(this._getTemplateWidget(), configurableServiceType);
      	
      	// Only enable the Add property buttons if the configurable service type is UserDefined:
      	var isTypeUserDefined = configurableServiceType === 'UserDefined';
      	this._csAddPropertyButton.set("disabled", !isTypeUserDefined);
      	
      	// Disable the Remove property button (should only be enabled if the configurable service
      	// type is UserDefined and there is a property selection, but there will not be a property
      	// selection since the type changed):
      	this._csRemovePropertyButton.set("disabled", true);
      	
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_handleTypeChange");
      },
      
      // Populates the provided widget with the list of configure service templates for the provided type:
      _populateWidgetWithConfigureServiceTemplates: function(widget, configurableServiceType) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_populateWidgetWithConfigureServiceTemplates");
        
      	// If there is no configurable service type, just clear the combo box:
      	if (configurableServiceType === undefined || configurableServiceType === "") {
      		var initialData = [];
      		var csTemplateStore = new Memory({data: initialData});
      		widget.set("store", csTemplateStore);
      		widget.set("value", "");
      		return;
      	}
      	else if (this._isLoadingWatermark(configurableServiceType)) {
      	  // type is still loading so we can not load the templates yet, so just return:
        	return;
        }
        
        // Show loading message in the widget while the REST call is made below:
        this._setWidgetToLoadingWatermark(widget);
        
      	// Example URI = /apiv1/policy/configurableservices/ActivityLog
        var uri = this._attributesStore.getAttribute("uri") + "/" + configurableServiceType;
		
        // REST call to get the configurable service templates
        xhr.get(
          uri,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json"
            }
          }
        ).then( lang.hitch(this, function(response) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Call to get configurable service templates for " + configurableServiceType + " was successful.");
          
          // Remove the current selection (if this is not done, and the same id is selected below, a change event will not fire):
          widget.set("value", "");
          
          // Place the types in a store:
          var initialData = [];
          var csTemplateStore = new Memory({data: initialData});
          
          // Set the current id to 1 for the store (this will be the first id):
          var currentId = 1;
          var firstItem;
          
          // If we are populating the combo box for the UserDefined type, add None as a template:
          if (configurableServiceType === "UserDefined") {
          	csTemplateStore.put({name:"None", id:currentId});
          	if (firstItem === undefined) {
              firstItem = {name:"None", id:currentId};
            }
          	currentId++;
          }
          
          // Add the rest of the templates that we received from the server:
          if (response !== undefined && response.configurableService !== undefined) {
            for (var i = 0; i < response.configurableService.length; i++) {
              var type = response.configurableService[i].name;
              csTemplateStore.put({name:type, id:currentId});
              if (firstItem === undefined) {
              	firstItem = {name:type, id:currentId};
              }
              currentId++;
            }
          }
          
          // Provide the store to the widget:
          widget.set("store", csTemplateStore);
          
          // Select the first item in the widget by default:
          if (firstItem !== undefined) {
            widget.set("item", firstItem);
          }
        }), lang.hitch(this, function(error) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Response: " + error.response.response);
          
          // Display a message that the configurable service templates could not be obtained:
          window.smallMessage.displayPlainMessage("error", "ConfigurableService_errorGettingConfigurableServiceTemplates");
        }));
          
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_populateWidgetWithConfigureServiceTemplates");
      },
      
      // Called when the user selects another configurable service template:
      _handleTemplateChange: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handleTemplateChange");
      	
      	// Populate the properties table with the properties of the template:
      	this._populateTableWithProperties(this._getType(), this._getTemplate());
      	
      	// Have to call validate because changing the type can affect whether the configurable service
        // name is a duplicate or not, but the templates that are needed for the name check are not
      	// available until now. Only call validate if the user has made a change in the UI:
      	if (this._hasUserMadeAChange && !this._isLoadingWatermark(this._getTemplate())) {
      	  this._validate();
      	}
      	
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_handleTemplateChange");
      },
      
      // Populates the provided widget with the properties of the provided template:
      _populateTableWithProperties: function(configurableServiceType, configurableServiceTemplate) {
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_populateTableWithProperties");
      	
      	// Set the text that will be read out by a screen reader for the '...' column header of the properties
      	// table. This has to be done or a screen reader will just read out that the column is read-only (or
      	// nothing will be said at all). The reason that this is being done here is so we can be sure that the
      	// csEditorPropertiesTable-valueDialog DOM element is available:
      	var elementThatIsTheAriaLabelForTheValueDialogColumn = dom.byId("csEditorPropertiesTable-valueDialog");
        if (elementThatIsTheAriaLabelForTheValueDialogColumn !== undefined) {
          attr.set(elementThatIsTheAriaLabelForTheValueDialogColumn, "aria-label", NLS.editValueDialogColumnHeaderText);
        }
        
      	// REST call to get the properties for the provided service type and service template:
      	
        // Special cases: Just clear the table:
        if ((configurableServiceType === "UserDefined" && configurableServiceTemplate === "None") ||
             (configurableServiceTemplate === undefined || configurableServiceTemplate === "") ||
             (this._isLoadingWatermark(configurableServiceTemplate))) {  // can not show properties if template is still loading
        	var propertyData = [];
        	this._getPropertiesTable().select.row.clear(); // clear any selections first
        	this._getPropertiesTable().model.clearLazyData(); // clear off any edits that may exist
            this._getPropertiesTable().model.clearCache();
            this._getPropertiesTable().column("name").setEditable(true); // allow cells in the name column to be edited if the type is UserDefined
        	this._getPropertiesTable().model.store.setData(propertyData);
            this._getPropertiesTable().body.refresh();
            this._populateTextAreaWithCommand();
            return;
        }
        
        // Example URI = /apiv1/policy/configurableservices/ActivityLog/ActivityLogTemplate
        var uri = RestUri.forConfigurableService(configurableServiceType, configurableServiceTemplate).toString();
        xhr.get(
          uri,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json"
            }
          }
        ).then( lang.hitch(this, function(response) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Call to get the properties for service template " + configurableServiceTemplate + " under service type " + configurableServiceType + " was successful.");
          
          // Populate table with properties:
          if (response !== undefined && response.properties !== undefined) {
            var propertyData = [];
            for (var i = 0; i < response.properties.length; i++) {
              var name = response.properties[i].name;
              var value = response.properties[i].value;
              propertyData.push({
                id: name,
                name: name,
                value: value
              });
            }
            this._getPropertiesTable().select.row.clear(); // clear any selections first
            this._getPropertiesTable().model.clearLazyData(); // clear off any edits that may exist
            this._getPropertiesTable().model.clearCache();
            this._getPropertiesTable().column("name").setEditable(configurableServiceType === "UserDefined"); // allow cells in the name column to be edited if the type is UserDefined
            this._getPropertiesTable().model.store.setData(propertyData);
            this._getPropertiesTable().body.refresh();
          }
          
          // Update the command that is displayed in the UI:
          this._populateTextAreaWithCommand();
        }), lang.hitch(this, function(error) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Response: " + error.response.response);
          
          // Display a message that the configurable service properties could not be obtained:
          window.smallMessage.displayPlainMessage("error", "ConfigurableService_errorGettingConfigurableServiceProperties", [configurableServiceTemplate]);
        }));
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_populateTableWithProperties");
      },
      
      // Called when the user changes the value of a property in the property table:
      _handlePropertyValueChanged: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handlePropertyValueChanged");
      
        // Set the change flag:
        if (!this._hasUserMadeAChange) {
      	  this._hasUserMadeAChange = true;
      	}
      	
      	// Validate:
      	this._validate();
      	
      	// Update the command:
      	this._populateTextAreaWithCommand();
      	
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handlePropertyValueChanged");
      },
      
      // Called after the user makes a change in the UI:
      _populateTextAreaWithCommand: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_populateTextAreaWithCommand");
      
        // Build the parts of the command based on the values in the UI:
        
        var nodeName = window.brokerName;
      	var configurableServiceType = this._getType();
      	var configurableServiceName = this._getName();
      	
      	var propertyNames = "";
      	var propertyValues = "";
      	var numberOfRows = this._getPropertiesTable().rowCount();
      	if (numberOfRows > 0) {
      	  for (var i = 0; i < numberOfRows; i++) {
      	    var name = this._getPropertiesTable().cell(i, 0).rawData();
      	    
      	    var rawValue = this._getPropertiesTable().cell(i, 1).rawData();
      	    // Enclose the value in " characters:
      	    var value = "\"" + rawValue + "\"";
      	    // If the rawValue contains a comma character (,), we have to enclose the
      	    // value in \" characters instead of " characters. For example: \"a,b\"
      	    if (rawValue !== undefined && rawValue.indexOf(",") !== -1) {
      	      // has one or more commas, enclose in \" characters instead of " characters:
      	      value = "\\\"" + rawValue + "\\\"";
      	    }
      	    
      	    if (i === 0) {
      	      propertyNames = name;
           		propertyValues = value;
      	    }
      	    else {
      	    	propertyNames = propertyNames + "," + name;
           		propertyValues = propertyValues + "," + value;
      	    }
          }
      	}
      	
      	// Determine the command name depending on whether we are in add or edit mode:
      	var commandName = "mqsicreateconfigurableservice"; // for add
      	if (this._isInEditMode()) {
      		commandName = "mqsichangeproperties"; // for edit
      	}
      	
      	// Put together and set the command:
      	var commandText = string.substitute("${0} ${1} -c ${2} -o ${3} -n ${4} -v ${5}", [commandName, nodeName, configurableServiceType, configurableServiceName, propertyNames, propertyValues]);
      	this._csCommandTextArea.set("value", commandText);
      	
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_populateTextAreaWithCommand");
      },
      
      // Called when there is a row selection change in the property table:
      _handleRowSelectionChanged: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handleRowSelectionChanged");
      
        // Only enable the property remove button if the configurable service type
        // is UserDefined and there is one or more selections:
        var isTypeUserDefined = this._getType() === 'UserDefined';
      	if (isTypeUserDefined) {
      	  var selected = this._getPropertiesTable().select.row.getSelected();
      	  var isOneMoreRowsSelected = selected !== undefined && selected.length > 0;
      	  this._csRemovePropertyButton.set("disabled", !isOneMoreRowsSelected);
      	}
      	else {
      	  this._csRemovePropertyButton.set("disabled", true);
      	}
      	
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_handleRowSelectionChanged");
      },
      
      // Called when the user presses the add property button:
      _handleAddPropertyButtonPressed: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handleAddPropertyButtonPressed");
        
        // Set the change flag:
        if (!this._hasUserMadeAChange) {
      	  this._hasUserMadeAChange = true;
      	}
        
        // find a unique default name for the new property to add:
        var baseNameForNewProperty = "property";
        var counter = 1;
        var uniqueNameForNewPropertyFound = false;
        while (!uniqueNameForNewPropertyFound) {
          var queryResult = this._getPropertiesTable().store.query({name: baseNameForNewProperty + counter});
          if (queryResult === undefined || queryResult.length === 0) {
        	uniqueNameForNewPropertyFound = true;
          }
          else {
            counter++;
          }
        }
        
        // Add the new property with the unique default name (note that the current time in
        // milliseconds since January 1, 1970 is used for the id; the property name can not
        // be used as the id because the user has the freedom to change the property name in
        // the UI):
        var nameForNewProperty = baseNameForNewProperty + counter;
        var idForNewProperty = String(new Date().getTime());
        this._getPropertiesTable().store.add({id:idForNewProperty, name:nameForNewProperty, value:""});
        
        // Remove the current selection, and select the row containing the newly added property:
        this._getPropertiesTable().select.row.clear();
        this._getPropertiesTable().select.row.selectById(idForNewProperty);
        
        // Update the command:
        this._populateTextAreaWithCommand();
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_handleAddPropertyButtonPressed");
      },
      
     // Called when the user presses the remove property button:
      _handleRemovePropertyButtonPressed: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handleRemovePropertyButtonPressed");
        
        // Set the change flag:
        if (!this._hasUserMadeAChange) {
      	  this._hasUserMadeAChange = true;
      	}
        
        // Remove the selected rows from the property table store:
        var selected = this._getPropertiesTable().select.row.getSelected();
        if (selected !== undefined && selected.length > 0) {
          for (var i = 0; i < selected.length; i++) {
            this._getPropertiesTable().store.remove(selected[i]);
          }
        }
        
      	this._validate();
        this._populateTextAreaWithCommand();
        this._handleRowSelectionChanged();
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_handleRemovePropertyButtonPressed");
      },
      
      // Validates the widget. Called when the user makes a change to the UI.
      // shouldSkipDuplicateConfigurableServiceNameCheck is an optional parameter
      // and if not provided defaults to false and the duplicate name check is
      // done.
      _validate: function(shouldSkipDuplicateConfigurableServiceNameCheck) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_validate");
        
        // If the parameter was not provided, assume false (i.e. that we do
        // want to do the duplicate name check):
        if (shouldSkipDuplicateConfigurableServiceNameCheck === null ||
              shouldSkipDuplicateConfigurableServiceNameCheck === undefined) {
          shouldSkipDuplicateConfigurableServiceNameCheck = false;
        }
        
        // Validate the configurable service name:
        var configurableServiceName = this._getName();
        
        // Validate that the configurable service name is set:
        if (configurableServiceName === null || configurableServiceName === undefined || configurableServiceName.trim() === '') {
        	this.toolbar.getButton("save").set("disabled", true);
      	  window.smallMessage.displayPlainMessage("error", "ConfigurableService_emptyName");
        	return;
        }
        
        // Validate that the configurable service name does not start with a digit:
        var firstCharacterAsInt = parseInt(configurableServiceName.charAt(0));
        if (!isNaN(firstCharacterAsInt)) {
        	this.toolbar.getButton("save").set("disabled", true);
      	  window.smallMessage.displayPlainMessage("error", "ConfigurableService_nameCanNotStartWithDigit");
        	return;
        }
        
        // Check whether the configurable service name contains any invalid characters:
        var invalidCharInConfigServiceName = this._findFirstInvalidCharInName(configurableServiceName);
        if (invalidCharInConfigServiceName !== null) {
          this.toolbar.getButton("save").set("disabled", true);
      	  window.smallMessage.displayPlainMessage("error", "ConfigurableService_nameContainsInvalidCharacter", [invalidCharInConfigServiceName]);
        	return;
        }
        
        if (shouldSkipDuplicateConfigurableServiceNameCheck === false && !this._isInEditMode()) {
          // Check if the configurable service name is duplicated:
      	  var csNameQueryResult = this._getTemplateWidget().get("store").query({name: configurableServiceName});
          if (csNameQueryResult !== undefined && csNameQueryResult.length > 0) {
            this.toolbar.getButton("save").set("disabled", true);
            window.smallMessage.displayPlainMessage("error", "ConfigurableService_nameAlreadyExists", [configurableServiceName, this._getType()]);
            return;
          }
        }
        
        // Validate the configurable service property names (have to be set and can not be duplicated):
        var numberOfRows = this._getPropertiesTable().rowCount();
      	if (numberOfRows > 0) {
      	  for (var i = 0; i < numberOfRows; i++) {
      	    var propertyName = this._getPropertiesTable().cell(i, 0).rawData();
      	    
      	    // Check if the property name is empty:
      	    if (propertyName === null || propertyName === undefined || propertyName.trim() === '') {
      	      this.toolbar.getButton("save").set("disabled", true);
      	      window.smallMessage.displayPlainMessage("error", "ConfigurableService_emptyPropertyName");
      	      return;
      	    }
      	    
      	    // Validate that the property name does not start with a digit:
      	    var firstCharacterOfPropertyNameAsInt = parseInt(propertyName.charAt(0));
            if (!isNaN(firstCharacterOfPropertyNameAsInt)) {
          	  this.toolbar.getButton("save").set("disabled", true);
        	    window.smallMessage.displayPlainMessage("error", "ConfigurableService_propertyNameCanNotStartWithDigit", [propertyName]);
          	  return;
            }
            
            // Validate that the property name does not start with "xml":
            if (propertyName.length > 2 && propertyName.slice(0, 3) === 'xml') {
              this.toolbar.getButton("save").set("disabled", true);
      	      window.smallMessage.displayPlainMessage("error", "ConfigurableService_propertyNameCanNotStartWithXML", [propertyName]);
      	      return;
            }
            
            // Check whether the property name contains any invalid characters:
            var invalidCharInPropertyName = this._findFirstInvalidCharInName(propertyName);
            if (invalidCharInPropertyName !== null) {
              this.toolbar.getButton("save").set("disabled", true);
      	      window.smallMessage.displayPlainMessage("error", "ConfigurableService_propertyNameContainsInvalidCharacter", [propertyName, invalidCharInPropertyName]);
      	      return;
            }
      	    
      	    // Check if the name is duplicated:
      	    var queryResult = this._getPropertiesTable().store.query({name: propertyName});
            if (queryResult !== undefined && queryResult.length > 1) {
              this.toolbar.getButton("save").set("disabled", true);
      	      window.smallMessage.displayPlainMessage("error", "ConfigurableService_duplicatePropertyName", [propertyName]);
      	      return;
            }
          }
        }
        
        // If we have gotten this far everything is good, so hide current message and enable the save button:
        window.smallMessage.hideMessage();
        this.toolbar.getButton("save").set("disabled", false);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_validate");
      },
      
      // Returns the first invalid character in the provided name or null if no invalid characters
      // were found. Used when validating the configurable service name.
      _findFirstInvalidCharInName: function(name) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_findFirstInvalidCharInName");
        var firstInvalidChar = null; // assume no invalid characters
        if (name !== null && name !== undefined) {
          var invalidSpecialCharacters = "~`!@#$%^&*()+={}[]|;\"'<>?/"; // '-', '_', '.', and ':' characters are allowed
          for (var i = 0; i < name.length; i++) {
          	var currentChar = name.charAt(i);
          	if (invalidSpecialCharacters.indexOf(currentChar) !== -1) {
          		firstInvalidChar = currentChar;
          		break;
          	}
          }
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_findFirstInvalidCharInName");
        return firstInvalidChar;
      },
      
      // Returns true if the editor is dirty, false otherwise.
      isDirty: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "isDirty");
        // Check if the editor is dirty by checking the state of the save button or the change flag:
        var result = false;
        if (this.toolbar !== undefined && this.toolbar.getButton("save") !== undefined && !this.toolbar.getButton("save").get("disabled")) {
        	result = true;
        }
        else if (this._hasUserMadeAChange) {
        	result = true;
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "isDirty");
        return result;
      },
      
      // Called by dojo when this widget is being destroyed:
      uninitialize: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "uninitialize");
        // Destroy the property value edit dialog if it exists:
      	var editPropertyValueDialog = registry.byId("editPropertyValueDialog");
      	if (editPropertyValueDialog !== null && editPropertyValueDialog !== undefined) {
      		editPropertyValueDialog.destroy();
      	}
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "uninitialize");
      }
      
    });
    return configurableServiceEditor;
  }
);

},
'webui/widgets/configurableservice/ImportConfigurableServiceFileDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 *
 */
 
/*
 * This widget is a dialog that allows a user pick a *.configurableservice file to import.
 *
 * When contructed, a client would typically provide the following callbacks:
 * 1. createCallback - Called when the dialog is closed by the user by pressing the OK button.
 * 2. uploadCompleteCallback - Called when the file upload completes (regardless of whether the
 *                             upload was successful or not).
 * 
 * When 1 is called, a client would typically call the upload function. When 2 is called, a
 * client would typically look at the response JSON object for "error" which contains an error
 * message or "uri" which indicates success and contains the URI of the imported configurable
 * service.
 */
 
define(
  "webui/widgets/configurableservice/ImportConfigurableServiceFileDialog",
  [ "dojo/text!webui/widgets/configurableservice/templates/ImportConfigurableServiceFileDialog.html", 
   "dojo/i18n!webui/nls/web", 
   "dojo/_base/declare",
   "dojo/dom-attr",
   "dojo/keys",
   "dojo/_base/event",
   "dojo/on",
   "dojo/_base/lang",
   "dijit/Dialog",
   "dijit/_TemplatedMixin", 
   "dijit/_WidgetsInTemplateMixin",
   "webui/widgets/common/Trace"
   ], 
   function( 
     template, 
     NLS, 
     declare,
     domAttr,
     keys,
     event,
     on,
     lang,
     Dialog,
     _TemplatedMixin,
     _WidgetsInTemplateMixin,
     Trace) {

  return declare("webui.widgets.configurableservice.ImportConfigurableServiceFileDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {    
    templateString : template,
    declaredClass : "webui.widgets.configurableservice.ImportConfigurableServiceFileDialog",
    _buttonOKLabel:NLS.okButtonLabel,
    _buttonCancelLabel: NLS.cancelButtonLabel,
    
    _onKey : function(evt) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onKey");
      this.inherited(arguments);
      if (evt.charOrCode) {
        if (evt.charOrCode === keys.ENTER) {
          if ( !this._okButton.get("disabled" ) ) {
            event.stop(evt);
            this.onExecute();
          }
        }
      }
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onKey");
    },

    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      
      this.inherited(arguments);

      // Set the title and description for the dialog:
      domAttr.set(this.titleNode, "innerHTML", NLS.configurableserviceImportCSFileDialogTitle);
      domAttr.set(this._csImportFileImportInstructionNode, "innerHTML", NLS.configurableserviceImportCSFileDialogDescription);
      
      // Remember the original color of the instruction text (so we can revert the color back if the
      // user introduces an error and then cleans up the error):
      this._originalInstructionNodeTextColor = this._csImportFileImportInstructionNode.style.color;
      
      this.titleNode.setAttribute("tabIndex", -1);
      
      // Set the label of the uploader button:
      domAttr.set(this._csImportUploader, "label", NLS.configurableserviceBrowseLabel);
      
      on(this, "execute", lang.hitch(this, function() {
         // Xhr post
         if (this.createCallback){
           this.createCallback.apply();
         }
         this.hide();
      }));
      
      on(this._cancelButton, "click", lang.hitch(this, function() {
        this.hide();
      }));
      
      // Listen for file selection changes:
      on(this._csImportUploader, "change", lang.hitch(this, this._fileSelectionChanged));
      
      // Listen for upload completion and call callback handler if any:
      on(this._csImportUploader, "complete", lang.hitch(this, function(response) {
         if (this.uploadCompleteCallback){
           this.uploadCompleteCallback.call(undefined, response);
         }
      }));
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },
    
    // Called on initial use and before an instance of this dialog is reused:
    refresh : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "refresh");

	  // Remove previously selected file:
	  this._csImportUploader.reset();
	  this._csImportFile.set("value", "");

	  // Set the OK button to disabled as the user has not made any changes yet:
      this._okButton.set("disabled", true);

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "refresh");
    },
    
    // Called after the user clicks the Browse... button, picks a file, and then
    // presses OK on the file selection dialog:
    _fileSelectionChanged : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_fileSelectionChanged");
      
      // Get the name of the selected file:
      var selectedFile = this._csImportUploader.getFileList()[0];
      var nameOfSelectedFile = selectedFile.name;
      
      // Set the name of the selected file in the text field:
      this._csImportFile.set("value", selectedFile.name);
      
      // Validate that the name of the selected file ends with *.configurableservice:
      var hasValidExtension = false;
      var configurableServiceExtension = ".configurableservice";
      if (nameOfSelectedFile.length >= configurableServiceExtension.length) {
        var endOfSelectedFileName = nameOfSelectedFile.substr(nameOfSelectedFile.length - configurableServiceExtension.length, nameOfSelectedFile.length - 1);
        if (endOfSelectedFileName.toLowerCase() === configurableServiceExtension) {
          hasValidExtension = true;
        }
      }
      
      if (!hasValidExtension) {
        // Not a valid extension, show error in red and disable the OK button:
        domAttr.set(this._csImportFileImportInstructionNode, "innerHTML", NLS.configurableserviceImportCSFileDialogInvalidFileExtensionError);
        this._csImportFileImportInstructionNode.style.color = "red";
        this._okButton.set("disabled", true);
      }
      else {
        // Is a valid extension, show regular instruction text in normal colour and enable the OK button:
        domAttr.set(this._csImportFileImportInstructionNode, "innerHTML", NLS.configurableserviceImportCSFileDialogDescription);
      	this._csImportFileImportInstructionNode.style.color = this._originalInstructionNodeTextColor;
      	this._okButton.set("disabled", false);
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_fileSelectionChanged");
    },
    
    // Called to perform the actual upload of the *.configurableservice file
    // to the server that results in the import of the configurable service:
    upload : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "upload");
      this._csImportUploader.upload();
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "upload");
    },
    
    // Returns the name of the file that the user selected.
    getNameOfFileToUpload : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "getNameOfFileToUpload");
      
      var name = this._csImportFile.get("value");
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "getNameOfFileToUpload");
      return name;
    }
    
  });
});

},
'webui/widgets/common/EditTextPropertyValueDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 *
 */

/*
 * This widget is a dialog that allows a user to edit a text value in a textarea.
 *
 * This widget contains validation. To get a text box without validation, use EditPropertyValueDialog.
 */

define(
  "webui/widgets/common/EditTextPropertyValueDialog",
  [
    "dojo/text!webui/widgets/common/templates/EditTextPropertyValueDialog.html",
    "dojo/i18n!webui/nls/web",
    "webui/widgets/common/EditPropertyValueDialog",
    "dojo/_base/declare",
    //"dijit/Dialog",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "webui/widgets/common/Trace",

    // For HTML template
    "dijit/form/Textarea"
  ],
  function(
    template,
    NLS,
    EditPropertyValueDialog,
    declare,
    //Dialog,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    Trace
  ) {

  var editPropertyValueDialog = declare("webui.widgets.common.EditTextPropertyValueDialog", [ EditPropertyValueDialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
    templateString : template,
    _isResettingValue : false,
    _valueChangedEventHandler : null,
    _buttonOKLabel:NLS.okButtonLabel,
    _buttonCancelLabel: NLS.cancelButtonLabel,
    currentValue : "",
    cell: null,

    // Returns the dialog type
    _dialogType: function() {
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "_dialogType");
      Trace.trace(this.widgetName, Trace.levels.EXIT, "_dialogType");
      return "text";
    }

  });
  return editPropertyValueDialog;
});

},
'webui/widgets/common/Toolbar':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="3041868574" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/i18n!webui/nls/web",
  "dojo/text!webui/widgets/common/templates/Toolbar.html",
  "dojo/_base/array",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/dom-class",
  "dojo/dom-construct",
  "dojo/on",
  "dojo/store/Memory",
  "dijit/_WidgetBase",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetsInTemplateMixin",
  "dijit/DropDownMenu",
  "dijit/form/Button",
  "dijit/form/DropDownButton",
  "dijit/MenuItem",
  "idx/form/ComboBox",
  "webui/widgets/common/Trace"
], function(
  NLS,
  template,
  array,
  declare,
  lang,
  domAttr,
  domClass,
  domConstruct,
  on,
  Memory,
  _WidgetBase,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  DropDownMenu,
  Button,
  DropDownButton,
  MenuItem,
  ComboBox,
  Trace
) {
  // Every button has a type and a name. In most cases you will only
  // ever have one button of a given type, which means the type uniquely
  // identifies it and no name is required/given.
  // If the name is omitted, you get this one instead.
  var DEFAULT_BUTTON_NAME = "noNameDefault";

  var toolbar = declare("webui.widgets.common.Toolbar", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {

    templateString: template,

    //Buttons
    _buttons: null,
    _infoPaneToolbar: null,
    _buttonContainers: null,

    postCreate: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      this._buttons = {};

      // Create Toolbar
      this._infoPaneToolbar = domConstruct.create("div", {
        className: "dijit dijitToolbar _common_toolbarPosition"
      }, this._toolbar); // `_toolbar` from HTML template

      //Create a container in the toolbar to hold the _buttons
      this._buttonContainers = {
        left: domConstruct.create("span", {
          className: "_common_leftToolbarButtonContainer"
        }, this._infoPaneToolbar, "last"),

        right: domConstruct.create("span", {
          className: "_common_rightToolbarButtonContainer"
        }, this._infoPaneToolbar, "last")
      };

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },

    addRightAlignButtons: function (buttonTypes, /*optional string or array*/ names) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_addRightAlignButtonsAttr");
      this._createButtons("right", buttonTypes, names);
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_addRightAlignButtonsAttr");
    },

    addLeftAlignButtons: function (buttonTypes, /*optional string or array*/ names) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_addLeftAlignButtonsAttr");
      this._createButtons("left", buttonTypes, names);
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_addLeftAlignButtonsAttr");
    },

    setButtonState: function (
      /* "enable" or "disable" */ state,
      /* string or array of strings */ buttonTypes,
      /* optional string or array of strings */ names
    ) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setDisableButtonsAttr");

      if(!lang.isArray(buttonTypes)){
        buttonTypes = [buttonTypes];
      }

      if(names){
        if(!lang.isArray(names)){
          names = [names];
        }
      }

      array.forEach(buttonTypes, lang.hitch(this, function(buttonType, i){

        var disabled;
        var iconClass;
        if (state == "enable"){
          disabled = false;
          iconClass = "infoPaneButton_" + buttonType + " infoPaneButton_" + buttonType + "Enabled";
        } else {
          disabled = true;
          iconClass = "infoPaneButton_" + buttonType + "Disabled";
        }

        var name = names && names[i] ? names[i] : undefined;

        var actualButton = this.getButton(buttonType, name);
        actualButton.set('disabled', disabled);
        actualButton.set('iconClass', iconClass);
      }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setDisableButtonsAttr");
    },

    /**
     * Set up a listener to be invoked if an event occurs on this button
     */
    connectButtons: function (buttonType, eventType, context, target, /*optional*/ name){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onButtonAttr");

      if(!name) {
        name = DEFAULT_BUTTON_NAME;
      }

      var actualButton = this.getButton(buttonType, name);
      on(actualButton, eventType, lang.hitch(context, context[target]));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onButtonAttr");
    },

    setAttribute: function (buttonType, attribute, value, /*optional*/ name){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setAttributeAttr");

      if(!name){
        name = DEFAULT_BUTTON_NAME;
      }

      var actualButton = this.getButton(buttonType, name);
      if(buttonType === "combo" && attribute == "store") {
        var store = new Memory({});
        array.forEach(value, lang.hitch(this, function(item){
          store.add(item);
        }));
        actualButton.store = store;
      } else if(
        buttonType === "title" ||
        buttonType === "subtitle" ||
        buttonType === "span" ||
        buttonType === "spacer"
      ) {
        domAttr.set(actualButton, attribute, value);
      } else {
        actualButton.set(attribute, value);
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setAttributeAttr");
    },

    /**
     * Get the value of a "combo" button. In general, all combo _buttons are named.
     */
    getComboValue: function (name){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "getComboValue");

      if(!name) {
        name = DEFAULT_BUTTON_NAME;
      }

      var comboObject = this.getButton("combo", name);
      var value = comboObject.value;

      // Try to get the item value from the combo object store
      array.forEach(comboObject.store.data, function(comboItem){
        if(comboItem.name === value && comboItem.value){
          value = comboItem.value;
        }
      });

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "getComboValue");

      return value;
    },

    _createButtons: function(alignment, buttonTypes, names) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createButtons");

      if(!lang.isArray(buttonTypes)){
        buttonTypes = [buttonTypes];
      }

      if(names){
        if(!lang.isArray(names)){
          names = [names];
        }
      }

      var buttonContainer = this._buttonContainers[alignment];

      array.forEach(buttonTypes, lang.hitch(this, function(buttonType, i){

        var name = names && names[i] ? names[i] : DEFAULT_BUTTON_NAME;

        var actualButton;
        switch(buttonType)
        {
          case "destroyActivityLogFilter":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.filterClearFilter,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_cancelEnabled"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "apply":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.apply,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_apply"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "newInstance":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.createNewInstance,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_apply"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "cancel":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.cancel,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_cancelEnabled"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "combo":
            var store = new Memory({});
            actualButton = new ComboBox({
              store: store
            });
            domClass.add(actualButton.domNode, "dataStoreCombo");
            domAttr.set(actualButton.domNode, "data-test-attrname", name);
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "customiseColumns":
            // Create and add button to the toolbar
            actualButton = new DropDownButton({
              label: NLS.action.customiseColumns,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_customiseColumns"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "deploy":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.deploy,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_deploy"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "filter":
            // Create and add button to the toolbar
            actualButton = new DropDownButton({
              label: NLS.action.filter,
              name: "programmatic2",
              // dropDown: filterDialog,
              //id: "progButton",
              iconClass: "infoPaneButton_filter"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "sendToReplayViewer":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.sendToReplayViewer,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_sendToReplayViewer"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "refresh":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.refresh,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_refresh"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "revert":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.revert,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_revert"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "startMonitoring":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.btStartMonitoring,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_sendToReplayViewer"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "replay":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.replay,
              showLabel: true,
              layoutAlign: alignment,
              iconClass: "infoPaneButton_replayDisabled",
              disabled: false
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "save":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.save,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_saveEnabled"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "expandAll":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.expandAll,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_saveEnabled"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "collapseAll":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.collapseAll,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_saveEnabled"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "saveAs":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.saveAs,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_saveEnabled"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "spacer":
            // Create and add a space in the toolbar
            actualButton = domConstruct.create("span", {
              className: "infoPaneButton_spacer"
            }, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "span":
            // Create and add button to the toolbar
            actualButton = domConstruct.create("span", {
            }, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "localTime":
            // Create and add button to the toolbar
            var localTimeMenu = new DropDownMenu({ style: "display: none;"});
            localTimeMenu.addChild(this.getButton("localTimeSelect"));
            actualButton = new DropDownButton({
              label: NLS.action.localTime,
              showLabel: true,
              layoutAlign: alignment,
              dropDown: localTimeMenu,
              name: "programmatic2",
              disabled: false,
              iconClass: "infoPaneButton_localTime"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "localTimeSelect":
            // Create and add button to the toolbar
            actualButton = new MenuItem({
              label: NLS.localTimeBrowser,
              iconClass:"infoPaneButton_localTimeUTC"
            });
            this._saveButton(actualButton, buttonType, name);
            break;

          case "title":
            // Add title to the toolbar
            actualButton = domConstruct.create("span", {
              className: "pageHeader2 infoPaneTabTitle"
            }, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "subtitle":
            // Add a subtitle to the toolbar
            actualButton = domConstruct.create("span", {
              className : "portletHeader1 infoPaneTabSubTitle"
            }, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "flowView":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.flowView,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_help"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "help":
            actualButton = new Button({
              label: NLS.btHelp,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_apply"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "edit":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.edit,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_edit"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          case "downloadData":
            // Create and add button to the toolbar
            actualButton = new Button({
              label: NLS.action.downloadData,
              showLabel: true,
              layoutAlign: alignment,
              disabled: false,
              iconClass: "infoPaneButton_downloadData"
            });
            domConstruct.place(actualButton.domNode, buttonContainer, "last");
            this._saveButton(actualButton, buttonType, name);
            break;

          default:
            throw new Error("Button type " + buttonType + " not recognised");
        }

      }));

      // Create a space at the end of the toolbar
      domConstruct.create(
        "span",
        {
          className: alignment == "right" ? "infoPaneButton_rightSpacer" : "infoPaneButton_leftSpacer",
          layoutAlign: alignment
        },
        buttonContainer,
        alignment == "right" ? "last" : "first"
      );

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createButtons");
    },

    getButton: function(buttonType, /* optional */ name) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "getButton");

      if(!name) {
        name = DEFAULT_BUTTON_NAME;
      }

      var actualButton = this._buttons[buttonType][name];
      if(!actualButton) {
        throw new Error("Unrecognised " + buttonType + " button name: " + name);
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "getButton");
      return actualButton;
    },

    _saveButton: function(button, buttonType, /*optional*/ name) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_saveButton");

      if(!name) {
        name = DEFAULT_BUTTON_NAME;
      }

      if(!this._buttons[buttonType]) {
        this._buttons[buttonType] = {};
      }

      if(this._buttons[buttonType][name]) {
        throw new Error(buttonType + " button named " + name + " already exists on this Toolbar");
      }

      this._buttons[buttonType][name] = button;

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_saveButton");
    }
  });
  return toolbar;
});

},
'webui/widgets/business/businesstransaction_configuration':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2015,2016" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.  
 * </copyright> 
 */

define(
  "webui/widgets/business/businesstransaction_configuration",
  [
    "dojo/text!webui/widgets/business/templates/businesstransaction_configuration.html",
    "dojo/i18n!webui/nls/web",
    "dojo/_base/declare",
    "dijit/_WidgetBase",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/TitlePane",
    "webui/widgets/common/Trace",
    "dojo/_base/array",
    "dojo/_base/lang",
    "dojo/dom",
    "dojo/dom-attr",
    "dojo/dom-construct",
    "dojo/hash",
    "dojo/request/xhr",
    "webui/config/Resources",
    "webui/widgets/business/BTPermissionsModel",
    "webui/widgets/common/AttributesStore",
    "webui/widgets/common/HasContextMenu",
    "webui/widgets/common/Toolbar",
    "webui/widgets/common/UIUtils"
  ],
  function(template,
    NLS,
    declare,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    TitlePane,
    Trace,
    array,
    lang,
    dom,
    domAttr,
    construct,
    hash,
    xhr,
    Resources,
    BTPermissionsModel,
    AttributesStore,
    HasContextMenu,
    Toolbar,
    UIUtils
  ) {
    var businessTransactionConfiguration = declare("webui.widgets.business.businesstransaction_configuration", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
      templateString: template,
      declaredClass : "webui.widgets.business.businesstransaction_configuration",
      _btDataSourceLabel: NLS.btDataSourceName,
      _attributesStore: new AttributesStore(),
      _configTP: null,
      _monitoringTP: null,
      _policyInfo: {},
      _monitoringMessageFlows: [],
      
      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
        this.inherited(arguments);
        // Create toolbar
        this.toolbar = new Toolbar();
        construct.place(this.toolbar.domNode, this._toolbar);
        this.toolbar.addLeftAlignButtons("title");

        // Enable all by default, will control interaction upon visit to page
        var buttons = ["help"];
        this.toolbar.addRightAlignButtons(buttons);
        this.toolbar.setButtonState("enable", buttons);
        this.toolbar.connectButtons("help", "click", this, "onHelpClick");

        this._createPropertiesContainer(this._propertyTitlePane);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
      },

      startup: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "startup");

        this.inherited(arguments);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "startup");
      },
      
     _createPropertiesContainer: function(target) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createPropertiesContainer");
        
        this._configTP = new TitlePane({
          title : NLS.businessTransactionsRootConfigPanel,
          open: true
        });
        
        target.appendChild(this._configTP.domNode);
        
        this._monitoringTP = new TitlePane({
          title : NLS.btConfigMonitoringTitle,
          open: true
        });
        
        target.appendChild(this._monitoringTP.domNode);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createPropertiesContainer");
      },
      
      _setupDefaultPolicy: function(hasWrite) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setupDefaultPolicy");
        
        var cbFnc = lang.hitch(this, function() {
          // Only show if we are looking at the config tab for a BTD
          if(hash().indexOf(Resources.REST.businessTransactionDefinitionConfig) > -1 ) {
            // Construct the policyProperties table for populating
            this._setDefaultPolicyPropertiesContent();
            this._populateValues(hasWrite);
          }
        });

				this._validateMonitoringStatus();
        this._retrieveDefaultPolicyInformation(cbFnc);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setupDefaultPolicy");
      },

      _populateValues: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_populateValues");

        var dataSourceName = NLS.btConfigPolicyValueNotFound;
        
        // Set datasource name value
        if(this._dataSourceNameFromPolicyExists()) {
          if(this._getDataSourceNameFromPolicyInfo() === "") {
            // None set, display message
            dataSourceName = NLS.btConfigPolicyValueNone;
          } else {
            dataSourceName = this._getDataSourceNameFromPolicyInfo();
          }
        }

        dom.byId("policyDataSourceName").innerHTML = dataSourceName;

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_populateValues");
      },
      
      // For now just the data source name value
      _retrieveDefaultPolicyInformation: function(cbFnc) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_retrieveDefaultPolicyInformation");
        
        // For now retrieve the default datacapturepolicy
        var uri = Resources.REST.dataCapturePolicy + Resources.REST.defaultDCP;
        // Get the odbc resoute types
        xhr(
          uri,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json",
              "Content-type" : "application/json",
          }
          }
        ).then(
          lang.hitch(this, function(response) {
            // If response is good then set the policyInformation
            this._policyInfo = {};
            if((typeof response != "undefined") && (typeof response.policyProperties != "undefined")) {
              this._policyInfo.type = response.type;
              this._policyInfo.name = Resources.REST.defaultDCP;
              // Add all the basic properties, for now we'll only show the data source name
              this._policyInfo.policyProperties = response.policyProperties;
            }
            cbFnc();
          }),
          lang.hitch(this, function(error) {
            var response = JSON.parse(error.response.text);
            window.smallMessage.displayMessage("error", "retrievePolicyInformation_5XX", response.bipNumber, response.description, [Resources.REST.defaultDCP] );
          })
        );
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_retrieveDefaultPolicyInformation");
      },
      
      // For all flows, check their monitoring status
      _validateMonitoringStatus: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_validateMonitoringStatus");
        
        var populate = this._attributesStore.populateAttributesStore();

        populate.then(lang.hitch(this, function() {
          // Only set this content if we are still looking at the same hash
          if(hash() === Resources.REST.businessTransactionDefinitionConfig + this._attributesStore.getAttribute("name")) {
            // Only retrieve the message flows that have business events currently set upon them (on disk version)
            var businessEvents = this._attributesStore.getAttribute("businessEvents");
            this._monitoringMessageFlows = [];
            var messageFlows = [];
            // We don't care about the type, so check across all
            Object.keys(businessEvents).forEach(lang.hitch(this, function(objectItem) {
              if (lang.isArray(businessEvents[objectItem])) {
                array.forEach(businessEvents[objectItem], lang.hitch(this, function(nextEvent) {
                  // Only add it once
                  if(messageFlows.indexOf(nextEvent.flowUri) == -1){
                    messageFlows.push( nextEvent.flowUri );
                  }
                }));
              }
            }));
            
            // If there are flows to check
            if(messageFlows.length > 0) {
              // Callback for each flow 
              var cbFnc = lang.hitch(this, function(flowUri) {
                this._getFlowMonitoringStatus(flowUri, this._hasMonitoringCallComplete, messageFlows.length);
              });
              
              array.forEach( messageFlows, lang.hitch(this, function(flowUri) {
                cbFnc(flowUri);
              }));
            } else {
              // Just set to state all is ok
              this._setPropertiesContent(construct.create("div", {
                innerHTML : this._getInvalidMonitoringContent(NLS.btConfigMonitoringNoFlows)
              }), this._monitoringTP);
            }
          }
        }));
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_validateMonitoringStatus");
      },
      
      // Get the flow monitoring status for the flow in question 
      _getFlowMonitoringStatus: function(flowUri, cbFnc, targetSize) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_getFlowMonitoringStatus");
        
        // Do the call to get monitoring flow attribute
        xhr(
            flowUri,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json",
              "Content-type" : "application/json",
          }
          }
        ).then(
          lang.hitch(this, function(response) {
            this._monitoringMessageFlows.push({ 
              flowUri : flowUri,
              monitoringStatus : response.flowMonitoringActive});
            if(cbFnc( this._monitoringMessageFlows.length, targetSize)) {
              this._setFlowMonitoringStatusPropertiesContent();
            }
          }),
          lang.hitch(this, function() {
            // Set to unknown if can't get status - flow could be undeployed etc...
            this._monitoringMessageFlows.push({ 
              flowUri : flowUri,
              monitoringStatus : "unknown"});
            if(cbFnc( this._monitoringMessageFlows.length, targetSize)) {
              this._setFlowMonitoringStatusPropertiesContent();
            }
          })
        );
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_getFlowMonitoringStatus");
      },
      
      // Add the flow to the 
      _hasMonitoringCallComplete: function(currentSize, targetSize) {
        return (currentSize === targetSize);
      },
      
      _setDefaultPolicyPropertiesContent: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setDefaultPolicyPropertiesContent");
        
        var dataSourceNameContent = "<table class='_common_propertyContainer'>" +
        "<tbody>" +
        "<tr class='bt_hidden'><th/><th/></tr>" +
        "<tr>" +
        "<td class='_common_propertySubTextEven'>" + NLS.btDataSourceName + "</td>" +
        "<td data-test-attrname='dataSourceName' class='_common_propertySubValueEven' id='policyDataSourceName'>" +
        "</td>" +
        "</tr>" +
        "</tbody>" +
        "</table>";
        
        var text = "";
        
        if(this._dataSourceNameFromPolicyExists()) {
          if(this._getDataSourceNameFromPolicyInfo() === "") {
            // None set, link text to set it.
            text = NLS.btLinkToEditPolicySet;
          } else {
            // Set, link text to change it.
            text = NLS.btLinkToEditPolicyChange;
          }
        } else {
          // None set, link text to set it.
          text = NLS.btLinkToEditPolicySet;
        }

        // Only show link if user can actually go on to edit it
        if(BTPermissionsModel.writeModeForBTD()) {
          var linkContent = "<div class='bt_ConfigInfo'><a target='_self' href='#" + Resources.REST.businessTransactionsHome + "'>" + text + "</a></div>";
          dataSourceNameContent += linkContent;
        }

        this._setPropertiesContent(construct.create("div", {
          innerHTML : dataSourceNameContent
        }), this._configTP);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setDefaultPolicyPropertiesContent");
      },
      
      _setFlowMonitoringStatusPropertiesContent: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setFlowMonitoringStatusPropertiesContent");
        
        // Only update the content if we are still looking at this tab
        if(hash() === Resources.REST.businessTransactionDefinitionConfig + this._attributesStore.getAttribute("name")) {
          
          var falseFlows = [];
          var unknownFlows = [];
          
          var falseContent = "";
          var unknownContent = "";
          
          // Add flows to array (so that they can be sorted)
          array.forEach(this._monitoringMessageFlows, lang.hitch(this, function(nextFlow) {
            // Unknown
            if(nextFlow.monitoringStatus === "unknown") {
              unknownFlows.push(UIUtils.deriveLabelValue(nextFlow.flowUri)[0]);
            } else {
              // False
              if(!nextFlow.monitoringStatus) {
                falseFlows.push(UIUtils.deriveLabelValue(nextFlow.flowUri)[0]);  
              }
              // Don't need to handle true
            }
          }));
          
          falseFlows.sort();
          unknownFlows.sort();
          
          array.forEach(falseFlows, lang.hitch(this, function(nextFlow) {
            falseContent += "<tr><td>" + nextFlow + "</tr></td>";  
          }));
          
          array.forEach(unknownFlows, lang.hitch(this, function(nextFlow) {
            unknownContent += "<tr><td>" + nextFlow + "</tr></td>";  
          }));
          
          var monitoringFlowContent = "";
          
          // All good, no flows to be listed
          if((falseContent === "") && (unknownContent === "")) {
            monitoringFlowContent = this._getValidMonitoringContent();
          } else {
            // Else create a table that shows the non active flows
            monitoringFlowContent = "<table class='_common_propertyContainer'>" +
            "<tbody>" +
            "<tr class='bt_hidden'><th/><th/></tr>";
            
            if(falseContent != "") {
              monitoringFlowContent += "<tr>" +
              "<td class='_common_propertySubTextEven'>" + NLS.btConfigMonitoringFalse + "</td>" +
              "<td data-test-attrname='noMonitoringFlows' class='_common_propertySubValueEven' id='noMonitoringMessageFlows'>" + 
              "<table><tbody><tr class='bt_hidden'><th/></tr>" +
              falseContent +
              "</tbody></table></td></tr>";
            }
            
            if(unknownContent != "") {
              monitoringFlowContent += "<tr>" +
              "<td class='_common_propertySubTextEven'>" + NLS.btConfigMonitoringUnknown + "</td>" +
              "<td data-test-attrname='noMonitoringFlows' class='_common_propertySubValueEven' id='noMonitoringMessageFlows'>" + 
              "<table><tbody><tr class='bt_hidden'><th/></tr>" +
              unknownContent +
              "</tbody></table></td></tr>";
            }
            
            monitoringFlowContent += "</tbody>" +
            "</table>"; 
            
            monitoringFlowContent += this._getInvalidMonitoringContent(NLS.btConfigMonitoringUserAction);
          }
          this._setPropertiesContent(construct.create("div", {
            innerHTML : monitoringFlowContent
          }), this._monitoringTP);
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setFlowMonitoringStatusPropertiesContent");
      },
      
      // This is stored currently at this._policyInfo.policyProperties.configurations.configuration[0].dataSourceName
      // Thorough checking before asserting the data source name value
      _dataSourceNameFromPolicyExists: function() {
        if((typeof this._policyInfo.policyProperties != "undefined") &&
            (typeof this._policyInfo.policyProperties.configurations != "undefined") &&
              (typeof this._policyInfo.policyProperties.configurations.configuration != "undefined") &&
                (typeof lang.isArray(this._policyInfo.policyProperties.configurations.configuration) &&
                  (this._policyInfo.policyProperties.configurations.configuration.length > 0)) && 
                    (typeof this._policyInfo.policyProperties.configurations.configuration[0].dataSourceName != "undefined")) {
          return true;
        }
        
        return false;
      },
            
      _getValidMonitoringContent: function() {
        return "<div class='bt_ConfigContainer bt_ConfigValid'>" +
        "<div class='bt_ConfigIconContainer'>" +
        "<div class='bt_ConfigIcon validationIcon_valid'></div></div>" +
        "<div class='bt_ConfigMessage'>" + NLS.btConfigMonitoringValid + "</div></div>";
      },
      
      _getInvalidMonitoringContent: function(msg) {
        return "<div class='bt_ConfigContainer bt_ConfigWarning'>" +
        "<div class='bt_ConfigIconContainer'>" +
        "<div class='bt_ConfigIcon validationIcon_warning'></div></div>" +
        "<div class='bt_ConfigMessage'>" + msg + "</div></div>";
      },

      _getDataSourceNameFromPolicyInfo: function() {
        if(this._dataSourceNameFromPolicyExists()) {
          return this._policyInfo.policyProperties.configurations.configuration[0].dataSourceName;
        }
        
        return null;
      },
      
      _setPropertiesLoading: function(container) {
        this._setPropertiesContent(construct.create("div", {
          innerHTML : "<div class='_common_propertyLoading'></div>",
          className : "btConfigLoading"
        }), container);
      },
      
      _removePropertiesContent: function(container) {
        this._setPropertiesContent("", container);
      },
      
      _setPropertiesContent: function(content, container) {
        domAttr.set(container, "content", content);
      },

      resize: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");

        this._businessTransactionConfiguration_borderContainer.resize();
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
      },

      // This function is called when we need to remove this tab.
      tabRemove: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
        
        this._policyInfo = {};
        this._removePropertiesContent(this._configTP);
        this._removePropertiesContent(this._monitoringTP);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
      },

      tabFocus: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");

        // Regenerate the policy information upon new visit to tab (from different hash)
        if(Object.keys(this._policyInfo).length == 0) {
          this._setPropertiesLoading(this._configTP);
          this._setupDefaultPolicy();
        }
        
        // Generate the flow monitoring information
        this._setPropertiesLoading(this._monitoringTP);
        this._validateMonitoringStatus();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
      },

      onHelpClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onHelpClick");

        window.open(Resources.help.businessTransactionConcept);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onHelpClick");
      },

      tabBlur: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
      }
    });
    return businessTransactionConfiguration;
  }
);

},
'webui/widgets/common/CustomJsonRest':function(){
define(
  [
    "dijit/registry",
    "dojo/_base/declare",
    "dojo/_base/lang",
    "dojo/dom-attr",
    "dojo/hash",
    "dojo/query",
    "dojo/store/JsonRest",
    "dojo/topic",
    "dojo/when",
    "webui/config/Resources",
    "webui/utils/RestUri",
    "webui/utils/WebUiHash",
    "webui/widgets/common/Trace"
  ],
  function(
    registry,
    declare,
    lang,
    attr,
    hash,
    query,
    JsonRest,
    topic,
    when,
    Resources,
    RestUri,
    WebUiHash,
    Trace
  ) {

    /**
     * An extension of Dojo's own JsonRest, with some custom methods
     * which we can use. This is the "model" for our CustomTree; it
     * retrieves items (i.e. JavaScript objects) on behalf of the
     * tree widget, and PUTs them into the REST API.
     *
     * Each item retrieved for the tree has a `dynamicUpdateHandle`,
     * a listener for admin notifications when the element changes
     * inside Integration Bus. Usually this listener is set to prompt
     * updates to CustomJsonRest and the tree. It's a bit messy right
     * now though, and probably this code should be inside CustomTree
     * rather than anywhere else. 
     *
     * CustomJsonRest makes it a point to often call this.onChange(),
     * this.onChildrenChange() and this.onDelete() when things happen.
     * These methods are NOT defined here, nor are they inherited from
     * JsonRest or some grandparent class.
     * In fact they are ADDED to the CustomJsonRest object after creation,
     * by CustomTree. This means that when the contents of this store changes,
     * CustomTree is notified.
     */
    return declare("webui.widgets.common.CustomJsonRest", JsonRest, {
      
      idProperty: "uri",
      _listeners : {},
      
      /**
       * Tells if an item has or may have children.  Implementing logic here
       * avoids showing +/- expando icon for nodes that we know don't have children.
       * (For efficiency reasons we may not want to check if an element actually
       * has children until user clicks the expando node.)
       * Public. Numerous Dijit Tree models (ForestStoreModel, TreeStoreModel, ...)
       * implement this method. In our case, our Tree is a `CustomTree` and
       * this, `CustomJsonRest`, is our model.
       */
      mayHaveChildren: function(item){
        return (
          !!item &&
          item.internal !== "true" &&
          (
            item.hasChildren === "true" ||
            this._hasPresentChildren(item)
          )
        );
      },

      /**
       * Inspect a JSON object (as retrieved from the REST API)
       * and return an array containing of all of its child objects.
       * `item` is something like {executionGroups: {uri: "/apiv1/executiongroups", ...}, ...}
       * In this case `executionGroups` is a child because it has
       * a URI property.
       */
      _extractChildren: function(item) {
        var children = [];
        Object.keys(item).forEach(function(key) {
          // __parent is not a child!
          if( key === "__parent" ){
            return;
          }
          
          var value = item[key];
          
          if (value instanceof Array) {
            value.forEach(function(innerItem) {
              if(innerItem.uri) {
                children.push(innerItem);
              }
            });
            return;
          }
          
          if (
            value instanceof Object &&
            value.uri &&

            // Hide users, and only show 'My Profile' if the user does not have admin rights
            (value.type !== "users" || window.currentuser.userPermission("broker", "write")) &&
            
            // if the object is internal, do not add it to the list of children to be shown in the tree
            value.internal === "false"
          ) {
            children.push(value);
            return;
          }
          
          // otherwise do nothing, this property isn't a child candidate
        });
        
        return children;
      },

      /**
       * @summary Does `item` have any children?
       * `item` is something like {executionGroups: {uri: "/apiv1/executiongroups", ...}, ...}
       * In this case `executionGroups` is a child because it has
       * a URI property.
       */
      _hasPresentChildren: function(item) {
        return this._extractChildren(item).length > 0;
      },
      
      /**
       * This is code which really should be inside bt_recorder_overview.js
       * and businesstransaction_overview.js, not here. It gets called when
       * messages are published on certain topics relating to changes to
       * business transaction recorders - these messages are published manually
       * in the mentioned JavaScript widgets, they do not come from the
       * admin notification topic hierarchy.
       * Really, they should just call CustomJsonRest.get() and handle the rest
       * themselves. TODO
       */
      _customRefreshParentObject: function(args, uri) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_customRefreshParentObject");
        
        this.get(uri).then(
          lang.hitch(this, function(fullObject) {
            if(args.save || args.del) {
              // If tree updated, and hash needs to be updated (first time creation or name update), then change hash
              if(this.put(fullObject)) { // TODO: why do we PUT to delete??
                // If a callback function has been defined, then run it
                if(typeof args.updateHashCallback != "undefined") {
                  args.updateHashCallback(args.bTXUri);
                }
              }
            }
          }),
          lang.hitch(this,function(error){
            Trace.trace("webui.widgets.common.WMBConsole", Trace.levels.ERROR, "Error getting Tree JSON: " + error.status + " Response: " + error.responseText);
          })
        );
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_customRefreshParentObject");
      },

      /**
       * Same as above, but this time for configurable service deletion.
       * TODO: This code should be in cs_overview.js.
       */
      _configurableServiceRefresh: function(args) {
        if(args === undefined || args.uri === undefined) {
          return;
        }

        // Convert e.g. "/apiv1/policy/configurableservices/ActivityLog/a1"
        // to "/apiv1/policy/configurableservices/ActivityLog"
        var uriOfDeletedObject = args.uri;
        var csRestUri = new RestUri(uriOfDeletedObject);
        var csTypeRestUri = csRestUri.getConfigurableServiceTypeRestUri();
        var uriOfParentOfDeletedObject = csTypeRestUri.toString();
        
        // Get the parent object using the parent URI:
        var parentObject = this.get(uriOfParentOfDeletedObject);

        // Notify the tree that the children of the parent object have changed
        // and call the callback function (if defined) to update the hash
        // and therefore the selection in the tree:
        when(
          parentObject,
          lang.hitch(this, function(fullObject) {
            // Notify the tree that the children have changed:
            this.onChildrenChange(fullObject, fullObject.configurableService);
            
            // If a callback function has been defined, then run it:
            if(typeof args.updateHashCallback != "undefined") {
              args.updateHashCallback(uriOfDeletedObject, fullObject);
            }
          }),
          lang.hitch(this,function(error){
            Trace.trace("webui.widgets.common.WMBConsole", Trace.levels.ERROR, "Error getting Tree JSON: " + error.status + " Response: " + error.responseText);
          })
        );
      },
      
      /**
       * An application may reference a library. The REST object representing an
       * application will contain a "references" URI listing all the libraries it
       * references. Similarly, the REST object for the library will contain a
       * "referents" URI listing all the applications which reference it.
       * This method detects whether the supplied item lies within the "references"
       * or "referents" directory of another artifact. This is useful to prevent
       * infinite loops.
       */
      _descendantOfReferencesOrReferents: function(item) {
        var ancestor = item.__parent;
        while (!!ancestor) {
          if (ancestor.type === "references" || ancestor.type === "referents") {
            return true;
          }
          ancestor = ancestor.__parent;
        }
        return false;
      },
      
      /**
       * Often we need to listen for changes to the set of deployed artifacts, but
       * those changes have no admin notifications associated with them. When this is
       * the case, we instead use our own (web UI-specific) Dojo topics, and publish
       * notifications on those topics when the web UI is used to make changes. For
       * example, when we create a new business transaction, we publish on
       * `Resources.pubSubTopic.businessRecorders` to say it happened. CustomJsonRest
       * listens on these topics and updates itself in response.
       * Call this method to add a listener for a particular Dojo topic.
       */
      _addListener: function(topicString, callback) {
        if(topicString in this._listeners) {
          console.log(this.declaredClass, Trace.levels.DEBUG, "Tried to add a second listener to {0} in CustomJsonRest", [topicString]);
          return;
        }
        
        this._listeners[topicString] = topic.subscribe(topicString, callback);
      },
      
      /**
       * Public method. This method is called from several places. You pass the
       * object in and then we call onComplete() with all of the child objects,
       * or onError with the error.
       * CustomTree calls this when a node is expanded. We also call it ourselves,
       * which arguably we shouldn't...
       */
      getChildren: function(object, onComplete, onError){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate.tree.getChildren()", arguments);

        if (!this._hasPresentChildren(object)) {
          /*
          // Temp code to re-load tree until we have true RDF store notifications, hook callback when save or delete of business transaction takes place. 
          if(object.type === Resources.REST.businessRecordersType) {
            this._addListener(Resources.pubSubTopic.businessRecorders, lang.hitch(this, function(args) {
              this._customRefreshParentObject(args, Resources.REST.businesstransactionrecorders);
            }));
          }*/

          // Temp code to re-load tree until we have true RDF store notifications, hook callback when save or delete of business transaction takes place. 
          if(object.type === Resources.REST.businessType) {
            this._addListener(Resources.pubSubTopic.businessTransactionsUpdated, lang.hitch(this, function(args) {
              this._customRefreshParentObject(args, Resources.REST.businessTransactions);
            }));
          }
          
          if (object.type === Resources.REST.configurableServiceTypes) {
            // Subscribe to listen for when a configurable service is deleted so
            // we can refresh the tree.
            this._addListener(Resources.pubSubTopic.configurableServiceDeleted, lang.hitch(this, function(args) {
              this._configurableServiceRefresh(args);
            }));
          }
          
          if (object.type === Resources.REST.policy) {
            // Subscribe to listen for when a configurable service is created so
            // we can select the new configurable service in the tree.
            this._addListener(Resources.pubSubTopic.configurableServiceCreated, lang.hitch(this, function(args) {
              if(args === undefined || args.uri === undefined) {
                return;
              }

              var restUri = new RestUri(args.uri);
              if(restUri.isConfigurableService()) {
                this._selectNewConfigurableService(restUri);
              }
            }));
          }
        }

        // `object` might already have children listed in which case we
        // don't need to do any work. Otherwise we need to make a REST
        // call.
        
        var def = object;

        if (!this._hasPresentChildren(object) && object.hasChildren === "true") {
          if(object.type === "messageFlows"){
            //use ?depth=2 here as we need more details about a flow, like stats on/off and policies
            // TODO: should not need this
            def = this.get(object.uri+"?depth=2");
          }else{
            def = this.get(object.uri);
          }
        }
        
        // If `def` is an object then the success callback gets invoked immediately,
        // passing the same object through as `fullObject`. If `def` is a GET request
        // promise then `fullObject` is the result from that GET.

        when(
          def,
          
          /**
           * Build a list of all of this object's children and pass it to onComplete()
           */
          lang.hitch(this, function(fullObject) {
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate.tree.getChildren().dojoWhen",[fullObject]);
            
            var children = this._extractChildren(fullObject);
            
            // A little post-processing on the children:
            children.forEach(lang.hitch(this, function(el){
              
              // Prevent infinite expansion in the explorer tree.
              // This might happen in the case of shared library references, where we don't
              // want to allow infinite recursion through the shared library
              // reference chain.
              var ancestor = object; // NOT `fullObject`, which doesn't have __parent set!
              while (!!ancestor) {
                if (ancestor.uri === el.uri) {
                  // Stop the item from displaying any further children.
                  el.hasChildren = "false";
                  break;
                }
                ancestor = ancestor.__parent;
              }

              // Set the parent on each of our children, so they can navigate back up the tree.
              // The `__parent` property is our own invention.
              el.__parent = object; // Again: not `fullObject`, which is just temporary
              
              if (this._descendantOfReferencesOrReferents(el)) {
                // Because this is a descendant of a references or referents element, we set
                // a virtual URI. The virtual URI is then used as the identity for this child,
                // which needs to be unique - whilst the child's actual URI acts as a symlink
                // to the actual resource.
                el.virtualURI = this.getIdentity(object) + "@" + el.uri;
              }

              // And subscribe to admin notifications for this element
              var uri = el.uri;
              var toSubscribe = new RestUri(uri).getNotificationTopic();
              if(toSubscribe) {
                el.dynamicUpdateHandle = topic.subscribe(toSubscribe, lang.hitch(this, function() {
                  this._subscriptionUpdate(uri);
                }));
              }
            }));

            onComplete(children);

            Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate.tree.getChildren().dojoWhen");
          }),

          /**
           * Called when an error has occurred while getting the children
           * from this point in the tree.
           */
          lang.hitch(this,function(error){
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate.tree.getChildren().dojoWhenError",[error]);
            // Display an appropriate error message
            Trace.trace("webui.widgets.common.WMBConsole", Trace.levels.ERROR, "Error getting Tree JSON: " + error.status + " Response: " + error.responseText);

            if((typeof error.response != "undefined") && (typeof error.response.text != "undefined")) {
              var response = JSON.parse(error.response.text);
              window.smallMessage.displayMessage("error", "BusinessTransactionViewer_5XX", response.bipNumber, response.description);
            } else {
              window.smallMessage.displayMessage("error", "TreeError_5XX", null, error.responseText);
            }

            // Add error icon to tree
            var treeImgs = query(".dijitTreeExpandoLoading");
            // There is a very small chance that more than 1 image could be returned from this query
            attr.set(treeImgs[0],"class","dijitIcon dijitTreeIcon explorerTree_error");

            onError(error);
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate.tree.getChildren().dojoWhenError");
          })
        );
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate.tree.getChildren()");
      },
      
      /**
       * Same problem as `_customRefreshParentObject()` and
       * `_configurableServiceRefresh()`.
       * This code should be inside ConfigurableServiceEditor.js and/or
       * cs_category_overview.js. TODO
       */
      _selectNewConfigurableService: function(csRestUri) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_selectNewConfigurableService");

        var configurableServicesUri = RestUri.forConfigurableServices().toString();
        var csTypeUri = csRestUri.getConfigurableServiceTypeRestUri().toString();

        // Get the configurable services object using the configurable services URI:
        this.get(configurableServicesUri).then(

          lang.hitch(this, function(fullObject) {
            // To be safe, if the new configurable service is a UserDefined type, refresh all
            // the types to be sure that the UserDefined category is actually in the tree and
            // so that the new configurable service can be selected below (i.e. the UserDefined
            // category is empty by default):
            if (csRestUri.getConfigurableServiceType() === "UserDefined") {
              // Refresh the configurable service types in the tree:
              this.onChildrenChange(fullObject, fullObject.configurableServiceType);
            }
          })

        ).then(
        
          lang.hitch(this, function() {
            // Get the configurable service type object using the configurable service type URI:
            return this.get(csTypeUri);
          })

        ).then(

          lang.hitch(this, function(fullObject) {
            // Refresh children of the configurable service type (to ensure that the configurable service is visible):
            this.onChildrenChange(fullObject, fullObject.configurableService);
          
            // Select the newly created object if needed:
            // Example, "configurableService/0/policy/configurableservices/ActivityLog/a22"
            var newHash = WebUiHash.fromRestUri(csRestUri).toString();
            if (hash() !== newHash) { 
              hash(newHash);
            }
            else {
              // Hash is already set, refresh the overview tab so that properties have the
              // latest values (needed to handle the case that a configurable service is
              // selected, and then updates are imported via a *.configurableservice file):
              var csOverview = registry.byId("webui.widgets.configurableservice.cs_overview");
              if (csOverview !== undefined) {
                csOverview.tabFocus();
              }
            }
          }),

          // This gets hit if any of the above fails
          lang.hitch(this,function(error){
            Trace.trace("webui.widgets.common.WMBConsole", Trace.levels.ERROR, "Error getting Tree JSON: " + error.status + " Response: " + error.responseText);
          })
        );

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_selectNewConfigurableService");
      },

      /**
       * Any model for a Dijit Tree (even our CustomTree), including
       * this CustomJsonRest, should implement getRoot().
       * Calls onItem() with the root object.
       */
      getRoot: function(onItem, onError){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate.tree.getRoot()",[onItem, onError]);
        
        this.get(Resources.REST.root).then(

          lang.hitch(this, function(fullObject) {

            // Hang this off the object itself so it lives and dies with it.
            // When an update occurs, then we'll re-apply the subscription by doing a new get.
            var toSubscribe = new RestUri(Resources.REST.root).getNotificationTopic();
            fullObject.dynamicUpdateHandle = topic.subscribe(toSubscribe, lang.hitch(this, function() {
              this._subscriptionUpdate(Resources.REST.root);
            }));
            
            return fullObject;
          }

        )).then(onItem, onError);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate.tree.getRoot()");
      },

      /**
       * Override. Every Tree model, such as CustomJsonRest,
       * should implement this, so that entities in the tree
       * can be uniquely identified.
       * 
       * If a virtual URI is set, then this is a descendant of a references or referents
       * element. The virtual URI is then used as the identity for this element, which
       * needs to be unique - whilst the elements actual URI acts as a symlink to the
       * actual resource.
       */
      getIdentity: function(item) {
        return item.virtualURI || item.uri || null;
      },

      /**
       * This method is called when an admin notification says that we need to update
       * the tree. Why do we need to recursively notify all of our children when
       * this happens? Surely if the children change, separate notifications will be
       * published?
       */
      _recursiveNotifyChildren: function(fullObject) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate.tree._recursiveNotifyChildren()",[fullObject]);
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "uri",fullObject.uri);

        // We're doing a "depth-first" notify of children, so that we inform the leaf nodes, then work back up the tree.
        
        if (this.mayHaveChildren(fullObject)) {
          this.getChildren(
            fullObject,
            lang.hitch(this, function(children) {
              children.forEach(lang.hitch(this, this._recursiveNotifyChildren));
              this.onChildrenChange(fullObject, children);
            })
          );
        } else {
          this.onChildrenChange(fullObject, []);
        }
        
        this.onChange(fullObject);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate.tree._recursiveNotifyChildren()");
      },

      recursiveNotifyChildrenAfterFilterChange: function(fullObject) {
        
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "recursiveNotifyChildrenAfterFilterChange()",[fullObject]);
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "uri",fullObject.uri);
        // We're doing a "depth-first" notify of children, so that we inform the leaf nodes, then work back up the tree.

        this.getChildren(
          fullObject,
          lang.hitch(this, function(children) {
            var i = 0;
            for (i = 0; i < children.length; i++) {
              this.recursiveNotifyChildrenAfterFilterChange(children[i]);
            }
            this.onChildrenChange(fullObject, children);
          }),
          lang.hitch(this, function(){
          })
        );
            
        this.onChange(fullObject);
          
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "recursiveNotifyChildrenAfterFilterChange()");
      },
      
      /**
       * Most of the elements in the explorer tree also have an associated
       * subscriber for admin notifications. This listener is added in getRoot()
       * and in getChildren().
       * For example, in the case of a flow, the flow's element in the explorer
       * tree subscribes to admin notifications related to that flow. When such
       * a notification is published, this method gets called.
       */
      _subscriptionUpdate: function(uri) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate.tree._subscriptionUpdate()", arguments);

        // Refresh the element, then notify the whole tree with the result
        this.get(uri).then(
          lang.hitch(this, this._recursiveNotifyChildren),
          lang.hitch(this, function(error){
            Trace.trace("webui.widgets.common.WMBConsole", Trace.levels.ERROR, "Error getting Tree JSON: " + error.status + " Response: " + error.responseText);

            /*
             * If we tried to get an object from the store and we got a 404
             * error, then that means the object doesn't exist. It's impossible
             * to determine whether (1) it did exist once and has since been deleted
             * or (2) it never existed and you made a typo.
             * Case (1) seems more likely. In fact it happens quite frequently.
             * In this case, it is our responsibility as the model to notify the
             * CustomTree widget of this change.
             */
            if(error.status === 404) {
              this.onDelete({"uri" : uri}); // not pretty
            }
          })
        );

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate.tree._subscriptionUpdate()");
      },

      /**
       * Override the base method from JsonRest. We have to notify the
       * CustomTree after we delete something successfully.
       */ 
      remove: function(uri) {
        return this.inherited(arguments).then(lang.hitch(this, function() {
          this.onDelete(uri);
          return arguments;
        }));
      },
      
      /**
       * Override the base method from JsonRest. We have to notify the
       * CustomTree after we create something successfully. TODO:
       * shouldn't just call put() here if not going to make a PUT
       * request!
       */
      put: function(object){
        if( object.type === "businessTransactions") {
          this.onChildrenChange(object, object.businessTransactionName);
          this.onChange(object);
          // Then don't actually put anything into the store??
          return true;
        }
        else if( object.type === "businessTransactionRecorders") {
          this.onChildrenChange(object, object.businessTransactionRecorder);
          this.onChange(object);
          // Then don't actually put anything into the store??
          return true;
        }
        
        return JsonRest.prototype.put.apply(this, arguments);
      }

    });
  }
);
},
'webui/widgets/common/Trace':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="392431026" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define(
  "webui/widgets/common/Trace",
  [
    "dojo/io-query"
  ],
  function(
    ioQuery
  ) {

  // Trace is turned on by putting "?logging=info" and possibly "&logComponent=webui.widgets.common,..." in the
  // address bar. This is read once only, at module load time. To enable trace, reload
  // the page.
  var search = window.location.search.substr(document.location.search[0] === "?" ? 1 : 0);
  var urlParms = ioQuery.queryToObject(search);

  // Compute severity number
  var minSeverityNumber;
  switch ((urlParms.logging || "").toLowerCase()) {
    case "all":
      minSeverityNumber = 0;
      break;
    case "debug":
      minSeverityNumber = 3;
      break;
    case "info":
      minSeverityNumber = 7;
      break;
    case "warning":
    case "":
      minSeverityNumber = 8;
      break;
    case "error":
      minSeverityNumber = 9;
      break;
    default:
      console.error("Logging level " + urlParms.logging + " is invalid. Valid values: all | debug | info | warning | error");
      minSeverityNumber = 8;
      break;
  }

  // set log filter based on ?logComponent=a,b,c uri parameter
  var traceComponentFilter = urlParms.logComponent || "";
  var componentArray = traceComponentFilter.split(",");

  return {

    /**
     * Public list of trace levels for handing to the trace() method
     */
    levels : {
      // summary:
      // a hash of all the trace severities
      ENTRY : {
        name : "ENTRY",
        symbol : ">",
        level : 1
      },
      EXIT : {
        name : "EXIT",
        symbol : "<",
        level : 1
      },
      PUB : {
        name : "PUB",
        symbol : ":",
        level : 3
      },
      SUB : {
        name : "SUB",
        symbol : ":",
        level : 3
      },
      DEBUG : {
        name : "DEBUG",
        symbol : ":",
        level : 4
      },
      INFO : {
        name : "INFO",
        symbol : "I",
        level : 7
      },
      WARNING : {
        name : "WARNING",
        symbol : "W",
        level : 8
      },
      ERROR : {
        name : "ERROR",
        symbol : "E",
        level : 9
      }
    },

    // WIDGET_NAME_DISPLAY_LENGTH: int
    // The display width of the widget name in a trace line
    WIDGET_NAME_DISPLAY_LENGTH : 50,

    // SEVERITY_DISPLAY_LENGTH: int
    // The display width of the severity in a trace line.
    SEVERITY_DISPLAY_LENGTH : 7,

    // PADDING: String
    // a space padded string the length of the longest *_DISPLAY_LENGTH
    // setting. Used by ui.widgets.BaseWidget.trace function during formatting.
    PADDING : "                                                  ",

    /**
     * Traces the message and infoObject to the javascript console if the
     * severity is greater than or equal to the currently enabled trace level
     * for this widget.
     */
    trace : function(
      /* String */ declaredClass,
      /* element of ui.widgets.BaseWidget.tr.levels */ severity,
      /* String */ message,
      /* Object? */ infoObject
    ) {
      try {
        // Determine as QUICKLY AS POSSIBLE whether to trace or not.
        
        var severityNumber = severity.level;
        
        // default level in case severity is wrong
        if(!severityNumber) {
          console.error("Unknown severity for trace message:", message);
          console.trace();
          severityNumber = this.levels.WARNING.level;
        }

        // minSeverityNumber should now be the trace level for this widget
        // so enable trace if the requested level is at least the minimum
        if(severityNumber < minSeverityNumber) {
          return;
        }

        // Has a whitelist of components been specified?
        if (
          traceComponentFilter.length > 0 &&
          !componentArray.some(function(component) {
            return (declaredClass || "").substring(0, component.length) == component;
          })
        ) {
          // No components in whitelist, do not trace
          return;
        }
        
        // Trace!

        if (!declaredClass) {
          console.error(" No widget name specified for trace : " + severity + " : " + message);
          console.trace();
          declaredClass = "";
        }

        // build up the trace string

        // pad out to 30chars, or trim to right most 30chars
        // 123456789012345678901234567890=30spaces
        var paddedWidgetName = String(declaredClass);
        if (paddedWidgetName.length < this.WIDGET_NAME_DISPLAY_LENGTH) {
          paddedWidgetName += this.PADDING.substring(0, this.WIDGET_NAME_DISPLAY_LENGTH - paddedWidgetName.length);
        } else if (paddedWidgetName.length > this.WIDGET_NAME_DISPLAY_LENGTH) {
          paddedWidgetName = paddedWidgetName.substring(paddedWidgetName.length - this.WIDGET_NAME_DISPLAY_LENGTH, paddedWidgetName.length);
        }

        // make severity always be the badded to the right length
        var severityString = severity.name + this.PADDING.substring(0, this.SEVERITY_DISPLAY_LENGTH - severity.name.length);

        // the string to be shown
        var timestamp = new Date().toISOString();

        var traceString = timestamp + " " + paddedWidgetName + " " + severityString + " " + severity.symbol + " " + message + " ";

        if (severityNumber < this.levels.INFO.level) {
          console.debug(traceString, infoObject);
        } else if (severityNumber == this.levels.DEBUG.level) {
          console.log(traceString, infoObject);
        } else if (severityNumber == this.levels.INFO.level) {
          console.info(traceString, infoObject);
        } else if (severityNumber == this.levels.WARNING.level) {
          console.warn(traceString, infoObject);
        } else {
          console.error(traceString, infoObject);
        }

      } catch (e) {
        console.error("ERROR while tracing", e, [ severity, message, infoObject ]);
      }
    }

  };

});

},
'webui/widgets/common/D3FlowDiagram':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63" 
 * years="2013, 2015" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63 
 *  
 * (C) Copyright IBM Corp. 2013, 2015 All Rights Reserved.  
 * </copyright> 
 *
 * 
 * Flow Diagram widget - displays the flow diagram profile as a visual graph representation.
 * 
 */
define(
  [
    "dojo/i18n!webui/nls/web",
    "dijit/_WidgetBase",
    "dojo/_base/array",
    "dojo/_base/declare",
    "dojo/_base/lang",
    "dojo/dom",
    "dojo/dom-attr",
    "dojo/dom-class",
    "dojo/dom-construct",
    "dojo/dom-style",
    "dojo/string",
    "webui/config/Resources",
		"webui/widgets/common/Trace",
		"d3js"        
	],
	function(
    NLS,
    _WidgetBase,
    array,
    declare,
    lang,
    dom,
    domAttr,
    domClass,
    domConstruct,
    domStyle,
    string,
    Resources,
    Trace
  ) {
 
    return declare("webui.widgets.common.D3FlowDiagram", [_WidgetBase], {

  		widgetContainer: null,
  		flowProfileWidget: null,
  		nodeIconPath: "/webui/widgets/common/images/flowDiagram/icons/node/",
  		terminalIconPath: "/webui/widgets/common/images/flowDiagram/icons/terminal/",
  		flowProfileId: "messageFlowDiagram",
  		mqOutputNodeType: "ComIbmMQOutputNode",
  		mqReplyNodeType: "ComIbmMQReply",
  		messageFlowURI: null,
  		// Default sizes
  		_height: 500, 
  		_width: 800,
  		_flowType: null,
  		_marginWidth: 60,
  		
  		constructor: function(args){
  	    if(args != null) {
  	      this._height = args.height;
  	      this._width = args.width;
  	      this._flowType = args.flowType;
  	    }
  	  },
  
  		postCreate : function() {
  			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
  			
  			Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
  		},
  		
  
  		place: function(target, flowDesignData, messageFlowURI){
  			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "initWidget");
  			
  			this.widgetContainer = target;
  			this.messageFlowURI = messageFlowURI;
  
  			// Merge the static definition of the flow view with the dynamic data from the runtime.
  			var flowDesign = this.processDynamicFlowDesignData(flowDesignData);
              
  			// Generate the flow profile diagram
  			this.flowProfileWidget = this.readyFlowProfile(flowDesign);
  
  			Trace.trace(this.declaredClass, Trace.levels.EXIT, "initWidget");
  		},

      processDynamicFlowDesignData: function(flowDesignData) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "processDynamicFlowDesignData");

        // A list of the nodes in the flow design. Each node has a name and type value. The index in the array relates to the id of the node in the connection details.
        var nodes = [];
        
        // A list of connections between nodes.  Each element is itself a 4 value json element array ("source","target","sourceTerminal","targetTerminal")
        var nodeConnections = [];
        
        // Track the most times a label breaks onto a new line
        var maxCarriageReturnCount = 0;
        
        // Create a list of the names and types of the nodes from the runtime from the REST response.
        flowDesignData.nodes.forEach( lang.hitch(this, function(node, i) {
          var LABEL_MARGIN = 10;
          var LABEL_HARDMAX= 20;
          
          var lastCarriageReturn = 0;  // Number of chars since we broke the line.            
          var lineWrappedNodeName = "";

          var localNodeName = node.name;
          
          var carriageReturnCount = 0;
          
          if (localNodeName.indexOf("InTerminal.", 0) === 0){
            localNodeName = localNodeName.substring(11);
      	  }
      	  else if (localNodeName.indexOf("OutTerminal.", 0) === 0){
      		  localNodeName = localNodeName.substring(12);
      	  }
      		
          
          for (var charIndex = 0; charIndex < localNodeName.length; charIndex++) {
            var charact = localNodeName.charAt(charIndex);

            carriageReturnCount++;
            
            if (lastCarriageReturn < LABEL_MARGIN) {
              lineWrappedNodeName = lineWrappedNodeName + charact;
              lastCarriageReturn++;
              carriageReturnCount--;
            } else {
              // Try and line wrap.
              if (charact == " ") {
                // Split on ' ' but don't add the space to the new line.
                lineWrappedNodeName = lineWrappedNodeName + "\n";
                lastCarriageReturn = 0;
              } else if (charact == "_") {
                // Split on '_'
                lineWrappedNodeName = lineWrappedNodeName + "\n_";
                lastCarriageReturn = 1;
              } else if (charact == "/") {
                // Split on '/'
                lineWrappedNodeName = lineWrappedNodeName + "\n/";
                lastCarriageReturn = 1;
              } else if (charact == "\\") {
                // Split on '\'
                lineWrappedNodeName = lineWrappedNodeName + "\n\\";
                lastCarriageReturn = 1;
              } else if (charact == ".") {
                // Split on '.'
                lineWrappedNodeName = lineWrappedNodeName + "\n.";
                lastCarriageReturn = 1;
              } else if (lastCarriageReturn >= LABEL_HARDMAX) {
                // Hard stop - force a newline
                lineWrappedNodeName = lineWrappedNodeName + "\n"+charact;
                lastCarriageReturn = 1;
              } else {
                // Carry on adding to the line
                lineWrappedNodeName = lineWrappedNodeName + charact;
                lastCarriageReturn++;
                carriageReturnCount--;
              }
            }                             
          }
          
          if(carriageReturnCount > maxCarriageReturnCount) {
          	maxCarriageReturnCount = carriageReturnCount;
          }

          nodes.push({"name" : localNodeName, "labelName" : lineWrappedNodeName, "type" : node.type, "policy" : {}, nodeProperties : node.nodeProperties, "idValue": i});            
        }));

        // Associate the array indexes of the nodes in the nodename list with the connections list.  Our D3 widget uses
        // numeric data, so any string data (names, types) is pushed off to another place and referred to by index.
        // However, we need to pull together the node names with the connections between them.    
        flowDesignData.nodeConnections.forEach( function(nodecon) {
          // For a given connection we need to push out a 4 element array
          //   (src_node, src_terminal, targ_node, targ_terminal)
          // Each node and terminal is a numeric index.
          var sourceNodeIndex = -1;
          var targetNodeIndex = -1;
          
          // NOTE: For now, terminals are unused, so we'll ignore them. (data will be zero)
          flowDesignData.nodes.forEach( function(node, nodeindex) {
            // Find the index
            if (node.name === nodecon.sourceNode) {
              // Great - found the source index.
              sourceNodeIndex = nodeindex;
            }
            if (node.name === nodecon.targetNode) {
              // Great - found the target index.
              targetNodeIndex = nodeindex;
            }
          });

          // Found the connection?  If so, put it in the list.
          if (sourceNodeIndex != -1 && targetNodeIndex != -1) {
          	nodeConnections.push({"source": sourceNodeIndex, "target": targetNodeIndex, "sourceTerminal": nodecon.sourceTerminal, "targetTerminal": nodecon.targetTerminal});
          }
        });
        
        var outputData = {"nodes" : nodes, "nodeConnections" : nodeConnections};

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "processDynamicFlowDesignData");
        return outputData;
      },
        
      readyFlowProfile: function(flowDesign) {
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "readyFlowProfile");

      	// Update starting width value - should only get generated when the container is visible
      	this._width = this.getContainerWidth(this._marginWidth) - this._marginWidth;
      	
        /*** For zooming and panning - start	***/
        var width = this._width;
        var height = this._height;
  
        // Define the margin boundaries
        var margin = {top: 2, right: 5, bottom: 5, left: 20};
        var widthMargin = width - margin.left - margin.right;
        var heightMargin = height - margin.top - margin.bottom;
  
          
        function zoomed() {
         	container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
          slider.property("value",  d3.event.scale);
        }
  
        function dragstarted() {
          d3.event.sourceEvent.stopPropagation();
          d3.select(this).classed("dragging", true);
        }
  
        function dragged(d) {
          d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
        }
  
        function dragended() {
          d3.select(this).classed("dragging", false);
        }
  
        function slided(){
          zoom.scale(d3.select(this).property("value")).event(svg);
        }
  
        var zoom = d3.behavior.zoom()
          .scaleExtent([0.1, 2])
          .on("zoom", zoomed);
  
        d3.behavior.drag()
          .origin(function(d) { return d; })
          .on("dragstart", dragstarted)
          .on("drag", dragged)
          .on("dragend", dragended);
          
        var sliderContainer = d3.select("#"+this.widgetContainer).append("p");
        
        sliderContainer.append("label")
          .attr("for", "zoomSlider")
          .attr("class", "flowDiagramSlider")
          .text(NLS.flowSlideLabel);
      
        // add zoom slider
        var slider = sliderContainer.append("input")
          	.datum({})
          	.attr("id", "zoomSlider")
          	.attr("type", "range")
          	.attr("value", 1) 
            .attr("min", zoom.scaleExtent()[0])
            .attr("max", zoom.scaleExtent()[1])
            .attr("step", (zoom.scaleExtent()[1] - zoom.scaleExtent()[0]) / 50)
            .on("change", slided)
            .append("use")
              .attr("width", "100%")
              .attr("height", "100%");
 
      
  
        // Create the svg template on the body element
        var svg = d3.select("#"+this.widgetContainer).append("svg")
          .attr("id", this.flowProfileId)
          .attr("width", width)
          .attr("height", height)
          .attr("class", "svg_flowDiagram")			
          .append("g")
          .attr("transform", "translate(" + margin.left + "," + margin.right + ")")
          .call(zoom);
                
        // diagram can be 5 times actual visible diagram size
        svg.append("rect")
        .attr("width", width*5)
        .attr("height", height*5)
        .style("fill", "none")
        .style("pointer-events", "all");
      
        var container = svg.append("g");
        
        /*** For zooming and panning - end ***/  
        
        // Create the flow object template
        var flowProfileWidget = this.newFlowProfileWidget()
            .nodeWidth(32)
            .nodeLength(32)
            .nodePadding(32)
            .linkCurvature(0.2)
            .diagramSize([widthMargin, heightMargin])
            .margins([margin.left, margin.top]); 

        // Set the links between nodes
        var path = flowProfileWidget.link();

        // Define the nodes and links from the parsed json data
        flowProfileWidget
        	.nodes(flowDesign.nodes)
            .links(flowDesign.nodeConnections)
            .layout();

        var tempSizes = flowProfileWidget.diagramSize();
        
        // Check it we need to update the sizings originally set to adapt to size of the flow
        if(widthMargin != tempSizes[0]) {
        	widthMargin = tempSizes[0];
        	width = widthMargin + margin.left + margin.right;
        	svg.attr("width", width);
        }
        
        if(heightMargin != tempSizes[1]) {
        	heightMargin = tempSizes[1];
        	height = heightMargin + margin.top + margin.bottom;
        	svg.attr("height", height);
        }
        
        // Set the starting size for the svg container of the diagram, to enable dynamic resizing
        flowProfileWidget.svgStartContainerSize([width,height]);
        
        // Define arrow markers for graph links.
        var defs = svg.append("defs");
        
        // Add image decorators
        this.addImageDefinitions(defs);
        
        defs.append("marker")
          .attr("id", "linkArrow")
          .attr("viewBox", "0 -5 10 10")
          .attr("markerWidth", flowProfileWidget.terminalWidth() / 2)
          .attr("markerHeight", flowProfileWidget.terminalLength())
          .attr("orient", "auto")
        .append("svg:path")
          .attr("d", "M0,-5L10,0L0,5")
          .attr("class", "link-arrow");

        // Set the links between nodes as paths that can be styled.
        var link = 
        	container  
            .append("g").selectAll(".link")
            	.data(flowDesign.nodeConnections)
            .enter().append("path")
            	.attr("class", "link")
            	.style("marker-end", "url(#linkArrow)")
            	.attr("d", path)
            	.sort(function(a, b) { return b.dy - a.dy; });

        // Set the title on the node, with information detailing the link from and to.
        link.append("title")
            	.text(function(d) { return d.source.name + " -> " + d.target.name ; });

        // Set the individual nodes
        var node = 
        	container.append("g")
 /*           .attr("id", "nodesElement")*/
            .selectAll(".node")
            	.data(flowDesign.nodes)
            // Add the g element to contain the node, and move the node (translate) to the relevant position.
            .enter().append("g")
            	.attr("class", "node")
            	.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
            // Call the drag behaviour function, when you move the node, will move the link accordingly from the parent, and its children.
            .call(d3.behavior.drag()
            	.origin(function(d) { return d; })
            	//.on("dragstart", function() { /*this.parentNode.appendChild(this); */})
            	// Dragmove function determines the drag behaviour of a selected and dragged node, moving the node and related paths to connected nodes.
              .on("drag", function(d) {
              	var offset = 0;
              	// If an unattached node, ensure if is only allowed to moved within the bounds of the profile viewer.
              	if((d.sourceLinks.length == 0) && (d.targetLinks.length == 0)) {
              		offset = flowProfileWidget.nodeLength();
              	}
              	
              	// Get the node and boundary values of the svg before we update the node position
                var yBefore = lang.clone(d.y);
              	
                // Ensure that the drag movement only allows the node to be moved between the flow profile boundaries.
              	d.y = Math.max(0 + offset, Math.min(height - d.dy - offset, d3.event.y));
              	d3.select(this).attr("transform", "translate(" + d.x + "," + d.y + ")");
              	
              	// Recalculates all the link depths after the drag action
              	flowProfileWidget.reCalculateLinks(d);
              	
              	// After link positions have been updated, the d (path position) is updated and applied to the updated graph representation
              	link.attr("d", path);
              	
              	// Now check whether the svg can be resized to maximise space efficiency
                var yChange = d.y - yBefore;
                d.absoluteY += yChange;
              	
                // Also if there is a eventTooltip dialog being shown then update the position here (and only if the dialog is attached to the node in question). 
  	          	if((typeof flowProfileWidget.eventTooltipId !== "undefined") && 
  	          			(!domClass.contains(flowProfileWidget.eventTooltipId, "event_tooltip_hidden")) &&
  	          				(domAttr.get(flowProfileWidget.eventTooltipId, "data-node-id") === d.name)) {
        	          	  // Get the x and y bounds that will be reference for the tooltip                 
        	          	  var divBounds = this.ownerSVGElement.parentNode.getBoundingClientRect();
                        var yOffset = Math.max((flowProfileWidget.margins()[0]/2),((divBounds.width - flowProfileWidget.diagramSize()[0])/ 2) - flowProfileWidget.margins()[0]);
                        
                        var x = d.absoluteX + yOffset + (flowProfileWidget.nodeWidth() * (3/4));
                        var y = d.absoluteY + flowProfileWidget.margins()[1] - (flowProfileWidget.nodeEventIconWidth() * (7/8));
                        
        	          		flowProfileWidget.eventTooltip.updatePosition(x, y);
  	          	}
              }))
              .on("mousedown", function(d) {
                // If there is a tooltip being shown, and it is the tooltip for this node that has been clicked upon, then consume event and don't close the tooltip
                if((typeof flowProfileWidget.eventTooltipId !== "undefined") && 
                    (!domClass.contains(flowProfileWidget.eventTooltipId, "event_tooltip_hidden")) &&
                      (domAttr.get(flowProfileWidget.eventTooltipId, "data-node-id") === d.name)) {
                  if (d3.event) {
                    d3.event.stopPropagation();
                  }
                }
              });

        // Create an image/icon for the node based on the node type.
        node.append("image")
        	.attr("id", lang.hitch(this, function(d) {
            return "nodeIcon_" + d.idValue;
          }))
        	// Force the node to be in the centre of the space that it occupies
        	.attr("y", function(d) { return (d.dy / 2) - (flowProfileWidget.nodeLength() / 2); })
        	.attr("height", flowProfileWidget.nodeLength())
        	.attr("width", flowProfileWidget.nodeWidth())
        	.attr("class", "node-image")
        	.attr("xlink:href", lang.hitch(this, function(d) {
        	  var type = d.type;
        	  // Check to if the node type is MQReply
        	  if((type === this.mqReplyNodeType)) {
        	    return this.nodeIconPath + "ComIbmMQReplyNode.png";
        	  }
        	  return this.nodeIconPath + d.type + ".png";
      	  }))
      	  .append("title")
      	  .text(function(d) {
      	    // use the type of the node from the REST call as the NLS key for a translatable
      	    // name for the node type
      	    // e.g. instead of ComIbmMQInputNode show MQInput
      	    var nlsType = d.type;
      	    if (d.type.indexOf("/") >= 0){
      	      // replace all occurrences of '/' with '_'
      	      nlsType = d.type.split('/').join('_');
      	    }
      	    var type = NLS.nodeType[nlsType];
      	    if (type) {
      	      return string.substitute(NLS.nodeTooltip, [type]);
      	    }
              		
      	    // if it is a subflow node, show subflow file name in node tooltip
      	    var subflowFileName = "";
      	    if (d.type === "SubFlowNode"){
      	      var properties = d.nodeProperties;
      	      properties.forEach(function(p) {
      	        if (p.name === 'subflowImplFile'){
      	          subflowFileName = p.value + "\n\n";
      	        }
      	      });
      	    }
      	    // not found in the nls file, show the raw type
      	    return subflowFileName + string.substitute(NLS.nodeTooltip, [d.type]);
      	  });

        // Iterate around the initially placed nodes and their node icons, to establish the absolute position of the node in reference to the parent svg
        node.each(lang.hitch(this, function(d) { 
          d.absoluteX = d.x + Number(d3.select("#nodeIcon_" + d.idValue).attr("x"));
          d.absoluteY = d.y + Number(d3.select("#nodeIcon_" + d.idValue).attr("y"));
        }));
        
        flowProfileWidget.terminalIconPath = this.terminalIconPath;

        // Create the target/in terminals (this should just be one for each node, apart from input nodes).
        node.append("g")
        	.filter(function(d) { return d.targetLinks.length > 0; })
        	.each(function() {
        	  // Only add an in terminal if it has an in terminal - there should only be one
        	  d3.select(this).append("image")
        	  // Force the terminal to be in the centre of the space that it occupies so that it aligns with the connecting link
        	  .attr("y", function(d) { return (d.dy / 2) - (flowProfileWidget.terminalLength()/2); })
        	  .attr("x", -flowProfileWidget.terminalWidth())
        	  .attr("height", flowProfileWidget.terminalLength())
        	  .attr("width", flowProfileWidget.terminalWidth())
        	  .attr("xlink:href", flowProfileWidget.terminalIconPath + "in.png")
        	  .append("title")
        	  .text(NLS.btFlowEventIn);
          });

        // Create the source/out terminals (defined by the outTerminals information).
        node.append("g")
        	.filter(function(d) { return d.outTerminals.length > 0; })
        	.each(function(d) {
        	  var g = d3.select(this);
        	  // If we have more than 4 out terminals on the node, then we need to make the icon a multiple icon
        	  if(d.outTerminals.length > 4) {
        	    g.append("image")
        	    // Force the terminal to be in the centre of the node on y axis so that it aligns with the connecting link
        	    .attr("y" , function(d) { return (d.dy / 2) - flowProfileWidget.terminalLength(); })
        	    .attr("x", flowProfileWidget.nodeWidth() - (flowProfileWidget.terminalWidth() / 2))
        	    .attr("height", flowProfileWidget.terminalLength() * 2)
        	    .attr("width", flowProfileWidget.terminalWidth() * 2)
        	    .attr("xlink:href", flowProfileWidget.terminalIconPath + "multiple.png");
        	  } else {
        	    // Else iterate around the terminals and set the appropriate terminal icon and positioning for each
        	    d.outTerminals.forEach( function(terminal) {
        	      g.append("image")
        	      // Added to force the node to be in the centre of the space that it occupies so that it aligns with the connecting link
        	      .attr("y",  function(d) { 
        	        return (d.dy / 2) - (flowProfileWidget.nodeLength() / 2) - (flowProfileWidget.terminalLength() / 2) + terminal.y;
        	      })
        	      .attr("x", flowProfileWidget.nodeWidth())
        	      .attr("height", flowProfileWidget.terminalLength())
        	      .attr("width", flowProfileWidget.terminalWidth())
        	      .attr("xlink:href", flowProfileWidget.terminalIconPath + terminal.type + ".png")
        	      .append("title")
        	      // Render the "breaked" name back into its original state.
        	      .text(terminal.name);
        	    });
        	  }
        	});

        // So that we attempt to elequently wrap long text labels on the node,
        // we should add a new text object per new line (as already separated earlier).
        node.append("svg")
        	.each( function(d) {

        		// Get an array of lines split by newline delimeter.
        		var lines = d.labelName.split("\n");
        		
              var svg = d3.select(this)
              			.attr("overflow", "visible")
                		.attr("y", function(d) { return (d.dy / 2) + (flowProfileWidget.nodeLength() / 1.75); })
                		.attr("width", flowProfileWidget.nodeWidth() + (1.5 * flowProfileWidget.nodePadding()))
                		.attr("height", lines.length + (lines.length * (flowProfileWidget.nodeLength() / 4)));
              
              var ySpacing = (flowProfileWidget.nodeLength() / 3) + 1;
              
              // Add the text element to enclose the text lines
              var text = svg.append("text")
              			.attr("y", 10)
              			.attr("class", "node-text");
              
              lines.forEach( function(line,j) {
              	// Sets the text displayed on the node
              	text.append("tspan")
      	        	.attr("x", flowProfileWidget.nodeWidth() / 2)
      	        	.attr("y", ySpacing * (j + 1))
                    	.text(line);
              	});
              });

        // Add the now rendered node data to the flow profile
        flowProfileWidget.profileNodes(node);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "readyFlowProfile");
        
        return flowProfileWidget;
      },
        
      newFlowProfileWidget: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "newFlowProfileWidget");
      	
    	  var flowProfileWidget = {},
    	      nodeWidth = 32,
    	      nodeLength = 32,
    	      nodePadding = 32,
    	      terminalWidth = nodeWidth / 4,
    	      terminalLength = nodeLength / 5,
    	      nodeEventIconWidth = 16,
    	      nodeEventIconLength = 16,
    	      diagramSize = [1, 1],
    	      margins = [1,1],
    	      nodes = [],
    	      links = [],
    	      linkCurvature = 0.5,
    	      // D3 node representation
    	      profileNodes = [],
    	      eventTooltip,
    	      svgStartContainerSize = [1, 1];

    	  // Force the terminal width to be a related to the node width
    	  flowProfileWidget.nodeWidth = function(_) {
    	    if (!arguments.length) {
    	      return nodeWidth;
    	    }
    	    nodeWidth = +_;
    	    flowProfileWidget.terminalWidth(_/4);
    	    flowProfileWidget.nodeEventIconWidth(_/(32/16));
    	    return flowProfileWidget;
    	  };

    	  // Force the terminal length to be a related to the node width
    	  flowProfileWidget.nodeLength = function(_) {
    	    if (!arguments.length) {
    	      return nodeLength;
    	    }
    	    nodeLength = +_;
    	    flowProfileWidget.terminalLength(_/5);
    	    flowProfileWidget.nodeEventIconLength(_/(32/16));
    	    return flowProfileWidget;
    	  };

    	  flowProfileWidget.nodePadding = function(_) {
    	    if (!arguments.length) {
    	      return nodePadding;
    	    }
    	    nodePadding = +_;
    	    return flowProfileWidget;
    	  };

    	  flowProfileWidget.terminalWidth = function(_) {
    	    if (!arguments.length) {
    	      return terminalWidth;
    	    }
    	    terminalWidth = +_;
    	    return flowProfileWidget;
    	  };

    	  flowProfileWidget.terminalLength = function(_) {
    	    if (!arguments.length) {
    	      return terminalLength;
    	    }
    	    terminalLength = +_;
    	    return flowProfileWidget;
    	  };

    	  flowProfileWidget.nodeEventIconWidth = function(_) {
      		if (!arguments.length) {
      		  return nodeEventIconWidth;
      		}
      		nodeEventIconWidth = +_;
    	    return flowProfileWidget;  
    	  };
    	  
    	  flowProfileWidget.nodeEventIconLength = function(_) {
      		if (!arguments.length) {
      		  return nodeEventIconLength;
      		}
      		nodeEventIconLength = +_;
    	    return flowProfileWidget;  
    	  };

    	  flowProfileWidget.nodes = function(_) {
    	    if (!arguments.length) {
    	      return nodes;
    	    }
    	    nodes = _;
    	    return flowProfileWidget;
    	  };

    	  flowProfileWidget.links = function(_) {
    	    if (!arguments.length) {
    	      return links;
    	    }
    	    links = _;
    	    return flowProfileWidget;
    	  };

    	  flowProfileWidget.diagramSize = function(_) {
    	    if (!arguments.length) {
    	      return diagramSize;
    	    }
    	    diagramSize = _;
    	    return flowProfileWidget;
    	  };
    	  
    	  // Top, Left
    	  flowProfileWidget.margins = function(_) {
          if (!arguments.length) {
            return margins;
          }
          margins = _;
          return flowProfileWidget;
        };

    	  flowProfileWidget.linkCurvature = function(_) {
    	    if (!arguments.length) {
    	      return linkCurvature;
    	    }
    	    linkCurvature = _;
    	    return flowProfileWidget;
    	  };
    	  
    	  flowProfileWidget.profileNodes = function(_) {
    	    if (!arguments.length) {
    	      return profileNodes;
    	    }
    	    profileNodes = _;
    	    return flowProfileWidget;
    	  };
    	  
    	  flowProfileWidget.eventTooltip = function(_) {
    	    if (!arguments.length) {
    	      return eventTooltip;
    	    }
    	    eventTooltip = _;
    	    return eventTooltip;
    	  };
    	  
    	  flowProfileWidget.svgStartContainerSize = function(_) {
    	    if(!arguments.length) {
    	      return svgStartContainerSize;
    	    }
    	    svgStartContainerSize = _;
    	  };

    	  // Create the layout for the flow profile
    	  flowProfileWidget.layout = function() {
    	    formNodeLinks();
    	    setNodeBreadths();
    	    setNodeDepths();
    	    setLinkDepths();
    	    return flowProfileWidget;
    	  };

    	  // Call to recalculate the link depths between nodes, called when a drag action is performed on one of the nodes.
    	  flowProfileWidget.reCalculateLinks = function(node) {
    	    updateNodeLinks(node);
    	    return flowProfileWidget;
    	  };

    	  // Returns the path element style values to denote the curvature and edges of the path. Applied to every link.
    	  flowProfileWidget.link = function() {

    	    function link(d) {
    	      var x0 = d.source.x + d.source.dx + terminalWidth - 1,
    	          x1 = d.target.x - (2 * terminalWidth),
    	          xi = d3.interpolateNumber(x0, x1),
    	          x2 = xi(linkCurvature),
    	          x3 = xi(1 - linkCurvature),
    	          yTerminal = getTerminalPos(d),
    	          // The source Y position of the link is the source node Y position plus half the Y size of the source node
    	          y0 = d.source.y + (d.source.dy / 2) - (nodeLength / 2) + yTerminal,
    	          // The target Y position of the link is the target node Y position plus half the Y size of the target node
    	          y1 = d.target.y + (d.target.dy / 2);
    	          
        	      // Return: M x0 = start position of curve on x axis.
        	      // y0 = start position of curve on y axis.
        	      // C x2 = The curvature value of where the curve starts on the x axis.
        	      // y0 = In a similar manner, the curvature value of where the curve starts on the y axis.
        	      // x3 = The centre (bend) of the curve on the x axis.
        	      // y1 = The centre (bend) of the curve on the y axis.
        	      // x1 = end position of the curve on x axis.
        	      // y1 = end position of the curve on y axis.
        	      return "M" + x0 + "," + y0 +
        	           "C" + x2 + "," + y0 +
        	           " " + x3 + "," + y1 +
        	           " " + x1 + "," + y1;
    	    }

    	    // Applies an adjustment based on the source terminal that it is connecting to (moves the y start point accordingly)
    	    function getTerminalPos(link) {
    	      var sourceTerminal = link.sourceTerminal;
    	      var outTerminals = link.source.outTerminals;
    	      
    	      // The number of different terminals that can be made visible on a single node otherwise have a multiple visual.
    	      var threshold = 4;
    	      // Spacing between each terminal, as a factor of the terminal length
    	      var yTerminalSpacing = terminalLength / 6;
    	      // The terminal position with respect to the other terminals.
    	      var pos = 0;

    	      // This should always be true, in that the source node for the link should have at least terminal to facilitate the link.
    	      if(outTerminals.length > 0) {
    	        // If we have exceeded the threshold for the number of individual terminals on a node
    	        // Then we know we are using a multiple style icon, position will be central to node.
    	        if(outTerminals.length > threshold) {
    	          return nodeLength / 2;
    	        } 
    	        // Else we need to accurately calculate the y position of the terminal, taking into consideration how many terminals will be on that node.
    	        else {
    	          var found = false,
    	              i = 0;
    	          while(!found && (i<outTerminals.length)) {
    	            // First find the terminal that we are calculating
    	            if(outTerminals[i].name === sourceTerminal) {
    	              pos = i;
    	              found = true;
    	            }
    	            i++;
    	          }
    	 
    	          // If the y value of the terminal for the source node hasn't already been set,
    	          // then set it according to the number of terminals (and set all the other terminals at the same time.
    	          if(typeof link.source.outTerminals[pos].y === "undefined") {
    	            // Depending on the make up of the set all the y positions, relative to the number of terminals on the node.
    	            switch(outTerminals.length) {
    	            case 1:
    	              // Only a single terminal, set it to be the middle of the node
    	              link.source.outTerminals[0].y = (nodeLength / 2);
    	              break;
    	            case 2:
    	              // Two terminals, have them separated from the middle of equal space
    	              link.source.outTerminals[0].y = (nodeLength / 2) - ((yTerminalSpacing + terminalLength) / 2);
    	              link.source.outTerminals[1].y = (nodeLength / 2) + ((yTerminalSpacing + terminalLength) / 2);
    	              break;
    	            case 3:
    	              // Three terminals, have them separated from the middle of equal space, with the middle one in the centre
    	              link.source.outTerminals[0].y = (nodeLength / 2) - (terminalLength + yTerminalSpacing);
    	              link.source.outTerminals[1].y = (nodeLength / 2);
    	              link.source.outTerminals[2].y = (nodeLength / 2) + (terminalLength  + yTerminalSpacing);
    	              break;
    	            case 4:
    	              // Four terminals, have them separated from the middle of equal space
    	              link.source.outTerminals[0].y = (nodeLength / 2) - ((yTerminalSpacing + terminalLength) * (3 / 2));
    	              link.source.outTerminals[1].y = (nodeLength / 2) - ((yTerminalSpacing + terminalLength) / 2);
    	              link.source.outTerminals[2].y = (nodeLength / 2) + ((yTerminalSpacing + terminalLength) / 2);
    	              link.source.outTerminals[3].y = (nodeLength / 2) + ((yTerminalSpacing + terminalLength) * (3 / 2));
    	              break;
    	            }  
    	          }
    	          // Else it has been set then just return the y value for the link
    	          return link.source.outTerminals[pos].y;
    	        }
    	      }
    	      // In case we suffer from no out terminals being found, match at the middle of the node
    	      return nodeLength / 2;
    	    }
    	    
    	    return link;
    	  };

    	  // Populate the source and target of all links for each node.
    	  // Also, if the source and target are not objects, assume they are indices.
    	  function formNodeLinks() {
    	    // Populate the node source and target links on a per node basis
    	    nodes.forEach(function(node) {
    	      node.sourceLinks = [];
    	      node.targetLinks = [];
    	      node.outTerminals = [];
    	    });

    	    // Populate the link configuration for each link, defining the source and target and the terminals that are also stored on each node.
    	    links.forEach(function(link) {
    	      var source = link.source,
    	          target = link.target,
    	          sourceTerminal = link.sourceTerminal;
    	      if (typeof source === "number") { source = link.source = nodes[link.source]; }
    	      if (typeof target === "number") { target = link.target = nodes[link.target]; }
    	      
    	      // Now add the terminals if not already added.
    	      if(link.source.outTerminals && 
    	         ((link.source.outTerminals.length == 0) ||
    	            !terminalExists(link.source.outTerminals,sourceTerminal))) {
    	              // If not found then add as new terminal
    	              var newTerminal = { "name": sourceTerminal, "type": "out" };
    	              // At the moment we only distinguish between out and fail.
    	              if(sourceTerminal === "failure") {
    	                newTerminal.type = "failure";
    	                // Make fail terminals the first in the list
    	                link.source.outTerminals.unshift(newTerminal);
    	              } else {
    	                link.source.outTerminals.push(newTerminal);
    	              }
    	      }
    	      source.sourceLinks.push(link);
    	      target.targetLinks.push(link);
    	    });
    	    
    	    // Standardise the node values, such that they are all the same, but used to aid resolving node collision and positioning.
    	    nodes.forEach(function(node) {
    	      node.value = Math.max(
    	        node.sourceLinks.length,
    	        node.targetLinks.length
    	      );
    	    });
    	  }

    	  // Checks whether the next terminal already exists in array of terminals
    	  function terminalExists(existingTerminals, terminal) {
    	    var i = 0;
    	    while(i<existingTerminals.length) {
    	      if(existingTerminals[i].name === terminal) {
    	        return true;
    	      }
    	      i++;
    	    }
    	    return false;
    	  }

    	  // Iteratively assign the breadth (x-position) for each node.
    	  // Nodes are assigned the maximum breadth of incoming neighbors plus one; - So if has 3 for max incoming, breadth is 4.
    	  // So node will be placed one direction along the x axis past its parent.
    	  // Nodes with no incoming links are assigned breadth zero, while nodes with no outgoing links are assigned the maximum breadth.
    	  function setNodeBreadths() {
    	    
    		// Before arranging the nodes in best placed breadth positions, 
    		// need to ensure that the start nodes (Input) and end nodes (Output) are appropriately separated in the node list.
    		// The order of the node array can have a impact on how this rendering is performed.
    		var initialNodes = nodes;
    		var inputNodes = [];
    		var outputNodes = [];
    		var intermediateNodes = [];
    		
    		// Rules:
    		// Input - no targets, but has source links
    		// Output - no source, but has target links (or both no source, and no target (floating nodes)
    		// Intermediate - both source and target links
    		initialNodes.forEach(function(node) {
    			if(node.targetLinks.length == 0) {
    				if(node.sourceLinks.length == 0) {
    					outputNodes.push(node);
    				} else {
    					inputNodes.push(node);
    				}
    			} else {
    				if(node.sourceLinks.length == 0) {
    					outputNodes.push(node);
    				} else {
    					intermediateNodes.push(node);
    				}
    			}
    		});
    		
    		// Now arrange the node array into the correct order
    		var updatedArray = inputNodes.concat(intermediateNodes).concat(outputNodes);
    		  
    		nodes = updatedArray;
    		
    		var remainingNodes = nodes,
    	        nextNodes,
    	        // Ensures we have full visibility of diagram at the start rather than starting at x = 0.
    	        x = 0.125;

    		var addNodes = function(node, i) {
          node.x = x;
          node.dx = nodeWidth;
          node.sourceLinks.forEach(function(link) {
            // Only add it to the array if it hasn't been added already
            var index = array.indexOf(nextNodes, link.target);
            
            if((index < 0) && (typeof link.target.added === "undefined")) {
              nextNodes.push(link.target);
            }
          });
          // If this is the first node to be updated then track this
          if(i == 0) {
            node.added = true;
          }
        };

        while (remainingNodes.length) {
          nextNodes = [];
          remainingNodes.forEach(addNodes);
          remainingNodes = nextNodes;
          ++x;
	      }
    	    
    	    // Now that 

    	    // Ensure all unattached nodes, output, or end of flow nodes (with no source connections) reside at the end of the diagram
    	    moveNonSourceNodes(x);
    	    
    	    // Establish the longest connection length
    	    var nodesSortedByBreadth = d3.nest()
    	    	.key(function(d) { return d.x; })
    	    	.sortKeys(d3.ascending)
    	    	.entries(nodes)
    	    	.map(function(d) { return d.values; });

    	    var maxWidth = nodesSortedByBreadth.length;
    	    var maxHeight = d3.max(nodesSortedByBreadth, function(d) { return d.length;} );

    	    // Check whether we need to increase the width of the diagram, if so make the size of the offset
    	    var offset = diagramSize[0] - (maxWidth * (nodeWidth + (2 * nodePadding)));
    	    if(offset < 0) {
    	    	diagramSize[0] += (-offset);
    	    }
    	    
    	    offset = diagramSize[1] - (maxHeight * (nodeLength + (2 * nodePadding)));
    	    if(offset < 0) {
    	    	diagramSize[1] += (-offset);
    	    }
  	    
    	    scaleNodeXPositions((diagramSize[0] - nodeWidth) / (x - 1) * 0.9); // shorten the width between each node by 10%
    	  }

    	  // Move every node to the end of the diagram - so end, of flow or stand alone nodes.
    	  function moveNonSourceNodes(xMax) {
    	    nodes.forEach(function(node) {
    	      // Only move the node if it not a source for any link connection
    	      if (!node.sourceLinks.length) {
    	        node.x = xMax - 1;
    	      }
    	    });
    	  }

    	  // Scale all nodes x values by a factor of scaleX, by the known x values, so that spacings are all equals (vertical swim lanes) and fill the entire diagram area
    	  function scaleNodeXPositions(scaleX) {
    	    nodes.forEach(function(node) {
    	      node.x *= scaleX;
    	    });
    	  }

    	  function setNodeDepths() {
    	    // Nesting allows elements in an array to be grouped into a hierarchical tree structure think of it like the GROUP BY operator in SQL,
          // except you can have multiple levels of grouping, and the resulting output is a tree rather than a flat table. - forms a key access data structure.
          // So will have a key of the x value, nested by this value, so all nodes with the same x value are nested to the same level.
          // These are sorted into ascending order, so closest to x axis first.
          // Returned is a nested array, each element in the outer array is a key-values pair, listing the values for each distinct key.
          // The map returns the values object, so all the values for that distinct key.
    	    var nodesByXPos = d3.nest()
    	        .key(function(d) { return d.x; })
    	        .sortKeys(d3.ascending)
    	        .entries(nodes)
    	        .map(function(d) { return d.values; });

    	    // Initialises the node depths.
          // So retrieves the first set of values as nodes in the x array.
          // Sets yScaleFactor = (y value initially set of chart - (number of nodes less one * nodePadding that is set)) / the sum of the nodes value
          // In our case it is a constant related to the number of nodes in this x lane
    	    var yScaleFactor = d3.min(nodesByXPos, function(nodes) {
            return (diagramSize[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);
          });

          // We then apply this value as a multiplier of every node (grouped by x key) value to d value (which is the same for every node).
          // dx, dy denotes the transform values
    	    // This means that the nodes are appropriately placed in the Y position for that X swim-lane
          nodesByXPos.forEach(function(nodes) {
            nodes.forEach(function(node, i) {
              node.y = i;
              node.dy = node.value * yScaleFactor;
            });
          });

          resolveYNodeCollisions();
          
          var collisionFactor = 100;

    	    // Will continue to resolve collisions
    	    for (var count = 1; collisionFactor > 0; --collisionFactor) {
    	      adjustRTL(count *= 0.9925);
    	      resolveYNodeCollisions();
    	      adjustLTR(count);
    	      resolveYNodeCollisions();
    	    }
    	    
    	    checkYPositions();

    	    // Updates the every node's y value, based on the sum of y positions of all target nodes (wrt their individual centered y value dervied from the links)
    	    // divided by the number of target links. So the updated y value of the node is related to the y position of the target node(s).
    	    // The current y node is then increased in value by this calculated y value - the current center position of the node, and multiplied by the alpha coefficient.
    	    // Iterated multiple times this will slowly move the nodes into a "best effort" center position related to the source and target nodes (if any) they are attached to.
    	    function adjustLTR(multiplier) {
    	      nodesByXPos.forEach(function(nodes) {
    	        nodes.forEach(function(node) {
    	          if (node.targetLinks.length) {
    	            var y = d3.sum(node.targetLinks, centerSource) / node.targetLinks.length;
    	            node.y += (y - centerPos(node)) * multiplier;
    	          }
    	        });
    	      });

    	      function centerSource(link) {
    	        return centerPos(link.source);
    	      }
    	    }

    	    // As adjustLTR but working from the opposite end first
    	    function adjustRTL(multiplier) {
    	      // Create new reversed array to process nodes, most right X first
    	      nodesByXPos.slice(0).reverse().forEach(function(nodes) {
    	        nodes.forEach(function(node) {
    	          if (node.sourceLinks.length) {
    	            var y = d3.sum(node.sourceLinks, centerTarget) / node.sourceLinks.length;
    	            node.y += (y - centerPos(node)) * multiplier;
    	          }
    	        });
    	      });

    	      function centerTarget(link) {
    	        return centerPos(link.target);
    	      }
    	    }

    	    // Attempt to best resolve collisions between nodes on the graph and the paths that interconnect them
    	    function resolveYNodeCollisions() {
    	      nodesByXPos.forEach(function(nodes) {
    	        var node,
    	            dy,
    	            y0 = 0,
    	            nodeCount = nodes.length,
    	            i;

    	        // Push any overlapping nodes down.
    	        // Sort the nodes into ascending order by comparing the y values of the 2 nodes that are being compared.
    	        // These are all nodes of the same breadth.
    	        nodes.sort(ascendingDepthFunction);

    	        // For each node, aggregate the moving y value, and update the node y value to be spaced from the previous node.
    	        // Update the moving y value such that we set the y value of the next node such that it won't overlap and nodes are equally spaced in that x swimlane.
    	        for (i = 0; i < nodeCount; ++i) {
    	          node = nodes[i];
    	          dy = y0 - node.y;
    	          if (dy > 0) {
    	            node.y += dy;
    	          }
    	          y0 = node.y + node.dy + nodePadding;
    	        }

    	        // If the bottom-most node goes outside the bounds, push it back up, by re-adjusting Y values.
    	        // dy = the bottom bound (maximum y value).
    	        dy = y0 - nodePadding - diagramSize[1];
    	        if (dy > 0) {
    	          // Get the updated y aggregate value - the maximum
    	          y0 = node.y -= dy;

    	          // Push any nodes outside the flow boundary (so overflowing at the bottom).
    	          // So push all but the last node back up.
    	          // Doing the reverse steps as previously performed, attempting to resolve any overlapping nodes.
    	          for (i = nodeCount - 2; i >= 0; --i) {
    	            node = nodes[i];
    	            dy = node.y + node.dy + nodePadding - y0;
    	            if (dy > 0) {
    	              node.y -= dy;
    	            }
    	            y0 = node.y;
    	          }
    	        }
    	      });
    	    }

    	    // Sorting function to sort ascending on y values
    	    function ascendingDepthFunction(a, b) {
    	      return a.y - b.y;
    	    }
    	    
    	    // Ensure that all the Y positions of the nodes are within the confinds of the initial area.
    	    // If not then adjust and increase the height of the diagram.
    	    function checkYPositions() {     	    	
    	    	var minYValue = nodeLength / 2;
    	    	var maxYValue = diagramSize[1] - minYValue;
    	    	var adjustTop = -1;
    	    	var adjustBottom = -1;
    	    	var i = 0;

    	    	// For each node ensure that its y position is in the boundaries of the diagram, firstly at the top, then at the bottom.
    	    	// Only set the largest difference.
    	    	while(!((adjustTop > 0) && (adjustBottom > 0)) && (i < nodes.length)) {
    	    		if((nodes[i].y < minYValue) && ((minYValue - nodes[i].y) > adjustTop)) {
    	    			adjustTop = minYValue - nodes[i].y;
    	    		} else if((nodes[i].y > maxYValue) && ((nodes[i].y - maxYValue) > adjustBottom)) {
    	    			adjustBottom = nodes[i].y - maxYValue;
    	    		}
    	    		i++;
   	    	}

    	    	// If we need to adjust the top, then move all node down by a fixed minimum value and increase the bottom limit of the diagram
    	    	if(adjustTop > 0) {
    	    		nodes.forEach(function(node) {
    	    			node.y += adjustTop;
    	    		});
    	    		diagramSize[1] += adjustTop;
    	    	}

    	    	// If we need to adjust the bottom then increase the bottom limit of the diagram
    	    	if(adjustBottom > 0) {
    	    		diagramSize[1] += adjustBottom;
    	    	}
    	    }
    	  }

    	  // As for nodes, compute the positions of the links between the nodes
    	  // For each node, sort their source links and target links in an ascending order based on their y value.
    	  function setLinkDepths() {
    	    nodes.forEach(function(node) {
    	      node.sourceLinks.sort(ascendingTargetDepthFunction);
    	      node.targetLinks.sort(ascendingSourceDepthFunction);
    	    });
    	    // Then for each node, iterate around each source link, set the y value (beginning at y=0 for the first link) and add the y value of each link to a y aggegate
    	    // Which is then used to set the next link's y value.
    	    // Then do the same for target links
    	    // This will attempt to ensure the y values of all the links are equally spaced on the node, so if there is 3 source links, then they are spaced equally.
    	    nodes.forEach(function(node) {
    	      var sy = node.y + (node.dy / 2),
    	          ty = 0;
    	      node.sourceLinks.forEach(function(link) {
    	        link.sy = sy;
    	      });
    	      node.targetLinks.forEach(function(link) {
    	        link.ty = ty;
    	      });
    	    });

    	    function ascendingSourceDepthFunction(a, b) {
    	      return a.source.y - b.source.y;
    	    }

    	    function ascendingTargetDepthFunction(a, b) {
    	      return a.target.y - b.target.y;
    	    }
    	  }
    	  
    	  function updateNodeLinks(node){
    	    var sy = node.y + (node.dy / 2),
          ty = 0;
          node.sourceLinks.forEach(function(link) {
            link.sy = sy;
          });
          node.targetLinks.forEach(function(link) {
            link.ty = ty;
          });
    	  }

    	  // Return the center Y position of the node
    	  function centerPos(node) {
    	    return node.y + node.dy / 2;
    	  }

    	  // Return the value variable of the object
    	  function value(object) {
    	    return object.value;
    	  }
    	  
    	  Trace.trace(this.declaredClass, Trace.levels.EXIT, "newFlowProfileWidget");

    	  // Return the created flowProfileWidget object
    	  return flowProfileWidget;
    	},
    	
    addImageDefinitions: function(defs) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "addImageDefinitions");
      
      // Add image definitions for rendering background images on the flow diagram
      switch(this._flowType) {
        case Resources.flowDiagram.businessTransaction:          
          // Clip path for sizing 16 pixels
          defs.append("clipPath")
            .attr("id", "flowDiagram_clipPath_16")
            .append("rect")
              .attr("x", 0)
              .attr("y", 0)
              .attr("width", 16)
              .attr("height", 16);
          
          // IF THE MAIN PNG IMAGE IS CHANGED IN SIZE, THESE SIZINGS MUST BE CHANGED ACCORDINGLY
          defs.append("image")
            .attr("id", "flowDiagram_image_16")
            .attr("height","16")
            .attr("width",Resources.icons.icons16pxWidth)
            .attr("xlink:href", Resources.icons.iconsLocation + Resources.icons.icons16px);
            
          // The Images
          // Flow Event Icon
          defs.append("g")
            .attr("id", "flowDiagram_nodeEvent")
            .attr("clip-path", "url(#flowDiagram_clipPath_16)")
            .append("use")
              .attr("xlink:href","#flowDiagram_image_16")
              .attr("transform","translate(-720,0)");      
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "addImageDefinitions");
    },

		destroy: function(){
	    Trace.trace(this.declaredClass, Trace.levels.ENTRY, "destroy");
      this.inherited(arguments);

	    // Destroy existing flow profile widget
	    if(this.flowProfileWidget != null){
	    	// Destroy the tooltip widget
  			if(typeof this.flowProfileWidget.eventTooltipId !== "undefined") {
  				this.flowProfileWidget.eventTooltip.destroy();
  			}
  	    
	    	// Remove the child g which holds the diagram from the main flow profile template
	    	d3.select(this.widgetContainer).select("g").remove();
	    	this.flowProfileWidget = null;
	    }

      domConstruct.empty(this.widgetContainer);
    
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "destroy");
		},
		
		resize: function() {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");
		  
		  // Calculate the width available for use by the d3 diagram
		  if(this.flowProfileWidget != null){
	      this._width = this.getContainerWidth(this._marginWidth) - this._marginWidth;
	      // Only adjust width to a positive number
	      if(this._width >= 0) {
	        var canvas = d3.select("#"+this.widgetContainer).select("svg");
	        canvas.attr("width", this._width); 
	      }
		  }
    
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
		},
		
		getContainerWidth: function(marginWidth) {
		  var containerWidth = this._width + marginWidth;
		  if(this.widgetContainer != null) {
		    var container = dom.byId(this.widgetContainer);
		    if(container) {
		      var width = domStyle.getComputedStyle(container).width;
		      if(width) {
		        containerWidth = parseInt(width);
		      }
		    }
		  }
		  
		  return containerWidth;
		}
	}); // end dojo declare
});

},
'webui/widgets/policy_editor/policy_editor_dynamic':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63" 
 * years="2013, 2015" 
 * crc="1106094409" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63 
 *  
 * (C) Copyright IBM Corp. 2013, 2015 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/i18n!./nls/web",
  "dojo/text!./templates/policy_editor_dynamic.html",
  "dojo/_base/array",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom-construct",
  "dojo/store/Memory",    
  "dojox/html/entities",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase", 
  "dijit/_WidgetsInTemplateMixin",
  "dijit/registry",
  "webui/widgets/common/Trace",
  
  // For generated HTML
  "idx/form/NumberSpinner",
  "idx/form/Select"
], function(
  NLS,
  template,
  array,
  declare,
  lang,
  domConstruct,
  Memory,
  entities,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  registry,
  Trace
) {
  var policyeditor = declare("webui.widgets.policy_editor.policy_editor_dynamic", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
		templateString: template,
		policyLayout: null,
		policyData: null,
		policyUrl: "",
		uri: null,
		id: "",

    postCreate: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate"); 
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate"); 
    }, 
    
    displayPolicy: function(policyData, policyLayout, policyUrl) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "displayPolicy"); 
    	
    	if(typeof policyLayout == 'undefined') {
    		this.displayPolicyLayout(policyData);
    	} else {
    		this.displayPolicyLayout(policyLayout);	
    	}
    	
    	this.policyData = policyData;
    	this.policyUrl = policyUrl;
    	this._displayPolicyData();
    	
    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "displayPolicy"); 
    },
    
    /** Public */
    displayPolicyURL: function(policyUrl) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "displayPolicyURL"); 
    	       	
    	this.policyUrl = policyUrl;
    	
    	var propertyName = this.id + "policyUrl";
    	if(typeof propertyName != 'undefined') {
    	  var propertyWidget = registry.byId(propertyName);
    	  if(typeof propertyWidget != 'undefined') {
    	    propertyWidget.set("value", this.policyUrl);
    	  }
    	}

    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "displayPolicyURL"); 
    },
      
    getProperty: function(propertyName) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "getProperty"); 
      var propertyWidget = registry.byId(propertyName);
      if(typeof propertyWidget != 'undefined') {
        var propertyValue = propertyWidget.get("value");
        if(typeof propertyValue != 'undefined') {
          return propertyValue;
        }
      }
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "getProperty"); 
    },
      
    getPropertyWidget: function(propertyName) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "getPropertyWidget"); 
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "getPropertyWidget"); 
        return registry.byId(propertyName);
    },
    
    getAllPolicyData: function() {
    	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "getAllPolicyData");

    	var policyData = new Memory();
    	array.forEach(this.policyLayout.data, lang.hitch(this, function(property) {
    	  if(property.propertyId === "policyUrl") {
    	    return;
    	  }

  			var propertyName = this.id + property.propertyId; 

				if(property.propertyType == 'Group') {
				  return;
				}

				var propertyWidget = registry.byId(propertyName); 
				if(typeof propertyWidget == 'undefined') {
				  return;
				}

				var propertyValue;
				if(property.propertyType == "Boolean") {
					propertyValue = propertyWidget.get("checked");
				} else {
					propertyValue = propertyWidget.get("value");
					if (property.propertyType == "Number") {
						if(isNaN(propertyValue)) {
							propertyValue = "";
						}
					}
				}

				policyData.put({"value": propertyValue, "id": propertyName});
    	}));

    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "getAllPolicyData"); 
    	return policyData;
    },
      
    isValid: function() {
    	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "isValid");

    	var isValid = true;
    	array.forEach(this.policyLayout.data, lang.hitch(this, function(property) {
    		var propertyName = this.id+property.propertyId;
    		if(typeof propertyName != 'undefined') {
    			if(property.propertyType != 'Group') {
    				var propertyWidget = registry.byId(propertyName); 
    				if(!propertyWidget.validate()) {
    					isValid = false;
    				}
    			}
    		}
    	}));

    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "isValid"); 
    	return isValid;
    },
      
    listInvalid: function() {
    	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "listInvalid");

    	var invalidProperties = [];
    	array.forEach(this.policyLayout.data, lang.hitch(this, function(property) {
    		var propertyName = this.id+property.propertyId;
    		if(typeof propertyName != 'undefined') {
    			if(property.propertyType != 'Group') {
    				var propertyWidget = registry.byId(propertyName); 
    				if(!propertyWidget.validate()) {
    					var propertyNLSName = property.propertyNameNLS;
    					var propertyValue;
    					if(property.propertyType == "Boolean") {
    						propertyValue = propertyWidget.get("checked");
    					} else if (property.propertyType == "Number") {
    						propertyValue = propertyWidget.get("displayedValue");
    					} else {
    						propertyValue = propertyWidget.get("value");
    					}
    					
    					invalidProperties.push({name: propertyNLSName, value: propertyValue});
    				}
    			}
    		}
    	}));
    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "listInvalid"); 
    	return invalidProperties;
    },
      
    displayPolicyLayout: function(policyLayout) {
    	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "displayPolicyLayout"); 
    	
    	if (this.policyLayout){
        try{
//      	this.policyLayout.destroy();
          this.policyLayout.setData([]);
        }
       	catch(e) {}
      }
    	this.policyLayout = new Memory();
    	this.policyData = null;
   		this._createPolicyLayout(policyLayout);	
   		Trace.trace(this.declaredClass, Trace.levels.EXIT, "displayPolicyLayout"); 
    },
      
    refresh: function() {
    	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "refresh"); 
    	
    	array.forEach(this.policyLayout.data, lang.hitch(this, function(property) {
    		var propertyName = this.id + property.propertyId; 
    		if(typeof propertyName != 'undefined') {
    			var propertyWidget = registry.byId(propertyName); 
    			if(typeof propertyWidget != 'undefined') {
    				if(typeof property.propertyDefault != 'undefined') {
    					if(typeof property.propertyType != 'undefined') {
    						var propertyType = property.propertyType;
    						if(propertyType == "Group") {
    							propertyWidget.set("open", property.propertyDefault);
    						} else if(propertyType == "Boolean") {
    							propertyWidget.set("checked", property.propertyDefault);
    						} else {
    							propertyWidget.set("value", property.propertyDefault);
    						}
    					}
    				}
    			}
    		}
    	}));
    	
    	if(typeof this.policyData != 'undefined' && this.policyData != null) {
    		this._displayPolicyData();
    	}
    	
    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "refresh"); 
    },

    _createPolicyLayout: function(policyLayout) {
    	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createPolicyLayout"); 
    	// TODO Renaming of entities
    	// layout => model
    	// array/arraylist => bounded/unbounded set OR Enumeration etc?
    	// typing of entries in the enumeration?

			var generatedPolicyLayout = "";
			var generatedStores = "";
			array.forEach(policyLayout.contents, lang.hitch(this, function(property) {
				var propertyId = property.id; // Mandatory
				
				var propertyType = property.type; // Mandatory
				if(typeof propertyType == 'undefined') {
					propertyType = "String";
				}
				
				var propertyContents = property.contents; // Optional
				var propertyDefault = property["default"]; // Optional
				var propertyReadOnly = property.readOnly; // Optional
				
				var propertyPattern = property.pattern; // Optional
				var propertyStyle = property.style; // Optional 
				var propertyConstraints = property.constraints; //Optional
				var propertySuffix = property.suffix; //Optional
				var propertyTooltip = property.tooltip; //Optional
				var propertyInvalidMessage = property.invalidMessage; // Optional 
				var propertyTooltipPosition = property.tooltipPosition; // Optional 
				var propertyRequired = property.required; // Optional 

				var propertyNameNLS = this._getPropertyNameNLS(propertyId);
				var propertySuffixNLS = propertySuffix ? this._getPropertyNameNLS(propertySuffix) : "";
				var propertyTooltipNLS = propertyTooltip ? this._getPropertyNameNLS(propertyTooltip) : "";

				var propertyLabelId = propertyId+"_Label";
				var propertyStoreId = propertyId+"_Store";
				var propertySuffixId = propertyId+"_Suffix";
				var propertyTooltipId = propertyId+"_Tooltip";
				
				this.policyLayout.put({
				  propertyId: propertyId,
				  propertyType: propertyType,
				  propertyContents: propertyContents,
				  propertyDefault: propertyDefault,
				  propertyNameNLS: propertyNameNLS,
				  propertyLabelId: propertyLabelId,
				  propertyStoreId: propertyStoreId
			  });
				
				var generatedPropertyHTML = "";
				
				if(propertyType == "Group") {
					generatedPropertyHTML = "<div data-dojo-type=\"dijit.TitlePane\" ";
					generatedPropertyHTML += "data-dojo-attach-point=\""+this.id+propertyId+"\" ";
					generatedPropertyHTML += "data-dojo-props=\"id: '"+this.id+propertyId+"'";
					generatedPropertyHTML += ", title: '"+propertyNameNLS+"'";
					if(typeof propertyDefault != 'undefined') {
						generatedPropertyHTML += ", open: " + propertyDefault;
					}
					generatedPropertyHTML += "\" >";

					//TODO Tooltipping of groups!
					
					if(typeof propertyContents != 'undefined') {
						generatedPropertyHTML += this._createPolicyLayout(property);
					}
					
					generatedPropertyHTML += "<hr class=\"common_Rule\"/>";
					generatedPropertyHTML += "</div>";
				} else {
					generatedPropertyHTML = "<div style=\"padding-bottom:3px\"><div class=\"_common_subText\" ";
					generatedPropertyHTML += "data-dojo-attach-point=\""+this.id+propertyLabelId+"\" id=\""+this.id+propertyLabelId+"\">";
					generatedPropertyHTML += "<label>"+propertyNameNLS+"</label>";
					generatedPropertyHTML += "</div>";

					if(typeof propertyTooltip != 'undefined') {
					  generatedPropertyHTML += '<div class="oneui informationMessage idxMessageIcon" id="'+this.id+propertyTooltipId+'"/>';
					  generatedPropertyHTML += "<div data-dojo-type=\"idx.widget.HoverHelpTooltip\" data-dojo-props=\"connectId:'"+propertyTooltipId+"', position:['above']\">";
					  generatedPropertyHTML += propertyTooltipNLS;
					  generatedPropertyHTML += "</div>";
					} else {
					  generatedPropertyHTML += "<span style=\"padding-right:10px\"></span>";
					}

					if(propertyType == "String") { // "Label" "Text box"
						generatedPropertyHTML += "<input data-dojo-type=\"idx.form.TextBox\" class=\"_common_propertySubValue\""; 
						generatedPropertyHTML += "data-dojo-attach-point=\""+this.id+propertyId+"\" ";
						generatedPropertyHTML += "data-dojo-props=\"id: '"+this.id+propertyId+"'";
						if(typeof propertyDefault != 'undefined') {
							generatedPropertyHTML += ", value: '"+propertyDefault+"' ";
						}
						if(typeof propertyPattern != 'undefined') {
							generatedPropertyHTML += ", regExp: '"+propertyPattern+"', type: 'text', instantValidate: 'true'"; 
						}
						if(typeof propertyInvalidMessage != 'undefined') {
							var propertyInvalidMessageNLS = this._getPropertyNameNLS(propertyInvalidMessage);
							generatedPropertyHTML += ", invalidMessage:'"+propertyInvalidMessageNLS+"'"; 
						}
						if(typeof propertyTooltipPosition != 'undefined') {
							generatedPropertyHTML += ", tooltipPosition: ['"+propertyTooltipPosition+"']"; 
						}
						if(typeof propertyRequired != 'undefined' && propertyRequired === true) {
							generatedPropertyHTML += ", required: 'true'"; 
						}
						if(typeof propertyReadOnly != 'undefined') {
							generatedPropertyHTML += ", readOnly: "+propertyReadOnly+" ";
						}
						if(typeof propertyStyle != 'undefined') { 
							generatedPropertyHTML += ", style: '"+propertyStyle+"' ";
						}
						generatedPropertyHTML += "\" >";
						generatedPropertyHTML += "</input>";

					} else if(propertyType == "Enum") { // "Label",
														// "Select"
						//Have had to set the class for this widget as it doesn't have a set width which can cause rendering peculiarities.
						generatedPropertyHTML += "<select name=\""+propertyId+"\" fieldWidth=\"182px\" data-dojo-type=\"idx.form.Select\" "; 
						generatedPropertyHTML += "data-dojo-attach-point=\""+this.id+propertyId+"\" ";
						generatedPropertyHTML += "data-dojo-props=\"id: '"+this.id+propertyId+"'";
						if(typeof propertyDefault != 'undefined') {
							generatedPropertyHTML += ", value: '"+propertyDefault+"' ";
						}
						if(typeof propertyReadOnly != 'undefined') {
							generatedPropertyHTML += ", readOnly: "+propertyReadOnly+" ";
						}
						if(typeof propertyStyle != 'undefined') { 
							generatedPropertyHTML += ", style: '"+propertyStyle+"' ";
						}
						generatedPropertyHTML += "\" >";
						if(typeof propertyContents != 'undefined') {
							var contentNLS;
							array.forEach(propertyContents, lang.hitch(this, function(content) {
								if(content) {
									contentNLS = this._getPropertyNameNLS(content, propertyId);
									generatedPropertyHTML += "<option value=\""+content+"\">"+contentNLS+"</option>";
								}
								else {
									generatedPropertyHTML += "<option value=\""+content+"\"> </option>";
								}
							}));
						}
						generatedPropertyHTML += "</select>";

					} else if(propertyType == "Set") { // "Label"
																// "Combobox"

						generatedPropertyHTML += "<input data-dojo-type=\"idx.form.ComboBox\" ";
						generatedPropertyHTML += "data-dojo-attach-point=\""+this.id+propertyId+"\" ";
						generatedPropertyHTML += "data-dojo-props=\"id: '"+this.id+propertyId+"'";
						generatedPropertyHTML += ", aria-label: "+propertyNameNLS;
						if(typeof propertyContents != 'undefined') {
							generatedStores += this._createDojoStoreHTML(propertyStoreId, propertyContents);
							generatedPropertyHTML += ", store: "+propertyStoreId;
						}
						if(typeof propertyDefault != 'undefined') {
							generatedPropertyHTML += ", value: '"+propertyDefault+"' ";
						}
						if(typeof propertyPattern != 'undefined') {
							generatedPropertyHTML += ", regExp: '"+propertyPattern+"' ";
						}
						if(typeof propertyReadOnly != 'undefined') {
							generatedPropertyHTML += ", readOnly: "+propertyReadOnly+" ";
						}
						if(typeof propertyStyle != 'undefined') { 
							generatedPropertyHTML += ", style: '"+propertyStyle+"' ";
						}
						generatedPropertyHTML += "\" >";
						generatedPropertyHTML += "</input>";

					} else if(propertyType == "Number") { // "Label",
															// "NumberSpinner"
						generatedPropertyHTML += "<div data-dojo-type=\"idx.form.NumberSpinner\" "; 
						generatedPropertyHTML += "data-dojo-attach-point=\""+this.id+propertyId+"\" ";
						generatedPropertyHTML += "data-dojo-props=\"id: '"+this.id+propertyId+"', instantValidate: 'true'"; 

						if(typeof propertyConstraints != 'undefined') {
							var propertyMin = propertyConstraints.min;
							var propertyMax = propertyConstraints.max;
							var propertyDPs = propertyConstraints.places;
							propertyPattern = propertyConstraints.pattern;
							generatedPropertyHTML += ", constraints: {";
							if(typeof propertyMin != 'undefined') {
								generatedPropertyHTML += "min:"+propertyMin;
								if(typeof propertyMax != 'undefined' || typeof propertyDPs != 'undefined') {
									generatedPropertyHTML +=",";
								}
							}
							if(typeof propertyMax != 'undefined') {
								generatedPropertyHTML += "max:"+propertyMax;
								if(typeof propertyDPs != 'undefined') {
									generatedPropertyHTML +=",";
								}
							}
							if(typeof propertyDPs != 'undefined') {
								generatedPropertyHTML += "places:"+propertyDPs;
								if(typeof propertyPattern != 'undefined') {
									generatedPropertyHTML +=",";
								}
							}
							if(typeof propertyPattern != 'undefined') {
								generatedPropertyHTML += "pattern:'"+propertyPattern+"'";
							}

							generatedPropertyHTML += "}";
						}					
						
						if(typeof propertyDefault != 'undefined') {
							generatedPropertyHTML += ", value: '"+propertyDefault+"' ";
						}
						if(typeof propertyReadOnly != 'undefined') {
							generatedPropertyHTML += ", readOnly: "+propertyReadOnly+" ";
						}
						if(typeof propertyStyle != 'undefined') { 
							generatedPropertyHTML += ", style: '"+propertyStyle+"' ";
						}
						// Has to use the default error message in the Number Spinner; otherwise dojo has problem in parsing a French message even 
						// after the message has escape html characters, will cause the Number Spinner widget disappear from the page.
//						if(typeof propertyInvalidMessage != 'undefined') {
//							var propertyInvalidMessageNLS = this._getPropertyNameNLS(propertyInvalidMessage);
//							generatedPropertyHTML += ", invalidMessage:'"+propertyInvalidMessageNLS+"' "; 
//						}
						generatedPropertyHTML += "\" >";
						generatedPropertyHTML += "</div>";
					} else if(propertyType == "Boolean") { // "Label",
															// "Checkbox"
						generatedPropertyHTML += "<input data-dojo-type=\"idx.form.CheckBox\" "; 
						generatedPropertyHTML += "data-dojo-attach-point=\""+this.id+propertyId+"\" ";
						generatedPropertyHTML += "data-dojo-props=\"id: '"+this.id+propertyId+"'";
						if(typeof propertyDefault != 'undefined') {
							generatedPropertyHTML += ", checked: '"+propertyDefault+"' ";
						}
						if(typeof propertyReadOnly != 'undefined') {
							generatedPropertyHTML += ", readOnly: "+propertyReadOnly+" ";
						}
						if(typeof propertyStyle != 'undefined') { 
							generatedPropertyHTML += ", style: '"+propertyStyle+"' ";
						}
						generatedPropertyHTML += "\" >";
						generatedPropertyHTML += "</input>";

					} else {
						// TODO Need to handle this (maybe create as a default
						// 'String' type
					}
				
					if(typeof propertySuffix != 'undefined') {
						generatedPropertyHTML += "<div style=\"padding-left:5px\" class=\"_common_subText\" ";
						generatedPropertyHTML += "data-dojo-attach-point=\""+this.id+propertySuffixId+"\">";
						generatedPropertyHTML += propertySuffixNLS;
						generatedPropertyHTML += "</div>";
					}
					
					generatedPropertyHTML += "</div>";
				}
				
				generatedPolicyLayout += generatedPropertyHTML;
			}));
			
			var generatedPolicyEditor = generatedStores + generatedPolicyLayout;
			
			if(policyLayout.id == "root") {
				this._policyEditorDynamic.set("content", domConstruct.create("div", {
					innerHTML : generatedPolicyEditor
				}));
			}

			Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createPolicyLayout"); 
			return generatedPolicyEditor;
		},
	
		_createDojoStoreHTML: function(storeName, contents) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createDojoStoreHTML"); 
			var generatedHTMLStore = "<div data-dojo-type=\"dojo.store.Memory\" data-dojo-id=\""+storeName+"\" data-dojo-attach-point=\""+storeName+"\" data-dojo-props=\"";

			generatedHTMLStore += "id: " + JSON.stringify(storeName);

			var data = [];
			var contentCounter = 0;
			array.forEach(contents, lang.hitch(this, function(content) {
			  if(!content) {
			    return;
			  }

			  var contentId = content.id ? content.id : null;
			  var contentName = content.name ? content.name : null;
			
				if(!contentId && !contentName) {
					contentName = content;
					contentId = contentCounter;
				}
				
				var contentNameNLS = this._getPropertyNameNLS(contentName, contentId);

				data.push({"id": this.id+contentId, "name": contentNameNLS});
				
				contentCounter += 1;
			}));
			generatedHTMLStore += ", data: " + JSON.stringify(data);
			
			generatedHTMLStore += "\"></div>";

			Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createDojoStoreHTML"); 
			return generatedHTMLStore;
		},
		
		_displayPolicyData: function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_displayPolicyData"); 
			if(this.policyLayout == null) {
				return;
			}
			
			array.forEach(this.policyLayout.data, lang.hitch(this, function(property) {
			  var propertyName = this.id + property.propertyId; 

		    var propertyWidget = registry.byId(propertyName);
		    if(propertyWidget === undefined) {
		      console.error("Property widget '" + propertyName + "' not found");
		      return;
		    }

	      var propertyById = array.filter(this.policyData.contents, 
	        function(item){
	          return item !== undefined && item.id === propertyName; 
		      }
	      );

	      var value;
	      if(propertyById !== undefined && propertyById.length > 0) {
	        value = propertyById[0].value;
	      } else if(property.propertyId === "policyUrl"){
          value = this.policyUrl;
	      } else {
	        value = property.propertyDefault;
	      }
	      
	      if(value === undefined) {
	        return;
	      }

        if(property.propertyType == "Boolean") {
          if(value === true) {
            propertyWidget.set("checked", true);
          } else if(value === false) {
            propertyWidget.set("checked", false);
          } else {
            console.error("Property '" + propertyName + "' should have been a Boolean but instead was", value);
          }
        } else {
          
          // Defect 50375: <select/> dropdowns are case-sensitive, but the
          // "startMode" field on a Workload Management policy is not.
          if(property.propertyId === "startMode") {
            value = value.toLowerCase();
          }

          console.log(property.propertyId, value);
          propertyWidget.set("value", value);
        }
			}));
			
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "_displayPolicyData"); 
		},
		
		_getPropertyNameNLS: function(propertyName, propertyId){
		  var result;
		  if(propertyName in NLS) {
		    result = NLS[propertyName];
		  } else if(propertyId && ((propertyId + propertyName) in NLS)) {
		    result = NLS[propertyId + propertyName];
		  } else {
		    if(propertyId) {
		      console.error("NLS string not found for key '" + propertyName + "' or '" + propertyId + propertyName + "'");
		    } else {
		      console.error("NLS string not found for key '" + propertyName + "'");
		    }		      
		    result = propertyName;
		  }
			return entities.encode(result);
		},

		destroyPolicyLayout: function(){
			
		  if (this.policyLayout){
		    try{
//        this.policyLayout.destroy();
		      this.policyLayout.setData([]);
		    }
		    catch(e) {}
		    
		    this.policyLayout = null;
		  }
		  
		  this.policyData = null;
		}
		
  });
  return policyeditor;
});

},
'webui/widgets/common/CustomTree':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="1771198255" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/i18n!webui/nls/web",
  "dijit/Tree",
  "webui/widgets/common/CustomTreeNode",
  "dojo/_base/array",
  "dojo/_base/lang",
  "dojo/topic",
  "dojo/_base/declare",
  "webui/widgets/business/BTSource",
  "webui/widgets/common/Trace",
  "webui/config/Resources",
  "dojo/hash",
  "dojo/_base/fx",
  "dojo/text!webui/config/Layout.json",
  "dojo/Deferred",
  "dojo/promise/all",
  "dojo/on",
  "dijit/a11yclick",
  "dojo/aspect",
  "dojo/touch",
  "dijit/tree/_dndSelector",
  "dijit/registry"
  ],
  function(
    NLS,
    Tree,
    CustomTreeNode,
    array,
    lang,
    topic,
    declare,
    BTSource,
    Trace,
    Resources,
    hash,
    fx,
    Layout,
    Deferred,
    all,
    on,
    a11yclick,
    aspect,
    touch,
    _dndSelector,
    registry
  ) {
    
    /**
     * The shimmed promise function is required by the code immediately below that
     * overrides the postCreate method on the dijit/Tree class.
     */
    function shimmedPromise(/*Deferred|Promise*/ d){
      // summary:
      //  Return a Promise based on given Deferred or Promise, with back-compat addCallback() and addErrback() shims
      //  added (TODO: remove those back-compat shims, and this method, for 2.0)
  
      return lang.delegate(d.promise || d, {
        addCallback: function(callback){
          this.then(callback);
        },
        addErrback: function(errback){
          this.otherwise(errback);
        }
      });
    }
  
    /*
     * We need to override the postCreate function on the dijit/Tree class because
     * Dojo v1.9.7 introduces an issue where mouse clicks on the tree node
     * context menus are being captured by the tree row and are causing focus to
     * be returned to the tree row.  Moving focus away from the drop down menus
     * causes them to close.  The overridden method checks that the event actually
     * occurred on a dijit.Tree._TreeNode before (rather than a DropDownButton) before
     * handling it.
     */
    lang.extend(Tree, {
      postCreate: function() {
        this._initState();
  
        // Catch events on TreeNodes
        var self = this;
        this.own(
          on(this.containerNode, on.selector(".dijitTreeNode", touch.enter), function(evt){
            self._onNodeMouseEnter(registry.byNode(this), evt);
          }),
          on(this.containerNode, on.selector(".dijitTreeNode", touch.leave), function(evt){
            self._onNodeMouseLeave(registry.byNode(this), evt);
          }),
          on(this.containerNode, on.selector(".dijitTreeRow", a11yclick.press), function(evt){
            var node = registry.getEnclosingWidget(evt.target);
            if(node.isInstanceOf(Tree._TreeNode)){
              self._onNodePress(node, evt);
            }
          }),
          on(this.containerNode, on.selector(".dijitTreeRow", a11yclick), function(evt) {
            var node = registry.getEnclosingWidget(evt.target);
            if(node.isInstanceOf(Tree._TreeNode)){
              self._onClick(node, evt);
            }
          }),
          on(this.containerNode, on.selector(".dijitTreeRow", "dblclick"), function(evt){
            self._onDblClick(registry.getEnclosingWidget(this), evt);
          })
        );
  
        // Create glue between store and Tree, if not specified directly by user
        if(!this.model){
          this._store2model();
        }
  
        // monitor changes to items
        this.own(
          aspect.after(this.model, "onChange", lang.hitch(this, this._onItemChange), true),
          aspect.after(this.model, "onChange", lang.hitch(this, this._refreshContextMenu), true),
          aspect.after(this.model, "onChildrenChange", lang.hitch(this, this._onItemChildrenChange), true),
          aspect.after(this.model, "onDelete", lang.hitch(this, this._onItemDelete), true)
        );
  
        this.inherited("postCreate", arguments);
  
        this.dndController = _dndSelector;
        if(this.dndController){
          // TODO: remove string support in 2.0.
          if(lang.isString(this.dndController)){
            this.dndController = lang.getObject(this.dndController);
          }
          var params = {};
          for(var i = 0; i < this.dndParams.length; i++){
            if(this[this.dndParams[i]]){
              params[this.dndParams[i]] = this[this.dndParams[i]];
            }
          }
          this.dndController = new this.dndController(this, params);
        }
  
        this._load();
  
        // onLoadDeferred should fire when all commands that are part of initialization have completed.
        // It will include all the set("paths", ...) commands that happen during initialization.
        this.onLoadDeferred = shimmedPromise(this.pendingCommandsPromise);
  
        this.onLoadDeferred.then(lang.hitch(this, this.onLoad));
      }
    });
    
    return declare(
      "webui.widgets.common.CustomTree",
      [Tree],
      {
        
        id: "_explorerTree_ID",
        model: null, // data structure where tree contents is stored
        persist: false,
        singular : true,
        dndController: BTSource,
        lastFocused: null, // sadly public at the moment

        // TODO: move to CSS
        style: "width:100%;position:absolute;top:0px;bottom:0px;padding-top:20px",
        
        _createTreeNode : function(/* Object */args) {
          return new CustomTreeNode(args);
        },

        // This function will be called whenever the user clicks on an element
        // in the explorer tree on the left. It is *not* called when you click
        // on the expand/collapse icons.
        // In general, the behaviour is to show a relevant ContentPane in
        // the main part of the console. However, about 50% of the elements
        // in the tree have no specific ContentPane associated, which means
        // clicking on them does nothing.
        onClick : function(
          obj // REST object e.g. application, broker
        ) {

          // Work out whether we actually ought to change the thing currently
          // being shown in the main pane in the browser. If we should, then...
          // Update the hash in the browser's URI. "event.type"
          // is the type of object you just clicked in the tree,
          // e.g. "broker", "policy"
          var go = true;
          if(
            // These types of element don't have any content pane
            // associated with them.
            obj.type === "applications" ||
            obj.type === "business" ||
            obj.type === "configurableServices" ||
            obj.type === "configurableServiceTypes" ||
            obj.type === "data" ||
            obj.type === "executionGroups" ||
            obj.type === "interface" ||
            obj.type === "libraries" ||
            obj.type === "messageFlows" ||
            obj.type === "monitoring" ||
            obj.type === "policyType" ||
            obj.type === "security" ||
            obj.type === "restApis" ||
            obj.type === "subFlows" ||
            obj.type === "resources" ||
            obj.type === "references" ||
            obj.type === "referents" ||
            obj.type === "services" ||
            obj.type === "sharedLibraries" ||
            obj.type === "missingSharedLibrary" ||
            obj.type === "users" ||

            // Ignore policy with undefined type.
            (obj.type === "policy" && obj.policyType === undefined) ||

            // Ignore items that the user does not have read permission for.
            (obj.type === "executionGroup" && !window.currentuser.userPermission("eg." + obj.name, "read")) ||
            (obj.type === "dataCaptureStores" && !window.currentuser.userPermission("datacapture", "read"))
          ) {
            go = false;
          }
          
          // No change there then...
          if(!go) {
            return;
          }

          // Other obj types which WOULD reach this point include
          // "application", "broker", "library", "service",
          // etc.

          this._changeHash(obj);
        },
        
        /**
         * Input an object (an item in the CustomTree). This function refreshes the
         * context menu widget for that item.
         */
        _refreshContextMenu: function(object) {
          var customTreeNodes = this.getNodesByItem(object);
          customTreeNodes.forEach(function(customTreeNode) {
            if(!customTreeNode) {
              return;
            }
            
            customTreeNode.createContextMenu();
          });
        },
        
        /**
         * User clicked in the explorer tree, AND we've confirmed we don't
         * have unsaved changes. Update the hash, so that the visible
         * content changes.
         */
        _changeHash: function (obj) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_changeHash");

          // Take the thing which we just clicked on and turn it into a hash
          // string

          var uriPath = obj.uri;
          // e.g. "/apiv1/executiongroups/..."

          uriPath = uriPath.substr(Resources.REST.root.length);
          // e.g. "/executiongroups/..."

          // In Layout.json, it's possible to specify a "selectTab"
          // which is the default tab to select when an object of
          // that type is selected in the explorer tree.
          var selectTab = null;
          var widgetLayout = JSON.parse(Layout);
          if(widgetLayout[obj.type] !== undefined){
            selectTab = widgetLayout[obj.type].selectTab;
          }

          // but usually it's not specified so default to 0
          if(!selectTab) {
            selectTab = "0";
          }

          var newHash = obj.type + "/" + selectTab + uriPath;
          // e.g. "executiongroup/0/executiongroups/..."

          hash(newHash);
          // See WMBConsole._router for what happens next!

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "_changeHash");
        },

        // When the page has loaded send a publish event
        // Also, move the slider and widen the tree if needed
        onLoad : function() {
          topic.publish("webui/tree", "loaded");

          if(window.currentuser.userPermission("broker", "read")) {
            fx.animateProperty({
              node:"_explorerTree_treeContainer",
              duration: 500,
              onEnd: function() {
                window.wmbConsole.moveSlideBar();
              }
            }).play();
          }
        },

        /**
         * Change the icon for each element in the tree to reflect its type and
         * status (public, override)
         */
        getIconClass : function(item) {

          var className;
          if (item.type === "resource"){
            //
            // this handles deployed resources which are of type "resource", but
            // which should have indidivual icons depending on their file extension
            //
            
            //hint : Look in Common.css for all explorer_
            className = "explorer_resource_";
            if ( item.uri !== undefined ){
              
              if (item.uri.toLowerCase().lastIndexOf(".map") != -1){
                className = className + "map";
              }//if
              else if (item.uri.toLowerCase().lastIndexOf(".rules") != -1){
                className = className + "rules";
              }//if
              else if (item.uri.toLowerCase().lastIndexOf(".esql") != -1){
                className = className + "esql";
              }//if
              else if (item.uri.toLowerCase().lastIndexOf(".wsdl") != -1){
                className = className + "wsdl";
              }//if
              else if (item.uri.toLowerCase().lastIndexOf(".xsd") != -1){
                className = className + "xsd";
              }//if
              else if (item.uri.toLowerCase().lastIndexOf(".xsdzip") != -1){
                className = className + "xsdzip";
              }//if
              else if (item.uri.toLowerCase().lastIndexOf(".xsl") != -1){
                className = className + "xsl";
              }//if
              else if (item.uri.toLowerCase().lastIndexOf(".xslt") != -1){
                className = className + "xsl";//yes... same as xsl
              }//if
              else if (item.uri.toLowerCase().lastIndexOf(".jar") != -1){
                className = className + "jar";
              }//if
              else if (item.uri.toLowerCase().lastIndexOf(".php") != -1){
                className = className + "php";
              }//if
              else if (item.uri.toLowerCase().lastIndexOf(".appdomainzip") != -1){
                className = className + "appdomainzip";
              }//if
              else if (item.uri.toLowerCase().lastIndexOf(".dictionary") != -1){
                className = className + "dictionary";
              }//if
              else if (item.uri.toLowerCase().lastIndexOf(".inadapter") != -1){
                className = className + "inadapter";
              }//if
              else if (item.uri.toLowerCase().lastIndexOf(".outadapter") != -1){
                className = className + "outadapter";
              }//if
              else {
                //unknown deployed resource
                className = className + "generic";
              }//endif
              
            }//if
            else {
              className = className + "generic";
            }//endif
            
          }//if
          else {

            var runningState = "";
            var testRecordState = "";
            if(item.isRunning !== undefined){
              switch(item.isRunning) {
                case true:
                  runningState = "_running";
                  break;
                case false:
                  runningState = "_stopped";
                  break;
                default:
                  runningState = "";
              }
            }
            if(item.type === "executionGroup"){
              if(!window.currentuser.userPermission("eg." + item.name, "read")){
                runningState= "_locked";
              }
            }
            if(item.type === "messageFlow"){
                if (runningState === "_running" && item.isInTestRecordMode === true) {
                  testRecordState = "_testRecordMode";
                }
              }
            if(item.type === "dataCaptureStores"){
              if(!window.currentuser.userPermission("datacapture", "read")){
                runningState= "_locked";
              }
            }
            className = "explorer_" + item.type + runningState + testRecordState;
            
            // If the type is policy and the policyType is WorkloadManagement, set icon
            // class to be policy type (prevents WorkloadManagement icon from incorrectly
            // not being shown after filtering has been changed in the UI):
            if (item.type === 'policy' && item.policyType === 'WorkloadManagement') {
              className = "explorer_policyType" + runningState + testRecordState;
            }
            
          }//endif
          

          return className;
        },

        // Overridable function to return CSS class name to display row
        // Remove hover effect from some items in the tree
        getRowClass : function(item) {

          // Basically, any group, or anything the user doesn't have access to,
          // gets no special highlighting when you hover over it.
          if(
            item.type === "applications" ||
            item.type === "business" ||
            item.type === "configurableServices" ||
            item.type === "configurableServiceTypes" ||
            item.type === "data" ||
            (item.type === "dataCaptureStores" && !window.currentuser.userPermission("datacapture", "read")) ||
            (item.type === "executionGroup" && !window.currentuser.userPermission("eg." + item.name, "read")) ||
            item.type === "executionGroups" ||
            item.type === "interface" ||
            item.type === "libraries" ||
            item.type === "sharedLibraries" ||
            item.type === "missingSharedLibrary" ||
            item.type === "messageFlows" ||
            (item.type === "policy" && item.policyType === undefined) ||
            item.type === "policyType" ||
            item.type === "security" ||
            item.type === "monitoring" ||
            item.type === "restApis" ||
            item.type === "subFlows" ||
            item.type === "resources" ||
            item.type === "references" ||
            item.type === "referents" ||
            item.type === "services" ||
            item.type === "users"
          ) {
            return "noNodeHover";
          }

          // Default: a nice blue background
          return "";
        },

        _sortChildrenOfThisParentNode : function(parentNode) {
          
          var doSort = false;
          if(
            (parentNode.item.type === "messageFlows")     ||
            (parentNode.item.type === "subFlows")         ||
            (parentNode.item.type === "resources")        ||
            (parentNode.item.type === "applications")     ||
            (parentNode.item.type === "restApis")         ||
            (parentNode.item.type === "services")         ||
            (parentNode.item.type === "libraries")        ||
            (parentNode.item.type === "sharedLibraries")
           ) {
            doSort = true;
          }//if
          
          return doSort;
        },
        
        _filterItems: function (originalChildrenList) {
    
          var filteredChildrenList = originalChildrenList;//default show everything
          
          if (
            window.wmbConsole.filterConfigServices === "!ibm" &&
            originalChildrenList !== undefined &&
            originalChildrenList.length > 0 &&
            originalChildrenList[0].type === Resources.REST.configurableServiceTypes
          ) {
            // children are configurable service types, so the parent must be the configurable services category
            filteredChildrenList = [];
            //filter out configurable services types that do not contain non-IBM defined configurable services (since we are not going to be showing IBM defined configurable services):
            originalChildrenList.forEach(function(entry) {
              if (
                entry.type !== undefined &&
                entry.type === Resources.REST.configurableServiceTypes &&
                entry.hasNonIBMDefinedChildren === true
              ) {
                filteredChildrenList.push(entry);
              }
            });
          }//if
          else if (
            window.wmbConsole.filterConfigServices === "!ibm" &&
            originalChildrenList !== undefined &&
            originalChildrenList.length > 0 &&
            originalChildrenList[0].type === Resources.REST.configurableService
          ) {
            // children are configurable services, so the parent must be a configurable service type
            filteredChildrenList = [];
            //filter out IBM defined configurable services (since we are not going to showing them):
            originalChildrenList.forEach(function(entry) {
              if (
                entry.type !== undefined &&
                entry.type === Resources.REST.configurableService &&
                entry.ibmDefined !== true
              ) {
                filteredChildrenList.push(entry);
              }
            });
          }//else if
          else if (window.wmbConsole.filterResources === "all"){
            filteredChildrenList = originalChildrenList;
          }//else if
          else if (window.wmbConsole.filterResources == "flows") {
              
            filteredChildrenList = [];
            //filter out subflow category and flow resources category
            originalChildrenList.forEach(function(entry) {
              
              if (
                entry.type !== undefined &&
                entry.type !== "subFlows" &&
                entry.type !== "resources" &&
                entry.type !== "interface"
              ) {
                filteredChildrenList.push(entry);
              }  
            });      
              
          }//endif
          
          return filteredChildrenList;
        },
        
        _onItemChildrenChange: function(/*dojo/data/Item*/ parent, /*dojo/data/Item[]*/ newChildrenList){
          // summary:
          //    Processes notification of a change to an item's children
          var model = this.model,
            identity = model.getIdentity(parent),
            parentNodes = this._itemNodesMap[identity];
    
          if(parentNodes){
            array.forEach(parentNodes, lang.hitch(this, function(parentNode){
              var filteredChildren = this._filterItems(newChildrenList);
              if ( this._sortChildrenOfThisParentNode(parentNode) ) {
                filteredChildren.sort(
                  function(a, b){
                    return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
                  }
                );
              }//if
              parentNode.setChildItems(filteredChildren);
            }));
          }
        },

        /**
         * summary:
         *     Called when the user has requested to expand the node
         * returns:
         *    Promise that resolves when the node is loaded and opened and (if persist=true) all it's descendants
         *    that were previously opened too
         */
        _expandNode: function(/*TreeNode*/ node){
    
          if(node._expandNodeDeferred){
            // there's already an expand in progress, or completed, so just return
            return node._expandNodeDeferred;  // dojo/Deferred
          }
    
          var model = this.model,
            item = node.item;
    
          // Load data if it's not already loaded
          if(!node._loadDeferred){
            // need to load all the children before expanding
            node.markProcessing();
    
            // Setup deferred to signal when the load and expand are finished.
            // Save that deferred in this._expandDeferred as a flag that operation is in progress.
            node._loadDeferred = new Deferred();
    
            // Get the children
            model.getChildren(
              item,
              lang.hitch(this, function(items){
    
                node.unmarkProcessing();
    
                // Display the children and also start expanding any children that were previously expanded
                // (if this.persist == true).   The returned Deferred will fire when those expansions finish.
    
                var filteredChildren = this._filterItems(items);
                
                if (this._sortChildrenOfThisParentNode(node) ) {
                  filteredChildren.sort(
                    function(a, b){
                      return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
                    }
                  );
                }//if
    
                node.setChildItems(filteredChildren).then(function(){
                  node._loadDeferred.resolve(filteredChildren);
                });
              }),
              lang.hitch(this, function(err){
                console.error(this, ": error loading " + node.label + " children: ", err);
                node._loadDeferred.reject(err);
              })
            );
          }
    
          // Expand the node after data has loaded
          var def = node._loadDeferred.then(lang.hitch(this, function(){
            var def2 = node.expand();
    
            // seems like these should delayed until node.expand() completes, but left here for back-compat about
            // when this.isOpen flag gets set (ie, at the beginning of the animation)
            this.onOpen(node.item, node);
            this._state(node, true);
    
            return def2;
          }));
    
          this._startPaint(def);  // after this finishes, need to reset widths of TreeNodes
    
          return def;  // dojo/promise/Promise
        },
    
        treeNodeLabelMaxLength : function () {
          return 40;  
        },
    
        getTooltip : function(item) {
    
          var tooltip = "";
          
          if( item.name !== undefined) {
                  
            var charLimit = this.treeNodeLabelMaxLength();
            if(item.name.length > charLimit) {
              tooltip = item.name;
            }//if
                    
          }//if
    
          return tooltip;
        },
    
        // Change the label displayed in the tree to a nice name
        getLabel : function(item) {
    
          var label;
    
          // If the resource has a username (A User's nice name) then use the
          // username as the label in the tree.
          if( item.username !== undefined) {
            if(item.type === "currentUser"){
              label = NLS.treeLabel[item.type];
            } else {
              label = item.username;
            }
          }
    
          // If the resource has a name then use the name as the label in the tree.
          else if( item.name !== undefined && item.name !== '') {
            // Check that if we have a really long name, that we truncate in a human readable manner of characters.
            var charLimit = this.treeNodeLabelMaxLength();
            if(item.name.length > charLimit) {
              label = item.name.substr(0,charLimit) + "...";
            } else {
              label = item.name;
            }
          }
          // If the resource does not have a name then use the 'type' as a NLS
          // key to display it in the tree
          else if(item.type !== undefined) {
            if(item.type ==='configurableServiceTypes') {
              label = item.configurableServiceType;
            } else if(item.type ==='policyType' || item.policyType === 'WorkloadManagement') {
                  // Use the policyType as the label if the policyType is WorkloadManagement
                  // (prevents "WorkloadManagement" label incorrectly being "Operation Policy"
                  // after filtering is changed in the UI):
                  label = item.policyType;
            } else {
              label = NLS.treeLabel[item.type];
            }
          }
    
          // If we have really bad returned JSON we want to show sometime.
          else {
            console.log("This returned object needs a 'name' or 'type' property:", item);
            label = "-------";
          }
    
          return label;
        },
    
        /**
         * Override dijit.Tree's _setPathsAttr ; since it causes
         * TreePath error for 'resource' type elements with slash
         * in name. e.g. IBMDefined/soap.xsd 
         */
        _setPathsAttr: function(/*Item[][]|String[][]*/ paths){
          // summary:
          //    Select the tree nodes identified by passed paths.
          // paths:
          //    Array of arrays of items or item id's
          // returns:
          //    Promise to indicate when the set is complete
    
          var selectPath = lang.hitch(this, function(path, nodes){
            // Traverse path, returning Promise for node at the end of the path.
            // The next path component should be among "nodes".
            var nextPath = path.shift();
            var nextNode = array.filter(nodes, function(node){
              return node.getIdentity() == nextPath;
            })[0];
    
            if(!!nextNode){
              if(path.length){
                return this._expandNode(nextNode).then(function(){
                  return selectPath(path, nextNode.getChildren());
                });
              }
    
              // Successfully reached the end of this path
              return nextNode;
            }
    
            if ( nextPath.indexOf("/resources/") == -1 ){
              //throw an exception IFF it is not a deployed resource
              throw new Tree.PathError("Could not expand path at " + nextPath);
            }//if
          });
    
          // Let any previous set("path", ...) commands complete before this one starts.
          // TODO for 2.0: make the user do this wait themselves?
          return this.myShimmedPromise(this.pendingCommandsPromise = this.pendingCommandsPromise.always(lang.hitch(this, function(){
            // We may need to wait for some nodes to expand, so setting
            // each path will involve a Deferred. We bring those deferreds
            // together with a dojo/promise/all.
            return all(array.map(paths, lang.hitch(this, function(path){
              // normalize path to use identity
              path = array.map(path, lang.hitch(this, function(item){
                return lang.isString(item) ? item : this.model.getIdentity(item);
              }));
    
              if(path.length){
                return selectPath(path, [this.rootNode]);
              }
    
              throw new Tree.PathError("Empty path");
            })));
          })).then(lang.hitch(this, function setNodes(newNodes){
            // After all expansion is finished, set the selection to last element from each path
            
            //
            // checking here to make sure the array doesn't have undefined first element. (Not done in dijit.Tree)
            //
            if ( (newNodes !== undefined) && (newNodes.length>0) && (newNodes[0]!== undefined)) {
              this.set("selectedNodes", newNodes);  
            }//if
            
            return this.paths;
          })));
        },
    
        /**
         * Cannot call dijit.Tree's private shimmedPromise, so created my
         * own here and calling it instead.
         */
        myShimmedPromise: function (/*Deferred|Promise*/ d) {
          // summary:
          //    Return a Promise based on given Deferred or Promise, with back-compat addCallback() and addErrback() shims
          //    added (TODO: remove those back-compat shims, and this method, for 2.0)
    
          return lang.delegate(d.promise || d, {
            addCallback: function(callback){
              this.then(callback);
            },
            addErrback: function(errback){
              this.otherwise(errback);
            }
          });
        },
    
        /**
         * Widen the tree if, when a node is expanded, the width is too large.
         * Call on open node event.
         * Have slight delay aso that tree is updated with its width before
         * checking if the slider needs to be moved.
         */
        onOpen : function(){
          if(window.currentuser.userPermission("broker", "read")){
            fx.animateProperty({
              node:"_explorerTree_treeContainer",
              duration: 500,
              onEnd: function() {
                // Move the Slide Bar if not all the tree is showing
                window.wmbConsole.moveSlideBar();
              }
            }).play();
          }
        },
        
        /**
         * Several ContentPanes in the Policy area call this
         * manually to make the correct info pane show. Strictly speaking,
         * it would be preferable for these ContentPanes to just call
         * hash(<new hash>) and allow WMBConsole's hashchange listener
         * to handle the rest.
         */
        openInfoPane : function(item){
          window.wmbConsole.createInfoPane(item.item, true);
        },
    
        refresh : function(){
          this._itemNodeMap = {};
          
          this.rootNode.state = "UNCHECKED";
          
          this._load();
        }
      }
    );
  }
);

},
'webui/widgets/policy/PolicyUtils':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63" 
 * years="2014, 2015" 
 * crc="392431026" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63 
 *  
 * (C) Copyright IBM Corp. 2014, 2015 All Rights Reserved.  
 * </copyright> 
 */
/*
 * This is a collection of static util methods for working with/near webstats
 */
define([
  "dojo/_base/array", 
  "dojo/_base/lang"
], function(array, lang) {
    
    /*
     * To convert the data structure returned from policy_editor_dynamic widget to a 
     * data structure used by update/create REST API of node policy.
     */
    function getNodePolicyPropertiesForREST(policyType, callerId, policyEditorDynamic) {
  		var policyData = policyEditorDynamic.getAllPolicyData();
  		
  		var updatePolicyProperties = {};
  		updatePolicyProperties.policyProperties = {};
  		var entryId = ""; 
  		
  		if (policyType === "MQTTPublish" || policyType === "MQTTSubscribe"){
  			updatePolicyProperties.policyProperties.description = {};
  			updatePolicyProperties.policyProperties.basic = {};
  			
  			array.forEach(policyData.data, lang.hitch(this, function(entry) {
  				entryId = entry.id.substring(callerId.length);
  				
  				if(entryId === "qos"){
  					// qos with "empty" value is only the watermark, set it to empty string.
  					if (entry.value === "empty"){
  						entry.value = "";
  					}
  				}
  				
  				if(entryId === "shortDesc" || entryId === "longDesc") {
  					// only add the entry when value is defined
  					if (entry.value !== ""){
  						updatePolicyProperties.policyProperties.description[entryId] = entry.value;
  					}
  				}
  				else if(entryId != "policyName") {
  					// only add the entry when value is defined
  					if (entry.value !== ""){
  						updatePolicyProperties.policyProperties.basic[entryId] = entry.value;
  					}
  				}
  			}));
  		}
  		else if (policyType === "MQEndpoint"){
  			updatePolicyProperties.policyProperties.mqConnectionDetailsPolicy = {};
  			array.forEach(policyData.data, lang.hitch(this, function(entry) {
  				entryId = entry.id.substring(callerId.length);
  				if(entryId != "policyName") {
  					// only add the entry when value is defined
  					if (entry.value !== ""){
  						updatePolicyProperties.policyProperties.mqConnectionDetailsPolicy[entryId] = entry.value;
  					}
  				}
  			}));
  		}
  		
  		updatePolicyProperties.type = policyType;
  		
  		return updatePolicyProperties;
  	}
 
    /*
     * To convert the data structure returned from a REST call to the 
     * data structure used by policy_editor_dynamic widget.
     */
    function loopThruPolicyDataStructureFromREST(group, policyData, policyContentsCounter, callerId){
    	for (var propName in group) {
    		if (typeof group[propName] != "undefined" && typeof group[propName] != "object"){
    		  policyContentsCounter = policyData.contents.length;
    		  var propValue = group[propName];

    		  policyData.contents[policyContentsCounter] = {id: callerId + propName, value: propValue}; 
    		  policyContentsCounter++;
    		}
    		else if (propName !== "__proto__"){
    		  loopThruPolicyDataStructureFromREST(group[propName], policyData, policyContentsCounter, callerId);
    		}
    	}
    	
    	return policyData;
    }
	 
    //return static public functions
    return {
      getNodePolicyPropertiesForREST: getNodePolicyPropertiesForREST,
    	loopThruPolicyDataStructureFromREST: loopThruPolicyDataStructureFromREST
  	};
});

},
'webui/widgets/broker/broker_overview':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/broker/templates/broker_overview.html",
	"dojo/i18n!webui/nls/web",
	"dojo/_base/declare", 
	"dojo/_base/lang",
	"dojo/dom-attr",
	"dojo/dom-construct",
  "dojo/keys",
	"dojo/on",
	"dojo/query",
	"dojo/ready",
	"dojo/topic",
	"dijit/_WidgetBase", 
	"dijit/_TemplatedMixin",
  "dijit/_WidgetsInTemplateMixin",
  "dijit/registry",
	"idx/widget/ConfirmationDialog",
	"idx/widget/HoverHelpTooltip",
	"webui/config/Resources",
	"webui/widgets/broker/BrokerPropertiesEditor",
	"webui/widgets/common/HasContextMenu",
	"webui/widgets/common/QuickAndAdvancedProperties",
	"webui/widgets/common/Toolbar",
	"webui/widgets/common/Trace",
	"webui/widgets/common/UIUtils"
], function(
  template,
  NLS,
  declare,
  lang,
  domAttr,
  domConstruct,
  keys,
  on,
  query,
  ready,
  Topic,
  _WidgetBase,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  registry,
  ConfirmationDialog,
  HoverHelpTooltip,
  Resources,
  BrokerPropertiesEditor,
  HasContextMenu,
  QuickAndAdvancedProperties,
  Toolbar,
  Trace,
  UIUtils
) {
  var brokerOverview = declare("webui.widgets.broker.broker_overview", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
    templateString: template,
    toolbar: null,
            
    postCreate: function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			this.inherited(arguments);	
			
			// Create toolbar
			this.toolbar = new Toolbar();
			domConstruct.place(this.toolbar.domNode, this._toolbar);
			this.toolbar.addLeftAlignButtons("title");
			
			// Add Edit button to the right side of the toolbar if the user has write permission:
			var doesUserHaveWritePermission = window.currentuser.userPermission("broker", "write");
			if (doesUserHaveWritePermission) {
				var buttons = ["edit"];
		 		this.toolbar.addRightAlignButtons(buttons);
		 		this.toolbar.addRightAlignButtons("spacer");
		 		this.toolbar.getButton("edit").set("disabled", false);

		 		// Add an event handler for the Edit button:
				this.toolbar.connectButtons("edit", "click", this, "_onEditClick");
			}
			
			this.properties = new QuickAndAdvancedProperties("broker");
			this.properties.createPropertiesContainer(this._propertyTitlePane);

	 		Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},
		
    // Hides the read-only view of the properties:
    _hideReadOnlyProperties: function() {
    	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_hideReadOnlyProperties");
    	//this._csOverview_borderContainer.style.display = "none";
    	this._brokerOverview_borderContainer.style.display = "none";

    	this.toolbar.style.display = "none";
    	this._propertyTitlePane.style.display = "none";
    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_hideReadOnlyProperties");
    },
    
    // Checks whether the properties editor is open:
    _isPropertyEditorOpen: function() {
    	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_isPropertyEditorOpen");
    	var returnValue = this.propertiesEditor !== null && this.propertiesEditor !== undefined;
    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_isPropertyEditorOpen");
    	return returnValue;
    },
    
    // Destroys the properties editor if one exists and removes the associated listeners.
    // Called when the user saves or cancels the properties editor, or when the user
    // navigates away from the editor:
    _destroypropertiesEditor: function() {
    	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_destroypropertiesEditor");
     
    	//Remove listeners:
    	if (this.editorUpdatedSubscription !== undefined && this.editorUpdatedSubscription !== null) {
    		this.editorUpdatedSubscription.remove();
    	}
    	
    	if (this.editorCancelSubscription !== undefined && this.editorCancelSubscription !== null) {
    		this.editorCancelSubscription.remove();
    	}
     
     	//Destroy the properties editor widget if it exists:
    	if (this._isPropertyEditorOpen()) {
    		this.propertiesEditor.destroy();
    		this.propertiesEditor = null;
    	}
      
    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_destroypropertiesEditor");
    },
    
    // Shows the read-only view of the properties:
    _showReadOnlyProperties: function() {
    	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showReadOnlyProperties");
    	this._brokerOverview_borderContainer.style.display = "";
    	this.toolbar.style.display = "";
    	this._propertyTitlePane.style.display = "";
    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showReadOnlyProperties");
    },
    
	  // Called when the user clicks the Edit button:
    _onEditClick: function() {
    	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onEditClick");

    	//Hide the existing read-only properties pane and associated title and toolbar:
    	this._hideReadOnlyProperties();
 	  
    	//Show the properties editor:
    	if (!this._isPropertyEditorOpen()) {
    		this.propertiesEditor = new BrokerPropertiesEditor({
    			mode: 'edit',
    			name: window.brokerName
    		});
        
    		//Subscribe to the properties editor's update event:
    		this.editorUpdatedSubscription = Topic.subscribe(Resources.pubSubTopic.brokerPropertiesUpdated, lang.hitch(this, function() {
    			// Destroy editor:
    			this._destroypropertiesEditor();
        
    			// Re-populate the properties because the read-only properties will be out of date after the update:
    			this.properties.populateProperties();
          
    			// Re-show the read-only properties pane and associated title and toolbar if hidden:
    			this._showReadOnlyProperties();
    		}));
        
    		// Subscribe to the properties editor's cancel event:
    		this.editorCancelSubscription = Topic.subscribe(Resources.pubSubTopic.brokerPropertiesEditCancelled, lang.hitch(this, function() {
    			// If the editor is not dirty, just proceed with the cancel:
    			if (this._isPropertyEditorOpen() && !this.propertiesEditor.isDirty()) {
    				// Destroy editor:
    				this._destroypropertiesEditor();
        	
    				//Re-show the read-only properties pane and associated title and toolbar if hidden:
    				this._showReadOnlyProperties();
	  	    
    				return;
    			}
          
    			//Create the confirmation dialog if it does not already exist:
    			var brokerEditConfirmCancelDialog = registry.byId("brokerEditConfirmCancelDialog");
    			if (typeof brokerEditConfirmCancelDialog === 'undefined') {
    				brokerEditConfirmCancelDialog = new ConfirmationDialog({
    					type : "information",
    					buttonLabel : NLS.btLeaveSave,
    					cancelButtonLabel : NLS.btStayOnPage,
    					closeButtonLabel : NLS.btStayOnPage,
    					text : NLS.messages.PropertiesUpdate_ConfirmNavigateAwayFromEditorConfirmationMessage
    				}, "brokerEditConfirmCancelDialog");
    			}
          
    			//Callback handler for when the user clicks 'confirm' on the dialog:
    			brokerEditConfirmCancelDialog.confirm(lang.hitch(this, function() {
    				// Destroy editor:
    				this._destroypropertiesEditor();
        	
    				// Re-show the read-only properties pane and associated title and toolbar if hidden:
    				this._showReadOnlyProperties();
    			}));
          
    			// Callback handler for when the user clicks 'cancel' on the dialog:
    			brokerEditConfirmCancelDialog.onCancel = lang.hitch(this, function() {
    				brokerEditConfirmCancelDialog.hide();
    			});
          
    			// Keyboard handler for dialog
    			on(brokerEditConfirmCancelDialog, "keydown", lang.hitch(this, function (event){
    				// Move the focus accordingly if the arrow keys are pressed
    				var key = event.keyCode;
    				if ((key == keys.LEFT_ARROW) && brokerEditConfirmCancelDialog.closeAction.focused) {
    					brokerEditConfirmCancelDialog.confirmAction.focus();
    				} 
    				else if ((key == keys.RIGHT_ARROW) && brokerEditConfirmCancelDialog.confirmAction.focused){
    					brokerEditConfirmCancelDialog.closeAction.focusNode.focus();
    				}
    				
    				//Extend confirm/close function to close on Enter key press
    				if (key == keys.ENTER) {
    					if(brokerEditConfirmCancelDialog.confirmAction.focused) {
    						brokerEditConfirmCancelDialog.hide();
             
    						//Destroy editor:
    						this._destroypropertiesEditor();
        	
    						// Re-show the read-only properties pane and associated title and toolbar if hidden:
    						this._showReadOnlyProperties();
    					} else {
    						if(brokerEditConfirmCancelDialog.closeAction.focused) {
    							brokerEditConfirmCancelDialog.onCancel();
    						}
    					}
    				} 
    				
    				// Stop the keyboard event propagating i.e. moving a flow on the canvas
    				event.stopPropagation();
    			}));
          
    			//Open the dialog and ask the user if they are sure that they want to cancel:
    			brokerEditConfirmCancelDialog.show();
    		}));
        
    		this.propertiesEditor.placeAt(this._brokerEditEditor);
    		this.propertiesEditor.startup();
    	}
      
    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onEditClick");
    },
    
  	resize: function() {
  		this._brokerOverview_borderContainer.resize();
  	},
  	    
  	//This function is called manually when we need to remove this tab.
  	tabRemove: function() {
  		Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
              
  		this.properties.unsubscribeAll();
  		if(this.propertiesEditor) {
  		  this.propertiesEditor.uninitialize();
  		}
  
  		Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove"); 
  	},
        
    tabFocus: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");
            
      this.properties.unsubscribeAll();
      domAttr.set("_infoPaneTitleID", "innerHTML", window.brokerName + " - " + NLS.brokerTitle);

      var secureText = "";
      var populate = this.properties.populateProperties();
      populate.then(lang.hitch(this,function(){
        if(query('._common_propertyHoverHelpIcon')[0]){
          domAttr.set(query('._common_propertyHoverHelpIcon')[0], "onmouseover", "idx.widget.HoverHelpTooltip.defaultPosition=['above', 'below']");
          domAttr.set(query('._common_propertyHoverHelpIcon')[0], "href", "#");
          
          var hh = new HoverHelpTooltip( {
            connectId : [ query('._common_propertyHoverHelpIcon')[0] ],
            label : NLS.brokerSecurityHelpText
          });
          hh.startup();
          secureText = "<div class='unsecureText'> - (" + NLS.brokerSecureText + ")</div>";
        }
      }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus"); 
    },
    
    contextButtonsClicks : function(event) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks", [event]);

  		// Get the URI and action from the event:
  		var uriAndAction = UIUtils.getURIAndAction(event, true);
  		var itemURI = uriAndAction.uri;
  		var buttonType = uriAndAction.action;

      this.actionBroker(itemURI, buttonType);
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
    },
    
    
    actionBroker : function(uri, action){
    	
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionBroker", [uri,action]);

      var uriArray = uri.split("_");
      var buttonType = uriArray[uriArray.length - 1];
      uri = uri.substr(0,uri.length - buttonType.length - 1);

      if ( action === "exportPortConfigurationAsWASPlugin" ) {
        uri = uri + "/portconfigurationexportaswasplugin";
      } else if ( action === "exportPortConfigurationAsModProxyModule" ) { 
        uri = uri + "/portconfigurationexportasmodproxymodule";
      }

      /*

        Downloading a file resource from a server and prompting the
        user with the browser's "File Save" dialog, cannot be
        done using ajax  dojo  xhr.get.

        All discussion groups on this matter suggest using
        a hidden iframe with src attribute to achieve this.
        This starts a separate thread. The user is free to
        interact with other web ui elements in the meantime.
        When the server response finally comes back, the user
        will be prompted with the File Save dialog if-and-only-if
        the browser settings are set to "Prompt where to save downloads"; otherwise
        user will not be prompted, and the file will be downloaded
        to the specified download directory.
        
        Look at webadmin/ImbRootRequestHandler.java
        methods : exportPortConfigurationAsModProxyModule(), exportPortConfigurationAsWASPlugin()
        to understand how the response is constructed.

      */

      ready(function(){  
        var ifrm = document.createElement("IFRAME");
    	  ifrm.setAttribute("src", uri);
    	  document.body.appendChild(ifrm); 
      });

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionBroker");
    },
      
      
    tabBlur: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
      
      this.properties.unsubscribeAll();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur"); 
    }
	});
	return brokerOverview;
});

},
'webui/widgets/executiongroup/eg_resource_statistics':function(){
/* 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63" 
 * years="2013" 
 * crc="1195428145" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63 
 *  
 * (C) Copyright IBM Corp. 2013 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/executiongroup/templates/eg_resource_statistics.html",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/array",
  "dojo/_base/lang",
  "dojo/_base/declare", 
  "dojo/aspect",
  "dojo/date",
  "dojo/date/locale",
  "dojo/dom",
  "dojo/dom-class",
  "dojo/dom-construct",
  "dojo/has",
  "dojo/hash",
  "dojo/on",
  "dojo/string",  
  "dojo/topic",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase",
  "dijit/_WidgetsInTemplateMixin",
  "dijit/form/Select",
  "webui/utils/StatsUtils",
  "webui/utils/WebUiHash",
  "webui/widgets/common/AttributesStore",
  "webui/widgets/common/PropertiesStore",
  "webui/widgets/common/Toolbar",
  "webui/widgets/common/Trace",
  "webui/widgets/executiongroup/ResourceStatisticsGrid",
  "webui/widgets/executiongroup/ResourceStatisticsChart",
  "dijit/layout/BorderContainer",  
  "dijit/layout/ContentPane",
  "dojo/domReady!"
], function(
  template,
  NLS,
  array,
  lang,
  declare,
  aspect,
  date,
  locale,
  dom,
  domClass,
  domConstruct,
  has,
  hash,
  on,
  string,
  Topic,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  Select,
  StatsUtils,
  WebUiHash,
  AttributesStore,
  PropertiesStore,
  Toolbar,
  Trace
) {

  return declare("webui.widgets.executiongroup.eg_resource_statistics", [ _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin ], {
    templateString: template,
    toolbar: null,
    _statsTopicHandle: null,
    _statsTopicName: null,
    notificationHandle: null,
    _propertiesStore: new PropertiesStore(),
    _attributesStore : new AttributesStore(),
    _sessionData: {},
    _sessionStartTime: null,
    _resourceStatsOn: false,
    NLS: NLS, // for the template

    constructor: function(args) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");

      if (args && args.event && args.event.type == "executionGroup") {
        this.executionGroupName = args.event.name; 
        this._uri = args.event.uri;
      }
      
      this.pane2Title = NLS.egResourceStatistics;
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
    },
    
    postCreate: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);
            
      // Create main toolbar
      this.toolbar = new Toolbar();
      domConstruct.place(this.toolbar.domNode, this._toolbar);
      this.toolbar.addLeftAlignButtons("title");
      
      /*
       * Now perform some feature detection on the browser to determine whether
       * to display the "Download data" button.  This capability requires
       * various aspects of the HTML5 File API.
       */
      if (window.Blob && window.File && window.URL) {
        var buttons = ["downloadData"];
        this.toolbar.addRightAlignButtons(buttons);
        this.toolbar.addRightAlignButtons("spacer");
        this.toolbar.getButton("downloadData").set("disabled", true);
        
        // Add an event handler for the "Download data" button:
        this.toolbar.connectButtons("downloadData", "click", this, "_onDownloadDataClicked");
      }
      
      this.populatAttributesPromise = this._attributesStore.populateAttributesStore(); 

      //-----------Pane 1--------------
      /*
       * Modify the various classes applied to the title pane to make it stretch
       * the width of the content pane.
       */
      domClass.remove(this.pane1.focusNode, "dijitTitlePaneTitleFocus");
      domClass.add(this.pane1.focusNode, "_common_propertyTitle");
      domClass.add(this.pane1.focusNode, "stats_titlePane");
      
      /*
       * Create the "toolbar" for the title pane.  Add this as the last child
       * of the panes "titleBarNode" so that it is actually part of the title
       * pane.  We need to do this programmatically because we cannot modify
       * the template for the dijit.TitlePane that ships with Dojo. 
       */
      var TrendGraphButtonsDiv = domConstruct.create("div", {
          className: "ResourceStatsTitleBarMenuDiv",
          id: "TrendGraph_ButtonsDiv"
        }, this.pane1.titleBarNode);
      domConstruct.create("span", {
          className: "toolbarWidgetSpacer",
          innerHTML: NLS.statistics.messageFlow_trendToolbar_setX_Label
        }, TrendGraphButtonsDiv);
      var sessionRangeSelect = new Select({
          name: "sessionRangeSelect",
          className: "ResourceStatsTitleBarSelect",
          options: [
            { label: NLS.statistics.messageFlow_trendToolbar_range_Session, value: "0" },//numeric 0 behaves oddly in the selection
            { label: NLS.statistics.messageFlow_trendToolbar_range_5mins,   value: 300},
            { label: NLS.statistics.messageFlow_trendToolbar_range_15mins,  value: 900},
            { label: NLS.statistics.messageFlow_trendToolbar_range_30mins,  value: 1800},
            { label: NLS.statistics.messageFlow_trendToolbar_range_60mins,  value: 3600}
          ],
          onChange: lang.hitch(this, function(sessionSeconds) {
            this._resourceStatisticsChart1.setChartTimeRange(sessionSeconds);
            this._resourceStatisticsChart2.setChartTimeRange(sessionSeconds);
            this._resourceStatisticsChart3.setChartTimeRange(sessionSeconds);
          }) 
        });
      sessionRangeSelect.startup();
      domConstruct.place(sessionRangeSelect.domNode, TrendGraphButtonsDiv);
      
      // Set the default metric indices for each of the chart widgets
      this._resourceStatisticsChart1.setDefaultMetricIndex(0);
      this._resourceStatisticsChart2.setDefaultMetricIndex(1);
      this._resourceStatisticsChart3.setDefaultMetricIndex(2);
      
      
      // Watch click events in case a resize is needed upon showing the message stats chart
      this.own(on(this.pane1, "click", lang.hitch(this, this._onStatsChartTitlePaneOpen)));
      
      //-----------End Pane 1----------
            
      //-----------Pane 2--------------
      /*
       * Modify the various classes applied to the title pane to make it stretch
       * the width of the content pane.
       */
      domClass.remove(this.pane2.focusNode, "dijitTitlePaneTitleFocus");
      domClass.add(this.pane2.focusNode, "_common_propertyTitle");
      domClass.add(this.pane2.focusNode, "stats_titlePane");
        
      /*
       * Create the "toolbar" for the title pane.  Add this as the last child
       * of the panes "titleBarNode" so that it is actually part of the title
       * pane.  We need to do this programmatically because we cannot modify
       * the template for the dijit.TitlePane that ships with Dojo. 
       */
      var resourceTypeDropDownDiv = domConstruct.create("div", {
        className: "ResourceStatsTitleBarMenuDiv",
        id: "resourceTypeDropDownDiv"
      }, this.pane2.titleBarNode);
      domConstruct.create("span", {
        className: "toolbarWidgetSpacer",
        innerHTML: NLS.resource_statistics_resource_type_Label
      }, resourceTypeDropDownDiv);
      
      var resourceTypes = this._resourceStatsGrid.getResourceTypes();
      var currentResourceType = this._resourceStatsGrid.getCurrentResourceType();
      var options = [];
      resourceTypes.forEach(function(resourceType) {
        var option = { label: NLS[resourceType], value: resourceType };
        if (resourceType == currentResourceType) {
          option.selected = true;
        }
        options.push(option);
      }); // FOR
      
      // Sort the options array based on the current browser locale
      options.sort(function(option1, option2) {
        return option1.label.localeCompare(option2.label);
      });
      
      // Create the resource type drop down
      this._resourceTypeSelect = new Select({
        name: "resourceTypeSelect",
        className: "ResourceStatsTitleBarSelect",
        options: options,
        onChange: lang.hitch(this, function(resourceType) {
          this._resourceStatsGrid.setCurrentResourceType(resourceType);
          this._resourceStatisticsChart1.setCurrentResourceType(resourceType);
          this._resourceStatisticsChart2.setCurrentResourceType(resourceType);
          this._resourceStatisticsChart3.setCurrentResourceType(resourceType);
        }) 
      });
      this._resourceTypeSelect.startup();
      domConstruct.place(this._resourceTypeSelect.domNode, resourceTypeDropDownDiv);
      //-----------End Pane 2----------

      // Setup up listeners for events from the data grid
      this.own(aspect.after(this._resourceStatsGrid, "onResourceSelected", lang.hitch(this, function(resourceIds) {
        this._resourceStatisticsChart1.setCurrentResourceIds(resourceIds);
        this._resourceStatisticsChart2.setCurrentResourceIds(resourceIds);
        this._resourceStatisticsChart3.setCurrentResourceIds(resourceIds);
      }), true));
      this.own(aspect.after(this._resourceStatsGrid, "onResourceMouseOver", lang.hitch(this, function(resourceId) {
        this._resourceStatisticsChart1.setLineHighlight(resourceId, true);
        this._resourceStatisticsChart2.setLineHighlight(resourceId, true);
        this._resourceStatisticsChart3.setLineHighlight(resourceId, true);
      }), true));
      this.own(aspect.after(this._resourceStatsGrid, "onResourceMouseOut", lang.hitch(this, function(resourceId) {
        this._resourceStatisticsChart1.setLineHighlight(resourceId, false);
        this._resourceStatisticsChart2.setLineHighlight(resourceId, false);
        this._resourceStatisticsChart3.setLineHighlight(resourceId, false);
      }), true));

      // Setup up listeners for events from the chart widget
      this.own(aspect.after(this._resourceStatisticsChart1, "onLineCreated", lang.hitch(this, function(resourceId, color) {
        this._resourceStatsGrid.setResourceLegendColor(resourceId, color);
      }), true));
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },
        
    startup: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "startup");
      this.inherited(arguments);

      this.toolbar.setAttribute("title", "innerHTML", NLS.resourceStatisticsAnalysis);
          
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "startup");
    },
    
    _onStatsChartTitlePaneOpen: function() {
      if((this.pane1.open) &&
          (this._resourceStatisticsChart1 && this._resourceStatisticsChart2 && this._resourceStatisticsChart3)) {
        this._resizeResourceStatisticsCharts();
        }
    },

    tabFocus: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");

      this.resize();
            
      this.populatAttributesPromise = this._attributesStore.populateAttributesStore();
      this.populatAttributesPromise.then(lang.hitch(this, function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus.populatePropertiesStore().then");

        if (window.WebSocket) {
          var notificationsTopicName = new WebUiHash(hash()).getNotificationTopic();

          //TODO: DOJO_UPGRADE_FIX_REQUIRED
          if(this._attributesStore.getAttribute("resourceStatsEnabled") == null){
              console.error("Error, properties stor attribute store doesn't have a snaphotStatistics section",
              this._attributesStore,this._attributesStore.getAttribute("snapshotStatistics"));
              //sometimes seeing the above as null. Causes error in console (when destroying stats tab?), but not sure if anything else breaks.
              //TypeError {stack: "TypeError: Cannot read property 'enabled' of undef")?    at complete (/dojo/_base/Deferred.js:168:4)", declaredClass: "uniqName_2", getMessage: function}
              // "TypeError: Cannot read property 'enabled' of undefined
              //    at eval (/webui/widgets/msgflows/msgflow_statistics.js:376:90)
              //    at eval (/dojo/_base/lang.js:375:55)
              //    at notify (/dojo/_base/Deferred.js:187:23)
              //    at complete (/dojo/_base/Deferred.js:168:4)
              //    at resolve.callback (/dojo/_base/Deferred.js:248:4)
              //    at notify (/dojo/_base/Deferred.js:196:69)
              //    at complete (/dojo/_base/Deferred.js:168:4)
              //    at resolve.callback (/dojo/_base/Deferred.js:248:4)
              //    at notify (/dojo/_base/Deferred.js:204:25)
              //    at complete (/dojo/_base/Deferred.js:168:4)" 
              return;
          }
          
          //Do a resize to get the initial size of the rave widgets correct
          this.resize();
          
          //Start with widgets knowing the correct state of stats
          this._performExecutionGroupCheck();

          // Do a dojo subscribe for any changes (AdminNotification's) to the current flow so we can recheck
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "registering for notifications on topic "+notificationsTopicName);
          this.notificationHandle = Topic.subscribe(notificationsTopicName, lang.hitch(this, this._performExecutionGroupCheck));

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus.populatePropertiesStore");   
        } else {
          window.smallMessage.displayMessage("warning", "WebSocket_unsupported", "", NLS.messages.WebSocket_unsupportedDescription);
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus.populatePropertiesStore().then");
      }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
    },
        
    _performExecutionGroupCheck: function() {
      // Check on startup, and then on flow property change, whether stats are enabled.
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_performExecutionGroupCheck");
      var populatAttributesPromise = this._attributesStore.populateAttributesStore();           
      
      // When both attributes (for stats) and basic properties (for run state) are populated, 
      // do the check.
      populatAttributesPromise.then(lang.hitch(this, function() {
        var populatePropertiesPromise = this._propertiesStore.populatePropertiesStore(this._uri);
        populatePropertiesPromise.then(lang.hitch(this, function() {
          // Once the store has been loaded we now want to get the basic property values
          this.queueManagerName = window.brokerProperties.getProperty("advanced", "queueManager");
          
          //TODO: Check for MQTT not QM
          //if ((!this.queueManagerName) || (this.queueManagerName === "")) {
          //  window.smallMessage.displayMessage("error", "PubSub_unavailable", "",
          //    NLS.messages.PubSub_unavailableDescription);
          //  return;                          
          //}
          var testMode     = StatsUtils.isTestingOn();
          var isRunning    = this._propertiesStore.getProperty("basic", "isRunning");
          var statsOn      = this._attributesStore.getAttribute("resourceStatsEnabled");
         
          /*
           * Check to see whether the execution group is running and resource
           * statistics are enabled and then displayed a suitable message.
           */
          if (isRunning == "true" && statsOn) {
            // Subscribe to the resource stats topic
            this._subscribeToResourceStatsTopic();
            
            /*
             * We will be notified of any admin event that occurs on this
             * exectution group by any user... not just when resource 
             * statistics are enabled or disabled.  Only initialize the 
             * session if the state stored on the browser indicates that 
             * resource statistics were previously disabled. 
             */
            if (!this._resourceStatsOn) {
              this.pane1.titleNode.innerHTML = NLS.messages.NoDataYet_XX;
              
              // Create a clean set of session data
              this._initializeSession();              
            }
          } else {
            this.pane1.titleNode.innerHTML = NLS.messages.NoData_XX;
            
            // Unsubscribe from the resource stats topic
            this._unsubscribeFromResourceStatsTopic();
          }

          // Store the resource stats state locally
          this._resourceStatsOn = statsOn;
          
          /*
           * Show error message if Execution Group is not running and we are
           * not in testing mode
           */ 
          if ((isRunning=="false") && !testMode) {
            // Execution Group is not running
            window.smallMessage.displayMessage("warning", "EGNotRunning_XX", "", NLS.messages.EGNotRunningDescription);
            this._resourceStatsGrid.removeNodesFromTable();
          } else if (!statsOn && !testMode) {
            // Resource statistics are off
            window.smallMessage.displayMessage("warning", "EGResourceStatsOff_XX", "", NLS.messages.EGResourceStatsOffDesc_XX);
          } else {
            // Looks good - cancel any previous messages
            window.smallMessage.hideMessage();
          }
        }));
      }));
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_performExecutionGroupCheck");
    },
        
    tabBlur: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");

      window.smallMessage.hideMessage();

      if (window.WebSocket) {
        // Unsubscribe from the resource stats topic
        this._unsubscribeFromResourceStatsTopic();
        
        // Remove the notification subscribe handle
        if (this.notificationHandle) {
          this.notificationHandle.remove();
          this.notificationHandle = null;
        }
        
        // Create a clean set of session data
        this._initializeSession();              
      }  

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
    },
        
    tabRemove: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");

      window.smallMessage.hideMessage();
      
      if (window.WebSocket) {
        // Unsubscribe from the resource stats topic
        this._unsubscribeFromResourceStatsTopic();
        
        // Remove the notification subscribe handle
        if (this.notificationHandle) {
          this.notificationHandle.remove();
          this.notificationHandle = null;
        }
        
        // Create a clean set of session data
        this._initializeSession();              
      }  
            
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
    },
        
    resize: function(){
      
      this._resizeResourceStatisticsCharts();
      
      this._resourceStatistics_borderContainer.resize();
      
    },
    
    _resizeResourceStatisticsCharts: function() {
      if(this.pane1.open) {
        if( dom.byId("resourceStatsContainerDiv")){
            if (this._resourceStatisticsChart1) {
              this._resourceStatisticsChart1.resize();
            }
            if (this._resourceStatisticsChart2) {
              this._resourceStatisticsChart2.resize();
            }
            if (this._resourceStatisticsChart3) {
              this._resourceStatisticsChart3.resize();
            }
        }
      }
    },

    _subscribeToResourceStatsTopic: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_subscribeToResourceStatsTopic");
      
      // Subscribe to the topic topicName
      if (!this._statsTopicHandle) {
        this._statsTopicName = new WebUiHash(hash()).getResourceStatsTopic();
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Registering for topic: " + this._statsTopicName);
        this._statsTopicHandle = Topic.subscribe(this._statsTopicName, lang.hitch(this, this._receivePublication ));
        
        // Inform the wsHandler to subscribe to the new topicName
        window.wsConnection.subscribe(this._statsTopicName);
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_subscribeToResourceStatsTopic");
    },

    _unsubscribeFromResourceStatsTopic: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_unsubscribeFromResourceStatsTopic");
      
      // Inform the wsHandler to unsubscribe
      if (this._statsTopicHandle) {
        window.wsConnection.unsubscribe(this._statsTopicName);
        
        // Unsubscribe from the resource stats topic
        this._statsTopicHandle.remove();
        this._statsTopicHandle = null;
        this._statsTopicName = null;
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_unsubscribeFromResourceStatsTopic");
    },
    
    /**
     * The _onDownloadDataClicked function handles the click of the "Download
     * data" button in the toolbar.  It generates a CSV file containing the 
     * resource statistics for the selected resource for the current session
     * and then gets the browser to download the file. 
     */
    _onDownloadDataClicked: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onDownloadDataClicked");

      // Generate the content of the download file from the session data
      var fileContent = this._generateDownloadDataFileContent();
      
      // Get the browser to prompt the user to save the file
      this._downloadData(fileContent);
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onDownloadDataClicked");
    },

    /**
     * The _generateDownloadDataFileContent function generates the content of
     * the CSV file containing the resource statistics for the selected resource
     * for the current session. 
     */
    _generateDownloadDataFileContent: function(){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_generateDownloadDataFileContent");
      
      // Create the variable to return
      var fileContent = "";

      /*
       * First, perform some basic checks, i.e., do we have some session data
       * for the currenty selected resource type. 
       */
      if (this._sessionData) {
        var currentResourceType = this._resourceTypeSelect.get("value");
        var resourceTypeData = this._sessionData[currentResourceType];
        if (resourceTypeData) {
          
          var ignoredAttributes = [
            "name",
            "date",
            "legend",
            "dummy",
            "Protocol",
            "NameOfJDBCProvider",
            "PolicySetApplied"
          ];

          Object.keys(resourceTypeData).forEach(lang.hitch(this, function(resourceId) {
            var resourceSessionData = resourceTypeData[resourceId];
            
            /*
             * Generate the "header" section of the CSV file for the current
             * resource.
             * 
             * Format:
             * 
             *   Integration Node, Integration Server, Resource Type, Resource Id
             *   IB9NODE, default, JVM, summary
             */
            fileContent += NLS.brokerTitle +
                         "," +
                         NLS.executionGroupTitle +
                         "," +
                         NLS.resource_statistics_resource_type +
                         "," +
                         NLS.resource_statistics_resource_identifier +
                         "\r\n" +
                         window.brokerName +
                         "," +
                         this.executionGroupName +
                         "," +
                         currentResourceType +
                         "," +
                         resourceId +
                         "\r\n";

            /*
             * Now iterate over session data for the current resource and add
             * a line to the file content for each one.
             */
            array.forEach(resourceSessionData, lang.hitch(this, function(item, index) {
              /*
               * The first line of the session data contains the names of the
               * attributes that are monitored for this resource type, i.e.,
               * the column headings.
               * 
               * The remaining lines contain the values for the session data,
               * one line for each entry. 
               *  
               * Format:
               * 
               *   ATTR_NAME_1, ATTR_NAME_2, ATTR_NAME_3... ATTR_NAME_N 
               *   ATTR_VALUE_1, ATTR_VALUE_2, ATTR_VALUE_3... ATTR_VALUE_N
               *   ATTR_VALUE_1, ATTR_VALUE_2, ATTR_VALUE_3... ATTR_VALUE_N
               *   ATTR_VALUE_1, ATTR_VALUE_2, ATTR_VALUE_3... ATTR_VALUE_N
               *   ATTR_VALUE_1, ATTR_VALUE_2, ATTR_VALUE_3... ATTR_VALUE_N
               */
              var attribute;
              if (index == 0) {
                // Always add the "snapshot time" as the first column
                fileContent += NLS.resource_statistics_snapshot_time;

                /*
                 * Now add the other attributes that we are interested in, i.e.,
                 * ignore the name, date, legend and dummy attributes.
                 */
                for (attribute in item) {
                  if (ignoredAttributes.indexOf(attribute) == -1) {
                    // Add a comma and then the attribute name
                    fileContent += ",";
                    fileContent += NLS[attribute];
                  }
                } // FOR

                // Add the newline to the end
                fileContent += "\r\n";
              } else { // IF - index == 0
                // Always add the "snapshot time" as the first column
                fileContent += locale.format(new Date(item.date), {selector: "time", timePattern: "H:m:s"});
                
                /*
                 * Now add the other attributes that we are interested in, i.e.,
                 * ignore the name, date, legend and dummy attributes.
                 */
                for (attribute in item) {
                  if (ignoredAttributes.indexOf(attribute) == -1) {
                    // Add a comma and then the attribute value
                    fileContent += ",";
                    fileContent += item[attribute];
                  }
                } // FOR
                
                // Add the newline to the end
                fileContent += "\r\n";
              }
            })); // FOREACH
            
            // Add an additional newline to separate each data set
            fileContent += "\r\n";
          })); // FOREACH
        } // IF - resourceTypeData
      } // IF - this._sessionData
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_generateDownloadDataFileContent");
      return fileContent;
    },

    /**
     * The _downloadData function generates a Blob from the specified file
     * content and then gets the browser to "download" the generated Blob.
     * Note that no network request takes place because this is all happening
     * on the browser. 
     * 
     * @param fileContent
     *          The content of the file to "download".
     */
    _downloadData: function(fileContent){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_downloadData");
      
      // Create the Blob object that contains the contents of the file
      var currentResourceType = this._resourceTypeSelect.get("value");
      var dateTimeSuffix = locale.format(new Date(this._sessionStartTime), {selector: "date", datePattern: "yyyyMMdd_HHmmss"});
      var fileName = NLS.resource_statistics_file_prefix + "_" + currentResourceType + "_" + dateTimeSuffix + ".csv";
      var generatedBlob = new Blob([ fileContent ], {type: "text/csv"});
      generatedBlob.name = fileName;
      generatedBlob.lastModified = new Date(this._sessionStartTime);
      
      /*
       * The download attribute on anchor elements is not currently supported on
       * all browsers, so we need to check the type of browser that we are 
       * running on.  Up-to-date support information can be found at: 
       * 
       *   http://caniuse.com/#feat=download
       *   
       * has("ie") will work for versions of IE < 11 and for IE 11 when
       * running as an earlier version using compatibility mode.  For IE 11
       * specifically, we need to use has("trident"), which is the native
       * browser engine for IE 11.
       */
      if (has("ie") || has("trident")) {
        /*
         * IE does not support the download atttribute.  Use the IE specific
         * msSaveOrOpenBlob API instead.
         */
        window.navigator.msSaveOrOpenBlob(generatedBlob, fileName);
      } else {
        /*
         * For FF, Chrome and Safari, we add an anchor (link) element to the 
         * page and simulate a click on the link.  We use the download attribute
         * to tell the browser to download the resource that the anchor points 
         * to rather than navigate to it.
         */
        var url = URL.createObjectURL(generatedBlob);
        var downloadLink = document.createElement("a");
        downloadLink.download = fileName;
        downloadLink.innerHTML = "Download File";
        downloadLink.href = url;

        if (has("safari")) {
          /*
           * Horrible workaround for Safari that encodes the data into the URL.
           * This enables the file to be opened in a new tab in the browser, 
           * allowing the user to stay on the Resource Stats page in a different
           * tab.  Not sure if this approach will hit a limit on the URL length
           * in Safari.
           * 
           * If this code is not included, the file is opened on the same tab
           * that was displaying the IIB Web UI, i.e., the user is navigated
           * away from the Web UI and their session data will be lost. 
           */
          downloadLink.href = "data:application/octet-stream;charset=utf-8," + encodeURIComponent(fileContent);
          downloadLink.target = "_blank";
        }
        downloadLink.onclick = function(event) {
          document.body.removeChild(event.target);

          /*
           * Always remember to revoke the url.  We do this after a short delay
           * to workaround an issue in FF where the URL is revoked before the
           * browser has had a chance to respond to the programmatic click
           * event.
           */
          setTimeout(lang.hitch(this, function() {
            URL.revokeObjectURL(url);
          }), 100);
        };
        downloadLink.style.display = "none";
        document.body.appendChild(downloadLink);
        downloadLink.click();
      } 
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_downloadData");
    },
    
    _receivePublication: function(message){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_receivePublication");

      /*
       * Parse the resource statistics data and process it.  This widget handles
       * all of the data processing and then passes the processed data down to 
       * the contained widgets for display.  This allows us to just maintain
       * a single subscription to the server over the websocket.
       * 
       * Start by iterating over each of the resource types contained in the
       * data.
       */
      var resourceStatsData = JSON.parse(message.payloadString);
      var now = new Date().getTime();
      array.forEach(resourceStatsData.ResourceStatistics.ResourceType, lang.hitch(this, function(resourceTypeData) {
        /*
         * Retrieve the session data for this resource type.  If we do not have
         * an entry in the session data for this resource type, create one.
         */
        var resourceTypeSessionData = this._sessionData[resourceTypeData.name];
        if (!resourceTypeSessionData) {
          resourceTypeSessionData = {};
          this._sessionData[resourceTypeData.name] = resourceTypeSessionData;
        }
        
        /*
         * Now iterate over each of the resources being monitored for this
         * resource type.
         */
        array.forEach(resourceTypeData.resourceIdentifier, lang.hitch(this, function(data) {
          /*
           * Retrieve the session data for this specific resource.  If we do not
           * have an entry in the session data for this resource, create one.
           * The entries for a specific resource are stored in an array, with
           * each entry representing a snapshot of the metrics at a specified
           * time.
           */
          var resourceSessionData = resourceTypeSessionData[data.name];
          if (!resourceSessionData) {
            resourceSessionData = [];
            
            /*
             * Inject a dummy entry as the first element of the array to ensure
             * that the graph renders in a sensible manner.  This entry needs to
             * be ignored when calculating things like min, max and average.
             */
            var dummyData = lang.clone(data);
            for (var metricKey in dummyData) {
              if (metricKey != "name") {
                dummyData[metricKey] = 0;
              }
            } // FOR
            dummyData.date = this._sessionStartTime;
            dummyData.legend = "";
            dummyData.dummy = true;
            resourceSessionData.push(dummyData);

            // Store the session data with the dummy entry
            resourceTypeSessionData[data.name] = resourceSessionData;
          }

          // Add the date to the data and store it
          data.date = now;
          data.legend = "";
          resourceSessionData.push(data);
        }));
      }));

      // Determine if the download data button should be enabled
      if (Object.keys(this._sessionData).length > 0) {
        this.toolbar.getButton("downloadData").set("disabled", false);
      }
      
      /*
       * Update the title for the top pane.  We need to calculate a number of
       * string inserts before setting the title.  Format of the string needs to
       * be:
       * 
       *    Updates from ${startTime} (${minutes} ${minString} ago). Last 
       *    updated at ${nowTime}
       * 
       * For example:
       * 
       *    Updates from 16:55:51 GMT Standard Time (<1 minute ago). Last 
       *    updated at 16:56:11 GMT Standard Time
       */
      var startTime = new Date(this._sessionStartTime);
      var endDateObj = new Date(now);
      var sessionMinutes = parseInt(date.difference(startTime, endDateObj, "second")/60);
      var startTimeStr = StatsUtils.formatToTime(startTime);                        
      var endTimeStr = StatsUtils.formatToTime(endDateObj);
      var minString = NLS.statistics.minute;
      if (sessionMinutes == 0){
        sessionMinutes = "&lt;1";
      } else if (sessionMinutes > 1) {
        minString = NLS.statistics.minutes;
      }
      this.pane1.titleNode.innerHTML = string.substitute(
        NLS.statistics.statsTrend_session_description, {
          startTime: startTimeStr,
          minutes: sessionMinutes,
          minString: minString,
          nowTime: endTimeStr
        });
      
      /*
       * Pass the relevant data down to the widgets contained on the page for
       * display.
       */
      this._resourceStatisticsChart1.refresh();
      this._resourceStatisticsChart2.refresh();
      this._resourceStatisticsChart3.refresh();
      if (this._resourceStatsGrid) {
        this._resourceStatsGrid.updateResourceStatsData(resourceStatsData);
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_receivePublication");
    },

    _initializeSession: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_initializeSession");

      // Create a clean set of session data
      this._sessionStartTime = new Date().getTime();
      this._sessionData = {};
      this.toolbar.getButton("downloadData").set("disabled", true);
      this._resourceStatisticsChart1.setSessionData(this._sessionData, this._sessionStartTime);
      this._resourceStatisticsChart2.setSessionData(this._sessionData, this._sessionStartTime);
      this._resourceStatisticsChart3.setSessionData(this._sessionData, this._sessionStartTime);
      
      // Clear any data from a previous session if it is still being displayed.
      this._resourceStatisticsChart1.refresh();
      this._resourceStatisticsChart2.refresh();
      this._resourceStatisticsChart3.refresh();
      this._resourceStatsGrid.removeNodesFromTable();
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_initializeSession");
    }

  });// end declare
});// end define

},
'webui/widgets/msgflows/msgflow_statistics':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2013,2016" 
 * crc="1195428145" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.  
 * </copyright> 
 */
define(
  [
    "dojo/text!webui/widgets/msgflows/templates/msgflow_statistics.html",
    "dojo/i18n!webui/nls/web",
    "dojo/_base/declare", 
    "dojo/_base/lang",
    "dojo/date",
    "dojo/dom",
    "dojo/dom-class",
    "dojo/dom-construct", 
    "dojo/hash", 
    "dojo/on",
    "dojo/request/xhr",
    "dojo/string",
    "dojo/topic", 
    "dijit/_TemplatedMixin", 
    "dijit/_WidgetBase", 
    "dijit/_WidgetsInTemplateMixin",
    "dijit/form/Select", 
    "webui/utils/StatsUtils",
    "webui/utils/WebUiHash",
    "webui/widgets/common/AttributesStore",
    "webui/widgets/common/D3FlowDiagram",
    "webui/widgets/common/PropertiesStore",
    "webui/widgets/common/Toolbar",
    "webui/widgets/common/Trace",
    "webui/widgets/msgflows/MessageFlowStatisticsChart",
    "webui/widgets/msgflows/MessageFlowStatisticsGrid",
    "dojo/domReady!"
  ], function(
    template, 
    NLS,
    declare,
    lang,
    date,
    dom,
    domClass,
    domConstruct,
    hash,
    on,
    xhr,
    string,
    Topic,
    _TemplatedMixin,
    _WidgetBase,
    _WidgetsInTemplateMixin,
    Select,
    StatsUtils,
    WebUiHash,
    AttributesStore,
    D3FlowDiagram,
    PropertiesStore,
    Toolbar,
    Trace
  ) {
  var populatAttributesPromise;
    
  return declare(
    "webui.widgets.msgflows.msgflow_statistics",
    [ _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin ],
    {
      templateString : template,
      toolbar : null,
      _statsTopicHandle : null,
      notificationHandle : null,
      _propertiesStore : new PropertiesStore(),
      _attributesStore : new AttributesStore(),
      flowDiagramWidget: null,
      _sessionData: [],
      _sessionStartTime : null,
      _messageFlowStatsOn: false,
      _statsTopicName : null,

      constructor: function(args) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");
      
        if (args && args.event && args.event.type == "messageFlow") {
          this._uri = args.event.uri;
        }
      
        /*
         * Associate the NLS resources with this widget so that we can
         * declaratively reference resources in the template markup.
         */
        this.NLS = NLS;
        
        this.pane2Title = string.substitute(NLS.statisticsNodesInFlow, [""]);
      
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
      },
    
      postCreate : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
        this.inherited(arguments);
      
        // Create main toolbar
        this.toolbar = new Toolbar();
        domConstruct.place(this.toolbar.domNode, this._toolbar);
        this.toolbar.addLeftAlignButtons("title");
        this.populatAttributesPromise = this._attributesStore.populateAttributesStore();
      
        //-----------Pane 1--------------
      
        /*
         * Modify the various classes applied to the title pane to make it stretch
         * the width of the content pane.
         */
        domClass.remove(this.pane1.focusNode, "dijitTitlePaneTitleFocus");
        domClass.add(this.pane1.focusNode, "_common_propertyTitle");
        domClass.add(this.pane1.focusNode, "stats_titlePane");
           
        /*
         * Create the "toolbar" for the title pane.  Add this as the last child of
         * the panes "titleBarNode" so that it is actually part of the title pane.
         * We need to do this programmatically because we cannot modify the 
         * template for the dijit.TitlePane that ships with Dojo. 
         */
        var TrendGraphButtonsDiv = domConstruct.create("div", {
            className: "TrendGraphButtonsDiv",
            id: "TrendGraph_ButtonsDiv"
          }, this.pane1.titleBarNode);
        domConstruct.create("span", {
            className: "toolbarWidgetSpacer",
            innerHTML: NLS.statistics.messageFlow_trendToolbar_setX_Label
          }, TrendGraphButtonsDiv);
        var sessionRangeSelect = new Select({
            name: "sessionRangeSelect",
            className: "ResourceStatsTitleBarSelect",
            options: [
              { label: NLS.statistics.messageFlow_trendToolbar_range_Session, value: "0" },//numeric 0 behaves oddly in the selection
              { label: NLS.statistics.messageFlow_trendToolbar_range_5mins,   value: 300},
              { label: NLS.statistics.messageFlow_trendToolbar_range_15mins,  value: 900},
              { label: NLS.statistics.messageFlow_trendToolbar_range_30mins,  value: 1800},
              { label: NLS.statistics.messageFlow_trendToolbar_range_60mins,  value: 3600}
            ],
            onChange: lang.hitch(this, function(sessionSeconds) {
              this._messageFlowStatisticsChart1.setChartTimeRange(sessionSeconds);
              this._messageFlowStatisticsChart2.setChartTimeRange(sessionSeconds);
              this._messageFlowStatisticsChart3.setChartTimeRange(sessionSeconds);
            })
          });
        sessionRangeSelect.startup();
        domConstruct.place(sessionRangeSelect.domNode, TrendGraphButtonsDiv);

        // Set the default metric indices for each of the chart widgets
        this._messageFlowStatisticsChart1.setDefaultMetricIndex(0);
        this._messageFlowStatisticsChart2.setDefaultMetricIndex(1);
        this._messageFlowStatisticsChart3.setDefaultMetricIndex(2);
        
        // Watch click events in case a resize is needed upon showing the message stats chart
        this.own(on(this.pane1, "click", lang.hitch(this, this._onStatsChartTitlePaneOpen)));
      
        //-----------Pane 2--------------
        /*
         * Modify the various classes applied to the title pane to make it stretch
         * the width of the content pane.
         */
        domClass.remove(this.pane2.focusNode, "dijitTitlePaneTitleFocus");
        domClass.add(this.pane2.focusNode, "_common_propertyTitle");
        domClass.add(this.pane2.focusNode, "stats_titlePane");

        /*
         * Create the "toolbar" for the title pane.  Add this as the last child
         * of the panes "titleBarNode" so that it is actually part of the title
         * pane.  We need to do this programmatically because we cannot modify
         * the template for the dijit.TitlePane that ships with Dojo. 
         */
        var buttonsDiv = domConstruct.create("div", {
          className: "buttonsDiv",
          id: "messageFlows_buttonsDiv"
        }, this.pane2.titleBarNode);
        this.minButton = domConstruct.create("span", {
          className: "notSelectedDiv",
          innerHTML: NLS.messageFlow_monitoring_minimum
        }, buttonsDiv);
        domConstruct.create("span", {
          innerHTML: " | "
        }, buttonsDiv);
        this.avgButton = domConstruct.create("span", {
          className: "notSelectedDiv",
          innerHTML: NLS.messageFlow_monitoring_average
        }, buttonsDiv);
        domConstruct.create("span", {
          innerHTML: " | "
        }, buttonsDiv);
        this.maxButton = domConstruct.create("span", {
          className: "notSelectedDiv",
          innerHTML: NLS.messageFlow_monitoring_maximum
        }, buttonsDiv);

        domClass.add(this.avgButton, "selectedDiv");

        this.own(on(this.minButton,  "click", lang.hitch(this, this._minClicked))); 
        this.own(on(this.maxButton,  "click", lang.hitch(this, this._maxClicked)));
        this.own(on(this.avgButton,  "click", lang.hitch(this, this._averageClicked)));
 
        //-----------Pane 3--------------
        /*
         * Modify the various classes applied to the title pane to make it stretch
         * the width of the content pane.
         */
        domClass.remove(this.pane3.focusNode, "dijitTitlePaneTitleFocus");
        domClass.add(this.pane3.focusNode, "_common_propertyTitle");
        domClass.add(this.pane3.focusNode, "stats_titlePane");
        //-----------End Pane 3--------------
        // Watch click events in case a resize is needed
        this.own(on(this.pane3, "click", lang.hitch(this, this.onFlowProfilePaneOpen)));
      
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
      },
        
      startup: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "startup");
        this.inherited(arguments);

        this.toolbar.setAttribute("title", "innerHTML", NLS.statisticsFlowAnalysis);
          
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "startup");
      },
      
      _onStatsChartTitlePaneOpen: function() {
        if((this.pane1.open) &&
            (this._messageFlowStatisticsChart1 && this._messageFlowStatisticsChart2 && this._messageFlowStatisticsChart3)) {
          this._resizeMessageFlowStatisticsCharts();
          }
      },
        
      tabFocus : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");

        this.resize();
            
        this.populatAttributesPromise = this._attributesStore.populateAttributesStore();
        this.populatAttributesPromise.then(lang.hitch(this, function() {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus.populatePropertiesStore().then");

          if (window.WebSocket) {
            var webUiHash = new WebUiHash(hash());
            var notificationsTopicName = webUiHash.getNotificationTopic();
              
            //TODO: DOJO_UPGRADE_FIX_REQUIRED
            if(this._attributesStore.getAttribute("snapshotStatistics") == null) {
              console.error("Error, attribute store doesn't have a snaphotStatistics section",
                this._attributesStore,this._attributesStore.getAttribute("snapshotStatistics")
              );
              //sometimes seeing the above as null. Causes error in console (when destroying stats tab?), but not sure if anything else breaks.
              //TypeError {stack: "TypeError: Cannot read property 'enabled' of undef")?    at complete (/dojo/_base/Deferred.js:168:4)", declaredClass: "uniqName_2", getMessage: function}
              // "TypeError: Cannot read property 'enabled' of undefined
              //    at eval (/webui/widgets/msgflows/msgflow_statistics.js:376:90)
              //    at eval (/dojo/_base/lang.js:375:55)
              //    at notify (/dojo/_base/Deferred.js:187:23)
              //    at complete (/dojo/_base/Deferred.js:168:4)
              //    at resolve.callback (/dojo/_base/Deferred.js:248:4)
              //    at notify (/dojo/_base/Deferred.js:196:69)
              //    at complete (/dojo/_base/Deferred.js:168:4)
              //    at resolve.callback (/dojo/_base/Deferred.js:248:4)
              //    at notify (/dojo/_base/Deferred.js:204:25)
              //    at complete (/dojo/_base/Deferred.js:168:4)" 
              return;
            }
              
            // Do a resize to get the initial size of the stats widgets correct
            this.resize();
              
            // Start with widgets knowing the correct state of stats
            this.performFlowCheck("");
              
            // Do a dojo subscribe for any changes (AdminNotification's) to the current flow so we can recheck
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "registering for notifications on topic "+notificationsTopicName);
            this.notificationHandle = Topic.subscribe(notificationsTopicName, lang.hitch(this, this.performFlowCheck));
              
            Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus.populatePropertiesStore");   
          } else {
            window.smallMessage.displayMessage("warning", "WebSocket_unsupported", "", NLS.messages.WebSocket_unsupportedDescription);
          }
        
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus.populatePropertiesStore().then");
        }));
            
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
      },
        
      createFlowDiagram: function () {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createFlowDiagram");
        //Create flow diagram rave widget
        if(this.flowDiagramWidget != null) {
          try {
            this.flowDiagramWidget.destroy();
          } catch(e) {}
          this.flowDiagramWidget = null;
        }
        var isService = false;

        // Only draw a flow diagram if this isn't a Service
        if (hash()) {
          if(new WebUiHash(hash()).getRestUri().getParentArtifactRestUri().getArtifactType() === "services") {
            isService = true;
          }
        }
            
        if (!isService) {
          try {
            this.flowDiagramWidget = new D3FlowDiagram();
          } catch(e) {
            Trace.trace(this.flowDiagramWidget.declaredClass, Trace.levels.DEBUG, "D3FlowDiagram Error: " + e);
          }
                
          if(dom.byId("statistics_messageFlowDiagram")) {
            dom.byId("statistics_messageFlowDiagram").innerHTML = "";
            
            // Request flow diagram information
            xhr(this._attributesStore.getAttribute("flowDesignUri"), {
              handleAs : "json",
              headers : {
                "Accept" : "application/json"
              }
            }).then( lang.hitch(this, function(response) {
                if(this.flowDiagramWidget){
                  this.flowDiagramWidget.place("statistics_messageFlowDiagram", response);
                }
              }), lang.hitch(this, function(error) {
                Trace.trace(this.flowDiagramWidget.declaredClass, Trace.levels.DEBUG, "D3FlowDiagram Error: " + error.response.xhr.status + " Response: " + error.response.xhr.response);
              })
            );
          }
        } else { // End-if (!isService)
          // Show some text to say that a flow profile is not supported for Services in the web ui.
          dom.byId("statistics_messageFlowDiagram").innerHTML = NLS.serviceNoFlowProfileData+"<br>";
        }
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "createFlowDiagram");
      },
        
      performFlowCheck : function() {
        // Check on startup, and then on flow property change, whether stats are enabled.
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "performFlowCheck");
        populatAttributesPromise = this._attributesStore.populateAttributesStore();
        
        /*
         * When both attributes (for stats) and basic properties (for run state)
         * are populated, do the check.
         */
        populatAttributesPromise.then(lang.hitch(this, function() {
          var populatePropertiesPromise = this._propertiesStore.populatePropertiesStore(this._uri);
          populatePropertiesPromise.then(lang.hitch(this, function() {
            this.createFlowDiagram();
            
            // Once the store has been loaded we now want to get the basic property values
            this.queueManagerName = window.brokerProperties.getProperty("advanced", "queueManager");
            
            //TODO: Check for MQTT not QM
            //if ((!this.queueManagerName) || (this.queueManagerName === "")) {
            //  window.smallMessage.displayMessage("error", "PubSub_unavailable", "",
            //    NLS.messages.PubSub_unavailableDescription);
            //  return;
            //}
            var testMode     = StatsUtils.isTestingOn();
            var isRunning    = this._propertiesStore.getProperty("basic", "isRunning");
            var statsOn      = this._attributesStore.getAttribute("snapshotStatistics").enabled;
            var outputFormat = this._attributesStore.getAttribute("snapshotStatistics").outputFormat;
            var nodeLevel    = this._attributesStore.getAttribute("snapshotStatistics").nodeLevel;
            
            // Update the line graph as to the current state of stats.
            if ((isRunning=="true" && statsOn && outputFormat.json) || testMode) {
              // Subscribe to the message flow stats topic
              this._subscribeToMessageFlowStatsTopic();
              
              /*
               * We will be notified of any admin event that occurs on this
               * message flow by any user... not just when message flow
               * statistics are enabled or disabled.  Only initialize the
               * session if the state stored on the browser indicates that
               * message flow statistics were previously disabled.
               */
              if (!this._messageFlowStatsOn) {
                this.pane1.titleNode.innerHTML = NLS.messages.NoDataYet_XX;
                
                // Create a clean set of session data
                this._initializeSession();
              }
            } else {
              this.pane1.titleNode.innerHTML = NLS.messages.NoData_XX;
              
              // Unsubscribe from the message flow stats topic
              this._unsubscribeFromMessageFlowStatsTopic();
            }
            
            // Store the message flow stats state locally
            this._messageFlowStatsOn = statsOn;
            
            // show error message if flow is not running, statistics are off or not in json mode (and not testing mode)
            if ((isRunning=="false") && !testMode) {
              // Flow is not running
              window.smallMessage.displayMessage("warning", "FlowNotRunning_XX", "", NLS.messages.FlowNotRunningDescription);
              this._messageFlowStatsGrid.removeNodesFromTable();
            } else if (!statsOn && !testMode) {
              // Statistics are off
              window.smallMessage.displayMessage("warning", "StatsOff_XX", "", NLS.messages.NodeStatsOffSingleFlow_XX);
              this._messageFlowStatsGrid.removeNodesFromTable();
            } else if (outputFormat && !outputFormat.json) {
              // show error message if format not json - for now as we only control JSON statistics in the WebUI, have the same consistent error message shown
              //window.smallMessage.displayMessage("warning", "NotJson_XX", "", NLS.messages.StatsOffDescription);
              window.smallMessage.displayMessage("warning", "StatsOff_XX", "", NLS.messages.NodeStatsOffSingleFlow_XX);
              this._messageFlowStatsGrid.removeNodesFromTable();
            } else if (nodeLevel && nodeLevel=="none") {
              // show warning message if node stats are not switched on
              var flowName = this._attributesStore.getAttribute("name");
              window.smallMessage.displayMessage("warning", "NodeStatsOffSingleFlow_XX", "", string.substitute(NLS.messages.NodeStatsOffDescription, [flowName]));
            } else {
              // Looks good - cancel any previous
              window.smallMessage.hideMessage();
            }
          }));
        }));
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "performFlowCheck");
      },
      
      onFlowProfilePaneOpen: function() {
        // Resize the flow profile canvas (svg) if it is currently visible
        if(this.pane3.open && (this.flowDiagramWidget != null)) {
          this.flowDiagramWidget.resize();
        }
      },
      
      tabBlur : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
        
        window.smallMessage.hideMessage();

        if (window.WebSocket) {
          // Unsubscribe from the message flow stats topic
          this._unsubscribeFromMessageFlowStatsTopic();
          
          // Remove the notification subscribe handle
          if (this.notificationHandle) {
            this.notificationHandle.remove();
          }
          
          // Create a clean set of session data
          this._initializeSession();              
        }
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
      },
      
      tabRemove : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
        
        if (window.WebSocket) {
          // Unsubscribe from the message flow stats topic
          this._unsubscribeFromMessageFlowStatsTopic();
          
          // Remove the notification subscribe handle
          if (this.notificationHandle) {
            this.notificationHandle.remove();
          }
          
          // Create a clean set of session data
          this._initializeSession();              
        }
        
        if(this.flowDiagramWidget != null) {
          try {
            this.flowDiagramWidget.destroy();
          } catch(e) {}
          this.flowDiagramWidget = null;
        }
        
        // Clear table data before leaving the tab
        this._messageFlowStatsGrid.removeNodesFromTable();
          
        this._sessionStartTime = null;
          
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
      },
      
      resize: function(){
        
        this._resizeMessageFlowStatisticsCharts();
        
        // Resize the flow profile canvas (svg) if it is currently visible
        this.onFlowProfilePaneOpen();
        
        this._msgflowStatistics_borderContainer.resize();

      },
      
      _resizeMessageFlowStatisticsCharts: function() {
        if(this.pane1.open) {
          if( dom.byId("messageFlowStatsContainerDiv")){
            if (this._messageFlowStatisticsChart1) {
              this._messageFlowStatisticsChart1.resize();
            }
            if (this._messageFlowStatisticsChart2) {
              this._messageFlowStatisticsChart2.resize();
            }
            if (this._messageFlowStatisticsChart3) {
              this._messageFlowStatisticsChart3.resize();
            }
          }
        }
      },
      
      _subscribeToMessageFlowStatsTopic: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_subscribeToMessageFlowStatsTopic");
        
        // Subscribe to the topic topicName
        if (!this._statsTopicHandle) {
          this._statsTopicName = new WebUiHash(hash()).getStatsTopic();
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Registering for topic: " + this._statsTopicName);
          this._statsTopicHandle = Topic.subscribe(this._statsTopicName, lang.hitch(this, this._receivePublication ));
          
          // Inform the wsHandler to subscribe to the new topicName
          window.wsConnection.subscribe(this._statsTopicName);
        }
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_subscribeToMessageFlowStatsTopic");
      },

      _unsubscribeFromMessageFlowStatsTopic: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_unsubscribeFromMessageFlowStatsTopic");
        
        // Inform the wsHandler to unsubscribe
        if (this._statsTopicHandle) {
          window.wsConnection.unsubscribe(this._statsTopicName);
          
          // Unsubscribe from the stats topic
          this._statsTopicHandle.remove();
          this._statsTopicHandle = null;
          this._statsTopicName = null;
        }
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_unsubscribeFromMessageFlowStatsTopic");
      },
      
      _receivePublication: function(message){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_receivePublication");
        
        // Parse the message flow snapshot data
        var statsData = JSON.parse(message.payloadString);
        
        // Process the message flow snapshot data and update the charts
        this._processMessageFlowSnapshotData(statsData.WMQIStatisticsAccounting.MessageFlow);
        this._messageFlowStatisticsChart1.refresh();
        this._messageFlowStatisticsChart2.refresh();
        this._messageFlowStatisticsChart3.refresh();
        
        /*
         * Check to see whether a session start time has been set and, if so,
         * whether it is different to the start time in the first item in the
         * session data array 
         */
        var startUnixTime = this._sessionData[0].GMTStartTime;
        if(!this._sessionStartTime || this._sessionStartTime != startUnixTime) {
          this._sessionStartTime = startUnixTime;
          this._messageFlowStatisticsChart1.setSessionData(this._sessionData, this._sessionStartTime);
          this._messageFlowStatisticsChart2.setSessionData(this._sessionData, this._sessionStartTime);
          this._messageFlowStatisticsChart3.setSessionData(this._sessionData, this._sessionStartTime);
        }

        /*
         * Update the title for the top pane.  We need to calculate a number of
         * string inserts before setting the title.  Format of the string needs to
         * be:
         *
         *    Updates from ${startTime} (${minutes} ${minString} ago). Last 
         *    updated at ${nowTime}
         * 
         * For example:
         * 
         *    Updates from 16:55:51 GMT Standard Time (<1 minute ago). Last 
         *    updated at 16:56:11 GMT Standard Time
         */
        var startTime = new Date(this._sessionStartTime);
        var endDateObj = new Date(statsData.WMQIStatisticsAccounting.MessageFlow.GMTEndTime);
        var sessionMinutes = parseInt(date.difference(startTime, endDateObj, "second")/60);
        var startTimeStr = StatsUtils.formatToTime(startTime);                        
        var endTimeStr = StatsUtils.formatToTime(endDateObj);
        var minString = NLS.statistics.minute;
        if(sessionMinutes == 0){
          sessionMinutes = "&lt;1";
        } else if (sessionMinutes > 1) {
          minString = NLS.statistics.minutes;
        }
        this.pane1.titleNode.innerHTML = string.substitute(
          NLS.statistics.statsTrend_session_description, {
            startTime:startTimeStr,
            minutes:sessionMinutes,
            minString: minString,
            nowTime:endTimeStr
          }
        );                       

        // Update the message flow statistics table
        this._messageFlowStatsGrid.updateMessageFlowStatsData(statsData);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_receivePublication");
      },

      _processMessageFlowSnapshotData: function(messageFlowSnapshotData) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_processMessageFlowSnapshotData");
  
        /*
         * Truncate the data to prevent memory leaks in the browser.  The 
         * default is to store 1 hours worth of data (approx. equal to 180 
         * data points).
         */
        var maxRows = this.getSessionSize();
        if(this._sessionData.length > maxRows){
          this._sessionData.splice(0, this._sessionData.length - maxRows);
        }
            
        // Calculate time interval of this data for the current snapshot
        var startDateObj = StatsUtils.parseStatsStartTime(messageFlowSnapshotData);
        var endDateObj = StatsUtils.parseStatsEndTime(messageFlowSnapshotData);
        var durationSeconds = date.difference(startDateObj, endDateObj, "millisecond")/1000;
  
        // Calculate average CPU time, average elapsed time and message rate
        var avgCpuTime = 0;
        var avgElapsedTime = 0;
        var rate = 0;
        if(messageFlowSnapshotData.TotalInputMessages > 0){
          avgCpuTime = messageFlowSnapshotData.TotalCPUTime / messageFlowSnapshotData.TotalInputMessages;
          avgElapsedTime = messageFlowSnapshotData.TotalElapsedTime / messageFlowSnapshotData.TotalInputMessages;
          rate = messageFlowSnapshotData.TotalInputMessages / durationSeconds;
        }
  
        /*
         * Calculate the minimum CPU and minimum elapsed times.  These metrics
         * are not all that accurate and, when very small, can be misleading.
         * Round anything lower than 0.1ms up to 0.1ms.
         */
        var minCPU = messageFlowSnapshotData.MinimumCPUTime/1000;
        if(minCPU < 0.1 && minCPU != 0){
          minCPU = 0.1;
        }
        var minElapsed = messageFlowSnapshotData.MinimumElapsedTime/1000;
        if(minElapsed < 0.1 && minElapsed != 0){
          minElapsed = 0.1;
        }
  
        // Create the new entry for the session data and push it onto our array
        var newDataEntry = {
          GMTStartTime: new Date(messageFlowSnapshotData.GMTStartTime).getTime(),
          GMTEndTime: new Date(messageFlowSnapshotData.GMTEndTime).getTime(),
          CPUTimeWaitingForInputMessage: messageFlowSnapshotData.CPUTimeWaitingForInputMessage/1000,
          ElapsedTimeWaitingForInputMessage: messageFlowSnapshotData.ElapsedTimeWaitingForInputMessage/1000,
          MaximumCPUTime: messageFlowSnapshotData.MaximumCPUTime/1000,
          MaximumElapsedTime: messageFlowSnapshotData.MaximumElapsedTime/1000,
          MaximumSizeOfInputMessages: messageFlowSnapshotData.MaximumSizeOfInputMessages/1024,
          MinimumCPUTime: minCPU,
          MinimumElapsedTime: minElapsed,
          MinimumSizeOfInputMessages: messageFlowSnapshotData.MinimumSizeOfInputMessages/1024,
          NumberOfThreadsInPool: messageFlowSnapshotData.NumberOfThreadsInPool,
          TimesMaximumNumberOfThreadsReached: messageFlowSnapshotData.TimesMaximumNumberOfThreadsReached,
          TotalCPUTime: messageFlowSnapshotData.TotalCPUTime/1000,
          TotalElapsedTime: messageFlowSnapshotData.TotalElapsedTime/1000,
          TotalInputMessages: messageFlowSnapshotData.TotalInputMessages,
          TotalNumberOfBackouts: messageFlowSnapshotData.TotalNumberOfBackouts,
          TotalNumberOfCommits: messageFlowSnapshotData.TotalNumberOfCommits,
          TotalNumberOfErrorsProcessingMessages: messageFlowSnapshotData.TotalNumberOfErrorsProcessingMessages,
          TotalNumberOfMQErrors: messageFlowSnapshotData.TotalNumberOfMQErrors,
          TotalNumberOfMessagesWithErrors: messageFlowSnapshotData.TotalNumberOfMessagesWithErrors,
          TotalNumberOfTimeOutsWaitingForRepliesToAggregateMessages: messageFlowSnapshotData.TotalNumberOfTimeOutsWaitingForRepliesToAggregateMessages,
          TotalSizeOfInputMessages: messageFlowSnapshotData.TotalSizeOfInputMessages/1024,
          AverageCPUTimePerMessage: avgCpuTime/1000,
          AverageElapsedTimePerMessage: avgElapsedTime/1000,
          AverageMessageRate: rate
        };
        
        /*
         * If this is the first publication of snapshot data that we have received
         * in this session, we need to inject a dummy entry with zero values as 
         * the first element of the array to ensure that the chart renders in a 
         * sensible manner.  This entry needs to be ignored when calculating 
         * things like min, max and average.
         */
        if (this._sessionData.length == 0) {
          var dummyData = lang.clone(newDataEntry);
          for (var metricKey in dummyData) {
            if (metricKey != "GMTStartTime" && metricKey != "GMTEndTime") {
              dummyData[metricKey] = 0;
            }
          } // FOR
          dummyData.GMTEndTime = newDataEntry.GMTStartTime;
          dummyData.dummy = true;
          this._sessionData.push(dummyData);
        }
  
        // Store the new snapshot entry in the session data
        this._sessionData.push(newDataEntry);
            
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_processMessageFlowSnapshotData");
      },
          
      _minClicked: function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_minClicked");

        this._messageFlowStatsGrid.setDisplayMode("min");

        domClass.add(this.minButton,"selectedDiv");
        domClass.remove(this.maxButton, "selectedDiv");
        domClass.remove(this.avgButton, "selectedDiv");
        domClass.add(this.maxButton, "notSelectedDiv");
        domClass.add(this.avgButton, "notSelectedDiv");
        
        // Stop the event propagating the TitlePane
        event.stopPropagation();
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_minClicked");
      },
      
      _maxClicked: function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_maxClicked");
        
        this._messageFlowStatsGrid.setDisplayMode("max");
        
        domClass.add(this.maxButton, "selectedDiv");
        domClass.remove(this.minButton,"selectedDiv");
        domClass.remove(this.avgButton, "selectedDiv");
        domClass.add(this.minButton,"notSelectedDiv");
        domClass.add(this.avgButton, "notSelectedDiv");

        // Stop the event propagating the TitlePane
        event.stopPropagation();
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_maxClicked");
      },
      
      _averageClicked: function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_averageClicked");
        
        this._messageFlowStatsGrid.setDisplayMode("avg");
        
        domClass.add(this.avgButton, "selectedDiv");
        domClass.remove( this.minButton,"selectedDiv");
        domClass.remove(this.maxButton, "selectedDiv");
        domClass.add( this.minButton,"notSelectedDiv");
        domClass.add(this.maxButton, "notSelectedDiv");

        // Stop the event propagating the TitlePane
        event.stopPropagation();
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_averageClicked");
      },
      
      getSessionSize: function () {
        // The session defaults to an hour's worth of data (well, 180 data points at 20 seconds interval)
        // This method provides a property to override the amount of data stored in the browser.
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "getSessionSize");
        
        var returnVal = 180;  // Default
        
        var sURL = window.document.URL.toString();
        if (sURL.indexOf("?") > 0) {
          var index = sURL.indexOf("#");
          if ( index > 0) {
            sURL = sURL.substring(0, index);
          }
          
          var arrParams = sURL.split("?");
          var arrURLParams = arrParams[1].split("&");
          for (var i=0; i < arrURLParams.length; i++){
            var sParam =  arrURLParams[i].split("=");
            if (sParam[0] =="sessionSize") {
              var sessionSize = sParam[1];
              if (sessionSize > 0) {
                returnVal = sParam[1];
              }
            }
          }
        }
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "getSessionSize", [returnVal]);
        return returnVal;
      },
      
      _initializeSession: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_initializeSession");
        
        // Create a clean set of session data
        this._sessionStartTime = new Date().getTime();
        this._sessionData = [];
//        this.toolbar.getButton("downloadData").set("disabled", true);
        
        this._messageFlowStatisticsChart1.setSessionData(this._sessionData, this._sessionStartTime);
        this._messageFlowStatisticsChart2.setSessionData(this._sessionData, this._sessionStartTime);
        this._messageFlowStatisticsChart3.setSessionData(this._sessionData, this._sessionStartTime);
        
        // Clear any data from a previous session if it is still being displayed.
        this._messageFlowStatisticsChart1.refresh();
        this._messageFlowStatisticsChart2.refresh();
        this._messageFlowStatisticsChart3.refresh();
        this._messageFlowStatsGrid.removeNodesFromTable();
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_initializeSession");
      }
  });// end declare
});// end define

},
'webui/widgets/business/BTDFilteringOptionsDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="763384209" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/business/templates/BTDFilteringOptionsDialog.html",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/declare",
  "dojo/_base/event",  
  "dojo/_base/lang",
  "dijit/Dialog",
  "dojo/dom-attr",
  "dojo/keys",
  "dojo/on",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetsInTemplateMixin",
  "webui/widgets/common/Trace"
], function(
  template,
  NLS,
  declare,
  event,
  lang,
  Dialog,
  domAttr,
  keys,
  on,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  Trace
) {
	var filterOptionsDialog = declare("webui.widgets.business.BTDFilteringOptionsDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
		templateString : template,

		bt_filter_transaction_id_Label : NLS.btResultsTableBtxId,
		bt_filter_status_Label: NLS.btResultsTableStatus,
		
		bt_filter_matchverb_equals : NLS.filterMatches,
		bt_filter_matchverb_contains : NLS.filterContains,
		bt_filter_matchverb_startsWith : NLS.filterStartsWith,
		bt_filter_matchverb_endsWith : NLS.filterEndsWith,
		
		bt_filter_status_inProgress   : NLS.btResultsTableRunningFilter,
		bt_filter_status_ended        : NLS.btResultsTableSucceededFilter,
		bt_filter_status_failed       : NLS.btResultsTableFailedFilter,
		bt_filter_status_inconsistent : NLS.btResultsTableInconsistentFilter,		
		
		_filterParms : null,
	  
		constructor: function(args){
		  if(args != null) {
		    this._callback         = args.cback;
		    this._filterParms      = args.filterParms;
		  }
		},

		_onKey : function(evt) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onKey");
			this.inherited(arguments);
			if (evt.charOrCode) {
				if (evt.charOrCode === keys.ENTER) {
					if ( !this._okButton.get("disabled" ) ) {
						event.stop(evt);
						this.onExecute();
					}
				}
			}
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onKey");
		},

		postCreate : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			this.inherited(arguments);

			domAttr.set(this.titleNode, "innerHTML", NLS.btResultsTableFilterDialogTitle );
			this.titleNode.setAttribute("tabIndex", -1);
			domAttr.set(this.instructionNode, "innerHTML", NLS.btResultsTableFilterDialogDescription );
			this.instructionNode.setAttribute("tabIndex", -1);
			
			domAttr.set(this._okButton, "label", NLS.okButtonLabel);
			domAttr.set(this._cancelButton, "label", NLS.cancelButtonLabel);


			//id
			if (this._filterParms.conditions[0].checked === true) {
				
				this._bt_filter_transaction_id.set("checked",true);
				
				if (this._filterParms.conditions[0].verb) {
					this._bt_filter_transaction_id_matchVerbs.set("value", this._filterParms.conditions[0].verb);
				}//if
				
				if (this._filterParms.conditions[0].value) {
					this._bt_filter_transaction_id_text.set("value", this._filterParms.conditions[0].value);
				}//if
				

			}//if
			
			if (this._filterParms.conditions[1].checked === true) {
				
				this._bt_filter_status.set("checked",true);

				if (this._filterParms.conditions[1].value) {
					this._bt_filter_status_values.set("value", this._filterParms.conditions[1].value);
				}//if

				//
			}//if
			
			
			this._okButton.set("disabled", false);
			this.instructionDiv.style.color = "black";


			on(this._bt_filter_transaction_id, "click", lang.hitch(this, function() {
				this._validateData();
			}));

			on(this._bt_filter_status, "click", lang.hitch(this, function() {
				this._validateData();				
			}));
			
			on(this._bt_filter_transaction_id_text, "change", lang.hitch(this, function() {
				this._validateData();				
			}));			
			
			on(this, "execute", lang.hitch(this, function() {

				
				this._filterParms.conditions[0].checked     = this._bt_filter_transaction_id.checked;
				this._filterParms.conditions[1].checked     = this._bt_filter_status.checked; 
				
				if (this._filterParms.conditions[0].checked === true){
					this._filterParms.conditions[0].verb  = this._bt_filter_transaction_id_matchVerbs.get("value");
					this._filterParms.conditions[0].value = this._bt_filter_transaction_id_text.get("value"); 
				}//if
				else {
					this._filterParms.conditions[0].verb  = null;
					this._filterParms.conditions[0].value = null; 
				}//endif
				
				if (this._filterParms.conditions[1].checked === true){
					this._filterParms.conditions[1].value   = this._bt_filter_status_values.get("value");
				}//if
				else {
					this._filterParms.conditions[1].value   = null;					
				}//endif
				
				
				this._callback(this._filterParms);
				this.hide();
			}));
			on(this._cancelButton, "click", lang.hitch(this, function() {
				this.hide();
			}));

			this._validateData();
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},

		show : function() {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "show");	
		  this.inherited(arguments);

		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "show");
		},
		
		_validateData : function() {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_validateData");

			if ( !this._bt_filter_transaction_id.checked &&
				  !this._bt_filter_status.checked
			) {
				this._okButton.set("disabled", true);
			}//if	  
			else {
				this._okButton.set("disabled", false);
			}

			domAttr.set(this.instructionNode, "innerHTML", NLS.btResultsTableFilterDialogDescription );
			this.instructionDiv.style.color = "black";
			
            if (this._bt_filter_transaction_id.checked){
               var textValue = this._bt_filter_transaction_id_text.get("value");
               if ( (textValue === "") || (textValue === null)){
					domAttr.set(this.instructionNode, "innerHTML", NLS.btResultsTableBtxIdEmptyMsg );
					this.instructionDiv.style.color = "red";
					this._bt_filter_transaction_id_text.focus();
					this._okButton.set("disabled", true);
               }//if
            }//if
		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "_validateData");			  
		}
	    
          
	});
	return filterOptionsDialog;
});

},
'webui/widgets/business/BTModel':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2013,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.  
 * </copyright> 
 *
 * Business Transaction Model
 * Used by the Business Transaction editor to store the data associated with a business transaction
 * the flows, the external system and the business events
 *
 */
define("webui/widgets/business/BTModel", ["dojo/i18n!webui/nls/web",
		"webui/widgets/common/Trace",
		"webui/config/Resources",
		"dojo/_base/declare",
		"dojo/_base/lang",
		"dojo/hash",
    "dojo/string",
    "dojo/topic",
    "dojo/_base/array",
    "webui/utils/RestUri"
		],

function(NLS,
  Trace,
  Resources,
  declare,
  lang,
  hash,
  string,
  Topic,
  array,
  RestUri) {

	var BTModel = declare("webui.widgets.business.BTModel", null, {

		elementsArray: null,
    selectedItem:null,
    businessEvents: null,
    description: null,
    unsavedChanges: false,

    // array of flows referenced by the BTD that are no longer found when loading the BTD
    flowsNotFound: null,

    //type flow
    typeFlow : Resources.businessTransaction.btElementTypeNamespace + Resources.businessTransaction.btElementTypeFlow,

 		constructor: function(/*Object*/ args){
 			this.btName = args.name;
 			this.elementsArray = [];
 			this.businessEvents = [];
 			this.description = args.description;
 			this.flowsNotFound =[];
 			this.canvasWidth = args.canvasWidth;
 			this.canvasHeight = args.canvasHeight;
 			this.cellWidth = args.cellWidth;
 			this.cellHeight = args.cellHeight;
 			this.xDelta = args.xDelta;
 			this.yDelta = args.yDelta;
 			// round down for number of columns to make sure the labels fit
      this.noColumns = Math.floor(this.canvasWidth/this.cellWidth);
      // round up the number of rows to go down
      this.noRows = Math.round(this.canvasHeight/this.cellHeight);
 		},
 		
 		/*
    * after a resize, reset the dimensions and the numbers of maximum rows and columns it can fit
    */
 		setCanvasDimensions : function (newWidth, newHeight) {		  
 		  if (newWidth>0) {
 		    this.canvasWidth = newWidth;
 		    this.noColumns = Math.floor(this.canvasWidth/this.cellWidth);
 		  }
      if (newHeight>0) {
        this.canvasHeight = newHeight;
        this.noRows = Math.round(this.canvasHeight/this.cellHeight);
      }
 		  
 		},

		postCreate : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},
		
		/*
    * Returns the cell in the canvas where the flow should go based on the index
    */
		getCellIndices : function (index) {
		  var columnIndex= index%this.noColumns;
      var rowIndex = Math.floor(index/this.noColumns);
      return {columnIndex: columnIndex, rowIndex: rowIndex};
		},
		
		/*
    * Returns the cell in the canvas where the flow should go based on the x and y position
    */
    getCellIndicesForPosition : function (x, y) {
      var columnIndex= Math.floor(x/this.cellWidth); 
      var rowIndex = Math.round(y/this.cellHeight);
      return {columnIndex: columnIndex, rowIndex: rowIndex};
    },

		addElement: function(d, save) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "addElement");

      // computes the cell for this flow      
      var cell = this.getCellIndicesForPosition(d.pos.x, d.pos.y);
      if (!d.columnIndex) {
        d.columnIndex= cell.columnIndex;
        d.rowIndex = cell.rowIndex;
      }
      
      // Generate the canvas icon label
      d.flowLabel = this.sanitiseNameLabel(d.name);
      
      this.elementsArray.push(d);
			this.updateState(save);
      // default type
      if (!d.type) {
        d.type = this.typeFlow;
      }
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "addElement");
		},

		updateDetails: function(btName, btDescription) {
		  this.btName = btName;
		  this.description = btDescription;
		  this.updateState();
		},
		
		sanitiseNameLabel: function(name) {

      var LABEL_MARGIN = 10;
      var LABEL_HARDMAX= 16;
      
      var lastCarriageReturn = 0;  // Number of chars since we broke the line.            
      var lineWrappedFlowName = "";

      var carriageReturnCount = 0;
      
      var shortSequence = "..";
      
      for (var charIndex = 0; charIndex < name.length; charIndex++) {
        var charact = name.charAt(charIndex);
        
        carriageReturnCount++;
        
        // I.e. now guaranteed to be on 3rd line, ensure no 3rd line shown and just a ".." ending sequence
        if(carriageReturnCount > 2) {
          // +1 for the newline that won't be rendered as a char
          lineWrappedFlowName = lineWrappedFlowName.substring(0, (LABEL_HARDMAX * 2) - shortSequence.length + 1) + shortSequence;
          // Stop adding characters, break loop
          charIndex = name.length;
           
        } else {
          if (lastCarriageReturn < LABEL_MARGIN) {
            lineWrappedFlowName = lineWrappedFlowName + charact;
            lastCarriageReturn++;
            carriageReturnCount--;
          } else {
            // Try and line wrap.
            if (charact == " ") {
              // Split on ' ' but don't add the space to the new line.
              lineWrappedFlowName = lineWrappedFlowName + "\n";
              lastCarriageReturn = 0;
            } else if (charact == "_") {
              // Split on '_'
              lineWrappedFlowName = lineWrappedFlowName + "\n_";
              lastCarriageReturn = 1;
            } else if (charact == "/") {
              // Split on '/'
              lineWrappedFlowName = lineWrappedFlowName + "\n/";
              lastCarriageReturn = 1;
            } else if (charact == "\\") {
              // Split on '\'
              lineWrappedFlowName = lineWrappedFlowName + "\n\\";
              lastCarriageReturn = 1;
            } else if (charact == ".") {
              // Split on '.'
              lineWrappedFlowName = lineWrappedFlowName + "\n.";
              lastCarriageReturn = 1;
            } else if (lastCarriageReturn >= LABEL_HARDMAX) {
              // Hard stop - force a newline
              lineWrappedFlowName = lineWrappedFlowName + "\n"+charact;
              lastCarriageReturn = 1;
            } else {
              // Carry on adding to the line
              lineWrappedFlowName = lineWrappedFlowName + charact;
              lastCarriageReturn++;
              carriageReturnCount--;
            }
          }
        }                          
      }
		  return lineWrappedFlowName;
		},

		clear: function(){
		    Trace.trace(this.declaredClass, Trace.levels.ENTRY, "clear");
		    this.elementsArray = [];
	      Trace.trace(this.declaredClass, Trace.levels.EXIT, "clear");
		},
		getElementsArray: function(){
			return this.elementsArray;
		},

		addFlowElementMonitoringEvents: function(flowUri, events){
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "addFlowElementMonitoringEvents");

		  if(this.elementsArray.length > 0) {
	      // Check that the previously added flow is indeed the one to add events to
		    var element = this.elementsArray[this.elementsArray.length-1];

	      if(element.uri === flowUri) {
	        element.monitoringEvents = events;
	      } else {
	        // If not, find the correct element before adding the event data
	        for(var i=0; i < this.elementsArray.length-1; i++) {
	          if(this.elementsArray[i].uri === flowUri) {
	            this.elementsArray[i].monitoringEvents = events;
	            break;
	          }
	        }
	      }
		  }

		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "addFlowElementMonitoringEvents");
		},

		getFlowElementMonitoringEvents: function(flowUri) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "getFlowElementMonitoringEvents");

		  var monitoringEvents = [];

		  for(var i=0; i < this.elementsArray.length; i++) {
        if(this.elementsArray[i].uri === flowUri) {
          monitoringEvents = this.elementsArray[i].monitoringEvents;
          break;
        }
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "getFlowElementMonitoringEvents");

		  return monitoringEvents;
		},

		removeFlowElementMonitoringEvents: function(flowUri){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "removeFlowElementMonitoringEvents");

      if(this.elementsArray.length > 0) {
        var index = -1;
        // Find the flow element entry and remove it from the array
        for(var i=0; i < this.elementsArray.length; i++) {
          if(this.elementsArray[i].uri === flowUri) {
            index = i;
            break;
          }
        }

        // If match was found then remove from the array
        if(index >= 0) {
          this.elementsArray.splice(index,1);
        }
        // when removing the flow, removing it also from the list of missing flows, if present
        index = this.flowsNotFound.indexOf(flowUri);
        if (index>=0) {
          this.flowsNotFound.splice(index,1);
        }
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "removeFlowElementMonitoringEvents");
    },

  	containsElement: function(uri) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "containsElement");
  		var result = array.filter(this.elementsArray,function(item){
          return (item.uri=== uri);
      });
      if (result.length ==0 ){
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "containsElement");
       	return false;
      }
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "containsElement");
      return true;
  	},

  	removeElement: function (flowUri) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "removeElement");

  			// remove the element that matches the URI
  			var toRemove = array.filter(this.elementsArray, function(item) {
  			  return (item.uri=== flowUri);
  			});
  			array.forEach(toRemove, lang.hitch (this, function(item) {
  			  var index = this.elementsArray.indexOf(item);
  			  if (index>=0) {
  			    this.elementsArray.splice(index,1);
  			    this.updateState();
			    }
  			}));

	      Trace.trace(this.declaredClass, Trace.levels.EXIT, "removeElement");
  	},

  	printElements: function () {
  		array.forEach(this.elementsArray, function(item, index){
				if (item && item.pos) {
				  console.log("Item("+index+"):"+ item.name+ ", pos:("+item.pos.x+","+item.pos.y+") selected flags:"+ item.selected + " cell("+item.columnIndex+
				      ", "+ item.rowIndex+") ");
				  
				}
  		});
  		array.forEach(this.businessEvents, function(item){
  		  console.dir(item);
  		});
  	},

  	/*
  	 *       CanvasWidth
  	 *    -----------------------------------------------------------
  	 *    |  cellWidth      |         2        |         3          |
  	 *    |      1          |cellHeight        |                    |
  	 *    |---------------------------------------------------------|   canvas
  	 *    |    4            |                  |                    |   height
  	 *    | --------------------------------------------------------|
  	 *    |   ....                                                  |
  	 *    |                                                         |
  	 *    |---------------------------------------------------------|
  	 * 
  	 * 
  	 */
  	getNextPosition : function () {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "getNextPosition");

      var nextIndex = this.elementsArray.length;
      
      //first try to find the next position cheaply, just based on the index
      
      // compute the cell where the flow it should go based on the index
      var cell = this.getCellIndices(nextIndex);
      var newColumn = cell.columnIndex;
      var newRow = cell.rowIndex;

      // check if this slot is already taken
      var flowForThisCell = array.filter(this.elementsArray,function(flow){
        return (flow.columnIndex === newColumn) && (flow.rowIndex===newRow);
      });

      var result;
      if (flowForThisCell.length>0) { 
        // this slot is taken
         // check if there are any gaps
        var gap = this.getAnyGaps();
        if ((gap.column>=0) && (gap.row>=0)) {
          newColumn = gap.column;
          newRow = gap.row;
          result = this.computeCoordinates(newColumn, newRow);
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "getNextPosition");      
          return result;
        }
        else { 
          // no gap found, the grid is full, this will cause the message to be shown
          result = {"x": -1, "y": -1};
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "getNextPosition");      
          return result;
          
        }
      }
      else {
        // the slot is not taken, use it
        result = this.computeCoordinates(newColumn, newRow);
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "getNextPosition");  	  
        return result;
      }
  	},
  	
  	getAnyGaps: function () {
  	  for (var i=0; i< this.noColumns;i++) {
  	    for (var j=0; j< this.noRows;j++) {
  	      var flowForThisCell = array.filter(this.elementsArray,function(flow){
            return (flow.columnIndex === i) && (flow.rowIndex===j);
          });
  	      if (flowForThisCell.length ===0 ) {
  	        return {column: i, row:j};
  	      }
  	    }
  	  }
  	  return {column: -1, row:-1};
  	},
  	
  	computeCoordinates: function (newColumn, newRow) {
      var x1 = newColumn * this.cellWidth + this.xDelta;
      var y1 = this.yDelta +newRow * this.cellHeight + this.yDelta;
      return {"x":x1, "y":y1};
  	},
  	
  	// maximum number of flows for graphical view
  	maxNumberOfFlowsReached : function() {
      var maxNum = this.noColumns* this.noRows;
      if (this.elementsArray.length >= maxNum )  {
        return true;
      }
      else { return false; }
  	},
  	
  	/* first algorithm for finding the space, find the biggest x gap and the biggest y gap and pick the point in the middle
  	 * 
    getNextPosition: function(width, height) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "getNextPosition");

      var xPos = [];
      var yPos = [];

      xPos.push(0);
      yPos.push(0);
      array.forEach(this.elementsArray, function(item){
        xPos.push(item.pos.x);
        yPos.push(item.pos.y);
      });
      xPos.push(width);
      yPos.push(height);

      var compare = function (a,b) {
          if (a*1 < b*1) {
             return -1;
          }
          if (a*1 > b*1) {
            return 1;
          }
          return 0;
      };
      xPos.sort(compare);
      yPos.sort(compare);
      var max = 0;
      var index = 0;
      var diff;
      for (var i=0; i<xPos.length-1;i++){
        diff = 1*xPos[i+1] -1*xPos[i];
        if (max< diff) {
          max = diff;
          index =i;
        }
      }
      var x1 = Math.round(xPos[index]+ 1*max/2);

      max = 0;
      index = 0;
      for (i=0; i<yPos.length-1;i++){
        diff = 1*yPos[i+1] - 1*yPos[i];
        if (max< diff) {
          max = diff;
          index = i;
        }
      }
      var y1 = Math.round(yPos[index]+ 1*max/2);
      //console.dir(xPos);
      //console.dir(yPos);
      //console.log("Computed "+x1+" "+y1);

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "getNextPosition");

      return {"x":x1, "y":y1};

    },
    */
  	computeEventsTooltipInformation: function(d){
  	    	/*
  	    	 * computes the tooltip for the decoration on the flow that describes the business events, start, end, failure that this flows contain
  	    	 */
	  		Trace.trace(this.declaredClass, Trace.levels.ENTRY, "computeEventsTooltipInformation");
	  		var result = "";
	  		array.forEach(d.businessEvents, function(item) {
	  			var text= "";
	  			if (item.role === Resources.businessTransaction.btEventStart) {
	  				text = string.substitute(NLS.btStartEvent, [item.eventSourceAddress]);
	  			} else if (item.role === Resources.businessTransaction.btEventEnd) {
	  				text = string.substitute(NLS.btEndEvent, [item.eventSourceAddress]);
	  			} else if (item.role === Resources.businessTransaction.btEventFailure) {
	  				text = string.substitute(NLS.btFailureEvent, [item.eventSourceAddress]);
	  			}
	  			// For appending on description information for the flow
	  			if (result === "") {
	  					result = text;
	  			}
	  			else {
	  				result += ",  " + text;
	  			}
  		});
  		Trace.trace(this.declaredClass, Trace.levels.EXIT, "computeEventsTooltipInformation");
  		return result;
  	},

    computeTooltipInformation: function  (d) {
    	/* d is something like
    	 * {  "uri":"/apiv1/executiongroups/eg1/applications/app/flows/SendApology",
       * 	"name":"SendApology",
       * 	"type": "flow",
       *	"description":"Error end of the process"},
       * { "id":"/localhost/port/QueueManager/Q1",
       *  "name": "Q1",
       *  "type": "system",
       *  "description": "The orders are received on this queue"},
       */
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "computeTooltipInformation");

		  var tooltipVal = "";

      var uri = d.uri;
      if (uri.indexOf(Resources.REST.root)>=0) {
        uri = uri.substring(Resources.REST.root.length);
      }

      tooltipVal += "Uri: " + uri;

      // Get the description
      if((typeof d.description != "undefined") && (d.description != "")) {
        tooltipVal += "\n" + NLS.btDescription + d.description;
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "computeTooltipInformation");

    	return tooltipVal;
    },

    changeEvent: function(newValue, event, flowUri, save) {
    	// there is some change to the business event definition, store this in the model
    	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "changeEvent");
    	if (!save) {
        // first remove this event from the business events array
        var toRemove = array.filter(this.businessEvents, function(item){
          return (item.role && (item.parentFlow === flowUri) && (item.monitorEvent.uri === event.uri));
        });
        array.forEach(toRemove, lang.hitch(this,function(item, index){
          index = this.businessEvents.indexOf(item);
          if (index>=0) {
                // found the event, now clear it
                this.businessEvents.splice(index, 1);
              }
        }));
        this.updateState(save);
    	}

    	// If the business event type is anything but "do not flag", i.e. Progress, Start, End, Failure add to the array of business events
    	if (newValue !== Resources.businessTransaction.btEventDoNotFlag) {
    		var businessEvent = { role: newValue, monitorEvent: event, parentFlow: flowUri};
    		this.businessEvents.push(businessEvent);
    	}

    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "changeEvent");
    },

    removeFlowBTMEvents: function(flowUri) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "removeFlowBTMEvents");

      if(this.businessEvents.length > 0) {
        // Find the business event entry and remove it from the array, starting at the end (so that indexes are preserved)
        for(var i= this.businessEvents.length-1; i > -1; i--) {
          if(this.businessEvents[i].parentFlow === flowUri) {
            this.businessEvents.splice(i,1);
          }
        }
        this.updateState();
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "removeFlowBTMEvents");
    },

    computePath: function (d) {
    	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "computePath");
    	// d is a link element e.g. {"source": "3", "target":0, "type": "read"},
			var si = d.source;
    	var ti = d.target;
    	var x1 =  parseInt(this.elementsArray[si].pos.x);
    	var y1 =  parseInt(this.elementsArray[si].pos.y);
    	var x2 = parseInt(this.elementsArray[ti].pos.x);
    	var y2 = parseInt(this.elementsArray[ti].pos.y);
    	if (x1<x2) { //adjustments
    		x1 = parseInt(x1)+this.elementWidth/2;
    	}
    	else {
    		x2 = parseInt(x2)-this.elementWidth/2;
    	}
  		if (y1<y2) {
      		y1 = parseInt(y1)+this.elementHeight;
      	}
      	else {
      		y2 = parseInt(y2)+this.elementHeight;
    	}
    	var x= "M"+ x1+","+y1+"L"+x2+","+ y2;
  		Trace.trace(this.declaredClass, Trace.levels.EXIT, "computePath");
      return x;
	},

	// Validates the business transaction
  validateModel: function() {
    Trace.trace(this.declaredClass, Trace.levels.ENTRY, "validateModel");
    var result;
    var progressEvents = [];
    var startEvents = [];
    var endEvents = [];
    var failureEvents = [];
    var details = [];
    // Checks whether start, end, failure are found
    array.forEach(this.businessEvents, function(item) {
      var eventToAdd = {flowUri: item.parentFlow, uri: item.monitorEvent.uri, monitoringEventSourceAddress: item.monitorEvent.eventSourceAddress};
      switch (item.role) {
        case Resources.businessTransaction.btEventProgress:
          progressEvents.push(eventToAdd);
          break;
        case Resources.businessTransaction.btEventStart:
          startEvents.push(eventToAdd);
          break;
        case Resources.businessTransaction.btEventEnd:
          endEvents.push(eventToAdd);
          break;
        case Resources.businessTransaction.btEventFailure:
          failureEvents.push(eventToAdd);
          break;
      }
    });

    if (startEvents.length == 0) {
      // or is it Error?
      details.push({sev:Resources.btValidation.btWarning, text : NLS.btNoStartEvent});
    }
    if (endEvents.length == 0) {
      details.push({sev:Resources.btValidation.btWarning, text: NLS.btNoEndEvent});
    }
    if (failureEvents.length == 0) {
      details.push({sev:Resources.btValidation.btInfo, text: NLS.btNoFailureEvent});
    }
    var businessEventValidation = this.getValidatedBusinessEventsArray();
    result = {
        status: ((startEvents.length > 0) && (endEvents.length > 0)),
        details: details,
        btModelData: {
          btName: this.btName,
          progressEvents: progressEvents,
          startEvents: startEvents,
          endEvents: endEvents,
          failureEvents: failureEvents},
       globalIDInfo: businessEventValidation.businessEventsWithoutGlobalId,
       disabledEventInfo: businessEventValidation.businessEventsDisabled
    };
    Trace.trace(this.declaredClass, Trace.levels.EXIT, "validateModel");
    return result;
	},
	
	/*
	 * computes an array of business events that do not have global IDs
	 */
	getValidatedBusinessEventsArray: function() {
	  var businessEventValidation = {
	      businessEventsWithoutGlobalId: [],
	      businessEventsDisabled: []
	  };
	  
	  this.businessEvents.forEach(lang.hitch(this, function(businessEvent) {
	    var flowUri = businessEvent.parentFlow;
	    var businessEventUri = businessEvent.monitorEvent.uri;
	    var role = businessEvent.monitorEvent.role;
	    // now get the monitoring events for the flow
	    var flowMonitoringEvents = this.getFlowElementMonitoringEvents(flowUri);
	    if (flowMonitoringEvents) {
	      // the monitoringEvents array contains the full monitoring event for all events defined on that node, including globalID and enabled value
  	    flowMonitoringEvents.forEach(function(flowMonitoringEvent) {
  	       if ((flowMonitoringEvent.nodeMonitoringEvents) && flowMonitoringEvent.nodeMonitoringEvents.length > 0) {
  	         // Iterate around all events defined on that node
  	         flowMonitoringEvent.nodeMonitoringEvents.forEach(lang.hitch(this, function(nextNodeMonitorEvent) {
  	           if (nextNodeMonitorEvent.uri === businessEventUri) {
                 var globalId = nextNodeMonitorEvent.transactionCorrelation.global;
                 var extendedMonitoringEvent;
                 // Check if business event has no global ID
                 if (globalId === "automatic") {
                   extendedMonitoringEvent = {"role":role, 
                       "flowUri": flowUri,
                       "monitoringEvent":nextNodeMonitorEvent };
                   businessEventValidation.businessEventsWithoutGlobalId.push(extendedMonitoringEvent);
                 }
                 
                 // Check if business event is disabled
                 var disabled = nextNodeMonitorEvent.isEnabled;
                 if(disabled === "false") {
                   extendedMonitoringEvent = {"role":role, 
                       "flowUri": flowUri,
                       "monitoringEvent":nextNodeMonitorEvent };
                   businessEventValidation.businessEventsDisabled.push(extendedMonitoringEvent);
                 }
               }
  	         }));
  	       }   
  	    });
	    } 
	  }));
	  
	  return businessEventValidation;
	},
	
	
	/*
	 * returns true if the events flagged in BTD have no correlation information whatsover
	 * In this case there is no chance of this BTD being recorded at all
	 */
	hasNoCorrelationInfo : function (validationObject) {
    
    if (validationObject && validationObject.globalIDInfo) {
      var global = validationObject.globalIDInfo;
      // if the number of business events without the correlation = number of business events
      if ((global.length=== this.businessEvents.length) &&(this.businessEvents.length>0)){
        return true;
      }    
    }
    return false;
  },
  
  /*
   * returns a comma separated list of business events that are not enabled
   */
  getDisabledBusinessEventsList:function (validationObject) {
     var result = "";
     if (validationObject && validationObject.disabledEventInfo) {
       var businessEventsDisabledList = validationObject.disabledEventInfo;
       if (businessEventsDisabledList.length > 0 ) {
         businessEventsDisabledList.forEach(lang.hitch(this,function(extendedMonitoringEvent) {
           result += ", "+extendedMonitoringEvent.monitoringEvent.eventName;      
         }));
       }
     }
     return this.getStringListResult(result);
   },
  
  /*
  * returns a comma separated list of business events that do not have a global ID
  */
  getMissingCorrelationEventsList:function (validationObject) {
    var result = "";
    if (validationObject && validationObject.globalIDInfo) {
      var businessEventsWithNoCorrelatorList = validationObject.globalIDInfo;
      if (businessEventsWithNoCorrelatorList.length>0){
        businessEventsWithNoCorrelatorList.forEach(lang.hitch(this,function(extendedMonitoringEvent) {
           var globalId = extendedMonitoringEvent.monitoringEvent.transactionCorrelation.global;
          if (globalId === "automatic") {
            result += ", "+extendedMonitoringEvent.monitoringEvent.eventName;
          }        
        }));
      }
    }
    return this.getStringListResult(result);
  },
  
  /*
  * Returns an array containing the business events that cannot be found
  * among the monitoring events of their parent flow.
  * Indicative of monitoring event changes for the flows in BTD
  */
  getOutOfDateBusinessEvents : function () {
    var bEventsStale =[];
    // looks through all the business events saved in the BTD
    
    this.businessEvents.forEach(lang.hitch(this, function (businessEvent){
      // parent Flow
      var flowUri = businessEvent.parentFlow;
      var flowForTheBusinessEvent = array.filter(this.elementsArray,function(flow){
        return (flow.uri === flowUri);
      });
      // if the flow is gone, then so should be the events
      if (flowForTheBusinessEvent.length==0) {// no flows found for this business event
        // out of date references
        bEventsStale.push(businessEvent);
      }
      else {
        // found, should be 1
        var businessEventUri = businessEvent.monitorEvent.uri;
        var found = false;
        var flowMonitoringEvents = this.getFlowElementMonitoringEvents(flowUri);
        
        if (flowMonitoringEvents && flowMonitoringEvents.length>0) {
          // the monitoringEvents array contains the full monitoring event definition i
          // see if any monitoring event has the uri of business event
          for (var i=0; i<flowMonitoringEvents.length;i++) {
            var event = flowMonitoringEvents[i];
            if (event.nodeMonitoringEvents && event.nodeMonitoringEvents.length>0) {
              // there might be multiple events for a node e.g. the input node havine txn start, end, rollback events
              // check all 
              var l = event.nodeMonitoringEvents.length;
              for (var j=0; j<l;j++) {
                var eventURI = event.nodeMonitoringEvents[j].uri;
                if (eventURI=== businessEventUri){
                  found = true;
                }              
              }
            }
          }
          // if no entries in events, it means the business event
          // was not found on the list of monitoring events of this flow
          // the event needs to go           
          if (!found) {
            bEventsStale.push(businessEvent);
          }
        }
      }
    }));
    return bEventsStale;
  }, 

  /*
  * From the array of business events that are out of date, 
  * returns a list, nicely formatted,  grouped by flow
  */  
  getListofOutOfDateBusinessEvents: function (eventsArray) {
    // arrays of flows uri whose flagged events have been changed
    var flowsWithEventsChanged = [];
    
    var l = eventsArray.length; 
    var result;
    if (l === 0) { return ""; }
    
    else {
      var i;
      for (i=0; i<l; i++) {
        var index = flowsWithEventsChanged.indexOf(eventsArray[i].parentFlow);
        if (index<0) {
          flowsWithEventsChanged.push(eventsArray[i].parentFlow);
        }
      }
      var flowsAndMissingEvents =[];
      for (i=0; i<flowsWithEventsChanged.length; i++) {
        var flowUri= flowsWithEventsChanged[i];
        var eventList = "<br>&nbsp&nbsp"; // ???
        var businessEventsForThisFlow = array.filter(eventsArray,function(event){
          return (event.parentFlow=== flowUri);
        });
        if (businessEventsForThisFlow.length >0 ) {
          for (var j=0; j<businessEventsForThisFlow.length-1; j++) {
            eventList += eventsArray[j].monitorEvent.eventSourceAddress+ ", ";
          }
          eventList += eventsArray[businessEventsForThisFlow.length-1].monitorEvent.eventSourceAddress+"&nbsp&nbsp";
          var flowName =   (new RestUri(eventsArray[i].parentFlow)).getMessageFlowName();
          
          flowsAndMissingEvents.push( 
              {
                "flow": flowName,
                "missingEvents": eventList
              }              
          );
        }
      }  
      l = flowsAndMissingEvents.length;
      result = "<br>";
      for (i=0; i<l-1; i++) {
        result += string.substitute(NLS.btEventFromFlow, [flowsAndMissingEvents[i].flow, flowsAndMissingEvents[i].missingEvents]) +",<br><br>";
      }
      result += string.substitute(NLS.btEventFromFlow, [flowsAndMissingEvents[l-1].flow, flowsAndMissingEvents[l-1].missingEvents])+".<br>";
    }
    return result;
  },
  
  /*
  * On user choice to remove out of date business events, this invoked the
  * method to set the business events as "doNotFlag". This will remove them from the BTD.
  */
  removeBusinessEvents: function (staleEventsArray) {
    staleEventsArray.forEach(lang.hitch(this, function(businessEvent) {
        // call the function that demotes the event 
        this.changeEvent(Resources.businessTransaction.btEventDoNotFlag, businessEvent.monitorEvent, 
            businessEvent.parentFlow, false);
    }));
        
  },
  
  addFlowNotFound: function (flowUri) {
    this.flowsNotFound.push(flowUri);
  },
  
  hasNeitherStartNorEndEvents: function(validationObject) {
    return ((this.elementsArray.length >0)&& (validationObject.btModelData.startEvents.length===0) && (validationObject.btModelData.endEvents.length===0));
  },
  
  hasNoStartEvents : function(validationObject) {
    return ((this.elementsArray.length >0)&& (validationObject.btModelData.startEvents.length===0));
    
  },
  hasNoEndEvents : function(validationObject) {
    return ((this.elementsArray.length >0)&& (validationObject.btModelData.endEvents.length===0));
    
  },
  
  /*
   * Return true if at least one of the flow has monitoring events defined
   * If not, you can't build any BTD
   */
  hasAnyMonitoringEvents: function() {
    if (this.elementsArray.length ===0) {
      // can't expect to find monitoring events if there are no flow
      return true;
    }
    var result = false;    
    this.elementsArray.forEach(lang.hitch(this, function (flow) {
      if (flow.monitoringEvents && flow.monitoringEvents.length>0) {
        result= true;
        return;
      }
    }));
    return result;
  },
  
  /*
   * Returns a comma separated list of flows for which none of their monitoring events have been flagged
   */
  getFlowsWithoutBusinessEvents : function() {
    var result ="";
    this.elementsArray.forEach(lang.hitch(this, function (flow) {
      var flowUri = flow.uri;
      
      var businessEventsForThisFlow = array.filter(this.businessEvents,function(event){
        return (event.parentFlow=== flowUri);
      });
      if (businessEventsForThisFlow.length ===0 ) {
        result+= ", " +  (new RestUri(flow.uri)).getMessageFlowName();
      }
    }));
    return this.getStringListResult(result);
  },
  
  /*
   * Utility method to return the comma separated list
   * The computed list is of the type ", item1, item2, ..., item n" or ""
   */
  getStringListResult: function(result) {
    if (result === "") {
      return result;
    }
    return result.substring(1);   
  },
  
  /*
   * format the list of missing flows names to be shown in the dialog
   */
	getMissingFlowsFormattedList : function () {
    var flowsUris = this.flowsNotFound;
    var result ="<br><br>";
    
    if (flowsUris && flowsUris.length >0) {
      var l = flowsUris.length;
      var flowNames = [];
      var i;
      for (i=0; i< l-1; i++) {
        flowNames.push((new RestUri(flowsUris[i])).getMessageFlowName());
      }
      flowNames.sort();
      var flow;
      for (i=0; i< l-1; i++) {            
        flow =   flowNames[i];
        result += "&nbsp&nbsp&nbsp"+flow+", <br>";
      }
      flow =   (new RestUri(flowsUris[l-1])).getMessageFlowName();
      result += "&nbsp&nbsp&nbsp"+flow;
    }
    return result;	  
	},
	
	_doesFlowElementExist: function(flowUri) {
	  var foundElements = array.filter(this.elementsArray,function(item){
      return (item.uri === flowUri);
    });
	  
	  return (foundElements.length > 0);	  
	},
	
	updateState: function(save) {
	  if(save) {
	    this.unsavedChanges = false;
	  } else {
	    if( !this.unsavedChanges ) {
	      this.unsavedChanges = true;
	      Topic.publish(Resources.pubSubTopic.businessTransaction, {"update": true, "name": this.btName, "description": this.btDescription, "callingHash": hash()});
	    }
	  }
	}

	}); // end dojo declare
	return BTModel;
});

},
'webui/widgets/configurableservice/cs_overview':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="4215630537" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/configurableservice/templates/cs_overview.html",
	"dojo/i18n!webui/nls/web",
	"dojo/_base/declare", 
	"dojo/_base/lang",
	"dojo/dom-attr",
	"dojo/dom-construct",
  "dojo/keys",
	"dojo/hash",
	"dojo/on",
  "dojo/ready",
	"dojo/request/xhr",
  "dojo/string",
	"dojo/topic",
	"dijit/_WidgetBase", 
	"dijit/_TemplatedMixin",
  "dijit/_WidgetsInTemplateMixin",
  "dijit/registry",
	"dojox/html/entities",
	"idx/widget/ConfirmationDialog",
	"webui/config/Resources",
	"webui/utils/RestUri",
	"webui/utils/WebUiHash",
	"webui/widgets/configurableservice/ConfigurableServiceEditor",
	"webui/widgets/common/QuickAndAdvancedProperties",
	"webui/widgets/common/Toolbar",
	"webui/widgets/common/HasContextMenu",
	"webui/widgets/common/Trace",
  "webui/widgets/common/UIUtils"
], function(
  template,
  NLS,
  declare,
  lang,
  domAttr,
  domConstruct,
  keys,
  hash,
  on,
  ready,
  xhr,
  string,
  topic,
  _WidgetBase,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  registry,
  entities,
  ConfirmationDialog,
  Resources,
  RestUri,
  WebUiHash,
  ConfigurableServiceEditor,
  QuickAndAdvancedProperties,
  Toolbar,
  HasContextMenu,
  Trace,
  UIUtils
) {
  var csOverview = declare("webui.widgets.configurableservice.cs_overview", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
    templateString: template,
    toolbar: null,
    _properties: null,
            
    postCreate: function() {
  		Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
  		this.inherited(arguments);	
  		
  		// Create toolbar
  		this.toolbar = new Toolbar();
  		domConstruct.place(this.toolbar.domNode, this._toolbar);
  		this.toolbar.addLeftAlignButtons("title");
  		
  		// Add Edit button to the right side of the toolbar if the user has write permission:
  		var doesUserHaveWritePermission = window.currentuser.userPermission("broker", "write");
  		if (doesUserHaveWritePermission) {
  		  var buttons = ["edit"];
  		  this.toolbar.addRightAlignButtons(buttons);
  		  this.toolbar.addRightAlignButtons("spacer");
  		  this.toolbar.getButton("edit").set("disabled", false);
  		  
  		  // Add an event handler for the Edit button:
  		  this.toolbar.connectButtons("edit", "click", this, "_onEditClick");
  		}
      		
  		this.properties = new QuickAndAdvancedProperties("configurableService");
  
  		this.properties.createPropertiesContainer(this._propertyTitlePane);
  		
   		Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
  	},
    
  	// Called when a user selects a button on the context-menu of a Configurable Service:
  	contextButtonsClicks : function(event) {
  	  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks");
  	
  	  // Get the URI and action from the event:
  	  var uriAndAction = UIUtils.getURIAndAction(event);
  	  var uri = uriAndAction.uri;
  	  var action = uriAndAction.action;
  	
  	  // Handle the action for the URI:
  	  if(action === "delete") {
  	    // Get the configurable service name:
  	    var csName = new RestUri(uri).getConfigurableServiceName() || "";
          
  	    var confirmDeleteCallback = lang.hitch(this, function() {
  	      // User wants to delete:
  	      this.deleteConfigurableService(uri, csName);
  	    });
       	
  	    // Ask the user to confirm the deletion before proceeding:
  	    var message = string.substitute(NLS.configurableserviceConfirmDeleteMessage, [csName]);
  	    window.wmbConsole.showConfirmationDialog("csConfirmDelete", "question", NLS.configurableserviceYesLabel, NLS.configurableserviceNoLabel, message, confirmDeleteCallback, null); 
  	  }
  	  else if (action == "exportConfigurableService") {
  	    this.exportConfigurableService(uri);
  	  }
        
  	  Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
  	},
  	
    deleteConfigurableService : function(uri, csName){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "deleteConfigurableService",[uri]);
      
      var previousHash = hash();
      
      // REST call to delete the configurable service:
      xhr.del(
        uri,
        {
          handleAs : "json",
          headers : {
            "Accept" : "application/json"
          }
        }
      ).then( lang.hitch(this, function() {
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Configurable service delete success");
        
        // Display a message that the delete was successful:
      	window.smallMessage.displayPlainMessage("success", "ConfigurableService_deleteSuccess", [csName]);
      	
      	// On successful delete check whether the hash is currently pointing at the deleted object.
        // If match then move the selection to another configurable service under the same category
        // if one exists; else the root node:
      	var refreshHashCallback;
        if(this.isHashCurrentConfigurableServiceObject(uri)) {
          refreshHashCallback = lang.hitch(this, function(uriOfDeletedObject, parentObjectOfDeletedObject) { // jshint ignore:line
            
            // If the user has navigated in the meantime, don't
            // overrule them
            if(hash() !== previousHash) {
              return;
            }
            
            // If the current object is no longer a configurable service there is nothing to do, so just return:
            if(!this.isHashCurrentConfigurableServiceObject(uri)) {
            	return;
            }
            
            // By default, no other configurable service available to select, so select the root tree node
            var newHash = Resources.REST.nodeHome;
            
            // See if we can move the selection to another configurable service
            // under the same configurable service category:
            if (
              parentObjectOfDeletedObject !== undefined &&
              parentObjectOfDeletedObject.configurableService !== undefined &&
              parentObjectOfDeletedObject.configurableService[0] !== undefined &&
              parentObjectOfDeletedObject.configurableService[0].uri !== undefined
            ) {
              // There is another configurable service available to select, so let's select it:
              
              newHash = WebUiHash.fromRestUri(new RestUri(parentObjectOfDeletedObject.configurableService[0].uri)).toString();
            }

            hash(newHash);
         });
        }
        
        // Publish to notify the tree that the configurable service has been deleted:
        topic.publish(Resources.pubSubTopic.configurableServiceDeleted, {uri: uri, updateHashCallback: refreshHashCallback});
      }),
      lang.hitch(this, function(error) {
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Response: " + error.response.response); 
  
        // Display a message that the delete was unsuccessful:
        window.smallMessage.displayPlainMessage("error", "ConfigurableService_deleteFailure", [csName]);
      }));
        
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "deleteConfigurableService");
    },
      
    // Returns true if the current hash is pointed to the object 
    isHashCurrentConfigurableServiceObject: function(objectUri) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "isHashCurrentConfigurableServiceObject");
      
      var curUri = new WebUiHash(hash()).getRestUri().toString();
      if(objectUri === curUri) {
        return true;
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "isHashCurrentConfigurableServiceObject");
      return false;
    },
      
    // Exports information about a configurable service to a file on the local file
    // system. Called when the user clicks on the 'Export *.configurableservice'
    // menu item on the context menu of a configurable service in the WebUI tree:
    exportConfigurableService : function(uri) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "exportConfigurableService");
      
      /*
        Downloading a file resource from a server and prompting the
        user with the browser's "File Save" dialog, cannot be
        done using ajax  dojo  xhr.get.
        
        All discussion groups on this matter suggest using
        a hidden iframe with src attribute to achieve this.
        This starts a separate thread. The user is free to
        interact with other web ui elements in the meantime.
        When the server response finally comes back, the user
        will be prompted with the File Save dialog if-and-only-if
        the browser settings are set to "Prompt where to save downloads"; otherwise
        user will not be prompted, and the file will be downloaded
        to the specified download directory.
        
        Look at exportConfigurableService method in
        webadmin/ImbPolicyRequestHandler.java to understand how the response is
        constructed.
      */
      
   		var uriToGetFile = uri + "/configurableServiceFile";
   		ready(function(){  
  		  var ifrm = document.createElement("IFRAME");
  		  ifrm.setAttribute("src", uriToGetFile);
  		  document.body.appendChild(ifrm); 
   		});
    
    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "exportConfigurableService");
    },
  	
  	actionDelete : function(){
  		Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionDelete");
  		Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionFlow");
  	},
  	
  	resize: function() {
  	  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize"); 
  		this._csOverview_borderContainer.resize();
  		Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize"); 
  	},
      
  	// This function is called manually when we need to remove this tab.
  	tabRemove: function() {
  	  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
  	  
  	  // Destroy the Configurable Service editor if it exists:
  	  this._destroyConfigurableServiceEditor();
            
  	  // Re-show the read-only properties pane and associated title and toolbar if hidden:
  	  this._showReadOnlyProperties();
          
  	  this.properties.unsubscribeAll();
  	  
  	  if(this.configurableServiceEditor) {
        this.configurableServiceEditor.uninitialize();
      }
  	  
  	  Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove"); 
  	},
    
    // Destroys the configurable service editor if one exists and removes the associated listeners.
    // Called when the user saves or cancels the configurable service editor, or when the user
    // navigates away from the editor:
    _destroyConfigurableServiceEditor: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_destroyConfigurableServiceEditor");
     
      // Remove listeners:
      if (this.editorUpdatedSubscription !== undefined && this.editorUpdatedSubscription !== null) {
        this.editorUpdatedSubscription.remove();
      }
      if (this.editorCancelSubscription !== undefined && this.editorCancelSubscription !== null) {
        this.editorCancelSubscription.remove();
      }
     
      // Destroy the configurable service editor widget if it exists:
      if (this._isConfigurableServiceEditorOpen()) {
        this.configurableServiceEditor.destroy();
        this.configurableServiceEditor = null;
       
        // Clear the current message (as there may be a message associated with editor that is not longer applicable):
        window.smallMessage.hideMessage();
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_destroyConfigurableServiceEditor");
    },
    
    // Shows the read-only view of the properties. Called after the configurable service editor
    // is disposed of:
    _showReadOnlyProperties: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showReadOnlyProperties");
      this._csOverview_borderContainer.style.display = "";
      this._toolbar.style.display = "";
      this._propertyTitlePane.style.display = "";
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showReadOnlyProperties");
    },
    
    // Hides the read-only view of the properties. Called before the configurable service
    // editor is opened:
    _hideReadOnlyProperties: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_hideReadOnlyProperties");
      this._csOverview_borderContainer.style.display = "none";
      this._toolbar.style.display = "none";
      this._propertyTitlePane.style.display = "none";
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_hideReadOnlyProperties");
    },
    
    // Checks whether the configurable service editor is open:
    _isConfigurableServiceEditorOpen: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_isConfigurableServiceEditorOpen");
      var returnValue = this.configurableServiceEditor !== null && this.configurableServiceEditor !== undefined;
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_isConfigurableServiceEditorOpen");
      return returnValue;
    },
    
    tabFocus: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");
      var name = "";
      var type = "";
      if(hash()){
        var webUiHash = new WebUiHash(hash());
        name = webUiHash.getConfigurableServiceName();
        type = webUiHash.getConfigurableServiceType();
      } else {
        //not sure we can ever get here this way. hash() should always be available...
        name = registry.byId('_explorerTree_ID').selectedItem.name;
        type = registry.byId('_explorerTree_ID').selectedItem.type;
      }
      var title = name + " - " + type + " " + NLS.configurableserviceTitle;
      domAttr.set("_infoPaneTitleID", "innerHTML", entities.encode(title));
      
      // Do not allow configurable services with PolicySet or PolicySetBindings types to be edited in WebUI
      // (as the user can get into trouble editing these by hand and they can be edited in the toolkit):
      if (this.toolbar !== undefined && this.toolbar.getButton("edit")) {
        if (type === "PolicySets" || type === "PolicySetBindings") {
          // hide the edit button and show a message that PolicySets and PolicySetBindings can be changed
          // in the toolkit:
          this.toolbar.getButton("edit").set("style", "display:none;");
          domAttr.set(this._csOverviewAdditionalInformation, "innerHTML", NLS.configurableservicePolicySetEditDescription);
        }
        else {
          // show the edit button and hide the message that PolicySets and PolicySetBindings can be changed
          // in the toolkit:
          this.toolbar.getButton("edit").set("style", "display:block;");
          domAttr.set(this._csOverviewAdditionalInformation, "innerHTML", "");
        }
      }
      
      this.properties.populateProperties(); 
            
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus"); 
     },
        
    tabBlur: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur"); 
    },
     
    // Called when the user clicks the Edit button:
    _onEditClick: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onEditClick");
  
      // Hide the existing read-only properties pane and associated title and toolbar:
      this._hideReadOnlyProperties();
      
      var webUiHash = new WebUiHash(hash());
      var csName = webUiHash.getConfigurableServiceName();
      var csType = webUiHash.getConfigurableServiceType();
    
      // Show the Configurable Service Editor:
      if (!this._isConfigurableServiceEditorOpen()) {
        this.configurableServiceEditor = new ConfigurableServiceEditor({
          mode: 'edit',
          configurableServiceName: csName,
          configurableServiceType: csType,
          configurableServiceTemplate: csName
        });
        
        // Subscribe to the configurable service editor's update event:
        this.editorUpdatedSubscription = topic.subscribe(Resources.pubSubTopic.configurableServiceUpdated, lang.hitch(this, function() {
          // Destroy editor:
          this._destroyConfigurableServiceEditor();
        
          // Re-populate the properties because the read-only properties will be out of date after the update:
          this.properties.populateProperties();
    	  
          // Re-show the read-only properties pane and associated title and toolbar if hidden:
          this._showReadOnlyProperties();
        }));
        
        // Subscribe to the configurable service editor's cancel event:
        this.editorCancelSubscription = topic.subscribe(Resources.pubSubTopic.configurableServiceEditCancelled, lang.hitch(this, function() {
          // If the editor is not dirty, just proceed with the cancel:
          if (this._isConfigurableServiceEditorOpen() && !this.configurableServiceEditor.isDirty()) {
          	// Destroy editor:
            this._destroyConfigurableServiceEditor();
        	
            // Re-show the read-only properties pane and associated title and toolbar if hidden:
            this._showReadOnlyProperties();
    	    
            return;
          }
          
          // Create the confirmation dialog if it does not already exist:
          var csEditConfirmCancelDialog = registry.byId("csEditConfirmCancelDialog");
          if (typeof csEditConfirmCancelDialog === "undefined") {
            csEditConfirmCancelDialog = new ConfirmationDialog({
              type : "information",
              buttonLabel : NLS.btLeaveSave,
              cancelButtonLabel : NLS.btStayOnPage,
              closeButtonLabel : NLS.btStayOnPage,
              text : NLS.messages.ConfigurableService_updateConfirmNavigateAwayFromEditorConfirmationMessage
            }, "csEditConfirmCancelDialog");
          }
          
          // Callback handler for when the user clicks 'confirm' on the dialog:
          csEditConfirmCancelDialog.confirm(lang.hitch(this, function() {
            // Destroy editor:
            this._destroyConfigurableServiceEditor();
        	
            // Re-show the read-only properties pane and associated title and toolbar if hidden:
            this._showReadOnlyProperties();
          }));
          
          // Callback handler for when the user clicks 'cancel' on the dialog:
          csEditConfirmCancelDialog.onCancel = lang.hitch(this, function() {
            csEditConfirmCancelDialog.hide();
          });
          
          on(csEditConfirmCancelDialog, "keydown", lang.hitch(this, function (event){
            // Move the focus accordingly if the arrow keys are pressed
            var key = event.keyCode;
            if ((key == keys.LEFT_ARROW) && csEditConfirmCancelDialog.closeAction.focused) {
              csEditConfirmCancelDialog.confirmAction.focus();
            } 
            else if ((key == keys.RIGHT_ARROW) && csEditConfirmCancelDialog.confirmAction.focused){
             csEditConfirmCancelDialog.closeAction.focusNode.focus();
            }
            // Extend confirm/close function to close on Enter key press
            if (key == keys.ENTER) {
              if(csEditConfirmCancelDialog.confirmAction.focused) {
                csEditConfirmCancelDialog.hide();
             
                // Destroy editor:
                this._destroyConfigurableServiceEditor();
        	
                // Re-show the read-only properties pane and associated title and toolbar if hidden:
                this._showReadOnlyProperties();
              } else {
                if(csEditConfirmCancelDialog.closeAction.focused) {
                 csEditConfirmCancelDialog.onCancel();
                }
              }
            }
            // Stop the keyboard event propagating i.e. moving a flow on the canvas
            event.stopPropagation();
          }));
          
          // Open the dialog and ask the user if they are sure that they want to cancel:
          csEditConfirmCancelDialog.show();
        }));
        
        this.configurableServiceEditor.placeAt(this._csEditEditor);
        this.configurableServiceEditor.startup();
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onEditClick");
    },
    
    // This method is called by WMBConsole and allows a potential change of the
    // hash to be veto'ed by returning false:
    canChangeHash: function(oldHash, newHash) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "canChangeHash");
      
      // Check if the user is trying to navigate to an editor that is already
      // open and dirty, and if so prevent the hash change (in order to prevent
      // the user from re-loading the editor and losing their changes):
      if (oldHash === newHash && this._isConfigurableServiceEditorOpen() && this.configurableServiceEditor.isDirty()) {
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "canChangeHash");
        return false;
      }
        
      // If the editor is dirty, we need to ask the user if they want to continue
      // to navigate away from the editor:
      if (this._isConfigurableServiceEditorOpen() && this.configurableServiceEditor.isDirty()) {
        
        // Create the confirmation dialog if it does not already exist:
        var csEditConfirmSwitchDialog = registry.byId("csEditConfirmSwitchDialog");
        if (typeof csEditConfirmSwitchDialog === "undefined") {
          csEditConfirmSwitchDialog = new ConfirmationDialog({
            type : "information",
            buttonLabel : NLS.btLeaveSave,
            cancelButtonLabel : NLS.btStayOnPage,
            closeButtonLabel : NLS.btStayOnPage,
            text : NLS.messages.ConfigurableService_updateConfirmNavigateAwayFromEditorConfirmationMessage
          }, "csEditConfirmSwitchDialog");
        }
        
       // Callback handler for when the user clicks 'confirm' on the dialog:
       csEditConfirmSwitchDialog.confirm(lang.hitch(this, function() {
  
         // Destroy the configurable service editor widget first or we will end up in an endless loop:
         this.tabRemove();
  	 
         // Allow the new hash to be selected:
         hash(newHash);
       }));
       
       // Callback handler for when the user clicks 'cancel' on the dialog:
       csEditConfirmSwitchDialog.onCancel = lang.hitch(this, function() {
         // Don't change the hash, but an item in the tree has been selected and focused upon.
         // Make sure the current item retains its focus, previous selected node, with no hash change/refresh.
         window.wmbConsole.expandTreeAndRefreshHash(oldHash, false);
         csEditConfirmSwitchDialog.hide();
       });
       
       on(csEditConfirmSwitchDialog, "keydown", lang.hitch(this, function (event){
         // Move the focus accordingly if the arrow keys are pressed
         var key = event.keyCode;
         if ((key == keys.LEFT_ARROW) && csEditConfirmSwitchDialog.closeAction.focused) {
           csEditConfirmSwitchDialog.confirmAction.focus();
         } 
         else if ((key == keys.RIGHT_ARROW) && csEditConfirmSwitchDialog.confirmAction.focused){
           csEditConfirmSwitchDialog.closeAction.focusNode.focus();
         }
         // Extend confirm/close function to close on Enter key press
         if (key == keys.ENTER) {
           if(csEditConfirmSwitchDialog.confirmAction.focused) {
             csEditConfirmSwitchDialog.hide();
             
             // Destroy the configurable service editor widget first or we will end up in an endless loop:
             this.tabRemove();
  	        
             // Allow the new hash to be selected:
             hash(newHash);
           } else {
             if(csEditConfirmSwitchDialog.closeAction.focused) {
               csEditConfirmSwitchDialog.onCancel();
             }
           }
         } 
         // Stop the keyboard event propagating i.e. moving a flow on the canvas
         event.stopPropagation();
       }));
        
       // Open the dialog:
       csEditConfirmSwitchDialog.show();
       
       // Return false to prevent the change in hash from happening automatically
       // (the user will determine if the change in hash will occur though the dialog
       // opened above):
       
       Trace.trace(this.declaredClass, Trace.levels.EXIT, "canChangeHash");
       return false;
     }
      	
     // editor is not open or is clean, so return true to allow the hash to change:
     Trace.trace(this.declaredClass, Trace.levels.EXIT, "canChangeHash");
     return true;
    }
  });
  return csOverview;
});

},
'webui/widgets/common/EditPropertyValueDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 *
 */

/*
 * This widget is a dialog that allows a user to edit a text value in a textarea.
 *
 * This widget is used by the properties editors. To get a text box with validation, use EditTextPropertyValueDialog
 *
 * When the user navigates away from the object in question, the dialog is automatically destroyed from the parent tabRemove call. This prevents multiple instances of the
 * dialog existing at once and naming collisions occuring.
 */

define(
  "webui/widgets/common/EditPropertyValueDialog",
  [
    "dojo/text!webui/widgets/common/templates/EditPropertyValueDialog.html",
    "dojo/i18n!webui/nls/web",
    "dojo/_base/declare",
    "dojo/keys",
    "dojo/_base/event",
    "dojo/on",
    "dojo/_base/lang",
    "dijit/Dialog",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "webui/widgets/common/Trace",

    // For HTML template
    "dijit/form/Textarea"
  ],
  function(
    template,
    NLS,
    declare,
    keys,
    event,
    on,
    lang,
    Dialog,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    Trace
  ) {

  var editPropertyValueDialog = declare("webui.widgets.common.EditPropertyValueDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
    templateString : template,
    _isResettingValue : false,
    _valueChangedEventHandler : null,
    _buttonOKLabel:NLS.okButtonLabel,
    _buttonCancelLabel: NLS.cancelButtonLabel,
    currentValue : "",
    cell: null,

    _onKey : function(evt) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onKey");
      this.inherited(arguments);
      if (evt.charOrCode) {
        if (evt.charOrCode === keys.ENTER) {
          if ( !this._okButton.get("disabled" ) ) {
            event.stop(evt);
            this.onExecute();
          }
        }
      }
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onKey");
    },

    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");

      this.inherited(arguments);

      this.titleNode.setAttribute("tabIndex", -1);

      on(this, "execute", lang.hitch(this, function() {
        // Xhr post
        if (this.createCallback){
          this.createCallback.apply();
        }
        this._valueChangedEventHandler.remove();
        this.hide();
      }));

      on(this._cancelButton, "click", lang.hitch(this, function() {
        this._valueChangedEventHandler.remove();
        this.hide();
      }));

      // Add value change event handler:
      this._valueChangedEventHandler = on(this.editPropertyValueArea, "change", lang.hitch(this, this._valueChanged));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },

    refresh : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "refresh");

      // Remove the value change event handler:
      this._valueChangedEventHandler.remove();

      // Set the value:
      if (this.editPropertyValueArea.get("value") !== this.currentValue) {
        this._isResettingValue = true; // to prevent the OK button from being enabled on re-open of the dialog
        if (this._dialogType() === "boolean") {
          // If the value is null, undefined, any empty string, "false", or "off", then set to false:
          if (this.currentValue === null || this.currentValue === undefined || this.currentValue === "" || this.currentValue === "false" || this.currentValue === "off") {
            this.editPropertyValueArea.set("value", false);
            // change event is not fired when the value is set to false, so manually set _isResettingValue:
            this._isResettingValue = false;
          }
          // anything else assume true:
          else {
            this.editPropertyValueArea.set("value", true);
          }
        }
        else {
          this.editPropertyValueArea.set("value", this.currentValue);
        }
      }

      // Give the textarea focus:
      this.editPropertyValueArea.focus();

      // Add the value change event handler back:
      this._valueChangedEventHandler = on(this.editPropertyValueArea, "change", lang.hitch(this, this._valueChanged));

      // Set the OK button to disabled as the user has not made any changes yet:
      this._okButton.set("disabled", true);

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "refresh");
    },

    // Called when the value in the textarea is changed:
    _valueChanged : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_valueChanged");

      // If we are not resetting the value, set the OK button to enabled:
      if (!this._isResettingValue) {
        this._okButton.set("disabled", false);
      }

      // Set the 'resetting value' flag back to false so that further changes by the user will
      // cause the OK button to enable or disable as appropriate:
      this._isResettingValue = false;

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_valueChanged");
    },

    // Returns the dialog type
    _dialogType: function() {
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "_dialogType");
      Trace.trace(this.widgetName, Trace.levels.EXIT, "_dialogType");
      return "base";
    },

  });
  return editPropertyValueDialog;
});

},
'webui/login/config/Resources':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2012" 
 * crc="1990199543" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2012 All Rights Reserved.  
 * </copyright> 
 */
define({
	unsupported:{
		url:"http://www.ibm.com/software/integration/wbimessagebroker/requirements/"
	}
});

},
'webui/widgets/policy/policy_overview':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="2931287569" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */

define([
  "dojo/text!webui/widgets/policy/templates/policy_overview.html",
  "dojo/text!webui/config/PolicyLayout.json",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/array",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/dom-construct",
  "dojo/hash",
  "dojo/query",
  "dojo/request/xhr",
  "dojo/string",
  "dojox/html/entities",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase", 
  "dijit/_WidgetsInTemplateMixin",
  "dijit/registry",
  "idx/widget/SingleMessage",
  "webui/config/Resources",
  "webui/utils/RestUri",
  "webui/utils/WebUiHash",
  "webui/widgets/common/HasContextMenu",
  "webui/widgets/common/Toolbar",
  "webui/widgets/common/Trace",
  "webui/widgets/policy/PolicySaveAsDialog",
  "webui/widgets/policy/PolicyUtils",
  "webui/widgets/policy_editor/policy_editor_dynamic"
], function(
  template,
  PolicyLayout,
  NLS,
  array,
  declare,
  lang,
  domAttr,
  domConstruct,
  hash,
  query,
  xhr,
  string,
  entities,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  registry,
  SingleMessage,
  Resources,
  RestUri,
  WebUiHash,
  HasContextMenu,
  Toolbar,
  Trace,
  PolicySaveAsDialog,
  PolicyUtils,
  policy_editor_dynamic
) {
  var POLICY_EDITOR_DYNAMIC_CALLER_ID = "policyEditorPageDynamic"; // this is an unique id from the caller to policy_editor_dynamic widget, for all the fields created by the widget will be prefixed by the caller id

  PolicyLayout = JSON.parse(PolicyLayout);

  var policyOverview = declare("webui.widgets.policy.policy_overview", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
    templateString: template,
    toolbar: null,
    policyEditorDynamic: null,
    policyDocumentURI: null,
    displayPolicyName: null,
    policyType: null,
    informationalMessage: null,
    isCreateAction: false, // to determine if the page is invoked from "Create" action or not

    postCreate: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);  

      // Create toolbar
      this.toolbar = new Toolbar();
      domConstruct.place(this.toolbar.domNode, this._toolbar);
      this.toolbar.addLeftAlignButtons("title");
      
      var buttons = ["save","saveAs","revert"];
      this.toolbar.addRightAlignButtons(buttons);
      this.toolbar.connectButtons("revert", "click", this, "revertContent");
      this.toolbar.connectButtons("saveAs", "click", this, "saveAsContent");
      this.toolbar.connectButtons("save", "click", this, "saveContent");

      this.toolbar.setButtonState("disable", "revert");
      this.toolbar.setButtonState("disable", "saveAs");
      this.toolbar.setButtonState("disable", "save");
      
      this.policyEditorDynamic = new policy_editor_dynamic({ 
        id: POLICY_EDITOR_DYNAMIC_CALLER_ID
      });
      domConstruct.place(this.policyEditorDynamic.domNode, this._policyEditorDynamicContentPane);
              
       Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },
    
    contextButtonsClicks : function(event) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks");
      
      var eventURI;

      var buttonNode;
      if(event._origType == "keyup"){ // TODO: don't get private property
        buttonNode = event.target;
        if (buttonNode.id == '') {
          eventURI = buttonNode.parentNode.id;        
        } else {
          eventURI = buttonNode.id;
        }
      }
      else { // mouse click
        buttonNode = event.target.parentNode;
        if (buttonNode.id == '') {
          eventURI = buttonNode.parentNode.id;        
        } else {
          eventURI = buttonNode.id;
        }
      }
      
      var temp = eventURI.split("_");
      var buttonAction = temp[temp.length-1];
      var policyURI = eventURI.substring(0, (eventURI.length - (buttonAction.length+1)));
      var policyRestUri = new RestUri(policyURI);
      var policyName = policyRestUri.getPolicyName();
      var policyType = policyRestUri.getPolicyType();

      switch (buttonAction) {
        case "create":
          var newEvent = {
            "type":"policy",
            "policyType" : policyType
          };
          var newHash = WebUiHash.fromRestUri(policyRestUri).toString();
          window.wmbConsole.safelyChangeHash(newHash);
          window.wmbConsole.createInfoPane(newEvent, true);
          break;
        case "delete":
                  
          var deleteConfirmationText = string.substitute(NLS.policyConfirmDelete, [policyName]);
          var confirmCallback = lang.hitch(this, function() {
            this.deletePolicy(policyURI, policyName);
          });
            
          // Cancel should do nothing, user resumes their activities
          window.wmbConsole.showConfirmationDialog("policyConfirmDelete", "information", NLS.policyYes, NLS.policyNo, deleteConfirmationText, confirmCallback, null);
          
          break;
        default:
          break;
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
    },

    saveContent : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "saveContent");

      var restUri = new RestUri(registry.byId('_explorerTree_ID').selectedItem.uri);
      var policyType = restUri.getPolicyType();

      var policyName;
      if(this.isCreateAction) {
        //Need to create a new policy
              
        policyName = this.policyEditorDynamic.getProperty(POLICY_EDITOR_DYNAMIC_CALLER_ID + "policyName");
        
        if(typeof policyName == "undefined" || policyName.length == 0) {
          window.smallMessage.displayMessage("error", "policyinvalidname_000");
          return;
        }

      } else {
        //Need to update this existing policy
        policyName = restUri.getPolicyName();
      }
      
      var uriTarget = RestUri.forPolicy(policyType, policyName).toString();

      if(!this.policyEditorDynamic.isValid()) {
        var output = "";
        var isFirst = true;
        var entryName = ""; 
        array.forEach(this.policyEditorDynamic.listInvalid(), lang.hitch(this, function(entry) {
          if(!isFirst) {
            output+=", ";
          } else {
            isFirst = false;
          }
          entryName = entry.name.substring(POLICY_EDITOR_DYNAMIC_CALLER_ID.length);
          output += entryName +" : "+entry.value;
        }));

        window.smallMessage.displayMessage("error", "policyinvalidproperty_000", null, NLS.messages.policyinvalidproperty_000+": '"+output+"'");
        return;
      }
      
      var treeRoot = Resources.REST.root;
      var policyRoot = "policy";

      // TODO: don't manipulate the explorer tree directly in this way
      var tree = window.wmbConsole._explorerTree;
      var model = tree.model;
      var policyObject = {
        "uri" : uriTarget,
        "name" : policyName,
        "type" : policyRoot,
        "policyType" : policyType,
        "documentURI" : this.policyDocumentURI
      };

      if (policyType === "WorkloadManagement"){
        policyObject.data = this._getPolicyDataForREST();
      }
      else {
        // get the policy content from policy dynamic editor to a structure used by REST API
        policyObject.data = PolicyUtils.getNodePolicyPropertiesForREST(policyType, "policyEditorPageDenamic", this.policyEditorDynamic);
      }
      // Add loading icon to tree
      tree = registry.byId('_explorerTree_ID');  
      var treeImgs = null;
      var oldIcon = null;
      if (tree.selectedNode !== null && tree.selectedNode.id !== null){
        treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
        oldIcon = domAttr.get(treeImgs[0],"class");
        domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");
      }
      
      if(this.isCreateAction) {
        
        var previousHash = hash();
        
        // Check whether this policy already exists
        model.get(treeRoot+"/"+policyRoot+"/"+policyType+"/"+encodeURIComponent(policyName)).then(

          // The policy already exists, report an error
          lang.hitch(this, function() {
            window.smallMessage.displayPlainMessage("error", "policysave_alreadyExists", [policyName]);
  
            if (treeImgs !== null){
              domAttr.set(treeImgs[0],"class",oldIcon);
            }
          }),
          
          // The policy does not already exist, go ahead and create the policy
          lang.hitch(this, function() {

            // Firstly set the path to /apiv1/policy/{policyType}
            tree.set(
              "path",
              [
                treeRoot,
                treeRoot+"/"+policyRoot,
                treeRoot+"/"+policyRoot+"/"+policyType
              ]
            ).then(lang.hitch(this, function() {

              // Now that the path is /apiv1/policy/{policyType} create the actual policy
              
              var toPut;
              var options;
              if (policyType === "WorkloadManagement") {
                toPut = policyObject;
                options = undefined;
              } else {
                // create non-WorkloadManagement policies
                toPut = policyObject.data;
                options = {
                  "id" : policyObject.uri,
                  "incremental" : false //PUT request to {target}/{id}
                };
              }

              model.put(toPut, options).then(
                
                // Policy creation succeeded, now refresh the model at /apiv1/policy/{policyType}
                lang.hitch(this, function() {
                  
                  window.smallMessage.displayPlainMessage("success", "policysave_successCreate", [policyName]);

                  model.get(treeRoot+"/"+policyRoot+"/"+policyType).then(
                    
                    // Model refresh succeeded, refresh the tree
                    lang.hitch(this, function(updatedPolicies) {
                      model.onChildrenChange(updatedPolicies, updatedPolicies.policy);
                      model.onChange(updatedPolicies);
                  
                      if (treeImgs !== null){
                        domAttr.set(treeImgs[0],"class",oldIcon);
                      }

                      // If the user has navigated elsewhere in the meantime, do not
                      // overrule them.
                      if(hash() !== previousHash) {
                        return;
                      }

                      tree.set(
                        'path',
                        [
                          treeRoot,
                          treeRoot+"/"+policyRoot,
                          treeRoot+"/"+policyRoot+"/"+policyType,
                          treeRoot+"/"+policyRoot+"/"+policyType+"/"+encodeURIComponent(policyName)
                        ]
                      ).then(
                        
                        lang.hitch(this, function() {
                      
                          // The path has now been set
                          // Display the newly created policy
                          if (tree.get('selectedNode') != null){
                            tree.focusNode(tree.get('selectedNode'));
                          }
                          var newHash = WebUiHash.forPolicy(policyType, policyName).toString();
                          window.wmbConsole.safelyChangeHash(newHash);
                          if (tree.get('selectedNode') != null){
                            tree.openInfoPane(tree.get('selectedNode'));
                          }
      
                          this.isCreateAction = false;
                        })
                      );
                    }),
                    
                    lang.hitch(this, function(error) {
  
                      // Model refresh failed
                      Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.status + " Response: " + error.responseText);            
                      if (treeImgs !== null){
                        domAttr.set(treeImgs[0],"class",oldIcon);
                      }
                    
                      try {
                        var response = JSON.parse(error.responseText);    
                        window.smallMessage.displayMessage("error", "TreeError_5XX", response.bipNumber, response.description);
                      } catch (e){
                        window.smallMessage.displayMessage("error", "TreeError_5XX");
                      }
                    })
                  ); // end of model.get
                }),
                
                // Policy creation failed
                lang.hitch(this, function(error) {
  
                  Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.status + " Response: " + error.responseText);
                  if (treeImgs !== null){
                    domAttr.set(treeImgs[0],"class",oldIcon);
                  }
                  
                  try {
                    var response = JSON.parse(error.responseText);        
                    window.smallMessage.displayMessage("error", "policysave_5XX", response.bipNumber, response.description);
                  } catch (e){
                    window.smallMessage.displayMessage("error", "policysave_5XX");
                  }
                  
                })
              );// end of model.put
            }));
          })
        );
      } else {
        
        // Update Policy
        // Check whether this policy exists first
        model.get(treeRoot+"/"+policyRoot+"/"+policyType+"/"+encodeURIComponent(policyName)).then(lang.hitch(this, function() {
        
          // The policy exists, go ahead and update it
          if (policyType === "WorkloadManagement"){
            model.put(policyObject).then(lang.hitch(this, function() { 
              if (tree.get('selectedNode') != null){
                tree.openInfoPane(tree.get('selectedNode'));
              }
              window.smallMessage.displayPlainMessage("success", "policyupdate_success", [policyName]);

              if (treeImgs !== null){
                domAttr.set(treeImgs[0],"class",oldIcon);
              }
            }), lang.hitch(this, function(error) {

              // Policy update failed
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.status + " Response: " + error.responseText);
              if (treeImgs !== null){
                domAttr.set(treeImgs[0],"class",oldIcon);
              }
              
              try {
                var response = JSON.parse(error.responseText);        
                window.smallMessage.displayMessage("error", "policyupdate_5XX", response.bipNumber, response.description);
              } catch (e){
                window.smallMessage.displayMessage("error", "policyupdate_5XX");                
              }
            }));
          }
          else {
            // Update non-WorkloadManagement Policy
            var options = {};
            options.id = policyObject.uri;
            model.put(policyObject.data, options)
            .then(lang.hitch(this, function() {
              
              
              this.unsavedChanges = false; 
              // Inform user that the save was successful
              if (tree.get('selectedNode') != null){
                tree.openInfoPane(tree.get('selectedNode'));
              }
              window.smallMessage.displayMessage("success", "policysave_successUpdate", null, NLS.messages.policysave_successUpdate+", '"+policyName+"'");
              if (treeImgs !== null){
                domAttr.set(treeImgs[0],"class",oldIcon);
              }
                                    
            }),
            lang.hitch(this, function(error) {

              // Policy update failed
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.status + " Response: " + error.responseText);
              if (treeImgs !== null){
                domAttr.set(treeImgs[0],"class",oldIcon);
              }
              
              try {
                var response = JSON.parse(error.responseText);
                window.smallMessage.displayMessage("error", "policyupdate_5XX", response.bipNumber, response.description);
              } catch (e){
                window.smallMessage.displayMessage("error", "policyupdate_5XX");                
              }
              
            })
            ); //then
          } //else
          

        }), lang.hitch(this, function(error) {

          // Policy update failed, policy does not exists
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.status + " Response: " + error.responseText);
          if (treeImgs !== null){
            domAttr.set(treeImgs[0],"class",oldIcon);
          }
          
          window.smallMessage.displayPlainMessage("error", "policyupdate_notExists", [policyName]);

        }));
      } //else
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "saveContent");
    },
    
    saveAsContent : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "saveAsContent");
      
      window.smallMessage.hideMessage();  
      
      var saveAsDialog = registry.byId("policySaveAsDialog");

      // callback function from saveAsDialog to create the policy
      var createCallback = lang.hitch(this, function (){
        var policyName = saveAsDialog._policyNameText.get("value");
 
        this.createSaveAsPolicy(policyName);
      }); //createCallback

      // create saveAsDialog
      if (!saveAsDialog) {
        saveAsDialog = new PolicySaveAsDialog( {
          id : "policySaveAsDialog",
          createCallback : createCallback
        });                
        saveAsDialog.startup();
      }
      domAttr.set(saveAsDialog.titleNode, "innerHTML", entities.encode(NLS.policy_saveAsDialogTitle));
      domAttr.set(saveAsDialog.instructionNode, "innerHTML", entities.encode(NLS.policySaveAsDescription));
      saveAsDialog._policyNameText.set("value", "");
      
      saveAsDialog.refresh();
      saveAsDialog.show();
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "saveAsContent");
    },
    
    createSaveAsPolicy : function(policyName){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createSaveAsPolicy");
         
      if(typeof policyName == "undefined" || policyName.length == 0) {
        window.smallMessage.displayMessage("error", "policyinvalidname_000");
        return;
      }
      
      domAttr.set("_infoPaneTitleID", "innerHTML", this.displayPolicyName + " - " + entities.encode(NLS.action.saveAs));

      // get target path
      var restUri;
      if(hash()){
        restUri = new WebUiHash(hash()).getRestUri();
      } else {
        restUri = new RestUri(registry.byId('_explorerTree_ID').selectedItem.uri);
      }  
      var policyType = restUri.getPolicyType();
      
      var uriTarget = RestUri.forPolicy(policyType, policyName).toString();
      // e.g. "/apiv1/policy/WorkloadManagement/MyPolicy1"

      // create policy
      if(!this.policyEditorDynamic.isValid()) {
        var output = "";
        var isFirst = true;
        array.forEach(this.policyEditorDynamic.listInvalid(), lang.hitch(this, function(entry) {
          if(!isFirst) {
            output+=", ";
          } else {
            isFirst = false;
          }
          output += entry.name +" : "+entry.value;
        }));

        window.smallMessage.displayMessage("error", "policyinvalidproperty_000",null, NLS.messages.policyinvalidproperty_000+": '"+output+"'");
        return;
      }

      var treeRoot = Resources.REST.root;
      var policyRoot = "policy";

      var tree = window.wmbConsole._explorerTree;
      var model = tree.model;
      var policyObject = {
        "uri" : uriTarget,
        "name" : policyName,
        "type" : policyRoot,
        "policyType" : policyType,
        "documentURI" : this.policyDocumentURI
      };

      if (policyType === "WorkloadManagement"){
        policyObject.data = this._getPolicyDataForREST();
      }
      else {
        // get the policy content from policy dynamic editor to a structure used by REST API
        policyObject.data = PolicyUtils.getNodePolicyPropertiesForREST(policyType, "policyEditorPageDenamic", this.policyEditorDynamic);
      }
      // Add loading icon to tree
      tree = registry.byId('_explorerTree_ID');    
      var treeImgs = null;
      var oldIcon = null;
      if (tree.selectedNode !== null && tree.selectedNode.id !== null){
        treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
        oldIcon = domAttr.get(treeImgs[0],"class");
        domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");
      }

      var previousHash = hash();
      
      // Check whether this policy already exists
      model.get(treeRoot+"/"+policyRoot+"/"+policyType+"/"+encodeURIComponent(policyName)).then(

        // The policy already exists, report an error
        lang.hitch(this, function() {
            window.smallMessage.displayPlainMessage("error", "policysave_alreadyExists", [policyName]);
            if (treeImgs !== null){
              domAttr.set(treeImgs[0],"class",oldIcon);
            }
        }),
  
        // The policy does not already exist, go ahead and create the policy
        lang.hitch(this, function() {
          
          // Firstly set the path to /apiv1/policy/{policyType}
          tree.set(
            "path",
            [
              treeRoot,
              treeRoot+"/"+policyRoot,
              treeRoot+"/"+policyRoot+"/"+policyType
            ]
          ).then(lang.hitch(this, function() {

            // Now that the path is /apiv1/policy/{policyType} create the actual policy

            var toPut;
            var options;
            if (policyType === "WorkloadManagement"){
              toPut = policyObject;
              options = undefined;
            } else {
              toPut = policyObject.data;
              options = {
                "id" : policyObject.uri,
                "incremental" : false //PUT request to {target}/{id}
              };
            }

            model.put(toPut, options).then(
              
              // Policy creation succeeded, now refresh the model at /apiv1/policy/{policyType}
              lang.hitch(this, function() {
              
                window.smallMessage.displayPlainMessage("success", "policysave_successCreate", [policyName]);

                model.get(treeRoot+"/"+policyRoot+"/"+policyType).then(
                  
                  // Model refresh succeeded, refresh the tree
                  lang.hitch(this, function(updatedPolicies) {
                    model.onChildrenChange(updatedPolicies, updatedPolicies.policy);
                    model.onChange(updatedPolicies);
                  
                    if (treeImgs !== null){
                      domAttr.set(treeImgs[0],"class",oldIcon);
                    }
                    
                    // If the user has navigated elsewhere in the meantime, do not
                    // overrule them.
                    if(hash() !== previousHash) {
                      return;
                    }

                    tree.set(
                      'path',
                      [
                        treeRoot,
                        treeRoot+"/"+policyRoot,
                        treeRoot+"/"+policyRoot+"/"+policyType,
                        treeRoot+"/"+policyRoot+"/"+policyType+"/"+encodeURIComponent(policyName)
                      ]
                    ).then(lang.hitch(this, function() {
                      
                      // The path has now been set
                      // Display the newly created policy
                      if (tree.get('selectedNode') != null){
                        tree.focusNode(tree.get('selectedNode'));
                      }
                      // change new hash
                      var newHash = WebUiHash.forPolicy(policyType, policyName).toString();
                      window.wmbConsole.safelyChangeHash(newHash);
                      if (tree.get('selectedNode') != null){
                        tree.openInfoPane(tree.get('selectedNode'));
                      }
                    }));
                  }),
                  
                  // Model refresh failed
                  lang.hitch(this, function(error) {
                    Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.status + " Response: " + error.responseText);            
                    
                    if (treeImgs !== null){
                      domAttr.set(treeImgs[0],"class",oldIcon);
                    }
                    
                    try {
                      var response = JSON.parse(error.responseText);    
                      window.smallMessage.displayMessage("error", "TreeError_5XX", response.bipNumber, response.description);
                    } catch (e){
                      window.smallMessage.displayMessage("error", "TreeError_5XX");
                    }
                  })
                ); // end of model.get
              }),
          
              // Policy creation failed
              lang.hitch(this, function(error) {
                Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.status + " Response: " + error.responseText);
                
                if (treeImgs !== null){
                  domAttr.set(treeImgs[0],"class",oldIcon);
                }
                
                try {
                  var response = JSON.parse(error.responseText);        
                  window.smallMessage.displayMessage("error", "policysave_5XX", response.bipNumber, response.description);
                } catch (e){
                  window.smallMessage.displayMessage("error", "policysave_5XX");
                }
              })
            );// end of model.put
          }));
        })
      );
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "createSaveAsPolicy");
    },
    
    revertContent : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "revertContent");
      this.policyEditorDynamic.refresh();
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "revertContent");
    },
    
    deletePolicy : function(policyURI, policyName) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "deletePolicy");

      var model = window.wmbConsole._explorerTree.model;
      
      //  Add loading icon to tree
      var tree = registry.byId('_explorerTree_ID');    
      var treeImgs = null;
      var oldIcon = null;
      if (tree.selectedNode !== null && tree.selectedNode.id !== null){
        treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
        oldIcon = domAttr.get(treeImgs[0],"class");
        domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");
      }
      
      // REST call to delete policy
      model.remove(policyURI).then(lang.hitch(this, function() {
        
        if (treeImgs !== null){
          domAttr.set(treeImgs[0],"class",oldIcon);
        }

        // Display a message that the delete was successful:
        window.smallMessage.displayPlainMessage("success", "policydelete_success", [policyName]);
        
        // On successful delete check whether the hash is currently pointing at the deleted object.
        // If match then move the selection to another policy under the same category
        // if one exists; else the root node:
        if(this._isHashCurrentPolicyObject(policyURI)) {
          if (hash() !== Resources.REST.nodeHome) {
            // No other policy available to select, so select the root tree node:
            hash(Resources.REST.nodeHome);
          }
        }
        
        // Publish to notify the tree that the policy has been deleted:
        //topic.publish(Resources.pubSubTopic.operationalPolicyDeleted, {uri: policyURI, updateHashCallback: refreshHashCallback});
              
      }), lang.hitch(this, function(error) {
        
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.status + " Response: " + error.responseText);            
        if (treeImgs !== null){
          domAttr.set(treeImgs[0],"class",oldIcon);
        }
        var bipNumber;
        var description;
        if(typeof error.responseText != 'undefined') {
          try{
            var response = JSON.parse(error.responseText);
            bipNumber = response.bipNumber;
            description = response.description;
          } catch (e) {
            // Parse failure
          }
        }
        window.smallMessage.displayMessage("error", "policydelete_5XX", bipNumber, description);
      }));
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "deletePolicy");
    },
    
    // Returns true if the current hash is pointed to the object 
    _isHashCurrentPolicyObject: function(objectUri) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_isHashCurrentPolicyObject");

      var curUri = new WebUiHash(hash()).getRestUri().toString();
      if(objectUri === curUri) {
        return true;
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_isHashCurrentPolicyObject");
      return false;
    },
        
    resize: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize"); 
      this._policyOverview_borderContainer.resize();
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize"); 
    },
    
    // Used by WLM Policy only
    _getPolicyDataForREST: function() {
      var policyData = this.policyEditorDynamic.getAllPolicyData();
      
      var updatePolicyData = [];
        
      var entryId = "";
      array.forEach(policyData.data, lang.hitch(this, function(entry) {
        
        entryId = entry.id.substring(POLICY_EDITOR_DYNAMIC_CALLER_ID.length);
        if(entryId == "startInstancesWhenFlowStarts") {
          if(entry.value == "yes") {
            updatePolicyData.push({name: entryId, value: "true"});
          } else if(entry.value == "no") {
            updatePolicyData.push({name: entryId, value: "false"});
          } else {
            updatePolicyData.push({name: entryId, value: ""});
          }
        } else {
          if(entryId != "policyName") {
            if(entry.value != 'unspecified') {
              //Need to copy the fields over as dojo memory store uses "id" and our rest api uses "name"
              updatePolicyData.push({name: entryId, value: entry.value});
            } else {
              updatePolicyData.push({name: entryId, value: ""});
            }
          }
        }
      }));
      
      return updatePolicyData;
    },
    
  
    _setTitle: function(policyName, policyType) {
      this.toolbar.setAttribute("title", "innerHTML", "");

      var title = NLS.policyTitle;
      if (typeof policyType != 'undefined' && policyType != null){
        title = title + " - " + policyType; 
      }
      if(typeof policyName != 'undefined' && policyName != null) {
        title = title + " : " + policyName; 
      }
      domAttr.set("_infoPaneTitleID", "innerHTML", entities.encode(title));
    },

    tabFocus: function () {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus"); 

      // e.g. "policy/0/policy/MQEndpoint",
      // "policy/0/policy/MQEndpoint/MyPolicy1"
      var webUiHash = new WebUiHash(hash());

      // e.g. "/apiv1/policy/MQEndpoint",
      // "/apiv1/policy/MQEndpoint/MyPolicy1"
      var uriTarget = webUiHash.getRestUri().toString();

      // A named policy? Go get it.
      var policyName = webUiHash.getPolicyName();
      if(policyName) {
        this.displayPolicyName = policyName;
      
        this.isCreateAction = false;

        xhr(
          uriTarget,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json"
            }
          }
        ).then(
          lang.hitch(this, function(response) {
            var policyType = null;
            if (typeof response.policyType != "undefined") {
              policyType = response.policyType;  
            }
            else if (typeof response.type != "undefined") {
              policyType = response.type;  
            }
            
            var policyData = { id: "root", contents: []};
            var policyContentsCounter = 0;
            if (policyType === "WorkloadManagement"){
              if(typeof response.name == "undefined") {
                window.smallMessage.displayMessage("error", "policyget_5XX");
              } else {
                //This is a request to display an existing policy
                this.policyDocumentURI = response.documentURI;
              
                array.forEach(response.data, lang.hitch(this, function(property) {
                  if(property.name == "startInstancesWhenFlowStarts") {
                    if(property.value == "true") {
                      policyData.contents[policyContentsCounter] = {id: POLICY_EDITOR_DYNAMIC_CALLER_ID+property.name, value: "yes"};
                    } else if(property.value == "false") {
                      policyData.contents[policyContentsCounter] = {id: POLICY_EDITOR_DYNAMIC_CALLER_ID+property.name, value: "no"};
                    }
                  } else {
                    if(property.name != "policyName") {
                      policyData.contents[policyContentsCounter] = {id: POLICY_EDITOR_DYNAMIC_CALLER_ID+property.name, value: property.value};
                    }
                  }
                  policyContentsCounter++;
                }));  
              }
            }
            else {
              if (typeof response.policyProperties != "undefined") {
                var policyProperties = response.policyProperties;
                  
                // loop thru the response to get the policy content
                policyData = PolicyUtils.loopThruPolicyDataStructureFromREST(policyProperties, policyData, policyContentsCounter, POLICY_EDITOR_DYNAMIC_CALLER_ID);
              }
            }
  
            //Determine readonly or readwrite layout
            var policyLayout;
            if(policyType == "WorkloadManagement") {
              if(window.currentuser.userPermission("broker", "write")) {
                policyLayout = PolicyLayout.wlm;
              } else {
                policyLayout = PolicyLayout.wlmReadOnly;
                this.toolbar.setButtonState("disable", "revert");
                this.toolbar.setButtonState("disable", "saveAs");
                this.toolbar.setButtonState("disable", "save");
              }
            }
            else if (policyType === "MQTTPublish"){
              if(window.currentuser.userPermission("broker", "write")) {
                policyLayout = PolicyLayout.mqttPublish;
              } else {
                policyLayout = PolicyLayout.mqttPublishReadOnly;
                this.toolbar.setButtonState("disable", "revert");
                this.toolbar.setButtonState("disable", "saveAs");
                this.toolbar.setButtonState("disable", "save");
              }
            }
            else if (policyType === "MQTTSubscribe"){
              if(window.currentuser.userPermission("broker", "write")) {
                policyLayout = PolicyLayout.mqttSubscribe;
              } else {
                policyLayout = PolicyLayout.mqttSubscribeReadOnly;
                this.toolbar.setButtonState("disable", "revert");
                this.toolbar.setButtonState("disable", "saveAs");
                this.toolbar.setButtonState("disable", "save");
              }
            }
            else if (policyType === "MQEndpoint"){
              if(window.currentuser.userPermission("broker", "write")) {
                policyLayout = PolicyLayout.mqEndpoint;
              } else {
                policyLayout = PolicyLayout.mqEndpointReadOnly;
                this.toolbar.setButtonState("disable", "revert");
                this.toolbar.setButtonState("disable", "saveAs");
                this.toolbar.setButtonState("disable", "save");
              }
            }
            this.policyEditorDynamic.displayPolicy(policyData, policyLayout, uriTarget);
            this._setTitle(this.displayPolicyName, policyType);
          }),
          
          lang.hitch(this, function(error) {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.xhr.status + " Response: " + error.response.xhr.response);            

            try {
              var response = JSON.parse(error.response.text);       
              window.smallMessage.displayMessage("error", "policyget_5XX", response.bipNumber, response.description);
            } catch (e){
              window.smallMessage.displayMessage("error", "policyget_5XX");             
            }
          })
        );

      }

      // Otherwise this is not a named policy, just a policy type.
      // So build a policy editor.
      else {
        this.isCreateAction = true;

        var policyType = webUiHash.getPolicyType();
      
        if(policyType === "WorkloadManagement") {
          this.policyEditorDynamic.displayPolicyLayout(PolicyLayout.wlmCreate);
        } 
        else if(policyType === "MQTTPublish") {
          this.policyEditorDynamic.displayPolicyLayout(PolicyLayout.mqttPublishCreate);
        }
        else if(policyType === "MQTTSubscribe") {
          this.policyEditorDynamic.displayPolicyLayout(PolicyLayout.mqttSubscribeCreate);
        }
        else if(policyType === "MQEndpoint") {
          this.policyEditorDynamic.displayPolicyLayout(PolicyLayout.mqEndpointCreate);
        }
        else {
          throw new Error("Policy type '" + policyType + "' not recognised.");
        }
        
        this._setTitle(null, policyType);
        this.policyEditorDynamic.getPropertyWidget(POLICY_EDITOR_DYNAMIC_CALLER_ID+"policyName").focus();
      }

      //Enable/disable buttons based on permissions
      //Same for all policy types
      if(window.currentuser.userPermission("broker", "write")) {
        this.toolbar.setButtonState("enable", "revert");
        if (this.isCreateAction){
          this.toolbar.setButtonState("disable", "saveAs");
        } else {
          this.toolbar.setButtonState("enable", "saveAs");
        }
        this.toolbar.setButtonState("enable", "save");
      } else {
        this.toolbar.setButtonState("disable", "revert");
        this.toolbar.setButtonState("disable", "saveAs");
        this.toolbar.setButtonState("disable", "save");
      }

      if (this.informationalMessage == null){
        var tooltipNLS = "_unspecifiedNodePolicyPropertiesTooltip_title";
        var descNLS = "_unspecifiedNodePolicyPropertiesTooltip_desc";
        if (this.policyType === "WorkloadManagement"){
          tooltipNLS = "_unspecifiedPropertiesTooltip_title";
          descNLS = "_unspecifiedPropertiesTooltip_desc";
        }
        
        if( typeof NLS[tooltipNLS] != 'undefined') {
          tooltipNLS = NLS[tooltipNLS];
        }
        
        if( typeof NLS[descNLS] != 'undefined') {
          descNLS = NLS[descNLS];
        }
        
        this.informationalMessage = new SingleMessage({ 
          title: tooltipNLS,
          type: "information",
          showAction: false,
          showDetailsLink: true,
          showId: false,
          showRefresh: false,
          description: descNLS,
          onMoreDetails: function(){
            window.open("http://www.ibm.com/support/knowledgecenter/SSMKHH_10.0.0/com.ibm.etools.mft.doc/bi62000_.htm");
          }
        }); 
        this.informationalMessage.placeAt(this._propertyAdditionalInformation); 
        this.informationalMessage.startup();
      }
    
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
    },
        
    tabBlur: function () {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur"); 
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
    },
        
    tabRemove: function () {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove"); 
        
        if (this.informationalMessage != null){
          try{
            this.informationalMessage.destroy();
          }
          catch(e) {}
        
          this.informationalMessage = null;
        }

        var saveAsDialog = registry.byId("policySaveAsDialog");
        if (saveAsDialog){
          try{
            saveAsDialog.destroy();
          }
          catch(e) {}
        
          saveAsDialog = null;
        }
        
        if (this.policyEditorDynamic){
          try{
            // only clean up the policy layout for policy_editor_dynamic widget
            this.policyEditorDynamic.destroyPolicyLayout();
          }
          catch(e) {}
        
        }
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");

    }
    
  });
  return policyOverview;
});

},
'webui/widgets/common/UIUtils':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2015,2016" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.  
 * </copyright> 
 */

/*
 * Provides common UI related utilities.
 */

define(
    "webui/widgets/common/UIUtils",
    [
      "dojo/i18n!webui/nls/web",
      "dojo/_base/lang",
      "dojo/hash",
      "dojo/topic",      
      "webui/widgets/common/PropertiesStore",
      "webui/widgets/common/Trace",
      "webui/config/Resources",
      "webui/utils/WebUiHash",      
      "webui/utils/RestUri"
    ],
    function(NLS,
        lang,
        hash,
        Topic,
        PropertiesStore,
        Trace,
        Resources,
        WebUiHash,
        RestUri) {

  return {
  
    _declaredClass: "webui.widgets.common.UIUtils",

    /**
     * Takes an event object associated with a context-menu button click and
     * returns the URI and action of the event. This function returns an object
     * containing a `uri` property and an `action` property. Note that if the URI
     * or action can not be determined, this function still returns the object but
     * the property values may be undefined.
     * 
     * `shouldKeepActionOnURI` is an optional boolean parameter. If true, the URI
     * that is returned will contain the action. If false, or not provided, the
     * URI that is returned will NOT contain the action. In some cases, the
     * action needs to remain on the uri (for example, for the actions on the
     * context-menu of an integration server).
     */
    getURIAndAction : function(event, shouldKeepActionOnURI) {
      // Get the URI of the object we need to take action on from the event
      // including the action.
      //
      // Two possible cases:
      // 1. User used the keyboard to select the context button. In this case,
      // the id of the parent node will be the URI and action, and the id
      // of the child node will end not be the URI and action (will be the
      // URI and action + "text").
      // 2. User clicked the mouse to press the context button. In this case,
      // the id of the parent node will be '', and the node id will be the
      // URI and action.
      Trace.trace(this._declaredClass, Trace.levels.ENTRY, "getURIAndAction");
      var uriIncludingAction;
      if (event !== undefined && event.target !== undefined) {
        if (event.target.parentNode !== undefined && event.target.parentNode.id !== '') {
          // Case 1 from above:
          uriIncludingAction = event.target.parentNode.id;
        } else {
          // Case 2 from above:
          uriIncludingAction = event.target.id;
        }
      }

      // Separate URI and action:
      var uri;
      var action;
      if (uriIncludingAction !== undefined) {
        var uriIncludingActionTokenized = uriIncludingAction.split("_");
        if (uriIncludingActionTokenized.length > 1) {
          action = uriIncludingActionTokenized[uriIncludingActionTokenized.length - 1];
          if (shouldKeepActionOnURI === true) {
            uri = uriIncludingAction;
          } else {
            uri = uriIncludingAction.substring(0, (uriIncludingAction.length - (action.length + 1)));
          }
        }
      }
      
      Trace.trace(this._declaredClass, Trace.levels.EXIT, "getURIAndAction");
      return {
        uri : uri,
        action : action
      };
    },
    
    /**
     * Returns the first invalid character in the provided string or null if no invalid characters were found.
     *
     * Invalid characters are: ^$.|\<>?+*=&[]()
     */
    findFirstInvalidCharInProperty: function(str, treatDotCharAsValid) {
      Trace.trace(this._declaredClass, Trace.levels.ENTRY, "findFirstInvalidCharInProperty");
      var firstInvalidChar = null; // assume no invalid characters
      if (str !== null && str !== undefined) {
        var invalidSpecialCharacters = "^$.|\\<>?+*=&[]()";  // Character set taken from ac26550_
        if (treatDotCharAsValid === true) {
        	invalidSpecialCharacters = "^$|\\<>?+*=&[]()";
        }
        for (var i = 0; i < str.length; i++) {
          var currentChar = str.charAt(i);
          if (invalidSpecialCharacters.indexOf(currentChar) !== -1) {
            firstInvalidChar = currentChar;
            break;
          }
        }
      }
      Trace.trace(this._declaredClass, Trace.levels.EXIT, "findFirstInvalidCharInProperty");
      return firstInvalidChar;
    },
    
    /**
     * Returns boolean on whether the current broker has a Queue Manager defined based on its advanced property value.
     */
    hasCurrentQMGR: function() {
      Trace.trace(this._declaredClass, Trace.levels.ENTRY, "hasCurrentQMGR");
      
      var currentQMGR = window.brokerProperties.getProperty("advanced", "queueManager");
      // If QMGR empty, then retrieve latest properties to test value
      if((currentQMGR === "") || (typeof currentQMGR === "undefined") || (currentQMGR == null)) {
        // Callback for processing populated properties object
        var callback = function(propertiesStore) {
          var currentQMGR = propertiesStore.getProperty("advanced", "queueManager");
          // Only return no queue manager if value is definitely empty
          if(currentQMGR === "") {
            return false;
          }
          return true;
        };
        
        // Call properties on broker to get the latest value
        var propertiesStore = new PropertiesStore();
        var populatePropertiesStore = propertiesStore.populatePropertiesStore(Resources.REST.root);
        // Run callback with propertiesStore passed in as parameter
        populatePropertiesStore.then(
          lang.partial(callback, propertiesStore),
          // If error returns, don't show no QMGR error, incase we are showing a true negative, when it really does have one, we just couldn't get at the broker properties.
          function() {  return true; });
      } else {
        // QMGR found, one is set
        return true;
      }
      
      Trace.trace(this._declaredClass, Trace.levels.EXIT, "hasCurrentQMGR");
    },
    
    // utility to setup notification admin handlers
    setupAdminHandlers : function(adminTopicHandlers, processAdminNotificationCallback) {
        // set a refresh topic at the broker level
        var refreshTopicBroker = new WebUiHash(Resources.REST.nodeHome).getNotificationTopic(false); // Broker object - i.e. EG deletion update
        var refreshTopicChildren = new WebUiHash(Resources.REST.nodeHome).getNotificationTopic(true); // plus wildcard

        adminTopicHandlers.push(Topic.subscribe(refreshTopicBroker, processAdminNotificationCallback));
        adminTopicHandlers.push(Topic.subscribe(refreshTopicChildren, processAdminNotificationCallback)); 
    },
    
    // utility to remove notification admin handlers
    removeAdminHandlers : function(adminTopicHandlers) {
      adminTopicHandlers.forEach(function(nextAdminHandler) {
        if(nextAdminHandler) {
          nextAdminHandler.remove();
        }
      });        
      adminTopicHandlers = [];
    },
    
    /*
     * Utility method for listen for admin notification
     * If the notification is about this object, reread the properties, in particular attribute
     * and call the toggleCallback based on the state of the attribute
     */
    processAdminHandlers: function (message, objectUri, attributesStore, attribute, toggleCallback) {
      Trace.trace(this._declaredClass, Trace.levels.ENTRY, "processAdminHandlers");
      Trace.trace(this._declaredClass, Trace.levels.DEBUG, "Received admin notification for "+message.destinationName);

      // if the notification is about this object
      var restUri = new RestUri(objectUri);
      if  (restUri.isAdminNotificationForThisObject(message)) {
        // reread the properties
        var populatAttributesPromise = attributesStore.populateAttributesStore(); 
        populatAttributesPromise.then(lang.hitch(this, function() {
          var enable = attributesStore.getAttribute(attribute);
          toggleCallback(enable);
        }));
      }
      // else Ignore other notifications
      Trace.trace(this._declaredClass, Trace.levels.ENTRY, "processAdminHandlers");

    },

    
    /**
     *  Returns a formatted label 
     */
    deriveLabelValue: function(objectUri) {
      Trace.trace(this._declaredClass, Trace.levels.ENTRY, "deriveLabelValue");
      
      var label = "";
      var uri = new RestUri(objectUri);
      var name = uri.getArtifactName();
      var parentUri = uri.getParentArtifactRestUri();
      var egName = parentUri.getArtifactName();
      
      // MsgFlow get possible container and eg
      if(uri.getArtifactType() === Resources.REST.messageFlowsTypeUri) {
        // If just in a plain old EG
        if(parentUri.getArtifactType() === Resources.REST.executionGroupsTypeUri) {
          // <FlowName> ( deployed <egName))
          label = name + " (" + parentUri.getArtifactName() + ")";
        } else {
          var egParentUri = parentUri.getParentArtifactRestUri();
          //<FlowName> ( <ContainerName> from <egName)
          label = name + " (" + egParentUri.getArtifactName() + " - " + parentUri.getArtifactName() + ")";
          egName = egParentUri.getArtifactName();
        }
      } else {
        // Else not a msg flow, just state artifact and container
        label = name + " (" + parentUri.getArtifactName() + ")";
      }
      
      Trace.trace(this._declaredClass, Trace.levels.EXIT, "deriveLabelValue");
      
      // Return both label and egName for further processing
      return [label, egName];
    },
    
    // Check on whether we are still operating upon the same object, irrelevant of tab number.
    // So UI elements are there in tab pane but might not be visible, but can still be acted upon.
    isSameObjectHash: function(previousHash, callingTab, numTabs) {
      var isSameObjectHash = false;
      var curHash = hash();
      // Same hash so true
      if(previousHash === curHash) {
        return true;
      } else {
        for(var i = 0; i < numTabs; i++) {
          if(callingTab != i) {
            var preUpdatedHash = previousHash.replace("\/" + callingTab + "\/", "\/" + i + "\/");
            // Same object, but different tab, so true
            if(preUpdatedHash === curHash) {
              isSameObjectHash = true;
            }
          }
        }
      }
      // Else false
      return isSameObjectHash;

    }
  };
});

},
'webui/widgets/common/EditNumericPropertyValueDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 *
 */

/*
 * This widget is a dialog that allows a user to edit a numeric value in a textarea.
 *
 * This widget is used by the properties editors.
 */

define(
  "webui/widgets/common/EditNumericPropertyValueDialog",
  [
    "dojo/text!webui/widgets/common/templates/EditNumericPropertyValueDialog.html",
    "dojo/i18n!webui/nls/web",
    "webui/widgets/common/EditPropertyValueDialog",
    "dojo/_base/declare",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "webui/widgets/common/Trace",

    // For HTML template
    "dijit/form/NumberTextBox"
  ],
  function(
    template,
    NLS,
    EditPropertyValueDialog,
    declare,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    Trace
  ) {

  var editPropertyValueDialog = declare("webui.widgets.common.EditNumericPropertyValueDialog", [ EditPropertyValueDialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
    templateString : template,
    _isResettingValue : false,
    _valueChangedEventHandler : null,
    _buttonOKLabel:NLS.okButtonLabel,
    _buttonCancelLabel: NLS.cancelButtonLabel,
    currentValue : "",
    cell: null,

    // Returns the dialog type
    _dialogType: function() {
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "_dialogType");
      Trace.trace(this.widgetName, Trace.levels.EXIT, "_dialogType");
      return "numeric";
    },

  });
  return editPropertyValueDialog;
});

},
'webui/widgets/common/SmallMessage':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="3085515704" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/i18n!webui/nls/web",
  "dojo/_base/declare",
  "dojo/_base/fx",
  "dojo/_base/lang",
  "dojo/dom-construct",
  "dojo/dom-style",
  "dojo/fx",
  "dojo/query",
  "dojo/string",
  "idx/widget/SingleMessage",
  "webui/widgets/common/Trace",
  "dojox/html/entities",
  "webui/utils/StatsUtils"
], function(
  NLS,
  declare,
  baseFx,
  lang,
  domConstruct,
  domStyle,
  coreFx,
  query,
  string,
  SingleMessage,
  Trace,
  HTMLEntities,
  StatsUtils
) {

  /**
   * SmallMessage is the small notification which appears above the main
   * tab widgets. There should be exactly one of these. WMBConsole creates it, and
   * all tabs (and PropertiesStores belonging to those tabs) share it.
   * 
   * In the main ContentPane there are two <div/>s, one is "messageContainer" which
   * contains SmallMessage, and the other is "titleContainer" which contains the
   * usual headline of the pane e.g. "IB10NODE" and the integration node icon.
   * Only one of these is shown at a time. 
   */
  var SmallMessage = declare("webui.widgets.common.SmallMessage", [], {

    _messageDialog: null,
    _displaying: false,

    /**
     * Show the message.
     * `type` is e.g. "error" or "success".
     * `msgId` is a key for NLS.messages.
     * optional `bipNumber`, set to `null` if not needed.
     * optional `description` should be a *fully NLSed string* or `null`.
     * optional argument `nlsArgs` to be substituted into the NLS message.
     */
    displayMessage : function(type, msgId, bipNumber, description, nlsArgs) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "displayMessage", [type, msgId, bipNumber, description, nlsArgs]);

      var msg = NLS.messages[msgId];
      if(!msg) {
        console.error("NLS message not found:", msgId);
        msg = "";
      }

      if (nlsArgs) {
        msg = string.substitute(msg, nlsArgs);
      }
      
      // Encode message before showing it to prevent code injection:
      msg = HTMLEntities.encode(msg);
      
      var messageId = bipNumber ? "BIP" + bipNumber : "";
      var details = description || "";

      // We may be displaying a message or in the middle of fading a message
      // out or in the middle of fading a message in. In any case this has
      // been pre-empted: destroying the existing message synchronously.
      // TODO: better message sequencing, so we don't have this problem.
      var testMode = StatsUtils.isTestingOn();
      if(this._displaying && !testMode){
    	// For testing purposes, we don't want messages being destroyed
        this._destroyMessage();
      }

      //////////// Args are now ready

      this._messageDialog = new SingleMessage({
        type: type,
        dateFormat: {selector: 'time', timePattern: 'HH:mm'},
        title: msg,
        showRefresh: false,
        showDetailsLink: false,
        showId: false,
        showAction: false,
        description: details,
        messageId: messageId,
        onClose: lang.hitch(this, function(){
          this.hideMessage();
        })
      });

      this._displaying = true;
      var effects = [
        baseFx.fadeOut({
          node: "titleContainer",
          duration: 100,
          onEnd: lang.hitch(this, function() {
            domStyle.set("titleContainer", "display", "none");
            domConstruct.place(this._messageDialog.domNode, "messageContainer");
          })
        }),
      
        baseFx.fadeIn({
          node: "messageContainer",
          onBegin: lang.hitch(this, function() {
            this._messageDialog.resize();
          }),
          duration: 500
        })
      ];

      // In addition to the above, success messages automatically fade out after a little while.
      // Note that these are the same steps as hideMessage() and _destroyMessage().
      // We don't want success messages to disappear in test mode

      if(type == "success" && !testMode) {
        effects.push(
          baseFx.fadeOut({
            node: "messageContainer",
            delay: 4000,
            duration: 2000,
            onEnd: lang.hitch(this, function(){
              query('#messageContainer > *').forEach(function(item) {
                domConstruct.destroy(item);
              });
            })
          }),

          baseFx.fadeIn({
            node: "titleContainer",
            onBegin: lang.hitch(this, function() {
              domStyle.set("titleContainer", "display", "");
              this._messageDialog.resize();
            }),
            duration: 100,
            onEnd: lang.hitch(this, function() {
              this._displaying = false;
            })
          })
        );
      }

      coreFx.chain(effects).play();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "displayMessage");
    },

    /**
     * Fade the message out and destroy it, then fade the titleContainer
     * back in.
     */
    hideMessage : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "hideMessage");

      coreFx.chain([
        baseFx.fadeOut({
          node: "messageContainer",
          duration: 300,
          onEnd: lang.hitch(this, function(){
            query('#messageContainer > *').forEach(function(item){
              domConstruct.destroy(item);
            });
          })
        }),
        baseFx.fadeIn({
          node: "titleContainer",
          onBegin: lang.hitch(this, function() {
            domStyle.set("titleContainer", "display", "");
          }),
          duration: 100,
          onEnd: lang.hitch(this, function() {
            this._displaying = false;
          })
        })
      ]).play();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "hideMessage");
    },

    /**
     * Hide the message, but do it immediately, no fadeout. Replace it
     * with the titleContainer. Usually used when another message needs
     * to replace this one urgently.
     * Same exact steps as hideMessage(), but performed synchronously. 
     */
    _destroyMessage : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_destroyMessage");

      domStyle.set("messageContainer", "opacity", "0");
      query('#messageContainer div').forEach(function(item){
        domConstruct.destroy(item);
      });
      domStyle.set("titleContainer", "display", "");
      domStyle.set("titleContainer", "opacity", "100");
      this._displaying = false;

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_destroyMessage");
    },

    /**
     * Display the SmallMessage (simpler method signature).
     * `msg` is a key for NLS.messages - this ensures all our messages are kept together and makes
     * it impossible to accidentally pass in a raw, un-NLSed string.
     * `nlsArgs` is optional
     */
    displayPlainMessage : function(type, msgId, nlsArgs) {
      return this.displayMessage(type, msgId, null, null, nlsArgs);
    }

  });

  return SmallMessage;
});

},
'webui/widgets/common/PropertiesStore':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="3085515704" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/store/JsonRest",
  "dojo/store/Memory",
	"webui/widgets/common/Trace"
], function(
  declare,
  lang,
  JsonRest,
  Memory,
  Trace
) {
  return declare("webui.widgets.common.PropertiesStore", [], {

		
		_store: null,
		_propertiesStores : {},

		/**
		 * Called when clicking on "Statistics" or "Policies" tabs of a flow or server
		 */
		populatePropertiesStore: function(uri) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "populateStore", [uri]);	
			
			// Load the memory store with properties from the item selected in the tree
			if(!uri) {
			  throw new Error("Tried to construct a PropertiesStore without passing in a REST artifact URI.");
			}

			// Add a trailing slash if it's missing
			if(uri.charAt(uri.length-1)!="/"){
				uri = uri + "/";
			}
			
			// Remove a leading slash if there is one (?)
			if(uri.charAt(0)=="/"){
				uri = uri.substr(1,uri.length-1);
			}

			var target = uri;

			Trace.trace(this.declaredClass, Trace.levels.DEBUG, "populatePropertiesStore", [target]);
			this._store = new JsonRest({"target": target});

			var propertiesStored = this._store.get("properties");
			
			propertiesStored.then(
		    lang.hitch(this,function(object) {
		      // e.g. {"uri":"/apiv1/properties","basicProperties":[{"name":"AdminSecurity","value":"inactive"},...],"advancedProperties":[...],...}
		      Object.keys(object).forEach(lang.hitch(this, function(type) {

		        // ignore "uri"
		        if(!Array.isArray(object[type])) {
		          return;
		        }

		        this._propertiesStores[type] = new Memory({
    					data : object[type],
    					idProperty : "name"
    				});
		      }));
  			}),
  			lang.hitch(this,function(error){

  			  var bipNumber;
  			  var description;

  			  if(error.responseText) {
  			    var errorResponse = JSON.parse(error.responseText);
  			    if(errorResponse.bipNumber) {
              bipNumber = errorResponse.bipNumber;
              description = errorResponse.description;
  			    }
  			  }

          // Specific message for deleted flows (BIP1019) and integration servers (BIP1038)

  			  if(error.status == 404) {
            if(bipNumber == "1019") {
              window.smallMessage.displayMessage("error", "DeployedObjectDoesNotExist_404", bipNumber, description);
            } else if(bipNumber == "1038") {
              window.smallMessage.displayMessage("error", "EGDoesNotExist_404", bipNumber, description);
            } else {
              window.smallMessage.displayMessage("error", "ItemDoesNotExist_404", bipNumber, description);
            }
          } else {
            if(bipNumber == "1019") {
              window.smallMessage.displayMessage("error", "DeployedObjectDoesNotExist_5XX", bipNumber, description);
            } else if(bipNumber == "1038") {
              window.smallMessage.displayMessage("error", "EGDoesNotExist_5XX", bipNumber, description);
            } else {
              window.smallMessage.displayMessage("error", "ItemDoesNotExist_5XX", bipNumber, description);
            }
          }
  			})
      );
			
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "populateStore");
			return propertiesStored;
		},
		
		getProperty: function(/* string */ type, /* string */ name) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "getProperty", [type,name]);
			
			type += "Properties"; // "basicProperties", "advancedProperties", ...

			var innerStore = this._propertiesStores[type];
			if(innerStore == null )
			{
			  //If we get here, then we may need a better solution to the window.brokerProperties 
			  //not having been populated yet.
			  throw new Error("No property store of type '" + type + "'");
			}

			var nvPair = innerStore.get(name); // e.g. {"name" : "name", "value" : "IB10NODE"}

			var value = nvPair ? nvPair.value : ""; // "IB10NODE"
			
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "getProperty", [value]);
			return value;
		}
		
	});
});

},
'webui/widgets/configurableservice/cs_category_overview':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63" 
 * years="2014, 2015" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63 
 *  
 * (C) Copyright IBM Corp. 2014, 2015 All Rights Reserved.  
 * </copyright> 
 */

/*
 * This widget provides the implementation of actions on the context-menu of the
 * Configurable Services category in the navigator.
 * 
 * Currently only a create action is supported. The create action opens an
 * instance of the Configurable Service Editor widget in a tab on the right-hand
 * side of the UI.
 *
 * This widget manages the life cycle of the editor:
 * - When tabFocus is called, a new Configurable Service Editor widget is
 *   created if one does not already exist.
 * - If the user tries to navigate away from the open Configurable Service Editor
 *   widget, this widget asks the user if they want to continue if there are
 *   unsaved changes (i.e. the configurable service has not been created yet).
 * - When tabRmove is called, the Configurable Serviced Editor widget is destroyed. 
 */
 
define(
  "webui/widgets/configurableservice/cs_category_overview",
  [
    "dojo/text!webui/widgets/configurableservice/templates/cs_category_overview.html",
    "dojo/i18n!webui/nls/web",
    "dojo/_base/declare",
    "dojo/_base/lang",
    "dojo/on",
    "dojo/hash",
    "dojo/keys",
    "dijit/_WidgetBase", 
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/registry",
    "idx/widget/ConfirmationDialog",
    "webui/widgets/common/HasContextMenu",
    "webui/widgets/common/Trace",
    "webui/widgets/configurableservice/ConfigurableServiceEditor",
    "webui/config/Resources",
    "webui/utils/WebUiHash",
    "dojo/topic",
    "webui/widgets/configurableservice/ImportConfigurableServiceFileDialog",
    "dojo/query",
    "dojo/dom-attr",
    "webui/widgets/common/UIUtils"
  ], 
  function(
    template,
    NLS,
    declare,
    lang,
    on,
    hash,
    keys,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    registry,
    ConfirmationDialog,
    HasContextMenu,
    Trace,
    ConfigurableServiceEditor,
    Resources,
    WebUiHash,
    topic,
    ImportConfigurableServiceFileDialog,
    query,
    attr,
    UIUtils
  ) {
    var cs_category_overview = declare("webui.widgets.configurableservice.cs_category_overview", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
      templateString: template, // points js to the html template to use
      declaredClass: "webui.widgets.configurableservice.cs_category_overview",
      
      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
        // Editor is created in the tabFocus function below
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
      },
      
      resize: function() {
         Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");
         
         // Resize the configurable service editor widget:
         if (this._isConfigurableServiceEditorOpen()) {
         	this.configurableServiceEditor.resize();
         }
         
         Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
      },
      
      tabFocus: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");
        
        // Create the configurable service editor widget if it is not already created:
        if (!this._isConfigurableServiceEditorOpen()) {
        	this.configurableServiceEditor = new ConfigurableServiceEditor();
        	
        	// Subscribe to cancel event:
        	this.editorCancelSubscription = topic.subscribe(
        	  Resources.pubSubTopic.configurableServiceAddCancelled,
        	  lang.hitch(this, function() {
        	    // Set the tree to the root node:
        	    hash(Resources.REST.nodeHome);
        	  })
        	);
        	
        	this.configurableServiceEditor.placeAt(this._csAddEditor);
        	this.configurableServiceEditor.startup();
        }
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus"); 
      },
      
      tabBlur: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur"); 
      },
      
      tabRemove: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
        this._destroyConfigurableServiceEditor();
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove"); 
      },
      
      // Called when a user selects a button on the context-menu of the Configurable Services category:
      contextButtonsClicks : function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks");
		
        // Get the URI and action from the event:
        var uriAndAction = UIUtils.getURIAndAction(event);
        var uri = uriAndAction.uri;
        var action = uriAndAction.action;
		
        // Handle the action for the URI:
        if(action === "create") {
          this._createConfigurableService(uri);
        }
        else if(action === "importConfigurableService") {
          this._importConfigurableService(uri);
        }
          
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
      },
      
      _createConfigurableService : function(uri) {
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createConfigurableService");
      	
      	var newHash = WebUiHash.fromRestUri(uri).toString();
      	
      	if (!this._isConfigurableServiceEditorOpen()) {
      	  // Causes tabFocus to be called on this widget:
          var newEvent = { type : "configurableServices" };
          window.wmbConsole.safelyChangeHash(newHash);
          window.wmbConsole.createInfoPane(newEvent, true);
        }
        
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createConfigurableService");
      },
      
      _importConfigurableService : function() {
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_importConfigurableService");
      	
      	// Used to show the loading icon when uploading, and to remove the loading icon
      	// when the upload is complete:
      	var treeImgs = null;
        var oldIcon = null;
      	
      	// Function that is called when the user clicks OK on the import dialog:
      	var confirmCallback = lang.hitch(this, function() {
      		var csImportCSFileDialog = registry.byId("csImportCSFileDialog");
      		
      		window.smallMessage.displayPlainMessage("information", "ConfigurableService_importing", [csImportCSFileDialog.getNameOfFileToUpload()]);
      		
      		// Add loading icon to tree:
      		var tree = registry.byId('_explorerTree_ID');
      		treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
      		oldIcon = attr.get(treeImgs[0],"class");
      		attr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");
      		
      		// Call upload after 1/2 second (to give a chance for information message
      		// from above to become visible):
      		setTimeout(
      		  function() {
      		    csImportCSFileDialog.upload();
      		  },
      		  500);
      	});
      	
      	// Function that is called when the upload is complete (regardless of whether
      	// the upload was successful or not):
      	var uploadCallback = lang.hitch(this, function(response) {
      	  // Reset old icon (to remove loading icon):
      	  attr.set(treeImgs[0],"class",oldIcon);
          
      	  var csImportCSFileDialog = registry.byId("csImportCSFileDialog");
      	  if (response.error === undefined) {
      	    // Display success message:
      	    window.smallMessage.displayPlainMessage("success", "ConfigurableService_importCSFileSuccess", [csImportCSFileDialog.getNameOfFileToUpload()]);
      	    // Publish the fact that the configurable service was created (may have only been
      	    // updated but that is OK):
      	    topic.publish(Resources.pubSubTopic.configurableServiceCreated, {uri: response.uri});
      	  }
          else {
            // Display the error message:
            window.smallMessage.displayPlainMessage("error", "ConfigurableService_importCSFileFailure", [csImportCSFileDialog.getNameOfFileToUpload(), response.error]);
          }
        });
      	
        // Create the import dialog if necessary:
    	var csImportCSFileDialog = registry.byId("csImportCSFileDialog");
    	if (!csImportCSFileDialog) {
    	  // Dialog does not exist, create the dialog:
    	  csImportCSFileDialog = new ImportConfigurableServiceFileDialog({
    	    id : "csImportCSFileDialog",
    	    createCallback : confirmCallback,
    	    uploadCompleteCallback: uploadCallback
          });
          csImportCSFileDialog.startup();
        }
        
        // Refresh and show the dialog:
        csImportCSFileDialog.refresh();
        csImportCSFileDialog.show();
        
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_importConfigurableService");
      },
      
      _isConfigurableServiceEditorOpen: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_isConfigurableServiceEditorOpen");
      	var returnValue = this.configurableServiceEditor !== null && this.configurableServiceEditor !== undefined;
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_isConfigurableServiceEditorOpen");
      	return returnValue;
      },
      
      _destroyConfigurableServiceEditor: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_destroyConfigurableServiceEditor");
        // Destroy the configurable service editor widget if it exists:
        if (this._isConfigurableServiceEditorOpen()) {
       	  
       	  if (this.editorCancelSubscription !== undefined && this.editorCancelSubscription !== null) {
     	    this.editorCancelSubscription.remove();
          }
       	  
       	  this.configurableServiceEditor.destroy();
          this.configurableServiceEditor = null;
          
          // Clear the current message (as there may be a message associated with editor that is not longer applicable):
          window.smallMessage.hideMessage();
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_destroyConfigurableServiceEditor");
      },
      
      // This method is called by WMBConsole and allows a potential change of the
      // hash to be veto'ed by returning false:
      canChangeHash: function(oldHash, newHash) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "canChangeHash");
      
        // Check if the user is trying to navigate to an editor that is already
        // open and dirty, and if so prevent the hash change (in order to prevent
        // the user from re-loading the editor and losing their changes):
        if (oldHash === newHash && this._isConfigurableServiceEditorOpen() && this.configurableServiceEditor.isDirty()) {
            Trace.trace(this.declaredClass, Trace.levels.EXIT, "canChangeHash");
          	return false;
        }
        
        // If the editor is dirty, we need to ask the user if they want to continue
        // to navigate away from the editor:
        if (this._isConfigurableServiceEditorOpen() && this.configurableServiceEditor.isDirty()) {
        
          // Create the confirmation dialog if it does not already exist:
      	  var csConfirmSwitchDialog = registry.byId("csConfirmSwitchDialog");
          if (typeof csConfirmSwitchDialog === "undefined") {
            csConfirmSwitchDialog = new ConfirmationDialog({
              type : "information",
              buttonLabel : NLS.btLeaveSave,
              cancelButtonLabel : NLS.btStayOnPage,
              closeButtonLabel : NLS.btStayOnPage,
              text : NLS.messages.ConfigurableService_creationConfirmNavigateAwayFromEditorConfirmationMessage
            }, "csConfirmSwitchDialog");
          }
          
         // Callback handler for when the user clicks 'confirm' on the dialog:
         csConfirmSwitchDialog.confirm(lang.hitch(this, function() {
           // Destroy the configurable service editor widget first or we will end up in an endless loop:
           this._destroyConfigurableServiceEditor();
		   
           // Allow the new hash to be selected:
           hash(newHash);
         }));
        
         // Callback handler for when the user clicks 'cancel' on the dialog:
         csConfirmSwitchDialog.onCancel = lang.hitch(this, function() {
           // Don't change the hash, but an item in the tree has been selected and focused upon.
           // Make sure the current item retains its focus, previous selected node, with no hash change/refresh.
           window.wmbConsole.expandTreeAndRefreshHash(oldHash, false);
           csConfirmSwitchDialog.hide();
         });
         
         on(csConfirmSwitchDialog, "keydown", lang.hitch(this, function (event){
            // Move the focus accordingly if the arrow keys are pressed
            var key = event.keyCode;                
            if ((key == keys.LEFT_ARROW) && csConfirmSwitchDialog.closeAction.focused) {
              csConfirmSwitchDialog.confirmAction.focus();
            } 
            else if ((key == keys.RIGHT_ARROW) && csConfirmSwitchDialog.confirmAction.focused){
              csConfirmSwitchDialog.closeAction.focusNode.focus();
            }
            // Extend confirm/close function to close on Enter key press
            if (key == keys.ENTER) {
              if(csConfirmSwitchDialog.confirmAction.focused) {
                csConfirmSwitchDialog.hide();
                
                // Destroy the configurable service editor widget first or we will end up in an endless loop:
                this._destroyConfigurableServiceEditor();
		        
                // Allow the new hash to be selected:
                hash(newHash);
              } else {
                if(csConfirmSwitchDialog.closeAction.focused) {
                  csConfirmSwitchDialog.onCancel();
                }
              }
            } 
            // Stop the keyboard event propagating i.e. moving a flow on the canvas
            event.stopPropagation();
         }));
          
         // Open the dialog:
         csConfirmSwitchDialog.show();
         
         // Return false to prevent the change in hash from happening automatically
         // (the user will determine if the change in hash will occur though the dialog
         // opened above):
         
         Trace.trace(this.declaredClass, Trace.levels.EXIT, "canChangeHash");
         return false;
      	}
      	
      	// editor is not open or is clean, so return true to allow the hash to change:
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "canChangeHash");
        return true;
      }
      
    });
    return cs_category_overview;
  }
);
},
'webui/widgets/business/EventDetailsDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="763384209" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/business/templates/EventDetailsDialog.html",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/on",
  "dijit/Dialog",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetsInTemplateMixin",
  "webui/widgets/common/Trace",
  "dojo/string",
], function(
  template,
  NLS,
  declare,
  lang,
  domAttr,
  on,
  Dialog,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  Trace,
  string
) {
	var eventDetailsDialog = declare("webui.widgets.business.EventDetailsDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
		templateString: template,
        
		_monitoringEvent : null,
	    _businessTransactionInstanceID : null,
	    _businessTransactionName : null,
    //need to pass in this info because we need to pass it along to the callback method for an ajax call.
  	constructor: function(args){
  		
  	  if(!args) {
  	    throw new Error("No arguments passed");
  	  }

  	  this._businessTransactionName = args.btdName;
  	  this._businessTransactionInstanceID = args.btdInstance;
  	  this._monitoringEvent = args.mEvent;
  	  
  	},


		postCreate : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			this.inherited(arguments);

			domAttr.set(this.titleNode, "innerHTML", NLS.btEventResultsTableEventDetailsDialogTitle );
			this.titleNode.setAttribute("tabIndex", -1);
			
			var desc = string.substitute(NLS.btEventResultsTableEventDetailsDialogDesc, [this._monitoringEvent.businessTransactionEventName,this._businessTransactionName,this._businessTransactionInstanceID]);
			
			domAttr.set(this.instructionNode, "innerHTML", desc );
			this.instructionNode.setAttribute("tabIndex", -1);

			
			domAttr.set(this._eventNameLabel, "innerHTML", NLS.btMEEventName );
			this._eventNameText.set("value", this._monitoringEvent.businessTransactionEventName);
			
			domAttr.set(this._eventSourceAddressLabel, "innerHTML", NLS.btMEEventSourceAddress );
			this._eventSourceAddressText.set("value", this._monitoringEvent.businessTransactionEventSourceAddress);


			domAttr.set(this._integrationNodeNameLabel, "innerHTML", NLS.btMEIntegrationNode );
			this._integrationNodeNameText.set("value", this._monitoringEvent.businessTransactionEventBrokerName);

			domAttr.set(this._integrationServerNameLabel, "innerHTML", NLS.btMEIntegrationServer );
			this._integrationServerNameText.set("value", this._monitoringEvent.businessTransactionEventExecutionGroupName);

			domAttr.set(this._flowNameLabel, "innerHTML", NLS.btMEFlowName );
			this._flowNameText.set("value", this._monitoringEvent.businessTransactionEventFlow);

			domAttr.set(this._nodeNameLabel, "innerHTML", NLS.btMEEventNodeName );
			this._nodeNameText.set("value", this._monitoringEvent.businessTransactionEventNodeName);
			
			domAttr.set(this._nodeTypeLabel, "innerHTML", NLS.btMEEventNodeType );
			this._nodeTypeText.set("value", this._monitoringEvent.businessTransactionEventNodeType);

			domAttr.set(this._nodeTerminalNameLabel, "innerHTML", NLS.btMEEventNodeTerminalName );
			this._nodeTerminalNameText.set("value", this._monitoringEvent.businessTransactionEventNodeTerminalName);

			
			domAttr.set(this._localCorrelationIDLabel, "innerHTML", NLS.btMEEventLocalCorrelationID );
			this._localCorrelationIDText.set("value", this._monitoringEvent.businessTransactionEventLocal);

			domAttr.set(this._parentCorrelationIDLabel, "innerHTML", NLS.btMEEventParentCorrelationID );
			this._parentCorrelationIDText.set("value", this._monitoringEvent.businessTransactionEventParent);

			domAttr.set(this._globalCorrelationIDLabel, "innerHTML", NLS.btMEEventGlobalCorrelationID );
			this._globalCorrelationIDText.set("value", this._monitoringEvent.businessTransactionEventGlobal);
			
			domAttr.set(this._cancelButton, "label", NLS.cancelButtonLabel);

			on(this._cancelButton, "click", lang.hitch(this, function() {
				this.hide();
			}));

				
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},

    show : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "show");	
      this.inherited(arguments);
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "show");
    }
	    
	});
	return eventDetailsDialog;
});

},
'webui/widgets/policy/policyActionDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63" 
 * years="2014, 2015" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63 
 *  
 * (C) Copyright IBM Corp. 2014, 2015 All Rights Reserved.  
 * </copyright> 
 *
 * 
 * policyActionDialog widget - displays information about a single of group of monitoring or business events.
 * 
 */
define([
  "dojo/text!webui/widgets/policy/templates/policyActionDialog.html",
  "dojo/i18n!webui/nls/web",
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/dom",
	"dojo/dom-attr",
	"dojo/dom-class",
	"dojo/dom-construct",
  "dojo/keys",
	"dojo/on",
  "dojox/html/entities",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase", 
  "dijit/_WidgetsInTemplateMixin",
  "dijit/DropDownMenu",
  "dijit/MenuItem",
  "dijit/registry",
	"webui/widgets/common/Trace",
	"webui/widgets/policy/MessageDialog",
	"webui/widgets/policy/PolicyEditorDialog"
], function(
  template,
  NLS,
  declare,
  lang,
  dom,
  domAttr,
  domClass,
  domConstruct,
  keys,
  on,
  entities,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  DropDownMenu,
  MenuItem,
  registry,
  Trace,
  MessageDialog,
  PolicyEditorDialog
) {
	var policyAction = declare("webui.widgets.policy.policyActionDialog", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin],{
    
	  templateString: template,
		eventPolicy: null,
		isFlowDiagram: false,
		curNode: null,
		tooltipId: null,
		posX: 0,
		posY: 0,
		flowProfileURI: null,
		flowProfileContainer: null,
		isHidden: true,
		nodePolicyActionMode : "",
		editPolicyMenuItem: null,

// Pull out story 28471 from V10      		
//		showRuntimePropertiesMenuItem: null,
//		attachPolicyMenuItem: null,
//		detachPolicyMenuItem: null,
//		generatePolicyMenuItem: null,
		
         						         							   
		constructor: function(isFlowDiagram, tooltipId, flowProfileURI, flowProfileContainer) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");
			
			// Array event handler stores
			this.closeTooltipHandlers = [];
			this.eventHandlers = [];
			
			this.isFlowDiagram = isFlowDiagram;
			this.tooltipId = tooltipId;
			this.flowProfileURI = flowProfileURI;
			this.flowProfileContainer = flowProfileContainer;
			
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
		}, 

		postCreate : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			
			var closeTooltipHandler = lang.hitch(this, function(event){				
				// Only close the tooltip when is is showing, and clicking on the X or elsewhere on the diagram
				if((!this.isHidden) && ((event.currentTarget.id === this.flowProfileContainer) || (event.currentTarget === this._node_policy_tooltip_close_text))) {
					this.hideTooltip();
					
				}
				// Stop the event bubbling - across browsers
				if (event.stopPropagation) {
					event.stopPropagation();
				}
				if (event.cancelBubble != null) {
					event.cancelBubble = true;
				}
			});

			// Set up the close handler on the tooltip
			this.closeTooltipHandlers.push( on(dom.byId(this._node_policy_tooltip_close_text), 'click', closeTooltipHandler));
			this.closeTooltipHandlers.push( on(dom.byId(this.flowProfileContainer), 'mousedown', closeTooltipHandler));
			this.closeTooltipHandlers.push( on(dom.byId(this._node_policy_tooltip_close_text), 'keypress',
				lang.hitch(this, function(event){
				    // Only close the tooltip if the key event was a space or return carriage
					var charCode = (typeof event.which == "number") ? event.which : event.keyCode;
					// Return               // Space
					if((charCode === keys.ENTER) || (charCode === keys.SPACE)) {
						closeTooltipHandler(event);
					}
				})
			));
						
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},
		
		renderTooltip: function(node, policyURL, posX, posY) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "renderTooltip");
			this.curNode = node.name;
			this.posX = posX;
			this.posY = posY;

			// Add the title information
			this.addTitle();
			
			if(this.isFlowDiagram) {
				// Add the details to tooltip 
				this.addDialogContent(node, policyURL);
				this.positionTooltip();
			}

			Trace.trace(this.declaredClass, Trace.levels.EXIT, "renderTooltip");
		},
		
		addTitle: function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "addTitle");
			
			this._node_policy_actions_heading.innerHTML = entities.encode(NLS.policy_actionDialogTitle); 
 		    
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "addTitle");
		},
		
		addDialogContent: function(node, policyURL) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "addDialogContent");
			   		
			// clear the action dialog content
			if (this.editPolicyMenuItem != null){
				this.editPolicyMenuItem.destroy();
				this.editPolicyMenuItem = null;
			}

// Pull out story 28471 from V10  			
//			if (this.showRuntimePropertiesMenuItem != null){
//				this.showRuntimePropertiesMenuItem.destroy();
//				this.showRuntimePropertiesMenuItem = null;
//			}
//			
//			if (this.attachPolicyMenuItem != null){
//				this.attachPolicyMenuItem.destroy();
//				this.attachPolicyMenuItem = null;
//			}
//			
//			if (this.detachPolicyMenuItem != null){
//				this.detachPolicyMenuItem.destroy();
//				this.detachPolicyMenuItem = null;
//			}
//			
//			if (this.generatePolicyMenuItem != null){
//				this.generatePolicyMenuItem.destroy();
//				this.generatePolicyMenuItem = null;
//			}
			
			if (this.policyActionSelect != null){
				this.policyActionSelect.destroy();
				this.policyActionSelect = null;
				this._node_policy_actions.innerHTML = "";
			}

                
			this.policyActionSelect = new DropDownMenu({
			  id: "policyAction",
			  autoComplete: true
			});            
            
			// policy already attached
			if (typeof policyURL != 'undefined' && policyURL !== "" && policyURL !== "default"){
			  this.editPolicyMenuItem = new MenuItem({
			    label: NLS.policy_actionEditPolicy,
			    onClick: lang.hitch(this, function() {
			      this.nodePolicyActionMode = "E";
			      this.hideTooltip();
			      this.openPolicyEditor("E", node, policyURL);
			    }) 
			  });

// Pull out story 28471 from V10                  
//                this.showRuntimePropertiesMenuItem = new MenuItem({ 
//                	label: NLS.policy_actionShowEffectiveProperties,
//                	onClick: lang.hitch(this, function() {
//                		this.nodePolicyActionMode = "S";
//                		this.hideTooltip();
//                		this.openPolicyEditor("S", node, policyURL);
//                	}) 
//                });
//                
//                this.detachPolicyMenuItem = new MenuItem({
//                	label: NLS.policy_actionDetachPolicy,
//                	onClick: lang.hitch(this, function() {
//                		this.nodePolicyActionMode = "D";
//                		this.hideTooltip();
//                		this.notImplementedDialog();
//                	}) 
//                });
			  
			  this.policyActionSelect.addChild(this.editPolicyMenuItem);
            	
// Pull out story 28471 from V10  
//            	this.policyActionSelect.addChild(this.showRuntimePropertiesMenuItem);
//            	this.policyActionSelect.addChild(this.detachPolicyMenuItem);

			}

// Pull out story 28471 from V10  
//            else { 
//                this.showRuntimePropertiesMenuItem = new MenuItem({ 
//                	label: policy_actionShowEffectiveProperties,
//                	onClick: lang.hitch(this, function() {
//                		this.nodePolicyActionMode = "S";
//                		this.hideTooltip();
//                		//this.notImplementedDialog();
//                		this.openPolicyEditor("S", node, policyURL);
//                	}) 
//                });
//                
//                this.attachPolicyMenuItem = new MenuItem({ 
//                	label: NLS.policy_actionAttachPolicy,
//                	onClick: lang.hitch(this, function() {
//                		this.nodePolicyActionMode = "A";
//                		this.hideTooltip();
//                		this.notImplementedDialog();
//                	}) 
//                });
//                               
//                this.generatePolicyMenuItem = new MenuItem({ 
//                	label: NLS.policy_actionGeneratePolicy,
//                	onClick: lang.hitch(this, function() {
//                		this.nodePolicyActionMode = "G";
//                		this.hideTooltip();
//                		this.notImplementedDialog();
//                	}) 
//                });
///            	this.policyActionSelect.addChild(this.showRuntimePropertiesMenuItem);
//            	this.policyActionSelect.addChild(this.attachPolicyMenuItem);
//            	this.policyActionSelect.addChild(this.generatePolicyMenuItem);
//             }         
              
			domConstruct.place(this.policyActionSelect.domNode,  this._node_policy_actions); 
			
			// Empty the handlers
			this.eventHandlers = [];
            
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "addDialogContent");
		},

		showTooltip: function(node, policyURL, posX, posY, refresh) { 
		  // force a refresh when the content of the tooltip needs to be updated as result of changes elsewhere
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "showTooltip");
			
			// Check that the tooltip needs updating
			if (refresh || (this.curNode != node.name)) {
			  // As content is changing, remove all the event handlers for the tooltip
			  this.clear();
			  this.renderTooltip(node, policyURL, posX, posY); 
			} 
			else {
				this.updatePosition(posX, posY);
			}
			
			// Now show the tooltip
			if(domClass.contains(this.tooltipId, "event_tooltip_hidden")) {
			  domClass.remove(this.tooltipId, "event_tooltip_hidden");
			  this.isHidden = false;
			}

	    Trace.trace(this.declaredClass, Trace.levels.EXIT, "showTooltip");
		},
		
		notImplementedDialog: function() {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "notImplementedDialog");
        	
		  var notImplementedDialog = registry.byId("policyMessageDialog");
		  if (!notImplementedDialog) {
		    notImplementedDialog = new MessageDialog( {
		      id : "policyMessageDialog"
		    });
		    
		    notImplementedDialog.startup();
            	
		  }
		  domAttr.set(notImplementedDialog.titleNode, "innerHTML", entities.encode(NLS.functionNotImplemented));

		  notImplementedDialog.refresh();
		  notImplementedDialog.show();
              
		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "notImplementedDialog"); 
		},
		
		openPolicyEditor: function(actiontype, node, policyURL) {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "openPolicyEditor");
        	
		  var policyEditorDialog = registry.byId("policyEditorDialog");
		  // destroy the dialog first and recreate it
		  if (policyEditorDialog != null) {
		    try{
		      policyEditorDialog.cleanup();
		      policyEditorDialog.destroy();
		    }
		    catch(e) {}
                
		    policyEditorDialog = null;
		  }
	        
		  policyEditorDialog = new PolicyEditorDialog( {
		    id : "policyEditorDialog"
		  });
            	  
		  policyEditorDialog.showDialogContent(actiontype, policyURL, node); 
		  policyEditorDialog.startup(node.type, policyURL);

		  policyEditorDialog.refresh();
		  policyEditorDialog.show();

		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "openPolicyEditor"); 
		},
        
		// TBD for foreignObject SVG
		getTooltipContent: function() {
		  var innerHTML = this._node_policy_tooltip.innerHTML;

		  return innerHTML;
		},
		
		hideTooltip: function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "hideTooltip");
			
			if(!domClass.contains(this.tooltipId, "event_tooltip_hidden")) {
			  domClass.add(this.tooltipId, "event_tooltip_hidden");
			  this.isHidden = true;
			}
			
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "hideTooltip");
		},
		
		positionTooltip: function() {
			var newLeft = this.posX + "px";
			var newTop = this.posY + "px";
			domAttr.set(this.tooltipId, "style", {top: newTop, left: newLeft});
			
		},
		
		updatePosition: function(newX, newY) {
			this.posX = newX;
			this.posY = newY;
			newX += "px";
			newY += "px";
			domAttr.set(this.tooltipId, "style", {top: newY, left: newX});
		},
		
		resize: function() {
		},
		
		clear: function(){
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "clear");
        
		  if(this.eventHandlers.length > 0) {
			  this.eventHandlers.forEach( function(eventHandle){ 
				  eventHandle.remove(); 
			  });
		  }
		  
		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "clear");
		},

		destroy: function(){
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "destroy");
      this.inherited(arguments);
	    
      if(this.closeTooltipHandlers.length > 0) {
				this.closeTooltipHandlers.forEach( function(closeEventHandle){ 
					closeEventHandle.remove(); 
				});
			}
		    
			if(this.eventHandlers.length > 0) {
				this.eventHandlers.forEach( function(eventHandle){ 
					eventHandle.remove(); 
				});
			}
			
			// clear the action dialog content
			if (this.editPolicyMenuItem != null){
				this.editPolicyMenuItem.destroy();
				this.editPolicyMenuItem = null;
			}

// Pull out story 28471 from V10  			
//			if (this.showRuntimePropertiesMenuItem != null){
//				this.showRuntimePropertiesMenuItem.destroy();
//				this.showRuntimePropertiesMenuItem = null;
//			}
//			
//			if (this.attachPolicyMenuItem != null){
//				this.attachPolicyMenuItem.destroy();
//				this.attachPolicyMenuItem = null;
//			}
//			
//			if (this.detachPolicyMenuItem != null){
//				this.detachPolicyMenuItem.destroy();
//				this.detachPolicyMenuItem = null;
//			}
//			
//			if (this.generatePolicyMenuItem != null){
//				this.generatePolicyMenuItem.destroy();
//				this.generatePolicyMenuItem = null;
//			}
			
			// clear the previous action dialog content
			if (this.policyActionSelect != null){
				this.policyActionSelect.destroy();
				this.policyActionSelect = null;
				this._node_policy_actions.innerHTML = "";
			}
			
			var notImplementedDialog = registry.byId("policyMessageDialog");
			if (notImplementedDialog != null) {
			  try{
			    notImplementedDialog.destroy();
			  }
			  catch(e) {}
                
			  notImplementedDialog = null;
			}
	        
			var policyEditorDialog = registry.byId("policyEditorDialog");
			if (policyEditorDialog != null) {
			  try{ 
			    policyEditorDialog.cleanup();
			    policyEditorDialog.destroy();
			  }
			  catch(e) {}
                
			  policyEditorDialog = null;
			}
	    Trace.trace(this.declaredClass, Trace.levels.EXIT, "destroy");
		}

	}); // end dojo declare
	
	return policyAction;
});

},
'webui/widgets/common/EditBooleanPropertyValueDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 *
 */

/*
 * This widget is a dialog that allows a user to edit a boolean value.
 *
 * This widget is used by the properties editors.
 */

define(
  "webui/widgets/common/EditBooleanPropertyValueDialog",
  [
    "dojo/text!webui/widgets/common/templates/EditBooleanPropertyValueDialog.html",
    "dojo/i18n!webui/nls/web",
    "webui/widgets/common/EditPropertyValueDialog",
    "dojo/_base/declare",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "webui/widgets/common/Trace",

    // For HTML template
    "dijit/form/CheckBox"
  ],
  function(
    template,
    NLS,
    EditPropertyValueDialog,
    declare,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    Trace
  ) {

  var editPropertyValueDialog = declare("webui.widgets.common.EditBooleanPropertyValueDialog", [ EditPropertyValueDialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
    templateString : template,
    _isResettingValue : false,
    _valueChangedEventHandler : null,
    _buttonOKLabel:NLS.okButtonLabel,
    _buttonCancelLabel: NLS.cancelButtonLabel,
    currentValue : "",
    cell: null,

    // Returns the dialog type
    _dialogType: function() {
      Trace.trace(this.widgetName, Trace.levels.ENTRY, "_dialogType");
      Trace.trace(this.widgetName, Trace.levels.EXIT, "_dialogType");
      return "boolean";
    },

  });
  return editPropertyValueDialog;
});

},
'webui/widgets/business/BTEventTooltip':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 *
 * 
 * BTEventTooltip widget - displays information about a single of group of monitoring or business events.
 * 
 */
define(
  [
    "dojo/i18n!webui/nls/web",
    "dojo/text!webui/widgets/business/templates/BTEventTooltip.html",
		
		"dijit/_TemplatedMixin",
		"dijit/_WidgetBase",
		"dijit/_WidgetsInTemplateMixin",
		
		"dojo/_base/declare",
		"dojo/_base/lang",
		"dojo/dom",
		"dojo/dom-attr",
		"dojo/dom-class",
	  "dojo/keys",
		"dojo/on",
    "dojo/string",
		"dojo/topic",
		
		"webui/config/Resources",
		"webui/widgets/common/Trace"
	],
	function(
    NLS,
    template,
    _TemplatedMixin,
    _WidgetBase,
    _WidgetsInTemplateMixin,
    declare,
    lang,
    dom,
    domAttr,
    domClass,
    keys,
    on,
    string,
    Topic,
    Resources,
    Trace    
	) {
    
	var eventTooltip = declare("webui.widgets.business.BTEventTooltip", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin],{
    
	  templateString: template,
		eventPolicy: null,
		isFlowDiagram: false,
		curNode: null,
		tooltipId: null,
		posX: 0,
		posY: 0,
		flowProfileURI: null,
		flowProfileContainer: null,
		isHidden: true,
		
		constructor: function(isFlowDiagram, tooltipId, flowProfileURI, flowProfileContainer) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");
			
			// Array event handler stores
			this.closeTooltipHandlers = [];
			this.eventHandlers = [];
			
			this.isFlowDiagram = isFlowDiagram;
			this.tooltipId = tooltipId;
			this.flowProfileURI = flowProfileURI;
			this.flowProfileContainer = flowProfileContainer;

			Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
		}, 

		postCreate : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			
			var closeTooltipHandler = lang.hitch(this, function(event){				
				// Only close the tooltip when is is showing, and clicking on the X or elsewhere on the diagram
				if((!this.isHidden) && ((event.currentTarget.id === this.flowProfileContainer) || (event.currentTarget === this._event_tooltip_close_text))) {
					this.hideTooltip();
			  }
				// Stop the event bubbling - across browsers
        if (event.stopPropagation) {
          event.stopPropagation();
        }
        if (event.cancelBubble != null) {
          event.cancelBubble = true;
        }
			});

			// Set up the close handler on the tooltip
			this.closeTooltipHandlers.push( on(dom.byId(this._event_tooltip_close_text), 'click', closeTooltipHandler));
			this.closeTooltipHandlers.push( on(dom.byId(this.flowProfileContainer), 'mousedown', closeTooltipHandler));
			this.closeTooltipHandlers.push( on(dom.byId(this._event_tooltip_close_text), 'keypress',
		    lang.hitch(this, function(event){
		      // Only close the tooltip if the key event was a space or return carriage
		      var charCode = (typeof event.which == "number") ? event.which : event.keyCode;
		      // Return               // Space
		      if((charCode === keys.ENTER) || (charCode === keys.SPACE)) {
		      	closeTooltipHandler(event);
		      }
		    })
	    ));
						
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},
		
		renderTooltip: function(target, eventPolicy, posX, posY) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "renderTooltip");
			this.curNode = target.name;
			this.eventPolicy = eventPolicy;
			this.posX = posX;
			this.posY = posY;

			// Add the title information
			this.addTitle(target);
			
			if(this.isFlowDiagram) {
				// Add the details to tooltip 
				this.addTableContent();
				this.positionTooltip();
			}

			Trace.trace(this.declaredClass, Trace.levels.EXIT, "renderTooltip");
		},
		
		addTitle: function(target) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "addTitle");
			
			this._event_table_heading.innerHTML = string.substitute(NLS.btEventTooltipTitleMonitoringEvents, [target.policy.eventPolicy.nodeName]);
 		    
	    Trace.trace(this.declaredClass, Trace.levels.EXIT, "addTitle");
		},
		
		addTableContent: function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "addTableContent");
			   
		  // Build up the table
	    var table = "<table class='event_tooltip_table'>";

	    // Add the basic event information
	    this.eventPolicy.nodeMonitoringEvents.forEach( lang.hitch(this, function(monitoringEvent) {
	    	table += "<tr><td>";

	    	var iconClass = "event_tooltip_icon event_icon_";

	    	// If this is a transaction predicate
	  		if(monitoringEvent.isTransactionEvent === "true") {
	  			// Determine the transaction type
    			switch(monitoringEvent.eventSource) {
	    			case "start":
              iconClass += "transaction_start";
	    				break;
	    			case "end":
              iconClass += "transaction_end";
	    				break;
	    			case "rollback":
              iconClass += "transaction_rollback";
	    				break;
    			}
	  		} else {
	  		  // Must be terminal event
    			switch(monitoringEvent.eventSource) {
	    			case "in":
              iconClass += "terminal_in"; 
	    				break;
	    			case "failure":
              iconClass += "terminal_fail";
	    				break;
	    			case "try":
              iconClass += "terminal_try";
              break;
            case "catch":
              iconClass += "terminal_catch";
              break;
            case "timeout":
              iconClass += "terminal_timeout";
              break;
    				// Else the default is an out terminal
	    			default:
              iconClass += "terminal_out";
    			}
	  		}
	    	
	    	table += "<div id='" + monitoringEvent.eventSourceAddress + "_Icon' alt='" + monitoringEvent.eventSourceAddress + "' class='" + iconClass + "'></div></td>" +
	  						"<td id='" + monitoringEvent.eventSourceAddress + "'>" + monitoringEvent.eventName + "</td><tr>";	
	  	}));
	    
	    table += "</table>";
	    
	    this._event_table.innerHTML = table;

	    // Empty the handlers
	    this.eventHandlers = [];

	    // Now add all the event Handlers on the images in the table
	    this.eventPolicy.nodeMonitoringEvents.forEach( lang.hitch(this, function(monitoringEvent) {
	    	this.eventHandlers.push(on(
	    	  dom.byId(monitoringEvent.eventSourceAddress+"_Icon"),
	    	  'click',
	    	  lang.partial(this.tooltipEventSelectedHandler,monitoringEvent,this.eventPolicy,this.flowProfileURI)
	    	));
	    }));
	    
	    Trace.trace(this.declaredClass, Trace.levels.EXIT, "addTableContent");
		},

		// Event handler for clicking on event on flow profile, or on event table. 
  	tooltipEventSelectedHandler: function(monitoringEvent, eventPolicy, flowProfileURI, event) {
  		// Update the selection in the table
  		// First remove any previous selections in the table so that they are n
  		for(var i=0; i < eventPolicy.nodeMonitoringEvents.length; i++) {
  			if(domClass.contains(eventPolicy.nodeMonitoringEvents[i].eventSourceAddress, "event_tooltip_table_row_selected")) {
  				domClass.remove(eventPolicy.nodeMonitoringEvents[i].eventSourceAddress, "event_tooltip_table_row_selected");
  				break;
  			}
  		}
  		domClass.add(monitoringEvent.eventSourceAddress, "event_tooltip_table_row_selected");
  		// Only publish if click was on dialog itself
  		if(typeof event !== "undefined") {
      		Topic.publish(Resources.pubSubTopic.businessTransactionEvent, monitoringEvent, flowProfileURI);
      		// Stop the event bubbling - across browsers
          if (event.stopPropagation) {
            event.stopPropagation();
          }
          if (event.cancelBubble != null) {
            event.cancelBubble = true;
          }
  		}
  	},

		showTooltip: function(target, eventPolicy, posX, posY, refresh) {
		  // force a refresh when the content of the tooltip needs to be updated as result of changes elsewhere
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "showTooltip");
			
			// Check that the tooltip needs updating
			if (refresh || (this.curNode != target.name)) {
			  // As content is changing, remove all the event handlers for the tooltip
			  this.clear();
				this.renderTooltip(target, eventPolicy, posX, posY);
			} else {
				this.updatePosition(posX, posY);
			}
			
			// Now show the tooltip
			if(domClass.contains(this.tooltipId, "event_tooltip_hidden")) {
			  domClass.remove(this.tooltipId, "event_tooltip_hidden");
			  this.isHidden = false;
			}

	    Trace.trace(this.declaredClass, Trace.levels.EXIT, "showTooltip");
		},
		
		// TBD for foreignObject SVG
		getTooltipContent: function() {
		  var innerHTML = this._event_tooltip.innerHTML;
		  
		  return innerHTML;
		},
		
		hideTooltip: function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "hideTooltip");
			
			if(!domClass.contains(this.tooltipId, "event_tooltip_hidden")) {
			  domClass.add(this.tooltipId, "event_tooltip_hidden");
			  this.isHidden = true;
			}
			
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "hideTooltip");
		},
		
		positionTooltip: function() {
			var newLeft = this.posX + "px";
			var newTop = this.posY + "px";
			domAttr.set(this.tooltipId, "style", {top: newTop, left: newLeft});
		},
		
		updatePosition: function(newX, newY) {
			this.posX = newX;
			this.posY = newY;
			newX += "px";
			newY += "px";
			domAttr.set(this.tooltipId, "style", {top: newY, left: newX});
		},
		
		resize: function() {
			
	  },
		
		clear: function(){
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "clear");
        
      if(this.eventHandlers.length > 0) {
        this.eventHandlers.forEach( function(eventHandle){ 
          eventHandle.remove(); 
        });
      }
		  
		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "clear");
		},

		destroy: function(){
	    Trace.trace(this.declaredClass, Trace.levels.ENTRY, "destroy");
	    this.inherited(arguments);
	    
	    if(this.closeTooltipHandlers.length > 0) {
				this.closeTooltipHandlers.forEach( function(closeEventHandle){ 
					closeEventHandle.remove(); 
				});
			}
		    
			if(this.eventHandlers.length > 0) {
				this.eventHandlers.forEach( function(eventHandle){ 
					eventHandle.remove(); 
				});
			}
		    
	    Trace.trace(this.declaredClass, Trace.levels.EXIT, "destroy");
		}

	}); // end dojo declare
	return eventTooltip;
});

},
'webui/widgets/restapi/Resource':function(){
/*   
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2015,2016" 
 * crc="857113219" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/i18n!webui/nls/web",
  "dojo/text!./templates/Resource.html",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/dom-class",
  "dojo/dom-construct",
  "dojo/fx",
  "dojo/fx/Toggler",
  "dojo/keys",
  "dojo/on",
  "dojo/string",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase",
  "dijit/_WidgetsInTemplateMixin",
  "webui/widgets/common/Trace",
  "webui/widgets/restapi/Operation"
], function(
  NLS,
  template,
  declare,
  lang,
  domAttr,
  domClass,
  domConstruct,
  coreFx,
  Toggler,
  keys,
  on,
  string,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  Trace,
  Operation
) {
  return declare("webui.widgets.restapi.Resource", [ _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin ], {

    templateString : template,
    resource : null,
    NLS : null,
    toggler : null,
    isHidden : true,
    operations : [],

    constructor : function() {

      // We need the NLS messages for the template.
      this.NLS = NLS;

      // Save the resource for later.
      this.resource = arguments.resource;

    },

    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      // Add the path to the widget.
      this._path.innerHTML = this.resource.path;
      if (this.resource.descripton) {
        this._description.innerHTML = this.resource.description;
      }

      // Create a toggler.
      this.toggler = new Toggler({
        node : this._container,
        showFunc : coreFx.wipeIn,
        hideFunc : coreFx.wipeOut
      });
      on(this._resource, 'click', lang.hitch(this, 'toggle'));
      on(this._resource, 'keypress', lang.hitch(this, function(evt) {
        var charOrCode = evt.charCode || evt.keyCode;
        switch (charOrCode) {
        case keys.ENTER:
        case keys.SPACE:
          this.toggle();
          break;
        case keys.LEFT_ARROW:
          this.close();
          break;
        case keys.RIGHT_ARROW:
          this.open();
          break;
        }
      }));
      this.toggle();

      // Sort the operations depending on their name.
      this.resource.operations.sort(function(a, b) {
        return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
      });

      // For each operation ...
      this.resource.operations.forEach(lang.hitch(this, function(operation) {

        // ... add a new operation widget.
        var newOperation = new Operation({
          operation : operation
        });
        this.operations.push(newOperation);
        domConstruct.place(newOperation.domNode, this._container);

      }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },
    
    open : function() {
      if (this.isHidden === true) {
        this.toggler.show();
        this.isHidden = false;
        domClass.add(this._expando, 'open');
        domClass.remove(this._expando, 'closed');
      }
      this.updateLabel();
      domAttr.set(this._container, 'aria-expanded', 'true');
    },
    
    close : function() {
      if (this.isHidden === false) {
        this.toggler.hide();
        this.isHidden = true;
        domClass.remove(this._expando, 'open');
        domClass.add(this._expando, 'closed');
      }
      this.updateLabel();
      domAttr.set(this._container, 'aria-expanded', 'false');
    },

    toggle : function() {
      if (this.isHidden) {
        this.open();
      } else {
        this.close();
      }
    },
    
    expandAll : function() {
      this.open();
      this.operations.forEach(function(operation) {
        operation.expandAll();
      });
      domAttr.set(this._container, 'aria-expanded', 'true');
    },
    
    collapseAll : function() {
      this.close();
      this.operations.forEach(function(operation) {
        operation.collapseAll();
      });
      domAttr.set(this._container, 'aria-expanded', 'false');
    },
    
    updateLabel : function() {
      var label;
      var open = this.isHidden ? NLS.restApis_closed : NLS.restApis_open;
      var args = [ this.resource.path, open.toLowerCase(), this.resource.description ];
      if (this.resource.description) {
        label = string.substitute(NLS.restApis_resourceWithDescription, args); 
      } else {
        label = string.substitute(NLS.restApis_resourceWithoutDescription, args);
      }
      domAttr.set(this._resource, 'aria-label', label);
    }

  });
});

},
'webui/widgets/executiongroup/eg_attach_policy':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="2931287569" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */

define("webui/widgets/executiongroup/eg_attach_policy", [
  "dojo/text!webui/widgets/executiongroup/templates/eg_attach_policy.html",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/declare", 
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/dom-construct",
  "dojo/hash",
  "dojo/keys",
  "dojo/on",
  "dojo/request/xhr",
  "dojo/string",
  "dijit/_WidgetBase", 
  "dijit/_TemplatedMixin", 
  "dijit/_WidgetsInTemplateMixin",
  "dijit/registry",
  "idx/widget/ConfirmationDialog",
  "webui/config/Resources",
  "webui/widgets/common/AttributesStore",
  "webui/widgets/common/Toolbar",
  "webui/widgets/common/Trace", 
  "webui/widgets/common/PropertiesStore",
  "dojo/store/Memory"
], function(
  template,
  NLS,
  declare,
  lang,
  attr,
  construct,
  hash,
  keys,
  on,
  xhr,
  string,
  _WidgetBase,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  registry,
  ConfirmationDialog,
  Resources,
  AttributesStore,
  Toolbar,
  Trace,
  PropertiesStore,
  Memory
) {
    var eg_attach_policy = declare("webui.widgets.executiongroup.eg_attach_policy", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
      templateString: template,
      toolbar: null,
      widgetContainer: null,
      eventTopicHandlers : [],
      _btRecorderLabel: NLS.btSelectRecorder,
      unsavedChanges: false,
      initialRecorder: null, // the recorder on tabFocus 
      recorder: null, //newly selected recorder
      firstTimeValidation: true,
      _propertiesStore: new PropertiesStore(),
      _attributesStore : new AttributesStore(),

      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
        this.inherited(arguments);          
            
        // Create toolbar
        this.toolbar = new Toolbar();
        construct.place(this.toolbar.domNode, this._toolbar);
        this.toolbar.addLeftAlignButtons("title");
        
        var buttons = ["apply","cancel"];
        this.toolbar.addRightAlignButtons(buttons);
        this.toolbar.connectButtons("cancel", "click", this, "resetContent");
        this.toolbar.connectButtons("apply", "click", this, "saveContent");
        
        this.toolbar.setButtonState("disable", "cancel");
        this.toolbar.setButtonState("disable", "apply");
        
        
        this._btRecorderPolicy.searchAttr=  "name";
        this._btRecorderPolicy.labelType= "html";
        
        this._btRecorderPolicy.labelFunc =  function(item) {
          var tooltip = "";
          if (item.description) {
            tooltip += item.description;
          }
          if (item.warning) {
            tooltip += item.warning;
          }          
          var content = "<div onmouseout='dijit.hideTooltip(this)' "+
            "onmouseover=' if (this.firstChild.value !==\"\") dijit.showTooltip(this.firstChild.value,this)' >"+
            "<textarea style='display:none'>" + 
            tooltip + "</textarea>"+ item.name+"</div>"; 
          return content;
        };
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
      },

      startup: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "startup");
        
        this.inherited(arguments);      
      
        this.toolbar.setAttribute("title", "innerHTML", "");      
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "startup");
      },
        
      tabFocus : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");
        
        // get the eg name from basic properties
        var populate = this._attributesStore.populateAttributesStore();  
        populate.then(lang.hitch(this, function() {
        
          // get the policy URI from advanced properties
          this.egName = this._attributesStore.getAttribute("name");
          var uri = encodeURI(Resources.REST.root+ "/executiongroups/"+this.egName);
          var advPopulate = this._propertiesStore.populatePropertiesStore(uri);
          advPopulate.then(lang.hitch(this,function(){
          
            this.policyUri = this._propertiesStore.getProperty("advanced", "businessTransactionPolicyUri");
            if (this.policyUri) {
              var index = this.policyUri.lastIndexOf("/");
              this.btRecorderName = this.policyUri.substring(index+1);
            }
            else {
              this.btRecorderName = NLS.btRecorderNone;
            }        
            var uri = Resources.REST.businesstransactionrecorders;  //possibly depth =2
            xhr(
             encodeURI(uri),
             {
                handleAs : "json",
                headers : {
                   "Accept" : "application/json"
                }
              }
            ).then( lang.hitch(this, function(response) {
              var recorderPolicies = [];
              var item= null;
              if (response.businessTransactionRecorder.length >0) {
                for (var i=0;i <response.businessTransactionRecorder.length;i++) {
                  var element = {
                    "name": response.businessTransactionRecorder[i].name, 
                    "value": response.businessTransactionRecorder[i].uri,
                    "description":response.businessTransactionRecorder[i].description,
                    "rest": response.businessTransactionRecorder[i],
                    "warning" : warning
                  };
                  if (response.businessTransactionRecorder[i].name === this.btRecorderName) {
                    item = element;
                  } 
                  var warning = this.validateRecorder(response.businessTransactionRecorder[i]);
                  recorderPolicies.push(element);                       
                }                                    
              }
              recorderPolicies.push( {
                "name": NLS.btRecorderNone, 
                "value": NLS.btRecorderNone,
                "warning": NLS.btRecorderNoneWarning});
                
              this._btRecorderPolicy.labelAttr="name";  
              this._btRecorderPolicy.store= new Memory({data: recorderPolicies, idProperty: "value"});
              if (this.btRecorderName !=="") {
                this._btRecorderPolicy.attr('value',  this.btRecorderName);  
              } else {
                this._btRecorderPolicy.attr('value', NLS.btRecorderNone);
              }
              if (item) {
                this._btRecorderPolicy.item = item;
              } 
                
              this.showDetails();
              this.unsavedChanges = false;
              this.recorderPolicyHandle = on(this._btRecorderPolicy, "change", lang.hitch(this, this.onFirstTime));
            }), lang.hitch(this, function(error) {
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Response: " + error.response.response);            
            }));
          }));
        }));
              
        var eg;
        //Enable/disable buttons based on permissions
        if(window.currentuser.userPermission("eg." + eg, "write")) {
          this.toolbar.setButtonState("enable", "cancel");
          this.toolbar.setButtonState("enable", "apply");
        } else {
          this.toolbar.setButtonState("disable", "cancel");
          this.toolbar.setButtonState("disable", "apply");
        }

         // Do a resize to get the initial size of the widgets
        this.resize();
                   
          //this._monitoringPolicySection.set("content", text);
        this._monitoringPolicySection.set('title', NLS.btMonitoringTitle);        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
      },
      
      validateRecorder : function(recorder) {
        var result = "";
        if (recorder.businessTransactionDefinitions.length ==0) {
             result = NLS.messages.BusinessRecorderWarning1;
        }
        if (recorder.dataSource.name === "") {
             result += NLS.messages.BusinessRecorderWarning2;
        }
        return result;
      },
            
      onSelectRecorder: function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onSelectRecorder");
        this.toolbar.setButtonState("enable", "cancel");
        this.toolbar.setButtonState("enable", "apply");        
        attr.set("_infoPaneTitleID", "innerHTML", this.egName + " *  - " + NLS.executionGroupTitle);
        if (this._btRecorderPolicy && this._btRecorderPolicy.item) {
          this.recorder = this._btRecorderPolicy.item.rest;  
        }        
        this.btRecorderName = this._btRecorderPolicy.getValue();        
        this.unsavedChanges = true;
        
        dijit.hideTooltip("btRecorderPolicy");
        
        this.showDetails();            
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onSelectRecorder");
        
      },
      
      showDetails: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "showDetails");
        construct.empty(this._btRecorderDetails); 
        if ((this.btRecorderName !== NLS.btRecorderNone) && (this.btRecorderName !=="")) {
          var content = "<div class=\"btRecAttribute\"> "+NLS.btSeeDetailsRecorder +
            "<a href=\"#businessTransactionRecorder/0/policy/businesstransactionrecorders/"+ this.btRecorderName+
                    "\" target=\"_blank\">"+this.btRecorderName+"</a> </div>";
          if (this._btRecorderPolicy && this._btRecorderPolicy.item &&
             this._btRecorderPolicy.item.warning && (this._btRecorderPolicy.item.warning!=""))  {
            content+= "<div class= \"adminLogWarning\"> "+ this._btRecorderPolicy.item.warning+"</div>";
          }   
          this._btRecorderDetails.innerHTML =content;          
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "showDetails");
      },
      
      showDescription: function(item){
        item = this._btRecorderPolicy.item;
        if (item) {
          dijit.hideTooltip("btRecorderPolicy");       
          //var parentName = item.parentName[0];
          var tooltip = string.substitute(NLS.btFlowFrom, ["Test"]); 
          dijit.showTooltip(tooltip,"btRecorderPolicy");       
        }        
      },
          
      saveContent : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "saveContent");

        this.toolbar.getButton("apply").set("disabled", true);

        this.unsavedChanges = false;
        var policyUri = Resources.REST.businesstransactionrecorders + this.btRecorderName;
        if (this.btRecorderName === NLS.btRecorderNone) {
          policyUri = "";
        }
        var uri = Resources.REST.root+"/executiongroups/"+this.egName+"?action=setBusinessRecorder&businessRecorderUri="+
           policyUri;
          xhr.put(
              encodeURI(uri),
              {
                handleAs : "json",
                headers : {
                  "Accept" : "application/json",
                  "Content-type" : "application/json"
                }
              }
            ).then( lang.hitch(this, function() {
              attr.set("_infoPaneTitleID", "innerHTML", this.egName + " - " + NLS.executionGroupTitle);
              this.toolbar.getButton("apply").set("disabled", true);
              
              // Inform user that the save was successful
              if (this.btRecorderName === NLS.btRecorderNone) {
                window.smallMessage.displayMessage("success", "BusinessRecorder_detachSuccess", "",
                  string.substitute(NLS.messages.BusinessRecorder_detachSuccessDescription, [this.egName]));
              } else {
                window.smallMessage.displayMessage("success", "BusinessRecorder_attachSuccess", "",
                  string.substitute(NLS.messages.BusinessRecorder_attachSuccessDescription, [this.btRecorderName, this.egName]));
              }
              this.unsavedChanges = false; 
            }),
            lang.hitch(this, function(error) {
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Response: " + error.response.response);            
              window.smallMessage.displayMessage("error", "BusinessRecorder_detachFailure", "", error.response.status + ": " + error.response.text);
            })
          );
           
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "saveContent");
      },
      
      resetContent : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resetContent");
        if (this.initialRecorder) {
          this._btRecorderPolicy.set("value", this.initialRecorder.name);
          this.unsavedChanges = false;
          attr.set("_infoPaneTitleID", "innerHTML", this.egName + " - " + NLS.executionGroupTitle);
          this.toolbar.getButton("apply").set("disabled", true);
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "resetContent");
      },
                  
      resize: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize"); 
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize"); 
      },
      
      tabRemove: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
        if (this.recorderPolicyHandle) {
          this.recorderPolicyHandle.remove();
        }
        this._btRecorderDetails.innerHTML = "";
        this.firstTimeValidation = true;
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove"); 
      },
      
      tabBlur: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");                
        if (this.recorderPolicyHandle) {
          this.recorderPolicyHandle.remove();
        }
        this.firstTimeValidation = true;
        this._btRecorderDetails.innerHTML = "";
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur"); 
      },
      
      onFirstTime: function() {
        
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onFirstTime");
        // avoids making the page appear dirty when setting the values of the fielf for the first time
        var unsavedChanges = true;
        if (this.firstTimeValidation) {
           this.firstTimeValidation = false;
           unsavedChanges = false;
        }                  
        if (unsavedChanges) {
          this.onSelectRecorder();
        }  
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onFirstTime");
      },

      // This method is called when the hash changes while this
      // tab widget is one of the (potentially several) tab widgets currently
      // visible. If you're okay with this hash change, return true. If there's
      // unsaved work, return false and provide a popup which will push the
      // change through.
      canChangeHash: function(oldHash, newHash) {

        // This method is sometimes called before btModel exists, so handle that
        if (!this.unsavedChanges){
          return true;
        }
        
        // You might want to examine oldHash and newHash at this point, maybe
        // see whether we're just flipping between tabs?

        var btConfirmAttachDialog = registry.byId("btConfirmLeaveEGAttach");
        if (typeof btConfirmAttachDialog === "undefined") {
          btConfirmAttachDialog = new ConfirmationDialog({
            type : "information",
            buttonLabel : NLS.btLeaveSave,
            cancelButtonLabel : NLS.btStayOnPage,
            closeButtonLabel : NLS.btStayOnPage,
            text : NLS.btRecAttachLeaveOrStay
          }, "btConfirmLeaveEGAttach");
        }

        // User clicks "confirm" -> override and try again
        btConfirmAttachDialog.confirm(lang.hitch(this, function() {
          this.unsavedChanges = false;
          hash(newHash);
        }));
        
        btConfirmAttachDialog.onCancel = lang.hitch(this, function() {
          // Don't change the hash, but an item in the tree has been selected and focused upon.
          // Make sure the current item retains its focus, previous selected node, with no hash change/refresh.
          window.wmbConsole.expandTreeAndRefreshHash(oldHash, false);
          btConfirmAttachDialog.hide();
        });
        
        on(btConfirmAttachDialog, "keydown", lang.hitch(this, function (event){
          // Move the focus accordingly if the arrow keys are pressed
          var key = event.keyCode;                
          if ((key == keys.LEFT_ARROW) && btConfirmAttachDialog.closeAction.focused) {
            btConfirmAttachDialog.confirmAction.focus();
          } 
          else if ((key == keys.RIGHT_ARROW) && btConfirmAttachDialog.confirmAction.focused){
            btConfirmAttachDialog.closeAction.focusNode.focus();
          }
          // Extend confirm/close function to close on Enter key press
          if (key == keys.ENTER) {
            if(btConfirmAttachDialog.confirmAction.focused) {
              btConfirmAttachDialog.hide();
              this.unsavedChanges = false;
              hash(newHash);
            } else {
              if(btConfirmAttachDialog.closeAction.focused) {
                btConfirmAttachDialog.onCancel();
              }
            }
          } 
          // Stop the keyboard event propagating i.e. moving a flow on the canvas
          event.stopPropagation();
        }));        

        btConfirmAttachDialog.show();

        // cancelAction i.e. stay on the page  do nothing
        
        // Veto the hash change, user will decide
        return false;
      }
      
        
      });
      return eg_attach_policy;
});

},
'webui/widgets/policy/policy_attach':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="2931287569" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */

define([
  "dojo/text!webui/widgets/policy/templates/policy_attach.html",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/array",
  "dojo/_base/declare", 
  "dojo/_base/lang",
  "dojo/dom",
  "dojo/dom-attr",
  "dojo/dom-class",
  "dojo/dom-construct",
  "dojo/dom-geometry",
  "dojo/hash", 
  "dojo/on",
  "dojo/query",
  "dojo/request/xhr",
  "dojo/topic",
  "dojox/html/entities",
  "dijit/_TemplatedMixin", 
  "dijit/_WidgetBase", 
  "dijit/_WidgetsInTemplateMixin",
  "dijit/form/Button",
  "dijit/layout/ContentPane",
  "dijit/registry",
  "dijit/TitlePane",  
  "webui/config/Resources",
  "webui/utils/RestUri",
  "webui/utils/WebUiHash",
  "webui/widgets/common/UIUtils",
  "webui/widgets/common/AttributesStore",
  "webui/widgets/common/D3FlowDiagram",
  "webui/widgets/common/Trace",
  "webui/widgets/policy/MessageDialog",
  "webui/widgets/policy/policyActionDialog",
  "dojo/domReady!"
], function(
  template,
  NLS,
  array,
  declare,
  lang,
  dom,
  domAttr,
  domClass,
  domConstruct,
  domGeom,
  hash,
  on,
  query,
  xhr,
  topic,
  entities,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  Button,
  ContentPane,
  registry,
  TitlePane,
  Resources,
  RestUri,
  WebUiHash,
  UIUtils,
  AttributesStore,
  D3FlowDiagram,
  Trace,
  MessageDialog,
  policyActionDialog
) {
  var populatAttributesPromise;
     
  var policyAttach = declare("webui.widgets.policy.policy_attach", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
      
    templateString: template,
    attachedPolicy: null,
    flowDiagramWidget: null,
    noAttachedPolicyRef: "no-Attached-Policy", // We do not allow '-' in the policy name, therefore this key should never interfere with an actual policy name
    eventIconPath: "/webui/widgets/policy/images/", 
    policyEditorPane : null,
    eventTopicHandlers : [],
    wlmPolicyWidgetArray : [], // hold all the WLM policy widget created
    _attributesStore : new AttributesStore(),
        
    // from msgflow_statistics.js
    nodePolicyViewMode : "G",
    eventTooltipId : "eventTooltip",
    flowType : "messageflows",  // can be messageflows or subflows
    
    // admin handlers to get notifications on changes to the object
    _adminHandlers: [],
    
    // the URI of the object (flow, subflow) that has a policy attached
    _objectUri: "",
    
    _brokerWritePermissions: false,


    postCreate: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);          
                
      this.populatAttributesPromise = this._attributesStore.populateAttributesStore(); 
            
//      if (!this.infoPaneToolbar) {        
//        this.infoPaneToolbar = domConstruct.create("div", {
//          className: "dijit dijitToolbar _common_toolbarPosition"
//        },
//        this._infopane_toolbar);
//      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },
    
    tabFocus : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");
      
      var restUri;
      if(hash()){
        restUri = new WebUiHash(hash()).getRestUri();
      } else {
        var uri = registry.byId('_explorerTree_ID').selectedItem.uri;
        restUri = new RestUri(uri);
      }
      this.flowType = restUri.getArtifactType();
      var eg = restUri.getIntegrationServerName();
            
      // WLM Flow Policies            
      if (!this.flowPoliciesPane && this.flowType === "messageflows") {
        this.flowPoliciesPane = new TitlePane({
          title : NLS.flowPolicyTitle, 
          open: true,
          className : "policy_propertyTitle"
        });
        this._policyAttachDynamic.appendChild(this.flowPoliciesPane.domNode);

        domAttr.set(this.flowPoliciesPane.domNode, "data-test-attrName", "flowPoliciesTitlePane");
                        
        // Container to hold buttons for flow policies actions
        var flowPoliciesButtonsDiv = domConstruct.create("div",{
          className: "policy_flowPoliciesButtonsDiv",
          id: "policy_flowPoliciesButtonsDiv"
        });
          
        var rightToolbarButtonContainer = domConstruct.create("span",  {
          className: "policy_rightToolbarButtonContainer"
        }, flowPoliciesButtonsDiv, "last"); 

        // Create and add buttons to the flow policies title pane twistie
        this._applyButton = new Button({
          label: NLS.action.apply,
          showLabel: true,
          layoutAlign: "right",
          disabled: true,
          iconClass: "policy_infoPaneButton_applyDisabled"
        });
        domConstruct.place(this._applyButton.domNode,  rightToolbarButtonContainer, "last");
 
        this._cancelButton = new Button({
          label: NLS.action.cancel,
          showLabel: true,
          layoutAlign: "right",
          disabled: true,
          iconClass: "policy_infoPaneButton_cancelDisabled"
        });
        domConstruct.place(this._cancelButton.domNode,  rightToolbarButtonContainer, "last");
          
        on(this._applyButton,  "click", lang.hitch(this, this.saveContent)); 
        on(this._cancelButton,  "click", lang.hitch(this, this.resetContent));
         
        this.flowPoliciesContainer = domConstruct.create("div",{
          id: "flowPoliciesContainer"
        });
        domConstruct.place(flowPoliciesButtonsDiv, this.flowPoliciesContainer);
         
        this.flowPoliciesPane.set("content", this.flowPoliciesContainer);
      }
      //-----------End WLM Flow Policies --------------

      //-----------Node Policies Flow Diagram pane --------------
      if (!this.flowDiagramPane) {
        this.flowDiagramPane = new TitlePane({
          title : NLS.nodePoliciesTitle, 
          open: true,
          className : "policy_propertyTitle"
        });
        
        this._flowProfileTitlePane.appendChild(this.flowDiagramPane.domNode);
        //DomAttr.set(this.flowDiagramPane.domNode, "class", "stats_titlePaneContainer");
        
        if (!this.nodePoliciesTextContainer){ 
          this.nodePoliciesTextContainer = domConstruct.create("div", {
            innerHTML : '<label>' + NLS.flowDiagramInformationalMsg + '</label>',
            className: "policy_nodePoliciesTextContainer",
            id: "nodePoliciesTextContainer"
          });                 
        }
//                var diagramButtonContainer = domConstruct.create("div", 
//                  {
//                    className: "policy_nodePoliciesButtonsContainer", 
//                    id: "policy_flowDiagramButtonsContainer"
//                  });                        
//                               
//                var mySelectView = new Select({
//                  name: "mySelectView",
//                  options: [
//                            { label: NLS.policy_nodeAttachPolicySelectGraphView,  value: "G", selected: true},
//                            { label: NLS.policy_nodeAttachPolicySelectTableView,  value: "T"}
//                           ],
//                  className: "policy_selectViewCombo",
//                  onChange: lang.hitch(this, function(viewMode) {
//                    if (viewMode === "G"){
//                      this.nodePolicyViewMode = "G";
//                      this.createNodePolicyFlowDiagram();
//                    }
//                    else {
//                      this.nodePolicyViewMode = "T";
//                      this.createNodePolicyFlowTable();
//                    }
//                  }) 
//                });
//                
//                domConstruct.place(mySelectView.domNode, diagramButtonContainer); 
//                                  
//                domConstruct.place(diagramButtonContainer, this.flowDiagramPane.focusNode);
        
        //spacer
        domConstruct.place(
          domConstruct.create("div",{className:"_common_textSpacer"}),
          this.flowDiagramPane.domNode
        );
        
        // Watch click events in case a resize is needed
        this.own(on(this.flowDiagramPane, "click", lang.hitch(this, this.onFlowProfilePaneOpen)));
        
      }
      //-----------End Flow Profile pane --------------
      
      // Enable/disable buttons based on permissions
      if (this.flowType === "messageflows"){
        this._brokerWritePermissions= window.currentuser.userPermission("eg." + eg, "write"); 
              
        // This is currently fixed to display WLM policies.
        var uriTarget = Resources.REST.root;
        uriTarget += "/policy/WorkloadManagement";

    
        if (!this.flowPoliciesTableContainer) { 
          this.flowPoliciesTableContainer = new ContentPane({
            id: "flowPoliciesTableContainer",
            className: "policy_flowPoliciesTableDiv"
          }); 
                 
          domConstruct.place(this.flowPoliciesTableContainer.domNode, this.flowPoliciesContainer, "after");
        
      
    
          // Get the names of all the flow policies (WLM)
          xhr(
            uriTarget,
            {
              handleAs : "json",
              headers : {
                "Accept" : "application/json"
              }
            }
          ).then(
            lang.hitch(this, function(response) {
            
              var generatedHTML = "<div>";
            
              generatedHTML += "<table class='policy_propertyContainer'>";
              var wlmPolicyTitle = NLS.availPolicies || "availPolicies";
            
              var wlmAttachedTitle = NLS.attachedPolicy || "attachedPolicy";
            
              generatedHTML+="<tr>";
              generatedHTML+="<th class='_common_propertyPolicyTextTitle'>" + wlmPolicyTitle + "</th>";
              generatedHTML+="<th class='_common_propertyPolicySelectTitle'>" + wlmAttachedTitle + "</th>";
              generatedHTML+="</tr>";
            
              var rowClass = "Odd";
              if(typeof response != 'undefined' && typeof response.policy != 'undefined' && response.policy.length > 0) {
              
                var noPolicyTitle = NLS.noAttachedPolicy || "noAttachedPolicy";
              
                generatedHTML+="<tr>";
                generatedHTML+="<td class='_common_propertyPolicyText" + rowClass + "'>" + noPolicyTitle + "</td>";
                if(window.currentuser.userPermission("eg." + eg, "write")) {
                  generatedHTML+="<td class='_common_propertyPolicySelect" + rowClass + "'><input type=\"radio\" data-dojo-type=\"dijit.form.RadioButton\" name=\"policy\" id=\""+this.noAttachedPolicyRef+"\" value=\""+this.noPolicyTitle+"\" checked=\"false\"/></td></tr>";
                } else {
                  generatedHTML+="<td class='_common_propertyPolicySelect" + rowClass + "'><input type=\"radio\" data-dojo-type=\"dijit.form.RadioButton\" data-dojo-props=\"readOnly: true\" name=\"policy\" id=\""+this.noAttachedPolicyRef+"\" value=\""+this.noPolicyTitle+"\" checked=\"false\"/></td></tr>";
                }
                  this.wlmPolicyWidgetArray.push(this.noAttachedPolicyRef);
                
                rowClass = "Even";
                array.forEach(response.policy, lang.hitch(this, function(policy) {
                  generatedHTML+="<tr>";
                  generatedHTML+="<td class='_common_propertyPolicyText" + rowClass + "'>" + policy.name + "</td>";
                  if(window.currentuser.userPermission("eg." + eg, "write")) {
                    generatedHTML+="<td class='_common_propertyPolicySelect" + rowClass + "'><input type=\"radio\" data-dojo-type=\"dijit.form.RadioButton\" name=\"policy\" id=\"" + policy.name + "\" value=\"" + policy.name + "\" checked=\"false\"/></td></tr>";
                  } else {
                    generatedHTML+="<td class='_common_propertyPolicySelect" + rowClass + "'><input type=\"radio\" data-dojo-type=\"dijit.form.RadioButton\" data-dojo-props=\"readOnly: true\" name=\"policy\" id=\"" + policy.name + "\" value=\"" + policy.name + "\" checked=\"false\"/></td></tr>";
                  }
                  this.wlmPolicyWidgetArray.push(policy.name);
                  if(rowClass == "Odd") {
                    rowClass = "Even";
                  } else {
                    rowClass = "Odd";
                  }
                  if(policy.name == this.noAttachedPolicyRef) {
                    //A user has a policy with an invalid name
                    //The noAttachedPolicyRef contains '-' which is a disallowed character in policy names
                    Trace.trace(this.declaredClass, Trace.levels.DEBUG, "A policy has been found with the same name as the noAttachedPolicyRef '"+this.noAttachedPolicyRef+"'. The ref contains the '-' which is a disallowed character in policy names. Therefore this is an invalid policy name.");
                  }
                }));
              } else {
                var noDefinedPolicies = NLS.noDefinedPolicies || "noDefinedPolicies";
              
                generatedHTML+="<tr>";
                generatedHTML+="<td colspan='2' class='_common_propertyPolicyText" + rowClass + "'>" + noDefinedPolicies + "</td>";
              }
  
              generatedHTML +="</table>";
              generatedHTML +="</div>";
            
            
              this.flowPoliciesTableContainer.set("content", domConstruct.create("div", {
                "innerHTML" : generatedHTML
              }));
            
              if(typeof response != 'undefined' && typeof response.policy != 'undefined' && response.policy.length > 0) {
                //Now select the displayed policy
                this._displayAttachPolicy();
                
                // update WLM policy attached table by subscribing to the current flow changes
                if (hash()) {
                  if( typeof window.brokerName != 'undefined') {
                    var notificationsTopicName = new WebUiHash(hash()).getNotificationTopic();
                    
                    // Do a dojo subscribe for any changes (AdminNotification's) to the current flow
                    this.eventTopicHandlers.push(topic.subscribe(notificationsTopicName, lang.hitch(this, this._displayAttachPolicy)));
                  }
                }
              }
            }),
            lang.hitch(this, function(error) {
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.xhr.status + " Response: " + error.response.xhr.response);
              if ((typeof error.response!= 'undefined') &&(typeof error.response.text!= 'undefined')) {            
                var response = JSON.parse(error.response.text);        
                window.smallMessage.displayMessage("error", "policyget_5XX", response.bipNumber, response.description);
              }
              else {
                Trace.trace(this.declaredClass, Trace.levels.DEBUG, "No response available. Error: "+error.message);
              }
            })
          );

        }
      }
      // Do a resize to get the initial size of the widgets
      this.resize();
            
      if (this.nodePolicyViewMode === "G") {
        this.createNodePolicyFlowDiagram();
      }
//    else {
//      this.createNodePolicyFlowTable();
//    }
      
      UIUtils.setupAdminHandlers(this._adminHandlers, lang.hitch(this, this.processAdminHandlers));
            
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
    },  
    
    /*
     * Listen for admin notification
     * If the notification is about this object, reread the properties, in particular the running state
     * and update the state of the buttons
     */
    processAdminHandlers: function (message) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "processAdminHandlers");
      UIUtils.processAdminHandlers (message, this._objectUri, this._attributesStore, "isRunning", lang.hitch(this, this.toggleButtonState));      
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "processAdminHandlers");

    },
    
    // change the state of the buttons depending on the attribute passed in
    toggleButtonState: function (enable) {
      if (this._applyButton && this._cancelButton) {
        if (enable && this._brokerWritePermissions) {
          this._applyButton.set('disabled', false);
          this._applyButton.set('iconClass', "policy_infoPaneButton_applyEnabled");
          this._cancelButton.set('disabled', false);
          this._cancelButton.set('iconClass', "policy_infoPaneButton_cancelEnabled");
        } else {
          this._applyButton.set('disabled', true);
          this._applyButton.set('iconClass', "policy_infoPaneButton_applyDisabled");
          this._cancelButton.set('disabled', true);
          this._cancelButton.set('iconClass', "policy_infoPaneButton_cancelDisabled");          
        }        
      }
    },
    
    
    // create graphical D3FlowDiagram for Node Policies
    createNodePolicyFlowDiagram: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createNodePolicyFlowDiagram");
          
      if(this.flowDiagramWidget == null){
                
        try {
          this.flowDiagramWidget = new D3FlowDiagram();   
                
          if (!dom.byId("nodePoliciesMessageFlowDiagram")){
            var flowDiagramCanvasContainer = new ContentPane({
              className: "policy_messageFlowDiagramSection",
              id: "nodePoliciesMessageFlowDiagram"
            }); 
            
            // put the top level widget into the document
            this.flowDiagramPane.set("content", flowDiagramCanvasContainer);
          }
          
        }
        catch(e) {
          Trace.trace(this.flowDiagramWidget.declaredClass, Trace.levels.DEBUG, "D3FlowDiagram Error: " + e);                    
        }            
            
        populatAttributesPromise = this._attributesStore.populateAttributesStore(); 
            
        populatAttributesPromise.then(lang.hitch(this, function() {
          // save the object Uri
          this._objectUri = this._attributesStore.getAttribute("uri");
          // the running state might change at any moment, 
          // just use it to set the state of the buttons
          var enable = this._attributesStore.getAttribute("isRunning");
          this.toggleButtonState(enable);          
          
          if(dom.byId("nodePoliciesMessageFlowDiagram")){
            dom.byId("nodePoliciesMessageFlowDiagram").innerHTML = "";
                
            // Request flow diagram information
            xhr(
              // uri is something like "http://localhost:4415/apiv1/executiongroups/default/applications/App1/messageflows/MQNodesFlow/flowdesign/policynode"
              this._attributesStore.getAttribute("flowDesignUri") + "/policynode",
              {
                handleAs : "json",
                headers : {
                  "Accept" : "application/json"
                }
              }
            ).then(
              lang.hitch(this, function(response) {
                if(this.flowDiagramWidget){       
                  this.flowDiagramWidget.place("nodePoliciesMessageFlowDiagram", response, false);
                  
                  // Click event for click on a node (MQTT)
//                this.eventTopicHandlers.push(Topic.subscribe(response.uri + "/notImplemented", 
//                  lang.hitch(this, function(event) {
//              
//                    this.notImplementedDialog();
//                  })
//                ));
                                                               
                  // click on policy decorator icon                                                               
                  this.addNodeActions(this.flowDiagramWidget.flowProfileWidget, this.flowDiagramWidget.flowProfileWidget.nodes(), response.uri, this.nodePoliciesTextContainer);
                }
              }),
              lang.hitch(this, function(error) {
                Trace.trace(this.flowDiagramWidget.declaredClass, Trace.levels.DEBUG, "D3FlowDiagram Error: " + error.response.xhr.status + " Response: " + error.response.xhr.response);
              })
            );
          }
          
        }));
        
      }
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "createNodePolicyFlowDiagram");
                     
    },
    
    // create table view for node policies
    createNodePolicyFlowTable: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createNodePolicyFlowTable");
            
      // destroy flow diagram widget in graph view
      if(this.flowDiagramWidget){
        try{
          this.flowDiagramWidget.destroy();
        }
        catch(e) {}
        this.flowDiagramWidget = null;
      }
            
      // destroy policy action dialog in graph view
      if(this.policyActionDialog){
        try{
          this.policyActionDialog.destroy();
        }
        catch(e) {}
        this.policyActionDialog = null;
      }
          
      this.flowDiagramPane.set("content", domConstruct.create("div", {
        innerHTML : entities.encode(NLS.functionNotImplemented) + "<div></div>",
        className: 'policy_notImplemented'
      }));
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "createNodePolicyFlowTable");
    },
          
    addNodeActions: function(flowProfileWidget, nodes, uri, nodePoliciesTextContainer) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "addNodeActions");
          
      flowProfileWidget.eventIconPath = this.eventIconPath;
      flowProfileWidget.messageFlowURI = uri;
          
//    var node = flowProfileWidget.profileNodes(); 
      this.policyActionDialog = new policyActionDialog(true, this.eventTooltipId, uri, this.flowDiagramWidget.flowProfileId); 

      // Add the tooltip to the main flow profile container.
      var toolTipContainer = d3.select("#nodePoliciesMessageFlowDiagram");                     
      toolTipContainer.append("div")
      .attr("id", this.eventTooltipId);

      domClass.add(this.eventTooltipId, "event_tooltip event_tooltip_hidden");
         
      // Add the hidden tooltip to the diagram, now prepared for rendering
      domConstruct.place(this.policyActionDialog.domNode, this.eventTooltipId);
      
      // Add the tooltip reference to the flow diagram
      flowProfileWidget.eventTooltip = this.policyActionDialog;
      
      var subflowMsgIsDisplayed = false;
    
      nodes.forEach(function(n) {
        // If there is an event policy defined on the node, then handle the processing in the flow profile
        if(typeof n.type !== "undefined") {
          
          if (!subflowMsgIsDisplayed && n.type === "SubFlowNode" && nodePoliciesTextContainer){
            nodePoliciesTextContainer.innerHTML = '<label>' + NLS.flowDiagramInformationalMsg + '</label>';
            domConstruct.place(nodePoliciesTextContainer, dom.byId('nodePoliciesMessageFlowDiagram'), 'before');
            subflowMsgIsDisplayed = true;
          }
          
          var node = flowProfileWidget.profileNodes();  
          node.append("g")
          .attr("id", "policyNode")
          // for each node, if the node has "policyUrl" then add a decorator icon
           .each( function(d, i) {
             var g = d3.select(this);
              
             // determine which icon to use, whether a policy is already attached to a node or not
             var policyUrlProperty = d.nodeProperties.filter(function(p) {
               return p.name === "policyUrl";
             })[0];
             
            var icon = null; 
            var tooltip = ""; 
            var isPolicyAttached = false;
            var policyURL = "";
             if(
               policyUrlProperty &&
               policyUrlProperty.value &&
               policyUrlProperty.value.toLowerCase() !== "default"
             ) {
               icon = flowProfileWidget.eventIconPath + "PolicyAttached.gif";
               tooltip = NLS.policy_policyAttachedToNode; 
               isPolicyAttached = true; 
               policyURL = policyUrlProperty.value;
               
               // The Toolkit accepts both "/apiv1/policy/MQTTPublish/FOO" and
               // the shorter form "/MQTTPublish/FOO".
               var s = Resources.REST.root + "/policy";
               if (
                 policyURL.substring(0, s.length) !== s ||
                 
                 // This happens if `policyURL` is "/apiv1/policy". We extend
                 // it to "/apiv1/policy/apiv1/policy", which is considered to
                 // be a policy of type "apiv1" with name "policy"
                 policyURL === s
               ) {
                 policyURL = s + policyURL;
               }
             }
                
             // First add the policy decorator icon
             g.append("image")
             .attr("id", "policyDecorator"+i)
             .attr("y",  function(d) { 
               // 9x9
               return (d.dy / 2) - (flowProfileWidget.nodeEventIconLength() * (7/8) + 12); //y location of decorator image
             })
             // 9x9
             .attr("x", flowProfileWidget.nodeWidth() - (flowProfileWidget.nodeEventIconWidth() * (9/8) - 5) + 6) //x location of decorator image
             .attr("height", flowProfileWidget.nodeEventIconLength())
             .attr("width", flowProfileWidget.nodeEventIconWidth())
             .attr("xlink:href", icon) 
             .attr("class", "policy_node-event-icon")

             // publish when a message node is clicked
             .on("click", lang.hitch(this, function(d) {
               // When user clicks on a node publish on a defined topic string
               //Topic.publish(uri + "/node", {"node":d});
                
               // Get the current position of the decorator icon, the position might have changed due to panning
               // Then calculate the proper position for the action dialog
               var decorator = dom.byId("policyDecorator"+i);
               var decoratorInfo = domGeom.position(decorator, true); // use true to get the x/y relative to the document root
               var diagramInfo = domGeom.position(dom.byId("nodePoliciesMessageFlowDiagram"), true);
                
               var x = decoratorInfo.x;
               var y = decoratorInfo.y;
                
               //action dialog cannot go beyond visible width and height
               if (x > 1400){ 
                 x = x-100;
               }

               if (y > 600){
                 y = y-70;
               }
                
               // subtract the margin and slider
               x = x - diagramInfo.x - (flowProfileWidget.margins()[1]);
               y = y - diagramInfo.y - flowProfileWidget.margins()[1] - 20;

               // show policy action dialog
               flowProfileWidget.eventTooltip.showTooltip(d, policyURL, x, y);
             }))
                
             .append("title")
             .attr("id", "policy_attachable_tooltip")
             .text(function(){
               return tooltip;
             });
           });                  
        }//if
      });//forEach
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "addNodeActions");
    },

    saveContent : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "saveContent");

      var uri;
      if(hash()){
        uri = new WebUiHash(hash()).getRestUri().toString();
      } else {
        uri = registry.byId('_explorerTree_ID').selectedItem.uri;
      }
      
      var uriTarget = uri+"/properties";
      
      var selectedPolicy = this._getSelectedPolicy();

      if(selectedPolicy != this.attachedPolicy) {
        var flowPropertiesObject = {};
        flowPropertiesObject.advancedProperties = [];
        var flowAdvancedPropertiesWLMPolicyObject = {};
        flowAdvancedPropertiesWLMPolicyObject.name = "wlmPolicy";
        if(selectedPolicy == this.noAttachedPolicyRef) {
          flowAdvancedPropertiesWLMPolicyObject.value = "";
        } else {
          flowAdvancedPropertiesWLMPolicyObject.value = selectedPolicy;
        }
        flowPropertiesObject.advancedProperties.push(flowAdvancedPropertiesWLMPolicyObject);

        xhr.put(
          uriTarget,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json",
              "Content-type" : "application/json"
            },
            data : JSON.stringify(flowPropertiesObject)
          }
        ).then( lang.hitch(this, function() {
          // Update the attachedPolicy variable
          var attached;
          if(selectedPolicy == this.noAttachedPolicyRef) {
            window.smallMessage.displayMessage("success", "policyattach_successDetach", null, NLS.messages.policyattach_successDetach+", '"+this.attachedPolicy+"'");
            attached = true;
          } else {
            window.smallMessage.displayMessage("success", "policyattach_successAttach", null, NLS.messages.policyattach_successAttach+", '"+selectedPolicy+"'");
            attached = false;
          }
          this.attachedPolicy = selectedPolicy;

          //  Update menu items
          var attachPolicyMenuItem = registry.byId(uri+"_attachPolicy");
          attachPolicyMenuItem.set("disabled", !attached);
          var detachPolicyMenuItem = registry.byId(uri+"_detachPolicy");
          detachPolicyMenuItem.set("disabled", attached);
        }),
        lang.hitch(this, function(error) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.xhr.status + " Response: " + error.response.xhr.response);
          if ((typeof error.response!= 'undefined') &&(typeof error.response.text!= 'undefined')) {            
            var response = JSON.parse(error.response.text);        
            window.smallMessage.displayMessage("error", "policyattach_5XX", response.bipNumber, response.description);
          }
          else {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "No response available. Error: "+error.message);
          }
        }));
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "saveContent");
    },
    
    resetContent : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resetContent");
      
      var selectedPolicy = this._getSelectedPolicy();
      if(selectedPolicy !== this.attachedPolicy) {
        var radioButton = registry.byId(this.attachedPolicy);
        radioButton.set('checked', true);
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "resetContent");
    },
    
    onFlowProfilePaneOpen: function() {
      // Resize the flow profile canvas (svg) if it is currently visible
      if((typeof this.flowDiagramPane != "undefined") && this.flowDiagramPane.open && (this.flowDiagramWidget != null)) {
        this.flowDiagramWidget.resize();
      }
    },    
   
    resize: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize"); 
      
      this._policyAttach_borderContainer.resize();

      // Resize the flow profile canvas (svg) if it is currently visible
      this.onFlowProfilePaneOpen();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize"); 
    },
    
    _getSelectedPolicy: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_getSelectedPolicy"); 
      var radioButtons = query('[name=\"policy\"]');
      
      var selectedPolicy;
      array.forEach(radioButtons, lang.hitch(this, function(radioButton) {
        if(radioButton.checked) {
          selectedPolicy = radioButton.id;
        }
      }));
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_getSelectedPolicy"); 
      return selectedPolicy;
    },
    
    _displayAttachPolicy: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_displayAttachPolicy"); 
      
      var uriTarget;
      if(hash()){
        var webUiHash = new WebUiHash(hash());
        this.displayPolicyName = webUiHash.getPolicyName();
        uriTarget = webUiHash.getRestUri().toString();
      } else {
        this.displayPolicyName = registry.byId('_explorerTree_ID').selectedItem.name;
        uriTarget = registry.byId('_explorerTree_ID').selectedItem.uri;
      }
      
      uriTarget += "/properties";

      //Get the name of the attached policy
      xhr(
        uriTarget,
        {
          timeout : 10000,
          handleAs : "json",
          headers : {
            "Accept" : "application/json"
          }
        }
      ).then( lang.hitch(this, function(response) {  
        if( typeof response.advancedProperties != 'undefined') {            
          var policyProperty = array.filter(response.advancedProperties, function(item){return item.name == "wlmPolicy";});
          var radioButton;
          if(policyProperty != 'undefined' && policyProperty.length > 0 && policyProperty[0].value != 'undefined') {
            this.attachedPolicy = policyProperty[0].value;              
            radioButton = registry.byId(this.attachedPolicy);
          } else {
            this.attachedPolicy = this.noAttachedPolicyRef;
            radioButton = registry.byId(this.attachedPolicy);
          }

          if(typeof radioButton == 'undefined' || radioButton == null) {
            window.smallMessage.displayMessage("error", "policyattachinvalid_000", null, NLS.messages.policyattachinvalid_000+", '" + this.attachedPolicy+"'");
          } else {
            radioButton.set('checked', true);
          }
        }
      }),
      lang.hitch(this, function(error) {
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.xhr.status + " Response: " + error.response.xhr.response);            
        if ((typeof error.response!= 'undefined') &&(typeof error.response.text!= 'undefined')) {            
          var response = JSON.parse(error.response.text);        
          window.smallMessage.displayMessage("error", "policyget_5XX", response.bipNumber, response.description);
        }           
        else {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "No response available. Error: "+error.message);
        }
      }));
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_displayAttachPolicy"); 
    },
    
    tabRemove: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
            
      if(this.nodePoliciesTextContainer){
        this.nodePoliciesTextContainer.innerHTML = "";
      }
        
      if (this.flowPoliciesPane){
        try{
          this.flowPoliciesPane.destroy();
        }
        catch(e) {}
                
        this.flowPoliciesPane = null;
      } 
            
      // destroy flow policies table
      if (this.flowPoliciesTableContainer){
        try{
          this.flowPoliciesTableContainer.destroy();
        }
        catch(e) {}
                
        this.flowPoliciesTableContainer = null;
      }
            
      // destroy node policy flow diagram
      if(this.flowDiagramWidget){
        try{
          this.flowDiagramWidget.destroy();
        }
        catch(e) {}
              
        this.flowDiagramWidget = null;
      }
           
      // destroy policy action dialog
      if (this.policyActionDialog){
        try{             
          this.policyActionDialog.destroy();
        }
        catch(e) {}

        this.policyActionDialog = null;
      }  
           
      // Remove all the topic handlers
      for (var i=0; i < this.eventTopicHandlers.length; i++) {
        var handle = this.eventTopicHandlers[i];
        handle.remove();  
      }
          
      // Reset the eventTopicHandles array
      this.eventTopicHandlers = [];
      
      var notImplementedDialog = registry.byId("policyMessageDialog");
      if (notImplementedDialog) {
        try{
          notImplementedDialog.destroy();
        }
        catch(e) {}
        notImplementedDialog = null;
      }
                 
      // Remove all the WLM policy widget
      for (i=0; i < this.wlmPolicyWidgetArray.length; i++) {
        var wlmPolicyWidget = registry.byId(this.wlmPolicyWidgetArray[i]);
        if (wlmPolicyWidget){
          try{
            wlmPolicyWidget.destroy();
          }
          catch(e) {}
        }
      }
      
      // Reset the eventTopicHandles array
      this.wlmPolicyWidgetArray = [];
      
      UIUtils.removeAdminHandlers(this._adminHandlers);
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove"); 
    },
        
    tabBlur: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
                              
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur"); 
    },

    notImplementedDialog: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "notImplementedDialog");
      
      var notImplementedDialog = registry.byId("policyMessageDialog");
      if (!notImplementedDialog) {
        notImplementedDialog = new MessageDialog( {
          id : "policyMessageDialog" 
        });
          
        notImplementedDialog.startup();
      }
      
      domAttr.set(notImplementedDialog.titleNode, "innerHTML", entities.encode(NLS.functionNotImplemented));
      notImplementedDialog.refresh();
      notImplementedDialog.show();
        
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "notImplementedDialog"); 
    }
  });
  return policyAttach;
});

},
'webui/widgets/business/businesstransaction_data':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2013,2016" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.  
 * </copyright> 
 */

define("webui/widgets/business/businesstransaction_data",[
  "dojo/text!webui/widgets/business/templates/businesstransaction_data.html",
	"dojo/_base/declare", 
	"dijit/_TemplatedMixin",
	"dijit/_WidgetBase", 
  "dijit/_WidgetsInTemplateMixin",
	"webui/widgets/common/Trace"
], function(
  template,
  declare,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  Trace
) {
  var businesstransactionData = declare("webui.widgets.business.businesstransaction_data", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
    templateString: template,
    sampleBTObj: null,

    postCreate: function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			this.inherited(arguments);	
	 		Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},

		resize: function() {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");
		  
		  this._businessTransactionDataView_borderContainer.resize();
		  
		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
    },
	    
    // This function is called manually when we need to remove this tab.
    tabRemove: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove"); 
    },
        
    tabFocus: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");
            
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus"); 
    },
        
    tabBlur: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
            
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur"); 
    }
	});
	return businesstransactionData;
});

},
'webui/widgets/business/businesstransactions':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2015,2016" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.  
 * </copyright> 
 */

define(
  "webui/widgets/business/businesstransactions",
  [
    "dojo/text!webui/widgets/business/templates/businesstransactions.html",
    "dojo/i18n!webui/nls/web",
    "dojo/_base/declare",
    "dijit/_WidgetBase",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/registry",
    "dijit/TitlePane",
    "webui/widgets/common/Trace",
    "dojo/_base/array",
    "dojo/_base/lang",
    "dojo/dom",
    "dojo/dom-attr",
    "dojo/dom-class",
    "dojo/dom-construct",
    "dojo/hash",
    "dojo/on",
    "dojo/query",
    "dojo/request/xhr",
    "dojo/string",
    "dojo/topic",
    "dijit/form/ComboBox",
    "dojo/store/Memory",
    "webui/config/Resources",
    "webui/utils/WebUiHash",
    "webui/widgets/common/HasContextMenu",
    "webui/widgets/common/Toolbar",
    "webui/widgets/common/UIUtils",
    "webui/widgets/business/NewBusinessTransactionDialog",
    "webui/widgets/business/BTPermissionsModel"
  ],
  function(template,
    NLS,
    declare,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    registry,
    TitlePane,
    Trace,
    array,
    lang,
    dom,
    domAttr,
    domClass,
    construct,
    hash,
    on,
    query,
    xhr,
    string,
    Topic,
    Select,
    Memory,
    Resources,
    WebUiHash,
    HasContextMenu,
    Toolbar,
    UIUtils,
    NewBusinessTransactionDialog,
    BTPermissionsModel
  ) {
    var businessTransactionsRoot = declare("webui.widgets.business.businesstransactions", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
      templateString: template,
      declaredClass : "webui.widgets.business.businesstransactions",
      _btDataSourceLabel: NLS.btDataSourceName,
      _configTP: null,
      _newBTDialog : null,
      _policyInfo: {},
      _availableContent: {},
      
      // Artifacts for editing/viewing
      _dataSourceNameSelect: null,
      _dataSourceNameStore: null,
      
      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
        this.inherited(arguments);
        // Create toolbar
        this.toolbar = new Toolbar();
        construct.place(this.toolbar.domNode, this._toolbar);
        this.toolbar.addLeftAlignButtons("title");

        // Enable all by default, will control interaction upon visit to page
        var buttons = ["save","cancel", "help"];
        this.toolbar.addRightAlignButtons(buttons);
        this.toolbar.setButtonState("enable", buttons);
        this.toolbar.connectButtons("help", "click", this, "onHelpClick");

        this._createPropertiesContainer(this._propertyTitlePane);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
      },

      startup: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "startup");

        this.inherited(arguments);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "startup");
      },

      contextButtonsClicks : function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks");
        
        // Get the URI and action from the event:
        var uriAndAction = UIUtils.getURIAndAction(event, true);
        var action = uriAndAction.action;
        
        switch(action) {
          case "create":
            this._askNewBusinessTransaction();
            
            break;
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
      },
      
      // Set permission functions, and derive for further value creation
      _derivePermissions: function() {
        // Set interaction layout based upon permissions
        if(BTPermissionsModel.readOnlyModeForBTD()) {
          this._showReadOnlyView();
          return false;
        }
        else {
          this._restoreWriteView();
          return true;
        }
      },
      
     _createPropertiesContainer: function(target) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createPropertiesContainer");

        this._configTP = new TitlePane({
          title : NLS.businessTransactionsRootConfigPanel,
          open: true
        });
        
        target.appendChild(this._configTP.domNode);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createPropertiesContainer");
      },
      
      _setupDefaultPolicy: function(hasWrite, previousBTDCallback) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setupDefaultPolicy");
        
        var complete = false;

        var cbFnc = lang.hitch(this, function() {
          if(complete) {
            // Need to check that hash hasn't changed
            if(hash() === Resources.REST.businessTransactionsHome) {
              // Construct the policyProperties table for populating
              this._setDefaultPolicyPropertiesContent();
              this._populateValues(hasWrite);
              // Callback to signal previous editing link
              if(previousBTDCallback) {
                previousBTDCallback();
              }
            }
          } else {
            complete = true;
          }
        });
        
        // Multiple XHR calls, that confirm both completed before running populateValues in callback
        this._retrieveDefaultPolicyInformation(cbFnc);
        this._retrieveDataSourceNames(cbFnc);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setupDefaultPolicy");
      },
      
      _populateValues: function(hasWrite) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_populateValues");

        var currentDataSourceNameValue = "";
        
        // Set datasource name value
        currentDataSourceNameValue = this._getDataSourceNameFromPolicyInfo();

        // Write creates selectable dropdown, view just readonly text
        if(hasWrite) {
          if(typeof this._availableContent.dataSourceNames != "undefined") {
            // Check that the selected value is indeed the current value - if not then state warning
            this.showDataSourceNameNotFoundWarning(this._isCurrentSelectionAvailable(currentDataSourceNameValue, this._availableContent.dataSourceNames), currentDataSourceNameValue, this._policyInfo.name);
            
            this._dataSourceNameStore = new Memory({data: this._availableContent.dataSourceNames, idProperty: "id"});          
            this._dataSourceNameSelect = new Select({
              "name": "dataSourceNameSelect",
              "store": this._dataSourceNameStore,
              "value": currentDataSourceNameValue,
              "labelType": "html",
              "labelFunc": function(item) {
                var tooltip = string.substitute(NLS.btPolicyDataSourceNameLabel, [item.id, item.uri]);
                var content = "<div onmouseout='dijit.hideTooltip(this)' "+
                  "onmouseover='dijit.showTooltip(this.firstChild.value, this)' >"+
                  "<textarea style='display:none'>" + 
                  tooltip + "</textarea>"+ item.name+"</div>"; 
                return content;
              }
            });
            
            construct.place(this._dataSourceNameSelect.domNode, dom.byId("policyDataSourceNameSelect"));
            // Disable user input into the dropdown
            this._dataSourceNameSelect.textbox.disabled = true;

            // Setup listener on change value
            on(this._dataSourceNameSelect, 'change', lang.hitch(this, function (value) {
              //dijit.hideTooltip("btFlowFilter");
              if(value != this._getDataSourceNameFromPolicyInfo()) {
                this._onDataSourceNameChange(value);
                this.showDataSourceNameNotFoundWarning(this._isCurrentSelectionAvailable(value, this._availableContent.dataSourceNames), value, this._policyInfo.name);
              }
            }));
          }
        } else {
          // Read only set to just being able to view the default value
          dom.byId("policyDataSourceNameSelect").innerHTML = currentDataSourceNameValue;
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_populateValues");
      },
      
      // For now just the data source name values available
      _retrieveDefaultPolicyInformation: function(cbFnc) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_retrieveDefaultPolicyInformation");
        
        // For now retrieve the default datacapturepolicy
        var uri = Resources.REST.dataCapturePolicy + Resources.REST.defaultDCP;
        xhr(
          uri,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json",
              "Content-type" : "application/json",
          }
          }
        ).then(
          lang.hitch(this, function(response) {
            // If response is good then set the policyInformation
            this._policyInfo = {};
            if((typeof response != "undefined") && (typeof response.policyProperties != "undefined")) {
              this._policyInfo.type = response.type;
              this._policyInfo.name = Resources.REST.defaultDCP;
              // Add all the basic properties, for now we'll only show the data source name
              this._policyInfo.policyProperties = response.policyProperties;
            }
            // Run to check all required calls have run
            cbFnc();
          }),
          lang.hitch(this, function(error) {
            var response = JSON.parse(error.response.text);
            window.smallMessage.displayMessage("error", "retrievePolicyInformation_5XX", response.bipNumber, response.description, [Resources.REST.defaultDCP] );
          })
        );
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_retrieveDefaultPolicyInformation");
      },
      
      // Retrieve all known ODBC DataSource Names
      _retrieveDataSourceNames: function(cbFnc) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_retrieveDataSourceNames");
        
        var uri = Resources.REST.securityIdentities + "?" + Resources.REST.identityType + Resources.REST.typeOdbc;
        // Get the odbc resource types
        xhr(
          uri,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json",
              "Content-type" : "application/json",
          }
          }
        ).then(
          lang.hitch(this, function(response) {
            // If response is good then populate the values
            this._availableContent.dataSourceNames = [];
            if((typeof response != "undefined") && (typeof response.securityIdentity != "undefined") && lang.isArray(response.securityIdentity)) {
              array.forEach(response.securityIdentity, lang.hitch(this, function(nextItem) {
                this._availableContent.dataSourceNames.push({
                  name: nextItem.name,
                  id: nextItem.resource,
                  uri: nextItem.uri
                });
              }));
            }
            // Run to check all required calls have run
            cbFnc();
          }),
          lang.hitch(this, function(error) {
            var response = JSON.parse(error.response.text);
            window.smallMessage.displayMessage("error", "retrievePolicyODBC_5XX", response.bipNumber, response.description, [Resources.REST.typeOdbc]);
          })
        );

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_retrieveDataSourceNames");
      },
      
      // Checks whether the current stored value in the model, is available in the available options (i.e. it currently exists)
      _isCurrentSelectionAvailable: function(currentValue, availableValues) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_isCurrentSelectionAvailable");

        var available = false;
        
        if(currentValue != "") {
          array.forEach(availableValues, function(nextVal) {
            // Test on name value.....
            if(nextVal.name === currentValue) {
              available = true; 
            }
          });
        }
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_isCurrentSelectionAvailable");
        return available;
      },
      
      // Show/Hide warning for name not available.
      showDataSourceNameNotFoundWarning: function(show, value) {
        var warningDiv = dom.byId("dataSourceNameWarning");
        if(warningDiv) {
          if(show) {
            warningDiv.innerHTML = "";
            domClass.add(warningDiv, "bt_hidden");
          } else {
            var warningMsg = "";
            if(value === "") {
              warningMsg = NLS.btPolicyDataSourceNameEmpty;
            } else {
              warningMsg = string.substitute(NLS.btPolicyDataSourceNameWarning,[value]);
            }
            warningDiv.innerHTML = warningMsg;
            domClass.remove(warningDiv, "bt_hidden");
          }
        }
      },
      
      _setDefaultPolicyPropertiesContent: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setDefaultPolicyPropertiesContent");
        
        // Create a property title pane that has editable values (if permitted)
        var dataSourceNameContent = "<table class='_common_propertyContainer'>" +
        "<tbody>" +
        "<tr class='bt_hidden'><th/><th/></tr>" +
        "<tr>" +
        "<td class='_common_propertySubTextEven'>" + NLS.btDataSourceName + "</td>" +
        "<td data-test-attrname='dataSourceName' class='_common_propertySubValueEven' id='policyDataSourceNameSelect'>" +
        "</td>" +
        "</tr>" +
        "</tbody>" +
        "</table>" +
        "<div class='bt_ConfigInfo bt_hidden' id='dataSourceNameWarning'></div>" +
        "<div class='bt_ConfigInfo' id='policyPreviousBTLink'></div>";
        
        this._setPolicyPropertiesContent(construct.create("div", {
          innerHTML : dataSourceNameContent
        }));
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setDefaultPolicyPropertiesContent");
      },
      
      _setPolicyPropertiesLoading: function() {
        this._setPolicyPropertiesContent(construct.create("div", {
          innerHTML : "<div class='_common_propertyLoading'></div>"
        }));
      },
      
      _removePolicyPropertiesContent: function() {
        this._setPolicyPropertiesContent("");
      },
      
      _setPolicyPropertiesContent: function(content) {
        domAttr.set(this._configTP, "content", content);
      },
      
      // This is stored currently at this._policyInfo.policyProperties.configurations.configuration[0].dataSourceName
      // Thorough checking before asserting the data source name value
      _dataSourceNameFromPolicyExists: function() {
        if((typeof this._policyInfo.policyProperties != "undefined") &&
            (typeof this._policyInfo.policyProperties.configurations != "undefined") &&
              (typeof this._policyInfo.policyProperties.configurations.configuration != "undefined") &&
                (typeof lang.isArray(this._policyInfo.policyProperties.configurations.configuration) &&
                  (this._policyInfo.policyProperties.configurations.configuration.length > 0)) && 
                    (typeof this._policyInfo.policyProperties.configurations.configuration[0].dataSourceName != "undefined")) {
          return true;
        }
        
        return false;
      },
      
      _getDataSourceNameFromPolicyInfo: function() {
        if(this._dataSourceNameFromPolicyExists()) {
          return this._policyInfo.policyProperties.configurations.configuration[0].dataSourceName;
        }
        
        return null;
      },
      
      _setDataSourceNameFromPolicyInfo: function(dataSourceName) {
        if(this._dataSourceNameFromPolicyExists()) {
          this._policyInfo.policyProperties.configurations.configuration[0].dataSourceName = dataSourceName;
        }
      },
      
      // Undo to last previous saved state
      _revertChanges: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_revertChanges");
        
        // Reset Data Source Name
        if(this._dataSourceNameSelect.getValue() != this._getDataSourceNameFromPolicyInfo()) {
          this._dataSourceNameSelect.setValue(this._getDataSourceNameFromPolicyInfo());
        }
        
        this._noChangesMade();
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_revertChanges");
      },
      
      _onDataSourceNameChange: function() {
        this._changesMade();
      },
      
      _changesMade: function() {
        this.toolbar.getButton("save").set("disabled", false);
        this.toolbar.getButton("cancel").set("disabled", false);
      },
      
      _noChangesMade: function() {
        this.toolbar.getButton("save").set("disabled", true);
        this.toolbar.getButton("cancel").set("disabled", true);
      },
      
      /*
       * Disable the options when no write permissions detected.
       */
      _showReadOnlyView : function () {
        this.toolbar.getButton("save").domNode.setAttribute("class",  "bt_Button_hidden");
        this.toolbar.getButton("cancel").domNode.setAttribute("class", "bt_Button_hidden");
      },
      
      _restoreWriteView: function () {
        this.toolbar.connectButtons("save", "click", this, "onSaveClick");
        this.toolbar.connectButtons("cancel", "click", this, "onCancelClick");
      },
      
      /**
       * NEW BTD Function 
       */
      //Function to enable new business transaction creation
      _askNewBusinessTransaction: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_askNewBusinessTransaction");
        
        this.destroyNewDialogIfItExists();
        
        // Always a new create ensures we get latest list of BTD Names
        this._newBTDialog = new NewBusinessTransactionDialog({
          id: "newBTDDialog",
          currentValue : "",
          cback : lang.hitch(this, this._createBusinessTransaction)
        });

        this._newBTDialog.startup();
        this._newBTDialog.show();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_askNewBusinessTransaction");
      },
      
      // Behaviour upon user confirming creation of a new business transaction definition
      _createBusinessTransaction: function(newBTName) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createBusinessTransaction");

        var uri = encodeURI(Resources.REST.businessTransactions + newBTName);
        var content = JSON.stringify(this._createBusinessTransactionDefinitionTemplate(newBTName));

        //  Add loading icon to business root
        var tree = registry.byId('_explorerTree_ID');
        var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
        var oldIcon = domAttr.get(treeImgs[0],"class");
        domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");          

        xhr.put(
          uri,
          {
            "handleAs":"json",
            "data": content,
            "headers" : {
              "Accept" : "application/json",
              "Content-type" : "application/json"
            }
          }
        ).response.then(
          lang.hitch(this, function(response){
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createBusinessTransaction.xhrPut()",[response]);

            //reset old icon
            domAttr.set(treeImgs[0],"class",oldIcon);
            window.smallMessage.displayPlainMessage("success", "CreateBusinessTransactionAction_successBTCreated", [ newBTName ] );
                
            // Now navigate to that business transaction for further editing
            // newHash is the Rest URI
            var refreshHashCallback;
            refreshHashCallback = lang.hitch(this, function(newUri) {
              var newHash = WebUiHash.fromRestUri(newUri).toString();
              // New object created, so no need to safely change hash, hard update
              hash(newHash);
            });

            // Publish to notify the tree that content under the business transactions has changed
            Topic.publish(Resources.pubSubTopic.businessTransactionsUpdated, {bTXUri: uri, save: true, updateHashCallback: refreshHashCallback});
  
            Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createBusinessTransaction.xhrPut()");
          }),
          lang.hitch(this,function(error){
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createBusinessTransaction.xhrPutError()",[error]);

            //reset old icon
            domAttr.set(treeImgs[0],"class",oldIcon);
            
            Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrPut to " + uri + " failed.", [error]);
            //show error message
            var response = JSON.parse(error.response.text);
            window.smallMessage.displayMessage("error", "btdcreate_5XX", response.bipNumber, response.description);
            
            Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createBusinessTransaction.xhrPutError()");
          })
        );
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createBusinessTransaction");
      },
      
      // Destroy new BTD dialog if one already exists, prevent memory leak
      destroyNewDialogIfItExists: function() {
        if (this._newBTDialog) {
          this._newBTDialog.destroy();
          this._newBTDialog=null;
        }
      },

      resize: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");

        this._businessTransactions_borderContainer.resize();
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
      },

      // This function is called when we need to remove this tab.
      tabRemove: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");

        // Remove all content - detroy select and reset store behind it
        if((typeof this._dataSourceNameSelect != "undefined") && (this._dataSourceNameSelect != null)) {
          this._dataSourceNameSelect.destroy();
          this._dataSourceNameSelect = null;
          this._dataSourceNameStore.setData([]);
          this._dataSourceNameStore = null;
        }
        
        this.destroyNewDialogIfItExists();
        this._policyInfo = {};
        this._availableContent = {};
        
        this._removePolicyPropertiesContent();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
      },

      tabFocus: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");
        
        if(BTPermissionsModel.noReadWriteAccessForBTM()) {
          // Error message insufficient permissions
          window.smallMessage.displayMessage("error", "BusinessTransaction_insufficientPermissions", "",
              NLS.BusinessTransaction_insufficientPermissionsDescription);
        } else {
          this._setPolicyPropertiesLoading();
          
          // Disable the Save and Cancel - until an edit is made
          this._noChangesMade();
          
          // Regenerate the policy upon visit to tab (new call every visit - only single tab so will be from hash change)
          var write = this._derivePermissions();

          var previousBTDCB = null;
          
          // Only show link if user can actually go on to edit it
          if(BTPermissionsModel.writeModeForBTD()) {
            // Verify where user came from, if old hash is BTD config tab allow link to return to that business transaction for further editing, if no previous do nothing
            if((window.wmbConsole != null) && (window.wmbConsole.previousHash != null)) {
              var previousHash = window.wmbConsole.previousHash;
              if(typeof previousHash != "undefined") {
                var webUiHash = new WebUiHash(previousHash);
                // Verify came from a BTD on the view config tab
                if((webUiHash.getType() === Resources.REST.businessTransactionType) && (webUiHash.getTabNum() == 1)) {
                  var btName = webUiHash.getName();
                  if(btName == null) {
                    btName = "?";
                  }
                  previousBTDCB = lang.hitch(this, function() {
                    this._setPreviousLinkContent("<a target='_self' href='#" + previousHash + "'>" + string.substitute(NLS.btLinkToResumeBTEdit,[btName]) + "</a>");
                  });
                }          
              }
            }
          }

          this._setupDefaultPolicy(write, previousBTDCB);
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
      },
      
      _setPreviousLinkContent: function(content) {
        var previousDiv = dom.byId("policyPreviousBTLink");
        previousDiv.innerHTML = content;
      },

      onCancelClick: function() { 
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onCancelClick");
          // Warn that changes will be undone TODO
          
          // Undo changes, by restoring old policy model
          this._revertChanges();
          
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "onCancelClick");
      },

      onSaveClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onSaveClick");
        // Commit the current values of policy
        
        // Gather current set values from the page
        // Data source name
        var dataSourceName = this._dataSourceNameSelect.getValue();
        if(dataSourceName != null && dataSourceName != "") {
          this._setDataSourceNameFromPolicyInfo(dataSourceName);
        }
        
        // Generate expected JSON structure
        var data = {
          policyProperties: this._policyInfo.policyProperties,
          type: Resources.REST.dataCapturePolicyType
        };
        
        data = JSON.stringify(data);
        
        // For now this should only just be the (if any) change to data source name
        var uri = Resources.REST.dataCapturePolicy + Resources.REST.defaultDCP;
        // Get the odbc resoute types
        xhr.put(
          uri,
          {
            handleAs : "json",
            data : data,
            headers : {
              "Accept" : "application/json",
              "Content-type" : "application/json"
            }
          }
        ).then(
          lang.hitch(this, function() {
            window.smallMessage.displayMessage("success", "policyDataCapture_saveSuccess", "",
                string.substitute(NLS.messages.policyDataCapture_saveSuccessDescription, [this._getDataSourceNameFromPolicyInfo()]));
            this._noChangesMade();
          }),
          lang.hitch(this, function(error) {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Response: " + error.response.response);
            window.smallMessage.displayMessage("error", "policyDataCapture_saveFailure", "", error.response.status + ": " + error.response.text);
          })
        );

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onSaveClick");
      },

      onHelpClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onHelpClick");

        window.open(Resources.help.businessTransactionConcept);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onHelpClick");
      },

      tabBlur: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
      },

      /**
       * This method is called when the hash changes while this
       * tab widget is one of the (potentially several) tab widgets currently
       * visible. If you're okay with this hash change, return true. If there's
       * unsaved work, return false and provide a popup which will push the
       * change through.
       */
      canChangeHash: function() {

        //if user clicked Cancel button, then return true
      	 if (this._clickedCancel){
      		 return true;
      	 }//if
      	 
      	 // TODO
        return true;
      },
      
      _createBusinessTransactionDefinitionTemplate: function(btName) {
        var definition = Resources.artifactTemplates.businessTransaction;
        definition.name = btName;

        return definition;
      }

    });
    return businessTransactionsRoot;
  }
);

},
'webui/widgets/business/businesstransaction_overview':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2013,2016" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.  
 * </copyright> 
 */

define(
  "webui/widgets/business/businesstransaction_overview",
  [
    "dojo/text!webui/widgets/business/templates/businesstransaction_overview.html",
    "dojo/i18n!webui/nls/web",
    "dojo/_base/declare",
    "dijit/_WidgetBase",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/registry",
    "webui/widgets/common/Trace",
    "dojo/_base/lang",
    "dojo/dom",
    "dojo/dom-construct",
    "dojo/dom-style",
    "dojo/keys",
    "webui/widgets/common/Toolbar",
    "dojo/request/xhr",
    "dojo/string",
    "dijit/TitlePane",
    "dijit/layout/ContentPane",
    "webui/config/Resources",
    "webui/utils/RestUri",
    "webui/utils/WebUiHash",
    "webui/widgets/business/BTEditor",
    "webui/widgets/business/AddFlowDialog",
    "webui/widgets/business/BTDialog",
    "webui/widgets/business/BTFlowRemovalDialog",
    "webui/widgets/business/BTFlowDiagram",
    "webui/widgets/common/AttributesStore",
    "webui/widgets/common/HasContextMenu",
    "dojo/on",
    "idx/widget/ConfirmationDialog",
    "dojo/topic",
    "dojo/dom-geometry",
    "dojo/dom-attr",
    "dojo/dom-class",
    "dojo/_base/array",
    "dojo/hash",
    // Grid X
    "gridx/Grid",
    "gridx/core/model/cache/Sync",
    "gridx/modules/CellWidget",
    "gridx/modules/ColumnResizer",
    "gridx/modules/ColumnWidth",
    "gridx/modules/select/Cell",
    "gridx/modules/select/Row",
    "gridx/modules/SingleSort",
    "gridx/modules/Focus",
    /*"gridx/modules/Pagination",
    "gridx/modules/pagination/PaginationBar",*/
    "gridx/modules/Tree",
    "dojo/store/Memory",
    "webui/widgets/common/UIUtils",
    "webui/widgets/business/BTPermissionsModel"
  ],
  function(template,
    NLS,
    declare,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    registry,
    Trace,
    lang,
    dom,
    construct,
    domStyle,
    keys,
    Toolbar,
    xhr,
    string,
    TitlePane,
    ContentPane,
    Resources,
    RestUri,
    WebUiHash,
    BTEditor,
    AddFlowDialog,
    BTDialog,
    BTFlowRemovalDialog,
    BTFlowDiagram,
    AttributesStore,
    HasContextMenu,
    on,
    ConfirmationDialog,
    Topic,
    domGeom,
    attr,
    domClass,
    array,
    hash,
    // GridX
    Grid,
    CacheSync,
    CellWidget,
    ColumnResizer,
    ColumnWidth,
    SelectCell,
    SelectRow,
    SingleSort,
    Focus,
    /*Pagination,
    PaginationBar,*/
    Tree,
    // Dojo Store
    Store,
    UIUtils,
    BTPermissionsModel
  ) {
    var businesstransactionOverview = declare("webui.widgets.business.businesstransaction_overview", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
      templateString: template,
      // data-dojo-attach-point: "_businessTransactionOverview_borderContainer"
      // data-dojo-attach-point: "_toolbar"
      // data-dojo-attach-point: "_profilePropertiesInfoPane"
      // data-dojo-attach-point: "_propertyTitlePane"

      btName: null,
      txnTp: null,
      tableTp: null,
      flowTp: null,
      evGridContainer: null,
      addFlowButton: null,
      deleteFlowButton: null,
      detailsButton: null,
      btFlowProfileWidget: null,
      toolbar: null,
      btEditor: null,
      btSummary: null,
      btContainer: null,
      eventTopicHandlers : [],
      _adminTopicHandlers: [],
      eventTableFlowCount: 0,
      flowEventTableEventCount: 0,
      flowProfileSelected: {selected: false, uri: "", definition: {}, seen: false},
      evDefLayout: null,
      evDefSingleLayout: null,
      evDefGrid: null,
      evDefStore: null,
      evDefSingleGrid: null,
      evDefSingleStore: null,
      messageFlowProfileId: "messageFlowProfile",
      evDefGridBusinessCellIndex: 2,
      evDefSingleGridBusinessCellIndex: 1,
      newlyCreated : false,
      // true if the BTD has been created in this browser session
      // and it is not saved yet. In this case, do not show "Monitor" tab and disable "Refresh" button

      // indicates whether the BTD has been initialised
      initialised: false,

      // all apps deployed on this broker, computed once per session
      _appStore: null,
      // all services deployed on this broker, computed once per session
      _serviceStore: null,
      // all rstApis deployed on this broker, computed once per session
      _restApiStore: null,

      // all flows deployed on this broker computed once per session
      // those present in this BTD will have the included flag set
      _allFlowsStore: null,
      _attributesStore: new AttributesStore(),
      _clickedCancel : false,
      
      // handlers for the BTD operations add flow, remove flow and see details
      btmOpsHandlers :[],
      
      // array of flows in the BTD that is filled in as the properties have been received
      _flowsProperties: [],
      
      // Track flow and event property calls
      _flowPropertiesCallbacks: [],
      _flowEventPropertiesCallbacks: [],
      
      // Track whether flows on broker is being processed
      _computingFlowsForBroker: false,
      
      // First time this session
      _firstTime: false,
      
      
      // thresholds for screen size. Anything lower and we fix the position
      // of the add flow dialog to make sure it works on low resolution
      lowScreenHeight: 1000,
      lowScreenWidth: 1000,
      
      
      roleOptions : [{label: NLS.btDoNotFlagRole, value: Resources.businessTransaction.btEventDoNotFlag},
                         {label: NLS.btProgressRole, value: Resources.businessTransaction.btEventProgress},
                         {label: NLS.btStartRole, value: Resources.businessTransaction.btEventStart},
                         {label: NLS.btEndRole, value: Resources.businessTransaction.btEventEnd},
                         {label: NLS.btFailureRole, value: Resources.businessTransaction.btEventFailure}],


      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
        this.inherited(arguments);
        // Create toolbar
        this.toolbar = new Toolbar();
        construct.place(this.toolbar.domNode, this._toolbar);
        this.toolbar.addLeftAlignButtons("title");

        this.createOverviewSections(this._propertyTitlePane);

        var buttons;

        buttons = ["save","cancel", "help"];
        this.toolbar.addRightAlignButtons(buttons);
        this.toolbar.setButtonState("enable", buttons);
        
        if (BTPermissionsModel.writeModeForBTD()) {
          this.toolbar.connectButtons("save", "click", this, "onSaveClick");
          this.toolbar.connectButtons("cancel", "click", this, "onCancelClick");
        }
        else { // make them invisible
          this.toolbar.getButton("save").domNode.setAttribute("class", "bt_Button_hidden");
          this.toolbar.getButton("cancel").domNode.setAttribute("class", "bt_Button_hidden");
          
        }
        this.toolbar.connectButtons("help", "click", this, "onHelpClick");


        this._appStore =  new Store({
          data: [],
          idProperty: "uri"
        });
        
        this._serviceStore =  new Store({
          data: [],
          idProperty: "uri"
        });
        
        this._restApiStore =  new Store({
          data: [],
          idProperty: "uri"
        });

        this._allFlowsStore =  new Store({
          data: [],
          idProperty: "uri"
        });
        this._clickedCancel = false;
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
      },

      startup: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "startup");

        this.inherited(arguments);
        
        // Initial call for first BT object visit - only done once per WebUI session here, and only when we first come into BTDs
        this.computeAllFlowsForBroker();

        attr.set("_infoPaneTitleID", "innerHTML", "");
        this.toolbar.setAttribute("title", "innerHTML", "");

        this.createBusinessTransactionSection();
        this.createMonitoringEventsTableSection();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "startup");
      },

      /*
       * Disable the options when no wrong permissions detected.
       */
      showReadOnlyView : function () {
        var buttonContainer = dom.byId("btBTEditor_buttonsContainer");
        domClass.add(buttonContainer, "readOnly");
        
        this.addFlowButton.setAttribute("class", "bt_Button_hidden");
        this.deleteFlowButton.setAttribute("class", "bt_Button_hidden");
        
        if (this.btmOpsHandlers.length>2) {
          // the Add and Remove flow buttons should not work
          this.btmOpsHandlers[0].remove();
          this.btmOpsHandlers[1].remove();
        }
      },
      
      restoreWriteView: function () {
        var buttonContainer = dom.byId("btBTEditor_buttonsContainer");
        domClass.remove(buttonContainer, "readOnly");
        
        this.addFlowButton.setAttribute("class","bt_BusinessTransactionSectionButtonActive");
        this.deleteFlowButton.setAttribute("class","bt_BusinessTransactionSectionButtonActive");
      },
      
      contextButtonsClicks : function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks");

        // Get the URI and action from the event:
        var uriAndAction = UIUtils.getURIAndAction(event, true);
        var itemURI = uriAndAction.uri;
        var buttonType = uriAndAction.action;
        var targetUri = itemURI.substring(0, (itemURI.length - (buttonType.length+1)));

        switch (buttonType) {
          case "create":
        	  
            var canvasGeom = domGeom.position(dom.byId("_explorerTree_infoPane"));
            window.wmbConsole.safelyChangeHash(targetUri);
            window.wmbConsole.createInfoPane( { type : "businessTransaction" }, true,0);

            var btDialog = registry.byId("createBTDDialog");
            if (!btDialog) {

              btDialog = new BTDialog( {
              "id" : "createBTDDialog"
              });
              btDialog.startup();
            }
            
            // Make the "monitor" tab invisible and "Refresh" button disabled
            this.onNewDefinition();

            var x = canvasGeom.x+ canvasGeom.w/3;
            var y = canvasGeom.y + canvasGeom.h/10;
            btDialog.setDialogCoordinates(x, y);

            var val ={
                "btNew": true,
                "btModel": this.btModel,
                "previousHash": Resources.REST.nodeHome
            };
            btDialog.setInitialValues(val);

            btDialog.refresh();
            btDialog.show();
            var dialogGeom = domGeom.position(dom.byId("createBTDDialog"));
            btDialog.setGeomAttributes(canvasGeom, dialogGeom);
          break;
          case "delete":
            this.deleteBusinessTransaction(targetUri);
            break;
          default:
            break;
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
      },

      createOverviewSections: function(target) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createOverviewSections");

        this.txnTp = new TitlePane({
          title : NLS.businessTransactionTitle
        });
        attr.set(this.txnTp.domNode, "data-test-attrName", "businessTxnProfile");
        // Layout improvements
        domClass.add(this.txnTp.focusNode, "btSectionTitlePane");
        domClass.add(this.txnTp.titleBarNode, "btSectionTitlePane_titleBarNode");
        domClass.add(this.txnTp.containerNode, "btSectionTitlePane_containerNode");
        target.appendChild(this.txnTp.domNode);

        this.flowTp = new TitlePane({
          title : NLS.btNoFlowSelected,
          open : false
        });
        attr.set(this.flowTp.domNode, "data-test-attrName", "flowProfile");
        domClass.add(this.flowTp.focusNode, "btSectionTitlePane");
        domClass.add(this.flowTp.titleBarNode, "btSectionTitlePane_titleBarNode");
        domClass.add(this.flowTp.containerNode, "btSectionTitlePane_containerNode");
        target.appendChild(this.flowTp.domNode);

        var container = new ContentPane({
          id: this.messageFlowProfileId
        });
        this.flowTp.set("content", container);

        // Watch click events in case a resize is needed upon showing the flow profile
        this.own(on(this.flowTp, "click", lang.hitch(this, this.onFlowTitlePaneOpen)));

        this.tableTp = new TitlePane({
          title : NLS.btTxnEventTitle,
          open : false
        });

        attr.set(this.tableTp.domNode, "data-test-attrName", "eventTable");
        domClass.add(this.tableTp.focusNode, "btSectionTitlePane");
        domClass.add(this.tableTp.titleBarNode, "btSectionTitlePane_titleBarNode");
        domClass.add(this.tableTp.containerNode, "btSectionTitlePane_containerNode");
        target.appendChild(this.tableTp.domNode);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "createOverviewSections");
      },

      createBusinessTransactionSection: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createBusinessTransactionSection");

        // Just have the editor canvas showing in this section
        new ContentPane({ className: "bt_BTXSectionEditor" });

        this.createEditorButtons(this.txnTp.titleBarNode);

        //var btDiv = construct.create("div", { id: "btCanvas", className: "btCanvas" });
        var btCanvasContainer = new ContentPane({ id: "btCanvas" });

        //btSectionContainer.addChild(btCanvasContainer);

        // put the top level widget into the document, and then call startup()
        this.txnTp.set("content", btCanvasContainer);

        attr.set("btCanvas", "tabindex", "0");

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "createBusinessTransactionSection");
      },

      createMonitoringEventsTableSection: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createMonitoringEventsTableSection");

        // Table content pane
        var eventSectionContainer = new ContentPane({ className: "bt_EventsSection" });
        var info = construct.create("div", {innerHTML: NLS.btTxnEventDescription, className:"btEventSectionDescription"});
        construct.place(info, eventSectionContainer.domNode, "first");


        this.createEventButtons(this.tableTp.focusNode);

        this.evGridContainer = new ContentPane({ id: "btEventTableContainer", className: "bt_EventsSectionTable" });
        this.evGridSingleContainer = new ContentPane({ id: "btEventTableSingleContainer", className: "bt_EventsSectionTable" });

        this.createEventDefinitionTables();

        eventSectionContainer.addChild(this.evGridContainer);
        eventSectionContainer.addChild(this.evGridSingleContainer);

        this.tableTp.set("content", eventSectionContainer);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "createMonitoringEventsTableSection");
      },

      computeHTMLFragmentForEventIcon: function (item) {
        
        var iconClass = "event_table_type_icon event_icon_";

        // If this is a transaction predicate
        if(item.isTransactionEvent === "true") {
          // Determine the transaction type
          switch(item.eventSource) {
            case "start":
              iconClass += "transaction_start";
              break;
            case "end":
              iconClass += "transaction_end";
              break;
            case "rollback":
              iconClass += "transaction_rollback";
              break;
          }
        } else {
          // Must be terminal event
          switch(item.eventSource) {
            case "in":
              iconClass += "terminal_in"; 
              break;
            case "failure":
              iconClass += "terminal_fail";
              break;
            case "try":
              iconClass += "terminal_try";
              break;
            case "catch":
              iconClass += "terminal_catch";
              break;
            case "timeout":
              iconClass += "terminal_timeout";
              break;
            // Else the default is an out terminal
            default:
              iconClass += "terminal_out";
          }
        }

        return "<div><div alt='" + item.eventSourceAddress + "' class='" + iconClass + "'></div><div class='event_table_type'>" + item.eventSourceAddress + "</div></div>";
      },

      createEventDefinitionTables: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createEventDefinitionTables");

        this.createMultiEventTable();

        this.createSingleEventTable();

        // Initially hide the single flow event view
        domClass.add(this.evGridSingleContainer.domNode,"bt_EventsSectionTableHidden");

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "createEventDefinitionTables");
      },

      createMultiEventTable: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createMultiEventTable");
        
				var roleOptions = this.roleOptions;
	
       // Event Table row formatters
        var flowSummary = function(item, value) {
          return treeSummaryFormatter(item, value, NLS.btOneMonitoringEvent, NLS.btMonitoringEvents);
        };

        var noSummary = function(item, value) {
          if(!item.isMessageFlow && value){
            return value;
          } else {
            return "";
          }
        };

        var treeSummaryFormatter = function(item, value, oneNLS, multipleNLS){

          if(!item.isMessageFlow && value){
            return value;
          } else {
            var childCount = 0;
            if((typeof item.children !== "undefined") && (typeof item.children.length)) {
              childCount = item.children.length;
            }

            return string.substitute((childCount == 1) ? oneNLS : multipleNLS, [childCount]);
          }
        };

        this.evDefStore = new Store({
          data: [],
          idProperty: "id"
        });

        // Set up children calls for tree data
        this.evDefStore.hasChildren = function(id, item){ // jshint ignore:line

          // Return true if the given row has children, false otherwise.
          var hasChildren = (typeof item !== "undefined") && (typeof item.children !== "undefined") && (item.children.length > 0);

          return hasChildren;
        };

        this.evDefStore.getChildren = function(item){

          // Returns an array of the child items of the given row item.
          var toReturn = null;

          if((typeof item !== "undefined") && (typeof item.children !== "undefined")) {
            toReturn = item.children;
          }

          return toReturn;
        };

        this.evDefLayout =
        [
          {id: 'name', field: 'name', name: NLS.btEventTableMessageFlowEvent, width: '27.5%', expandLevel: 1,
            formatter: lang.hitch(this, function(item) {
              if(!item.isMessageFlow){
                return item.eventName;
              } else {
                return this.deriveLabelValue(item);
              }
            })},
           {id: 'eventSourceAddress', field: 'eventSourceAddress', width : '25%', name : NLS.btEventTableEventSourceAddress,
             formatter: lang.hitch(this, function(item) {
               if(!item.isMessageFlow){
                 return this.computeHTMLFragmentForEventIcon(item);
               } else {
                 return flowSummary(item, item.eventSourceAddress);
               }
             })
           },
           {id: 'role', field: 'role', name: NLS.btRole,  width: '12.5%', widgetsInCell: true,
             decorator: function(){
               if (BTPermissionsModel.writeModeForBTD()) {
                 return "<div class='eventTable_center' data-dojo-attach-point='roleSelectCell'></div><div class='eventTable_center' data-dojo-attach-point='roleSelectContainer'><select width='100px' tabindex='0' data-dojo-type='idx.form.Select' data-dojo-attach-point='roleSelect'></select></div>";
               }
               else {
                 return "<div class='eventTable_center' data-dojo-attach-point='roleSelectCell'></div><div class='eventTable_center' data-dojo-attach-point='roleSelect'></div>";
               }
             },
             onCellWidgetCreated: function(cellWidget) {
               if (BTPermissionsModel.writeModeForBTD()) {
                 // Set label on select value for descriptive
                 cellWidget.roleSelect.compLabelNode.textContent = NLS.btRole;
                 cellWidget.roleSelect.addOption(roleOptions);
                 cellWidget.roleSelect.set("tabIndex", 0);
               }
               else {
                 cellWidget.roleSelect.compLabelNode = NLS.btRole;
               }
             },
             setCellValue: lang.hitch(this, function(gridData, storeData, cellWidget){
               // If a noSummary value, then must be a flow row, remove the dropdown and replace with the "-"
               if (BTPermissionsModel.writeModeForBTD()) {
                 if(gridData === "") {
                   // Add make invisible class as we don't want to show the dropdown
                   domClass.add(cellWidget.roleSelectContainer,"bt_EventsSectionTableCellWidgetHidden");
                   cellWidget.roleSelectCell.innerHTML = gridData;
                 } else {
                   domClass.remove(cellWidget.roleSelectContainer,"bt_EventsSectionTableCellWidgetHidden");
                   cellWidget.roleSelectCell.innerHTML = "";
                   if(typeof storeData !== "undefined") {
                     cellWidget.roleSelect.set('value', storeData);
                   } else {
                     cellWidget.roleSelect.set('value', gridData);
                   }
                 }
               }
               else {
                 cellWidget.roleSelectCell.innerHTML = this.getNLSRole(storeData, gridData);
               }
             }),
             getCellWidgetConnects: lang.hitch(this, function(cellWidget){
               // Return an array of connection arguments, this allows for auto handle of connecting and disconnecting on events.
               return [
                       // On value change for select
                   [cellWidget.roleSelect, 'onChange', lang.hitch(this, function(newRole){

                       var monitorEventItem = cellWidget.cell.row.item();
                       var newRoleLabel = cellWidget.roleSelect.get("displayedValue");

                       // Only call promote if the value has been changed (also stops any setting of the value on first rendering).
                       // Does so by comparing new value with value of store, only if different should a "promote" action occur.
                       // Also only call promote if this row is a monitor event, i.e. not a message flow.
                       if ((typeof monitorEventItem !== "undefined") && (typeof newRole !== "undefined") && (newRole !== monitorEventItem.role) && (!monitorEventItem.isMessageFlow)) {
                         monitorEventItem.role = newRole;
                         this.promoteEvent(newRole, monitorEventItem, newRoleLabel);
                         Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Change value on event: " + monitorEventItem.id + " newRole: " + newRole);
                       }
                   })]
               ];
             }),
             formatter: function(item) {
               return noSummary(item, item.role);
             }
           },
           {id: 'globalId', field: 'globalId', name: NLS.btGlobalTran, width: '25%',
             formatter: function(item) {
               
               var globalId = "";
               if(item.transactionCorrelation && item.transactionCorrelation.global) {
                 globalId = item.transactionCorrelation.global;
               }
               
               return noSummary(item, globalId);
             }},
           {id: 'details', field: 'details', width: 'auto', name: NLS.btDetailsButton,
               formatter: function(item) {
                 return noSummary(item, NLS.btEventTableEventDetailsCell);
            }}
        ];

        // GridX Table
        this.evDefGrid = new Grid({
          store: this.evDefStore,
          cacheClass: CacheSync,
          structure: this.evDefLayout,
          autoHeight: true,
          //columnWidthAutoResize: true,
          autoWidth: false,
          autoResize: true,
          // Select a row when any cell in that row is clicked.
          selectRowTriggerOnCell: true,
          selectRowMultiple: false,
          //paginationBarMessage: NLS.btEventsTableMessageFlowsTotal + ": ${0} " + NLS.btEventsTableMessageFlowsRange + ": ${2} - ${3}",
          bodyEmptyInfo: NLS.btEventResultsTableNoFlows,          
          //Declare initialOrder as grid parameter:
          sortInitialOrder: { colId: 'name', descending: false },          
          modules: [
            ColumnResizer,
            ColumnWidth,
            CellWidget,
            SelectRow,
            Focus,
            SingleSort,
            Tree/*,
            Pagination,
            PaginationBar,
            Filter,
            FilterBar,
            QuickFilter*/
          ]
        });

        this.evDefGrid.placeAt("btEventTableContainer");
        this.evDefGrid.startup();

        this.evDefGrid.connect(this.evDefGrid, "onCellMouseOver", lang.hitch(this, function(event){
          if ((event.columnId === "details") && (event.rowId !== "") && (event.parentId !== "")) { // Details column
            var monitoringEvent = this.evDefGrid.model.byId(event.rowId).item;
            this.showMonitoringEventDetail(event, monitoringEvent);
          }
        }));

        this.evDefGrid.connect(this.evDefGrid, "onCellMouseOut", lang.hitch(this, function(event){
          this.hideMonitoringEventDetail(event, this.evDefGrid);
        }));

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "createMultiEventTable");
      },

      createSingleEventTable: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createSingleEventTable");

				var roleOptions = this.roleOptions;
				
        // Empty data store with no items
        this.evDefSingleStore = new Store({
          idProperty: "id",
          data: []
        });

        this.evDefSingleLayout = [
                                  {id: 'eventName', field: 'eventName', width : '27.5%', name : NLS.btEventTableEventName},
                                  {id: 'eventSourceAddress', field: 'eventSourceAddress', width : '25%', name : NLS.btEventTableEventSourceAddress,
                                   formatter: lang.hitch(this, function(item) {
                                     return this.computeHTMLFragmentForEventIcon(item);
                                    })
                                  },
                                  {id: 'role', field: 'role', name: NLS.btRole,  width: '12.5%', widgetsInCell: true,
                                    decorator: function(){
                                      if (BTPermissionsModel.writeModeForBTD()) {
                                        return "<div class='eventTable_center'><select width='100px' tabindex='0' data-dojo-type='idx.form.Select' data-dojo-attach-point='roleSelect' ></select></div>";                                        
                                      }
                                      else {
                                        return "<div class='eventTable_center' data-dojo-attach-point='roleSelect'></div>";
                                      }
                                    },
                                    onCellWidgetCreated: function(cellWidget) {
                                      if (BTPermissionsModel.writeModeForBTD()) {
                                        // Set label on select value for descriptive
                                        cellWidget.roleSelect.compLabelNode.textContent = NLS.btRole;
                                        cellWidget.roleSelect.addOption(roleOptions);
                                        cellWidget.roleSelect.set("tabIndex", 0);
                                      }
                                      else {
                                        cellWidget.roleSelect.compLabelNode = NLS.btRole;
                                      }
                                    },
                                    setCellValue: lang.hitch(this, function(gridData, storeData, cellWidget){
                                      if (BTPermissionsModel.writeModeForBTD()) {                                      
                                        if(typeof storeData !== "undefined") {
                                          cellWidget.roleSelect.set('value', storeData);
                                        } else {
                                          cellWidget.roleSelect.set('value', gridData);
                                        }
                                      }
                                      else {
                                        cellWidget.roleSelect.innerHTML = this.getNLSRole(storeData, gridData);
                                      }
                                    }),
                                    getCellWidgetConnects: lang.hitch(this, function(cellWidget){
                                      // Return an array of connection arguments, this allows for auto handle of connecting and disconnecting on events.
                                      return [
                                              // On value change for select
                                          [cellWidget.roleSelect, 'onChange', lang.hitch(this, function(newRole){
                                              var monitorEventItem = cellWidget.cell.row.item();
                                              var newRoleLabel = cellWidget.roleSelect.get("displayedValue");

                                              // Only call promote if the value has been changed (also stops any setting of the value on first rendering.
                                              // Does so by comparing new value with value of store, only if different should a "promote" action occur.
                                              if ((typeof monitorEventItem !== "undefined") && (typeof newRole !== "undefined") && (newRole !== monitorEventItem.role)) {
                                                monitorEventItem.role = newRole;

                                                // Update the value on the multi-flow store also
                                                var multiMonitorEvent = this.evDefGrid.model.byId(monitorEventItem.id).item;
                                                multiMonitorEvent.role = newRole;
                                                this.promoteEvent(newRole, monitorEventItem, newRoleLabel);

                                                Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Change value on event: " + monitorEventItem.id + " newRole: " + newRole);
                                              }
                                          })]
                                      ];
                                    })
                                  },
                                  {id: 'globalId', field: 'globalId', name: NLS.btGlobalTran, width: '25%',
                                    formatter: function(item) {
                                      
                                      var globalId = "";
                                      if(item.transactionCorrelation && item.transactionCorrelation.global) {
                                        globalId = item.transactionCorrelation.global;
                                      }
                                      
                                      return globalId;
                                    }},
                                  {id: 'details', field: 'details', width: 'auto', name:NLS.btDetailsButton,
                                    formatter: function(){
                                      return NLS.btEventTableEventDetailsCell;
                                    }}
                             ];

        // GridX Table
        this.evDefSingleGrid = new Grid({
          store: this.evDefSingleStore,
          cacheClass: CacheSync,
          structure: this.evDefSingleLayout,
          autoHeight: true,
          //columnWidthAutoResize: true,
          autoWidth: false,
          autoResize: true,
          // Select a row when any cell in that row is clicked.
          selectRowTriggerOnCell: true,
          selectRowMultiple: false,
          bodyEmptyInfo: NLS.btEventResultsTableNoMonitoringEvents,
          //Declare initialOrder as grid parameter:
          sortInitialOrder: { colId: 'eventSourceAddress', descending: false },

          modules: [
            ColumnResizer,
            ColumnWidth,
            CellWidget,
            SelectRow,
            SelectCell,
            SingleSort,
            Focus/*,
            Filter,
            QuickFilter,
            Pagination,
            PaginationBar*/
          ]
        });

        //this.evGridSingleContainer.addChild(domConstruct.create("div", { id: "btResultsTransactionGrid", className: "btResultsTransactionGridContainer"}));
        this.evDefSingleGrid.placeAt("btEventTableSingleContainer");
        this.evDefSingleGrid.startup();

        this.evDefSingleGrid.connect(this.evDefSingleGrid.select.row, 'onSelected',
            lang.hitch(this, function(data, rowId) { // jshint ignore:line
              this.onEventTableSelectionHandler(rowId);
            }
          )
        );

        this.evDefSingleGrid.connect(this.evDefSingleGrid, "onCellMouseOver", lang.hitch(this, function(event){
          if (event.columnId === "details") { // Details column
            var monitoringEvent = this.evDefSingleStore.get(event.rowId);
            this.showMonitoringEventDetail(event, monitoringEvent);
          }
        }));

        this.evDefSingleGrid.connect(this.evDefSingleGrid, "onCellMouseOut", lang.hitch(this, function(event){
          this.hideMonitoringEventDetail(event, this.evDefSingleGrid);
        }));

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "createSingleEventTable");
      },

      showMonitoringEventDetail: function(ev, monitoringEvent){
          var msg = '<div >' +NLS.btMonitoringEvent + '</div>';
          var table = "<table class='event_tooltip_table'>";
          if (!monitoringEvent) {
            return;
          }
          if (monitoringEvent.eventName) {
            table += "<tr><td> "+ NLS.btMEEventName +"</td><td>"+ monitoringEvent.eventName + "</td></tr>";
          }

          if (monitoringEvent.eventSourceAddress) {
            table += "<tr><td> "+ NLS.btMESourceAdress +"</td><td>"+ monitoringEvent.eventSourceAddress + "</td></tr>";
          }
          if (monitoringEvent.transactionCorrelation) {
            table +="<tr><td> "+ NLS.btMECorrelation +"</td><td></td></tr>" +
              "<tr><td align=center>"+ NLS.btMELocal +"</td><td>"+ monitoringEvent.transactionCorrelation.local + "</td></tr>" +
              "<tr><td align=center> "+ NLS.btMEGlobal +"</td><td>"+ monitoringEvent.transactionCorrelation.global + "</td></tr>" +
              "<tr><td align=center> "+ NLS.btMEParent +"</td><td>"+ monitoringEvent.transactionCorrelation.parent + "</td></tr>";
          }
          if (monitoringEvent.eventFilter) {
            table += "<tr><td> "+ NLS.btMEFilter +"</td><td>"+ monitoringEvent.eventFilter + "</td></tr>";
          }
          if ((typeof monitoringEvent.enabled != "undefined") && (monitoringEvent.enabled != null)) {
            table += "<tr><td> "+ NLS.btMEEnabled +"</td><td>"+ monitoringEvent.enabled + "</td></tr>";
          }
          if (monitoringEvent.payload.dataLocations.length > 0) {
             table += "<tr><td> "+ NLS.btMEData +"</td><td></td></tr>";
             for (var i=0;i<monitoringEvent.payload.dataLocations.length; i++) {
               table = table+ "<tr><td align=center> "+ i+":</td><td>"+ monitoringEvent.payload.dataLocations[i].xPathQuery + "</td></tr>";
             }
          }
          else {
            table += "<tr><td> "+ NLS.btMEData +"</td><td>"+NLS.btMEDataNone+ "</td></tr>";
          }

          if (monitoringEvent.name) {
            table += "<tr><td> "+ NLS.btMEName +"</td><td>"+ monitoringEvent.name + "</td></tr>";
          }
          if (monitoringEvent.isTransactionEvent) {
            table += "<tr><td> "+ NLS.btMEisData +"</td><td>"+ monitoringEvent.isTransactionEvent + "</td></tr>";
          }
          if (monitoringEvent.isBitstreamDataIncluded) {
            table +=  "<tr><td> "+ NLS.btMEIsTxnEvent +"</td><td>"+ monitoringEvent.isBitstreamDataIncluded + "</td></tr>";
          }
          if (monitoringEvent.eventUnitOfWork) {
            table +=  "<tr><td> "+ NLS.btMEUnitOfWork +"</td><td>"+ monitoringEvent.eventUnitOfWork + "</td></tr>";
          }
          if (monitoringEvent.payload) {
            table += "<tr><td> "+ NLS.btMEEnc +"</td><td>"+ monitoringEvent.payload.bitstreamContentEncoding + "</td></tr>" +
                "<tr><td> "+ NLS.btMEType +"</td><td>"+ monitoringEvent.payload.bitstreamContentType + "</td></tr>";
          }
          table += "</table>";
          msg = msg+ table;
          dijit.showTooltip(msg, ev.cellNode);
      },

      hideMonitoringEventDetail: function(event){
        if (event && event.cellNode) {
          dijit.hideTooltip(event.cellNode);
        }
      },

      promoteEvent: function(newRole, monitoringEvent) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "promoteEvent");

        // Store new event in the model
        this.btEditor.changeEvent(newRole, monitoringEvent, monitoringEvent.flowUri);

        // broadcast a change to business event
        Topic.publish(Resources.pubSubTopic.businessTransaction, {"businessEvent":[newRole, "role", monitoringEvent, monitoringEvent.flowUri], "callingHash": hash()});
//        if (monitoringEvent.role === Resources.businessTransaction.btEventDoNotFlag) {
//          window.smallMessage.displayMessage("success", "BusinessEvent_demoted", "",
//          string.substitute(NLS.messages.BusinessEvent_demotedDescription, [monitoringEvent.name, newRoleLabel]));
//        }
//        else {
//          window.smallMessage.displayMessage("success", "BusinessEvent_promoted", "",
//          string.substitute(NLS.messages.BusinessEvent_promotedDescription, [monitoringEvent.name, newRoleLabel]));
//        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "promoteEvent");
      },

      createEditorButtons: function(target) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createEditorButtons");
        // Set read only to begin with, make visible if user has write permissions
        var buttonContainer = construct.create("div", {className: "bt_BusinessTransactionSectionButtonsContainer readOnly", id: "btBTEditor_buttonsContainer"});
        
        var addFlowContainer = construct.create("span",{
          className: "bt_BusinessTransactionSectionSingleButtonContainer"
        });
        
        this.addFlowButton = construct.create("div",{
          className: "bt_Button_hidden",
          innerHTML: NLS.btAddFlowButton,
          tabindex: "0",
          title: NLS.btAddFlowButtonDesc
        });
        
        var deleteFlowContainer = construct.create("span",{
          className: "bt_BusinessTransactionSectionSingleButtonContainer"
        });
        
        this.deleteFlowButton = construct.create("div",{
          className: "bt_Button_hidden",
          innerHTML: NLS.btDeleteFlowButton,
          tabindex: "0",
          title: NLS.btDeleteFlowButtonDesc
        });
        
        var detailsContainer = construct.create("span",{
          className: "bt_BusinessTransactionSectionSingleButtonContainer"
        });
        
        // Will always show
        this.detailsButton = construct.create("div",{
          className: "bt_BusinessTransactionSectionButtonActive",
          tabindex: "0",
          innerHTML: NLS.btDetailsButton,
          title: NLS.btDetailsButtonDesc
        });

        construct.place(this.addFlowButton, addFlowContainer);
        construct.place(addFlowContainer, buttonContainer);
        construct.place("<span class='bt_BusinessTransactionSectionButtonsDivider' aria-hidden='true'>|</span>", buttonContainer);
        construct.place(this.deleteFlowButton, deleteFlowContainer);
        construct.place(deleteFlowContainer, buttonContainer);
        construct.place("<span class='bt_BusinessTransactionSectionButtonsDivider' aria-hidden='true'>|</span>", buttonContainer);
        construct.place(this.detailsButton, detailsContainer);
        construct.place(detailsContainer, buttonContainer);

        // Stop click events around buttons
        on(buttonContainer, "click", lang.hitch(this, function(event) {
          event.stopPropagation();
        }));

        // Add class to retain button positioning
        domClass.add(target, "btSectionTitlePane_titleBarNodeButtonContainer");
        
        construct.place(buttonContainer, target);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "createEditorButtons");
      },

      createEventButtons: function(/*target*/) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createEventButtons");
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "createEventButtons");
      },

      onFlowSelectedHandler: function(targetFlow) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onFlowSelectedHandler");

        this.selectedFlow = targetFlow;

        // Only act on flow selection if it is not currently being shown
        if((this.btFlowProfileWidget == null) || (this.btFlowProfileWidget.flowProfileURI != targetFlow.uri)) {
            var flowType = new RestUri(targetFlow.uri).getParentArtifactRestUri().getArtifactType();
            var flowLabel = this.deriveLabelValue(targetFlow);
            
            var profileTitle;
            if(this.canHaveFlowDiagram(flowType)) {
              // Set the flow profile.
              profileTitle = string.substitute(NLS.btFlowProfileTitle, [flowLabel]);
              this.flowTp.set('title', profileTitle);
              this.createFlowProfile(targetFlow);
            } else {
              profileTitle = string.substitute(NLS.btFlowProfileNoVisualTitle, [flowLabel, flowType]);              
              this.flowTp.set('title', profileTitle);
              this.flowTp.set('open', false);
              this.deleteFlowProfile();
            }
            
            var eventsTitle = "";
            switch(flowType) {
              case Resources.REST.servicesType:
                // Extract the service name
                eventsTitle = string.substitute(NLS.btFlowEventTitleService, [RestUri(targetFlow.uri).getParentArtifactRestUri().getArtifactName()]);
                break;
                
              case Resources.REST.restApisTypeUri:
                // Extract the RST API name
                eventsTitle = string.substitute(NLS.btFlowEventTitleRestApi, [RestUri(targetFlow.uri).getParentArtifactRestUri().getArtifactName()]);
                break;
                
              default:
                eventsTitle = string.substitute(NLS.btFlowEventTitle, [flowLabel]);
            }
            this.tableTp.set('title', eventsTitle);

            // Update the event table
            this.populateSingleFlowEventTable(targetFlow.uri);

        } else {
          // If the newly selected flow profile is not being shown, then update the table
          if(!this.flowProfileSelected.selected) {
            this.populateSingleFlowEventTable(targetFlow.uri);
          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onFlowSelectedHandler");
      },

      onDeselectFlowHandler: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onDeselectFlowHandler");

        // Only do anything if a flow profile is currently being shown  or have been explicitly told to overwrite
        if (this.flowProfileSelected.selected) {
          this.flowProfileSelected = {selected: false, uri: "", definition: {}, seen: false};
          // Switch the event grid so that multiple flows are visible
          this.showHideEventsSections(this.evGridContainer, this.evGridSingleContainer);
          this.deleteFlowProfile();
          this.flowTp.set('title', NLS.btNoFlowSelected);
          this.flowTp.set('open', false);
          this.tableTp.set('title', NLS.btTxnEventTitle);
          this.evDefGrid.body.refresh();
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onDeselectFlowHandler");
      },

      onDeleteFlowHandler: function(messageFlowUri) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onDeleteFlowHandler");

        // Delete the flow
        this.evDefStore.remove(messageFlowUri);

        // Update the BTModel to remove any references to the existing flow BT Monitor events
        this.btEditor.removeFlowFromModel(messageFlowUri);

        // mark the flow available for future additions, clear the flag
        var flow = this._allFlowsStore.get(messageFlowUri);
        if (flow) {
            flow.available = true;
        }

        // Now that the data stores have been updated, ensure that no flow profile is selected
        this.onDeselectFlowHandler();
        this.evDefGrid.body.refresh();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onDeleteFlowHandler");
      },

      /**
       * Computes an array of all flows deployed on this integration node.
       * The array will be used as choices of flows to add to the business transaction.
       * Note that this is a potentially expensive operation.
       * Do it once per browser session and reuse the list.
       */
      computeAllFlowsForBroker: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "computeAllFlowsForBroker");
        
        this._computingFlowsForBroker = true;
        
        var uri = Resources.REST.allFlowsURI + Resources.REST.allFlowsDepth;
        xhr(
            encodeURI(uri),
            {
              handleAs : "json",
              headers : {
                 "Accept" : "application/json"
              }
            }
        ).then(
          lang.hitch(this, function(response) {
            this._recurseTree(response);
            this._computingFlowsForBroker = false;
            Topic.publish(Resources.pubSubTopic.businessTransactionFilters.flows, true);
          }),
          lang.hitch(this, function(error) {
            this._computingFlowsForBroker = false;
            Topic.publish(Resources.pubSubTopic.businessTransactionFilters.flows, true); 
            Trace.trace(this.btFlowProfileWidget.declaredClass, Trace.levels.DEBUG, "FlowProfile Error: " + error.response.xhr.status + " Response: " + error.response.xhr.response);
          })
        );
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "computeAllFlowsForBroker");
      },

      _recurseTree: function(response) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_recurseTree");

        Object.keys(response).forEach(lang.hitch(this, function(objectItem) {
          if (lang.isArray(response[objectItem])) {
            array.forEach(response[objectItem], lang.hitch(this, function(arrayItem) {
              switch(arrayItem.type) {
                case Resources.REST.messageFlowType:
                    var parent = new RestUri(arrayItem.uri).getParentArtifactRestUri().getArtifact();
                    // Add messageFlow to the messageFlowArray
                    this._allFlowsStore.put({
                      "name": arrayItem.name,
                      "parentName":parent.name,
                      "parentType":parent.type,
                      "available" : true,
                      "uri": arrayItem.uri
                    });
                  break;

                case Resources.REST.applicationType:
                  parent = new RestUri(arrayItem.uri).getParentArtifactRestUri().getArtifact();
                  this._appStore.put({
                    "name": arrayItem.name,
                    "parentName":parent.name,
                    "parentType":parent.type,
                    "uri": arrayItem.uri
                  });
                  break;
                  
                case Resources.REST.serviceType:
                  parent = new RestUri(arrayItem.uri).getParentArtifactRestUri().getArtifact();
                  this._serviceStore.put({
                    "name": arrayItem.name,
                    "parentName":parent.name,
                    "parentType":parent.type,
                    "uri": arrayItem.uri
                  });
                  break;
                  
                case Resources.REST.restApiType:
                  parent = new RestUri(arrayItem.uri).getParentArtifactRestUri().getArtifact();
                  this._restApiStore.put({
                    "name": arrayItem.name,
                    "parentName":parent.name,
                    "parentType":parent.type,
                    "uri": arrayItem.uri
                  });
                  break;
              }
              this._recurseTree(arrayItem);
            }));
          } else {
            if ( typeof response[objectItem] == "object") {
              this._recurseTree(response[objectItem]);
            }
          }
        }));

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_recurseTree");
      },

      createFlowProfile: function (targetFlow) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createFlowProfile", targetFlow);
        var flowName = targetFlow.name;
        
        if(targetFlow.type === Resources.businessTransaction.btElementTypeNamespace + Resources.businessTransaction.btElementTypeFlow) {
          if(dom.byId(this.messageFlowProfileId)){
            // If there is already a flow profile rendered, then remove it
            this.deleteFlowProfile();
            this._setFlowProfileLoading();
            // Request flow diagram information
            xhr(
              targetFlow.uri + "/flowdesign",
              {
                handleAs : "json",
                headers : {
                  "Accept" : "application/json"
                }
              }
            ).then(
              lang.hitch(this, function(response) {
								// Remove loading in prep for showing the flow
                this._removeFlowProfileContent();

                try {
                  this.btFlowProfileWidget = new BTFlowDiagram();
                }
                catch(e) {
                  Trace.trace(this.btFlowProfileWidget.declaredClass, Trace.levels.DEBUG, "FlowProfile Error: " + e);
                }

                if(this.btFlowProfileWidget){
                  this.flowProfileSelected.definition = response;
                  
                  // If the flowTP is visible then add the flow, else we'll render it later when its requested
                  if(this.flowTp.open) {
                    // Generate the flow profile, and render any events for that flow
                    this.btFlowProfileWidget.createFlowDiagram(this.messageFlowProfileId, response, targetFlow.uri, this.btEditor.getFlowEventsFromModel(targetFlow.uri));
                    this.flowProfileSelected.seen = true;
                  } else {
                    this.flowProfileSelected.seen = false;
                  }
                }
              }),
              lang.hitch(this, function(error) {
                if (this.btFlowProfileWidget && this.btFlowProfileWidget.declaredClass) {                                  
                  Trace.trace(this.btFlowProfileWidget.declaredClass, Trace.levels.DEBUG, "FlowProfile Error: " + error.response.xhr.status + " Response: " + error.response.xhr.response);
                }
                var profileTitle = string.substitute(NLS.btFlowProfileTitleError, [flowName]);
                this._removeFlowProfileContent();
                this.flowTp.set('title', profileTitle);
              })
            );
          }
        }
        // End-if (!isService)
        else {
          this._setFlowProfileContent(NLS.noFlowProfileData+"<br>");
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "createFlowProfile");
      },

      onFlowProfileEventSelectionHandler: function(monitoringEvent) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onFlowProfileEventSelectionHandler");

        // Get the name and event address name as the pair of key identifiers for the table data.
        // For now assume that we are querying the single flow event store, so if we have multiple event store being shown then no callout is made
        if(this.flowProfileSelected.selected) {
          if(!this.evDefSingleGrid.select.row.isSelected(monitoringEvent.uri)) {
            this.evDefSingleGrid.select.row.clear();
            this.evDefSingleGrid.select.row.selectById(monitoringEvent.uri);
          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onFlowProfileEventSelectionHandler");
      },

      onEventTableSelectionHandler : function(index) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onEventTableSelectionHandler");

        // Check that the index is one of the monitoring events
        if(this.flowProfileSelected.selected) {
          // Callout to the event handler for highlighting the event, only if a flow profile is currently being viewed
          if(this.btFlowProfileWidget && this.flowProfileSelected.selected) {
            var element = this.evDefSingleGrid.store.get(index);
            if(element != null) {
              this.btFlowProfileWidget.flowDiagramWidget.flowProfileWidget.flowProfileEventSelectedHandler(element);
            }
          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onEventTableSelectionHandler");
      },

      onAddFlowButtonClickHandler: function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onAddFlowButtonClickHandler");
        event.stopPropagation();
        var addFlowDialog = registry.byId("addFlowDialog");
        if (!addFlowDialog) {
          addFlowDialog = new AddFlowDialog( {
            'id' : 'addFlowDialog',
            'class':'nonModal'
          });
          addFlowDialog.startup();
        }
        // filter out the flows already part of the transaction
        // this will only show new flows.
        var messageFlowsArray = this._allFlowsStore.query({'available':true});
        var val = {
          "btEditor": this.btEditor,
          "flows": messageFlowsArray,
          "apps": this._appStore.data,
          "services" : this._serviceStore.data,
          "restApis" : this._restApiStore.data,
          "initialised" : this._firstTime
        };
        addFlowDialog.setInitialValues(val);
        addFlowDialog.refresh();
        addFlowDialog.show();
        if (this.isLowResolution()) {
       		addFlowDialog._setStyleAttr('position:fixed;');
       		// put the dialog at the top
          addFlowDialog._setStyleAttr('top:0px !important;');
          // and centered in the middle of the screen
          var dialogGeom = domGeom.position(dom.byId("addFlowDialog"));
          var screenWidth = window.screen.width;
          var dialogWidth = dialogGeom.width;
          var left = (screenWidth - dialogWidth)/2;          
          addFlowDialog._setStyleAttr('left:'+left+'px !important;');

        }
            
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onAddFlowButtonClickHandler");
      },
      
      isLowResolution: function () {
      	var result = false;
      	var height = window.screen.height;
      	var width = window.screen.width;
      	if ((height < this.lowScreenHeight) || (width< this.lowScreenWidth)) {
	      	result = true;
      	}
      	return result;
			},
			
      onDeleteFlowButtonClickHandler: function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onDeleteFlowButtonClickHandler");
        event.stopPropagation();
        if (!this.flowProfileSelected.selected) {
           //window.smallMessage.displayMessage("warning", "BusinessTransaction_nothingToDelete", "",
           //       NLS.messages.BusinessTransaction_nothingToDeleteDescription);
          var btFlowRemovalDialog = registry.byId("btFlowRemovalDialog");
          if (!btFlowRemovalDialog) {
            btFlowRemovalDialog = new BTFlowRemovalDialog( {
              id : "btFlowRemovalDialog"
            });
            btFlowRemovalDialog.startup();
          }
          btFlowRemovalDialog.setInitialValues({"btEditor": this.btEditor});
          btFlowRemovalDialog.refresh();
          btFlowRemovalDialog.show();
           return;
        }
        this.btEditor.deleteFlowByUri(this.flowProfileSelected.uri);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onDeleteFlowButtonClickHandler");
      },

      onDetailsButtonClickHandler: function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onDetailsButtonClickHandler");
        event.stopPropagation();
        var btDialog = registry.byId("createBTDDialog");
        if (!btDialog) {
          btDialog = new BTDialog( {
            id : "createBTDDialog"
          });
          btDialog.startup();
        }
        var val ={"btName": this.btEditor.btModel.btName, "btDescription": this.btEditor.btModel.description,
          "btNew": false, "btModel": this.btEditor.btModel, animation: "none"};
        btDialog.setInitialValues(val);
        btDialog.refresh();
        btDialog.show();
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onDetailsButtonClickHandler");
      },
      
      onFlowTitlePaneOpen: function() {
        if(this.flowTp.open && this.flowProfileSelected.selected) {
        	// I haven't seen the diagram yet. Let's draw it!
          if(this.btFlowProfileWidget != null) {
            if(!this.flowProfileSelected.seen) {
              this.btFlowProfileWidget.createFlowDiagram(this.messageFlowProfileId, this.flowProfileSelected.definition, this.flowProfileSelected.uri, this.btEditor.getFlowEventsFromModel(this.flowProfileSelected.uri));
              this.flowProfileSelected.seen = true;
            } else {
              this._resizeFlowDiagram();
            }
          } 
        }
      },

      removeFlowFromList: function(messageFlow){
        var flow = this._allFlowsStore.get(messageFlow.uri);
        if (flow) {
          flow.available = false;
        }
      },

      onAddEventButtonClickHandler: function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onAddEventButtonClickHandler");

        event.stopPropagation();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onAddEventButtonClickHandler");
      },

      onEditEventButtonClickHandler: function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onEditEventButtonClickHandler");

        event.stopPropagation();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onEditEventButtonClickHandler");
      },

      onDeleteEventButtonClickHandler: function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onDeleteEventButtonClickHandler");

        event.stopPropagation();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onDeleteEventButtonClickHandler");
      },

      populateSingleFlowEventTable: function(messageFlowUri) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "populateSingleFlowEventTable");

        // First check that there are already flows in the event table that can be queried.
        if(this.eventTableFlowCount > 0) {
          // Get the message flow details for the flow in question
          var singleMessageFlow = this.evDefStore.get(messageFlowUri);

          // If message flow retrieved from the multi-flow store
          if((typeof singleMessageFlow !== "undefined") && (singleMessageFlow.children)) {
            this.flowEventTableEventCount = 0;
            var eventSingleData = [];

            // Iterate around each node, those that have predicates defined
            array.forEach( singleMessageFlow.children, lang.hitch( this, function(monitorEvent) {

              var nextMonitorEvent =
                {
                  role: monitorEvent.role,
                  id: monitorEvent.id,
                  enabled: monitorEvent.enabled,
                  eventSourceAddress: monitorEvent.eventSourceAddress,
                  eventFilter: monitorEvent.eventFilter,
                  nodeId: monitorEvent.nodeId,
                  flowUri: monitorEvent.flowUri,
                  eventUnitOfWork: monitorEvent.eventUnitOfWork,
                  payload: monitorEvent.payload,
                  isBitstreamDataIncluded: monitorEvent.isBitstreamDataIncluded,
                  transactionCorrelation: monitorEvent.transactionCorrelation,
                  uri: monitorEvent.uri,
                  eventName: monitorEvent.eventName,
                  name: monitorEvent.name,
                  eventSource: monitorEvent.eventSource,
                  isTransactionEvent: monitorEvent.isTransactionEvent
                };
              eventSingleData.push(nextMonitorEvent);
              this.flowEventTableEventCount++;
            }));

            this.showHideEventsSections(this.evGridSingleContainer, this.evGridContainer);

            this.evDefSingleGrid.model.clearCache();
            this.evDefSingleGrid.model.store.setData(eventSingleData);
            this.evDefSingleGrid.body.refresh();

            this.flowProfileSelected.selected = true;
            this.flowProfileSelected.uri = messageFlowUri;
          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "populateSingleFlowEventTable");
      },

      onDropPopulateFlowEventTables: function(messageFlow, selected, callingHash) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onDropPopulateFlowEventTables");
        var messageFlowUri = messageFlow.uri;
        var flowPublisherUri = messageFlow.uri;
        var messageFlowName = messageFlow.name;

        // If this is the first message flow being added then open the event table title pane
        if(this.eventTableFlowCount == 0) {
            this.tableTp.set('open', true);
            this.resize();
        }
        
        // Request message flow monitoring information - depth 2 which gets all monitoring events and their details
        this._flowEventPropertiesCallbacks.push(
          xhr(
            Resources.REST.monitoringEventsURI + Resources.REST.allEventDetails + "&" + Resources.REST.monitoringEventsFlow + flowPublisherUri,
            {
              handleAs : "json",
              headers : {
                "Accept" : "application/json"
              }
            }
          ).then(
            lang.hitch(this, function(response) {
              // Check still at calling object hash (irrelevant of tab number)
              if(UIUtils.isSameObjectHash(callingHash, 0, 3)) {
                // Empty json store for the message flow event data - one per message flow
                // At moment name is the id field. Might need to move this to URI or some sort of combination
                var monitorEventData =
                  {
                    name: messageFlowName,
                    id: messageFlowUri,
                    uri: messageFlowUri,
                    children: [],
                    isMessageFlow: true
                  };
  
                var childMonitoringEvents = [];
  
                if(typeof response.event !== "undefined") {
  
                  var monitoringEvents = [];
  
                  // Take event data and order into policy based structure, on a per node basis
                  // This assists for when rendering on diagram, or when redrawing diagram, data already in required structure
                  /*
                   * Structure
                   * monitoringEvents : [ nodeName: "myEvent",
                   *                      nodeMonitoringEvents: [ monitorEvent1, monitorEvent2, ... ]
                   *                    ]
                   */
  
                  response.event.forEach( lang.hitch(this, function(nextEvent) {
                      var found = false;
                      var nodeName = this.getNodeNameFromEventAddress(nextEvent.eventSourceAddress);
                      // Either create a new node policy entry in the array, or add to an existing one
                      for(var j=0; j < monitoringEvents.length; j++) {
                        if(nodeName === monitoringEvents[j].nodeName) {
                          monitoringEvents[j].nodeMonitoringEvents.push(nextEvent);
                          found = true;
                          break;
                        }
                      }
  
                      // If no existing node entry was found then add this event as new item in the array
                      if(!found) {
                        monitoringEvents.push({ nodeName: nodeName, nodeMonitoringEvents: [nextEvent] });
                      }
                    }
                  ));
  
                  // Add event data to the flow diagram and BTModel
                  this.btEditor.addFlowEventsToModel(messageFlowUri, monitoringEvents);
  
                  // Iterate around each monitoring event (if any) for the flow and find if any has been promoted.
                  // If yes, add them to the event store with that specific role.
                  // This is used when a BTD has been loaded (the business events already set),
                  // and we now have the monitor events, that we would need to set to a business type where appropriate.
                  array.forEach( response.event, lang.hitch( this, function(event) {
                    var role = Resources.businessTransaction.btEventDoNotFlag;
  
                    var i;
                    if (messageFlow && messageFlow.businessEvents) {
                      for (i = 0; i<messageFlow.businessEvents.length;i++) {
                        if (messageFlow.businessEvents[i].eventSourceAddress === event.eventSourceAddress) {
                          role = messageFlow.businessEvents[i].role;
                          break;
                        }
                      }
                    }
  
                    var payload = {};
                    payload.bitstreamContentEncoding = event.payload.bitstreamContentEncoding;
                    payload.bitstreamContentType = event.payload.bitstreamContentType;
                    payload.dataLocations= [];
                    for (i =0; i<event.payload.dataLocations.length;i++) {
                      payload.dataLocations.push(event.payload.dataLocations[i]);
                    }
  
                   var transactionCorrelation = {};
                   transactionCorrelation.local = event.transactionCorrelation.local;
                   transactionCorrelation.global = event.transactionCorrelation.global;
                   transactionCorrelation.parent = event.transactionCorrelation.parent;
  
                   var nextMonitorEvent =
                      {
                        role: role,
                        id: event.uri,
                        enabled: (event.isEnabled === "true") ? true : false,
                        eventSourceAddress: event.eventSourceAddress,
                        eventFilter: event.eventFilter,
                        nodeId: this.getNodeNameFromEventAddress(event.eventSourceAddress),
                        flowUri: messageFlowUri,
                        eventUnitOfWork: event.eventUnitOfWork,
                        payload: payload,
                        isBitstreamDataIncluded: event.payload.isBitstreamDataIncluded,
                        transactionCorrelation: transactionCorrelation,
                        uri: event.uri,
                        eventName: event.eventName,
                        name: event.name,
                        eventSource: event.eventSource,
                        isTransactionEvent: event.isTransactionEvent,
                        isMessageFlow: false
                      };
                   childMonitoringEvents.push(nextMonitorEvent);
                  }));
                }
  
                // Set children for the parent flow item
                monitorEventData.children = childMonitoringEvents;
                
                // Further validation that we are still operating within the calling object hash (irrelevant of tab number), and only add data if entry doesn't already exist in the store
                if(UIUtils.isSameObjectHash(callingHash, 0, 3) && (this.evDefStore.query({"uri": monitorEventData.uri}).length == 0)) {
                  this.evDefStore.add(monitorEventData);
  
                  this.eventTableFlowCount++;
  
                  if (selected) {
                    this.evDefGrid.body.refresh();
                    // Now that the store for all monitoring events has been saved, select the newly added flow to be viewed
                    this.onFlowSelectedHandler(messageFlow);
                  }
                  else { // loading multiple events
                    Topic.publish(Resources.pubSubTopic.businessTransaction, {
                      "gotEvents": {"success": true}, "messageFlow": messageFlowUri, "selected":selected, "monitorEvents": childMonitoringEvents, "callingHash": hash()});
                  }
                }
              } else {
                // No longer in scope of calling object, clear up any other callbacks that we are waiting upon.              
                this._removeRedundantEventsCallbacks();
              }
            }),
            lang.hitch(this, function(error) {
              if (error.dojoType === "cancel") { return; }
              if (this.btFlowProfileWidget) {
                Trace.trace(this.btFlowProfileWidget.declaredClass, Trace.levels.DEBUG, "FlowProfile Error: " + error.response.xhr.status + " Response: " + error.response.xhr.response);
              }
              // Check still at correct calling object hash (irrelevant of tab number)
              if(UIUtils.isSameObjectHash(callingHash, 0, 3)) {
                Topic.publish(Resources.pubSubTopic.businessTransaction, {"gotEvents": {"success": false}, "messageFlow": messageFlowUri, "callingHash": hash()});
              }
            })
          )
        );

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onDropPopulateFlowEventTables");
      },

      // Get the properties for a flow that has been added to the business transaction
      onDropGetFlowProperties: function(messageFlow, callingHash) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onDropGetFlowProperties");

        if(typeof messageFlow.uri !== undefined) {
          // Request message flow information
          this._flowPropertiesCallbacks.push(
            xhr(messageFlow.uri + "/" + Resources.REST.messageFlowProperties,
              {
                handleAs : "json",
                headers : {
                  "Accept" : "application/json"
                }
              }
            ).then(
              lang.hitch(this, function(response) {
                // Check still at correct calling object hash (irrelevant of tab number)
                if(UIUtils.isSameObjectHash(callingHash, 0, 3)) {
                  // add it to the list of flow properties that has been received
                  // if all has been received, will check if all flows still exist
                  this.onFlowPropertiesReceived(messageFlow.uri);
                  messageFlow.description = "";
                  // For now just add the flow description (save us parsing it out everytime we want it), but opportunity to add more properties if/when needed
                  if((typeof response.basicProperties != "undefined") && (response.basicProperties.length > 0)) {
                    for(var i=0; i < response.basicProperties.length; i++) {
                      if(response.basicProperties[i].name === Resources.REST.messageFlowLongDesc) {
                        messageFlow.description = response.basicProperties[i].value;
                        this.btEditor.updateFlowTooltipInformation(messageFlow);
                        break;
                      }
                    }
                  }
                } else{
                  // No longer in scope of calling object, clear up any other callbacks that we are waiting upon.
                  this._removeRedundantFlowCallbacks();
                }
              }),
              lang.hitch(this, function(error) {
                if (error.dojoType === "cancel") { return; }
                // Check still at correct calling object hash (irrelevant of tab number)
                if(UIUtils.isSameObjectHash(callingHash, 0, 3)) {
                  // get properties failed, the main reason is the flow has been deleted  
                  this.btEditor.btModel.addFlowNotFound(messageFlow.uri);
                  this.onFlowPropertiesReceived(messageFlow.uri);
                  if (this.btFlowProfileWidget) {
                    Trace.trace(this.btFlowProfileWidget.declaredClass, Trace.levels.DEBUG, "FlowGet Error: " + error.response.xhr.status + " Response: " + error.response.xhr.response);
                  } 
                }
              }
            )
          ));
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onDropGetFlowProperties");
      },

     /*
     * checks whether the flow properties have been received for all flows in BTD
     * if yes and some flows cannot be found, shows the option to delete
     */
      onFlowPropertiesReceived : function (messageFlowUri) {
        var index = this._flowsProperties.indexOf(messageFlowUri);
        // adds the flow to the list of those that have been received
        if (index<0) {
          this._flowsProperties.push(messageFlowUri);
        }
        if (this._flowsProperties.length===this.btEditor.btModel.getElementsArray().length ) {
          // when I got all of them, check if there is any flows to clean up
          this.cleanFlows();
        }
      },

      
      // Switch which event table container is shown
      showHideEventsSections: function(showTarget, hideTarget) {
        domClass.add(hideTarget.domNode,"bt_EventsSectionTableHidden");
        domClass.remove(showTarget.domNode,"bt_EventsSectionTableHidden");
        // Called to ensure we re-render the current showing grid in the container
        this.resize();
      },

      // Helper method for extracting node name from monitor event address (which identifies the node it applies to)
      getNodeNameFromEventAddress: function(eventAddress) {
        var nodeAddress = eventAddress.substr(0, eventAddress.lastIndexOf("."));
        return nodeAddress.substr(0, nodeAddress.lastIndexOf("."));
      },

      deleteFlowProfile: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "deleteFlowProfile");

        if(this.btFlowProfileWidget != null){
          try{
            this.btFlowProfileWidget.destroy();
          }
          catch(e) {}
          this.btFlowProfileWidget = null;
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "deleteFlowProfile");
      },
      
      deriveLabelValue: function(item) {
        // Return just the label
        return UIUtils.deriveLabelValue(item.uri)[0];
      },

      resize: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");

        this._businessTransactionOverview_borderContainer.resize();
        this._resizeFlowDiagram();

        // Resize the editor to be consistent on the visible windows
        if(this.btEditor != null) {
          this.btEditor.resizeCanvas();
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
      },
      
      _resizeFlowDiagram: function() {
			  // Only call resize on diagram is we definitely have one to resize
        if(this.flowTp.open && (this.btFlowProfileWidget != null) && (this.btFlowProfileWidget.flowDiagramWidget != null)) {
          this.btFlowProfileWidget.resize();
        }
      },

      markFlowsAsNotIncluded: function() {
        // mark the flows as not included
        for (var i=0; i<this._allFlowsStore.data.length;i++){
          this._allFlowsStore.data[i].available = true;
        }
      },
      
      _removeRedundantFlowCallbacks: function() {
        if(this._flowPropertiesCallbacks) {
          array.forEach(this._flowPropertiesCallbacks, lang.hitch(this, function(nextFlowCallback) {
            if(nextFlowCallback && !nextFlowCallback.isResolved()) {
              nextFlowCallback.cancel("Cancelling event properties callback - no longer in BTD Object scope.");
            }
          }));
          this._flowPropertiesCallbacks = [];
        }
      },
      
      _removeRedundantEventsCallbacks: function() {
        if(this._flowEventPropertiesCallbacks) {
          array.forEach(this._flowEventPropertiesCallbacks, lang.hitch(this, function(nextFlowEventCallback) {
            if(nextFlowEventCallback && !nextFlowEventCallback.isResolved()) {
              nextFlowEventCallback.cancel("Cancelling flow properties callback - no longer in BTD Object scope.");
            }
          }));
          this._flowEventPropertiesCallbacks = [];
        }
      },

      // This function is called manually when we need to remove this tab.
      tabRemove: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");

        // Set the BTName to null - used as main identifier
        this.btName = null;
        this._clickedCancel = false;
        this.markFlowsAsNotIncluded();
        
        // Ensure we fully empty the store, so just set an empty one
        this.evDefSingleStore = new Store({
          idProperty: "id",
          data: []
        });
        
        if(this.evDefSingleGrid) {
          this.evDefSingleGrid.model.clearCache();
          this.evDefSingleGrid.model.setStore(this.evDefSingleStore);
          this.evDefSingleGrid.body.refresh();
        }

        // Check first that if flow profile being shown, i.e. single flow event table being shown, then clean it up
        if(this.flowProfileSelected.selected) {
          // Show the multiple flow events table so that this can be cleaned up
          this.showHideEventsSections(this.evGridContainer, this.evGridSingleContainer);
          this.flowEventTableEventCount=0;
        }
        
        this.flowProfileSelected = {selected: false, uri: "", definition: {}, seen: false};

        // Remove all the topic handlers
        for (var i=0; i < this.eventTopicHandlers.length; i++) {
          var handle = this.eventTopicHandlers[i];
          handle.remove();
        }

        // Reset the eventTopicHandles array
        this.eventTopicHandlers = [];

        // Clean up the last selected/created entities for the business transaction
        if(this.btEditor != null) {
          try {
            this.btEditor.destroy();
          } catch(e) {}
          this.btEditor = null;
        }

        this.deleteFlowProfile();

        // Ensure we fully empty the store, so just set an empty one
        this.evDefStore = new Store({
          data: [],
          idProperty: "id"
        });

        // Set up children calls for tree data
        this.evDefStore.hasChildren = function(id, item){ // jshint ignore:line
          // Return true if the given row has children, false otherwise.
          var hasChildren = (typeof item !== "undefined") && (typeof item.children !== "undefined") && (item.children.length > 0);
          return hasChildren;
        };

        this.evDefStore.getChildren = function(item){
          // Returns an array of the child items of the given row item.
          var toReturn = null;
          if((typeof item !== "undefined") && (typeof item.children !== "undefined")) {
            toReturn = item.children;
          }

          return toReturn;
        };
        
        if(this.evDefGrid) {
          // Ensure all expandos on tree are shut
          this.evDefStore.data.forEach(lang.hitch(this, function(dataItem) {
            var isExpanded = this.evDefGrid.tree.isExpanded(dataItem.id);
            if(isExpanded) {
              // If currently then collapse before being shown, and don't refrsh automatically
              this.evDefGrid.tree.collapseRecursive(dataItem.id, true);
            }
          }));
          
          this.evDefGrid.model.clearCache();
          this.evDefGrid.model.setStore(this.evDefStore);
          this.evDefGrid.body.refresh();
        }

        this.eventTableFlowCount=0;

        this.flowTp.set('title', NLS.btNoFlowSelected);
        this._removeFlowProfileContent();
        this.tableTp.set('title', NLS.btTxnEventTitle);
        this.flowTp.set('open', false);
        this.tableTp.set('open', false);
        // Next time on tabFocus, reinitialise the content of the BTD
        this.initialised = false;

        // explicitly remove the results tab
        if (this.resultsWidget){
          //registry.byId('_infoPaneTabContainer_ID').removeChild(this.resultsWidget);
        }
        
        // So handlers are only active during BTD object interaction
        this._removeBTMHandlers();
        
        if(this._addFlowDialog != null) {
          this._addFlowDialog.destroy();
          this._addFlowDialog = null;
        }

        this._removeRedundantFlowCallbacks();
        this._removeRedundantEventsCallbacks();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
      },

      tabFocus: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");
    	
      	window.smallMessage.hideMessage();//to get rid of warnings or errors launched from "View" tab

        this.newlyCreated = false;
        this._flowsProperties =[];
        
        if (!this.initialised){
          var populate = this._attributesStore.populateAttributesStore();

          populate.then(lang.hitch(this, function() {
            // Set BTD name
            if((this.btName === null) || (this.btName === "")) {
              this.btName = this._attributesStore.getAttribute("name");
              if(typeof this.btName === "undefined") {
                this.btName = NLS.businessTransactionNewName;
                this._attributesStore.updateAttributeValue("name", this.btName);
              }
              createBTX = true;
              attr.set("_infoPaneTitleID", "innerHTML", this.btName + " - " + NLS.businessTransactionTitle);
            }
            
            // Only proceed if the hash has not changed - View Tab
            if(hash() === Resources.REST.businessTransactionDefinition + this._attributesStore.getAttribute("name")) {
              // First load, so not changes to be saved
              this.toolbar.getButton("save").set("disabled", true);
              this.toolbar.getButton("cancel").set("disabled", true);
              
              // TODO Establish whether creating new business transaction, or working with existing (loaded) - based on hash?
              var createBTX = false;

              if (!this.btEditor) {
                this.btEditor = new BTEditor({
                  name: this.btName,
                  containerId: "btCanvas",
                  attributesStore: this._attributesStore
                });
              }

              // If no topicHandlers have been set yet
              if(this.eventTopicHandlers.length < 1) {
                // Called when a new Business Transaction is created - update the name
                 this.eventTopicHandlers.push(Topic.subscribe(Resources.pubSubTopic.businessTransactionNew, lang.hitch(this, function(event) {
                   if (event.newBTD){
                     this.btName = event.newBTD;
                     this.btEditor.btModel.updateDetails(event.newBTD, event.description);
                     this.onDefinitionUnsavedChanges();
                   }
                 })));
                // Called when a click event occurs on a message flow event tooltip
                this.eventTopicHandlers.push(Topic.subscribe(Resources.pubSubTopic.businessTransaction, lang.hitch(this, function(event) {
                  if(UIUtils.isSameObjectHash(event.callingHash, 0, 3)) {
                    this.btEventHandler(event);
                  }
                })));

                // Called when a a click event occurs on flow profile in the BTEditor
                this.eventTopicHandlers.push(Topic.subscribe(Resources.pubSubTopic.businessTransactionEvent, lang.hitch(this, function(monitoringEvent, msgFlowURI) {
                  this.onFlowProfileEventSelectionHandler(monitoringEvent, msgFlowURI);
                })));
              }
              if (!createBTX) {
                // If a loading div hasn't already been attached (prevent multiple loading divs)
                if(( this.evDefGrid != null) && (this.evDefGrid.domNode.getElementsByClassName("loadingOverlay pageOverlay").size == 0)) {
                  // when loading an existing BTX show loading div while getting the events
                  var loadingText = NLS.dataLoading;
                  this.loadingDiv = construct.create("div",{
                    "class": "loadingOverlay pageOverlay",
                    innerHTML: '<div class="loadingMessage">'+loadingText+'</div>'
                  });
                  this.evDefGrid.domNode.appendChild(this.loadingDiv);
                }
                this.tableTp.set('open', true);
                this.showLoading();
              }

              // if the set of all flows deployed on the broker is still being computed, set up a subscription to handle add flow content later.
              if (this._computingFlowsForBroker) {
                this.eventTopicHandlers.push(Topic.subscribe(Resources.pubSubTopic.businessTransactionFilters.flows, lang.hitch(this, function() {
                  this.onFlowsComputedHandler();
                  // decide if to show the add/remove flow buttons - only when we have flow information processed.
                  this._updateReadWriteView();
                })));
              }
              else {
                // the list of all flows has been computed, only compute the available flows for this BTD
                this.onFlowsComputedHandler();
                // Subscribe to any further calls during this object visit
                this.eventTopicHandlers.push(Topic.subscribe(Resources.pubSubTopic.businessTransactionFilters.flows, lang.hitch(this, function() {
                  this.onFlowsComputedHandler();
                })));
              }

              this.btEditor.showBTD();
              
              // Instantly show the buttons (if applicable)
              if(this.btEditor.btModel.getElementsArray().length === 0) {
                this._checkAddFlowClass();
                if(!this._computingFlowsForBroker) {
                  // decide if to show the add/remove flow buttons 
                  this._updateReadWriteView();
                }
              }  
            } else {
              // Complete initialisition did not occur, re-perform upon next tab focus
              this.initialised = false;
            }
          }));

          // now the BTD has been initialised
          this.initialised = true;
        }
        
        // For AdminNotification updates
        this._setupBTMHandlers();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
      },
      
      _setupBTMHandlers : function() {
        if(this._adminTopicHandlers.length == 0) {
          UIUtils.setupAdminHandlers(this._adminTopicHandlers, lang.hitch(this, this.processAdminNotification));
        }
        
        if(this.btmOpsHandlers.length == 0) {
          // Add handler button
          this.btmOpsHandlers.push(
              on(this.addFlowButton, "click", lang.hitch(this, this.onAddFlowButtonClickHandler))
          );
          this.btmOpsHandlers.push(
              on(this.deleteFlowButton, "click", lang.hitch(this, this.onDeleteFlowButtonClickHandler))
          );
          this.btmOpsHandlers.push(
              on(this.detailsButton, "click", lang.hitch(this, this.onDetailsButtonClickHandler))
          );
        }
      },
      
      _removeBTMHandlers : function() {
        UIUtils.removeAdminHandlers(this._adminTopicHandlers);
        
        this.btmOpsHandlers.forEach(function(nextOpsHandler) {
          if(nextOpsHandler) {
            nextOpsHandler.remove();
          }
        });        
        this.btmOpsHandlers = [];
      },
      
      processAdminNotification : function (message) {

        // ignore all admin notifications other then those at the EG level
        if (this.isEGChangeDeployNotification(message)) {
          // reset the stores
          this._appStore =  new Store({
            data: [],
            idProperty: "uri"
          });
          this._serviceStore =  new Store({
            data: [],
            idProperty: "uri"
          });
          this._restApiStore =  new Store({
            data: [],
            idProperty: "uri"
          });
          this._allFlowsStore =  new Store({
            data: [],
            idProperty: "uri"
          });
          this.computeAllFlowsForBroker(); 
        }        
      },
      
      /*
       * Returns true iff the admin notification  has a destinationName of the form
       *  IBM/IntegrationBus/<BrokerName>/AdminNotifications/Broker/<BrokerName>/ExecutionGroup/<egName>"  
       */
      isEGChangeDeployNotification: function(message) {
        if (!message) {
          return false;
        }        
        var destinationName = message.destinationName;
        if (!destinationName) {
          return false;
        }

        // On the Broker in question
        if(destinationName === new WebUiHash(Resources.REST.nodeHome).getNotificationTopic(false)) {
          return true;
        }
        
        var components = destinationName.split("/").map(decodeURIComponent);
        // e.g. ["IBM", "IntegrationBus", "MyBroker", "executiongroups", "default"]
        var index = components.indexOf("ExecutionGroup");
        if (index<0) {
          return false;
        }
        // after ExecutionGroup there should be only name
        if (components.length == index+2) { // 0 based index, plus the name of the EG
          return true;
        }
        // ignore the notifications for resources on EG
        return false;
      }, 

      onFlowsComputedHandler: function() {
        // when allFlows have been computed set the available flag to false for those that
        // are already in the BTD. These will not be shown in the dialog
        var flowsInBTD = this.btEditor.btModel.getElementsArray();
        for (var i=0; i<flowsInBTD.length; i++) {
          var flow = this._allFlowsStore.get(flowsInBTD[i].uri);
          if (flow) {
            flow.available = false;
          }
        }
        
        // If the addFlowArray is currently showing, try to update it
        var addFlowDialog = registry.byId("addFlowDialog");
        if (addFlowDialog && addFlowDialog._isShown()) {
          var messageFlowsArray = this._allFlowsStore.query({'available':true});
          // Only need the flow and object info for active update.
          var val = {
            "flows": messageFlowsArray,
            "apps": this._appStore.data,
            "services" : this._serviceStore.data,
            "restApis" : this._restApiStore.data
          };
          addFlowDialog.refreshWhilstShowing(val);
        }
      },

      btEventHandler:function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "btEventHandler");
        // If selection of a flow - emit update flow visualisations and selection on canvas
        if(event.flow) {
          this.onFlowSelectedHandler(event.flow);
        } else {
          if(event.none) {
            this.onDeselectFlowHandler(event.overwrite);
          } else {
            if(event.deleted) {
              this.onDeleteFlowHandler(event.flowUri);
            } else {
              // Adding of flow to canvas
              if(event.flowAdded) {
                this.onDropPopulateFlowEventTables(event.messageFlow, event.selected, event.callingHash);
                this.onDropGetFlowProperties(event.messageFlow, event.callingHash);
                this.removeFlowFromList(event.messageFlow);
              } else {
                if(event.update) {
                  if((event.name != this.btEditor.btModel.btName) || (event.description != this.btEditor.btModel.btDescription)) {
                    this.btEditor.btModel.updateDetails(event.name, event.description);
                    this.btName = event.name;
                  }
                  if (BTPermissionsModel.writeModeForBTD()) {
                    // Call to change the * value on the title
                    this.onDefinitionUnsavedChanges();                    
                  }
                }
                else {
                  if (event.gotAllEvents) {
                    this.hideLoading();
                    // Handle edge case of when addFlows dialog has been requested before all events and flows ahve been retrieved.
                    // Needed to keep consistency of UI on addflowdialog due to xhr precedence.
                    // Only applied once per session.
                    this._checkAddFlowClass();
                    
                    // show the monitoring event table
                    this.evDefGrid.body.refresh();
                    // now we can validate
                    this.validate();
                    
                    // gives the user the option of cleaning the business events that can no longer be found, if any.
                    this.cleanBusinessEvents();
                    
                    // decide if to show the add/remove flow buttons 
                    this._updateReadWriteView();
                  }
                }
              }
            }
          }
        }
        if(event.dirty) {
          this.onDefinitionUnsavedChanges();
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "btEventHandler");
      },
      
      /*
       * If any flows could no longer be found, give the user the choice to clean them up
       */
       cleanFlows: function() {
         // If the hash has changed, then don't call dialog as no longer applicable
         if(hash() === Resources.REST.businessTransactionDefinition + this._attributesStore.getAttribute("name")) {

           var flowsUris = this.btEditor.btModel.flowsNotFound;
           if (flowsUris && flowsUris.length >0) {
             var result = this.btEditor.btModel.getMissingFlowsFormattedList(); 

             // make a copy of the flows to avoid concurrency issues
             var missingFlowsUris = flowsUris.slice(0);
             
             var deleteText = string.substitute(NLS.messages.BusinessTransaction_flowsNotFound, [result])+
               "<br><br>"+ 
               NLS.messages.BusinessTransaction_deleteFlowsNotFound;
             var confirmCallback = lang.hitch(this, function() {
               array.forEach( missingFlowsUris, lang.hitch(this, function(flowUri) {
                 this.btEditor.removeFlowFromBTD(flowUri);
                 this.onDeleteFlowHandler(flowUri);
             }));
             });
             window.wmbConsole.showConfirmationDialog("btConfirmDelete", "information", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, deleteText, confirmCallback, null);
           }
         }
       },
      
      cleanBusinessEvents: function () {        
        
        var confirmCallback = lang.hitch(this, function() {
          this.btEditor.btModel.removeBusinessEvents(staleEventsArray);
          this.btEditor.validateBT();
          
          // need to update the roles in the store for stale events, if still found, either by sourceAddress or URI, 
          // to have them as "Do not flag"          
          for (var i=0; i<staleEventsArray.length; i++) {
            var flowURI = staleEventsArray[i].parentFlow;
            // get the monitoring events for the flow from thegrid store
            var flow = this.evDefStore.query({"uri":flowURI});
            if (flow.length>0) {
              flow = flow[0];
              // children are the monitoring events for the parent flow, with the latest definition 
              var children= flow.children;              
              var mEvent = staleEventsArray[i].monitorEvent;
              
              var result = array.filter(children,function(item){
                return ((item.eventSourceAddress=== mEvent.eventSourceAddress)|| (item.uri=== mEvent.uri));
              });
              if (result.length>0) {
                // if any monitoring events found that still have the source or URI as before
                result[0].role = Resources.businessTransaction.btEventDoNotFlag;
              }
            }            
          }            
          this.evDefGrid.body.refresh();
        });
        
        var staleEventsArray = this.btEditor.btModel.getOutOfDateBusinessEvents();
        
        var staleReferences = this.btEditor.btModel.getListofOutOfDateBusinessEvents(staleEventsArray);
        if (staleReferences !=="") {        
          // Cancel should do nothing, user resumes their activities
          var deleteText = string.substitute(NLS.messages.BusinessTransaction_btEventsNotFound, [staleReferences])+
            "<br>"+
            NLS.messages.BusinessTransaction_btEventsNotFoundDelete;
          window.wmbConsole.showConfirmationDialog("btConfirmDelete", "information", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, deleteText, confirmCallback, null);
        }
        
      },
      
      onNewDefinition: function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onNewDefinition");
        this.newlyCreated = true;
        this.toolbar.getButton("cancel").set("disabled", false);
        this.markFlowsAsNotIncluded();
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onNewDefinition");
      },

      onNewDefinitionSaved: function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onNewDefinitionSaved");

        this.toolbar.getButton("cancel").set("disabled", true);

        this.newlyCreated = false;


        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onNewDefinitionSaved");
      },
      
      _updateReadWriteView: function() {
        if(BTPermissionsModel.readOnlyModeForBTD()) {
          this.showReadOnlyView();
        }
        else {
          this.restoreWriteView();
        }
      },
      
      _checkAddFlowClass: function() {
        if(!this._firstTime) {
          this._firstTime = true;
          var addFlowDialog = registry.byId("addFlowDialog");
          if (addFlowDialog) {
            addFlowDialog.updateRadioButtonClass(true);
          }
        }
      },

      onCancelClick: function() {
    	  
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onCancelClick");

          this._clickedCancel = true;
          
          if (this.newlyCreated){
        	  
        	  //user clicked Cancel on a newly-created (but unsaved) BTD
        	  hash(Resources.REST.nodeHome);
        	  
          }//if
          else {
        	  //user clicked Cancel after making changes to an existing BTD
        	  this.onRefreshClick();
          }//endif
          
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "onCancelClick");
      },

      onSaveClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onSaveClick");

        // Generate the json data based upon the current structure of the BTX and its underlying BTModel
        var bTXModel = this.btEditor.generateModel();

        var valid = this.validate();       
        // Do some basic validation on the current BTM Model
          

        // Output just to show what the json will look like
        var btmData = JSON.stringify(bTXModel);
           
        // If valid then save        
          var bTXUri = encodeURI(Resources.REST.businessTransactions + bTXModel.name);
          xhr.put(
            bTXUri,
            {
              handleAs : "json",
              data : btmData,
              headers : {
                "Accept" : "application/json",
                "Content-type" : "application/json"
              }
            }
          ).then(
            lang.hitch(this, function() {
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Business transaction save success");

              attr.set("_infoPaneTitleID", "innerHTML", bTXModel.name + " - " + NLS.businessTransactionTitle);
              this.toolbar.getButton("save").set("disabled", true);
              this.toolbar.getButton("cancel").set("disabled", true);
              
              if(valid) {                
                // Inform user that the save was successful
                window.smallMessage.displayMessage("success", "BusinessTransaction_saveSuccess", "",
                  string.substitute(NLS.messages.BusinessTransaction_saveSuccessDescription, [bTXModel.name]));
              }
              // otherwise keep the warning
              
              // Set the model to be up to date and remove the * unsaved notification
              this.btEditor.btModel.updateState(true);

              // TB Implemented, renaming story - would need redirect if we allow rename within BTX overview
              // For now, just assume this is first time creation.
              // If the current hash is not equal to the new BTXUri, then update the hash to point (but don't reload page) (denoted in updateHash argument)
              var refreshHashCallback;
              if(!this.isHashCurrentBusinessTransactionObject(bTXUri)) {
                refreshHashCallback = lang.hitch(this, function(newUri) {
                  // newHash is the Rest URI
                  var newHash = WebUiHash.fromRestUri(newUri).toString();

                  window.wmbConsole.expandTreeAndRefreshHash(newHash, true);
                });
              }

              // Publish to notify the tree that content under the business transactions has changed
              Topic.publish(Resources.pubSubTopic.businessTransactionsUpdated, {bTXUri: bTXUri, save: true, updateHashCallback: refreshHashCallback});
              if (this.newlyCreated === true) {
                this.onNewDefinitionSaved();
              }
            }),
            lang.hitch(this, function(error) {
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Response: " + error.response.response);

              window.smallMessage.displayMessage("error", "BusinessTransaction_saveFailure", "", error.response.status + ": " + error.response.text);
            })
          );
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onSaveClick");
      },
      
     /*
      * Asks the model and then shows the corresponding error message
      */
      validate: function() {
        
        var validationModel = this.btEditor.btModel.validateModel();

        // only the first problem that is true is shown
        // so the order here is significant
        
        // first check if there are any monitoring events
        if (!this.btEditor.btModel.hasAnyMonitoringEvents()) {
          window.smallMessage.displayMessage("error", "BusinessTransaction_noMonitoringEvents", "",
              string.substitute(NLS.messages.BusinessTransaction_noMonitoringEventsDescription, [this.btName]));
            return false;
        }
        
        // does it have start and end events
        if (this.btEditor.btModel.hasNeitherStartNorEndEvents(validationModel)) {
          window.smallMessage.displayMessage("error", "BusinessTransaction_neitherStartNotEndEvent", "",
              string.substitute(NLS.messages.BusinessTransaction_IncompleteDescription, [this.btName]));
            return false;
        }
        
        // does it have at least a start
        if (this.btEditor.btModel.hasNoStartEvents(validationModel)) {
          window.smallMessage.displayMessage("error", "BusinessTransaction_noStartEvent", "",
              string.substitute(NLS.messages.BusinessTransaction_IncompleteDescription, [this.btName]));
            return false;
        }
        
        // does it have at least an end
        if (this.btEditor.btModel.hasNoEndEvents(validationModel)) {
          window.smallMessage.displayMessage("error", "BusinessTransaction_noEndEvent", "",
              string.substitute(NLS.messages.BusinessTransaction_IncompleteDescription, [this.btName]));
            return false;
        }

        // no global ID
        if (this.btEditor.btModel.hasNoCorrelationInfo(validationModel)) {
          window.smallMessage.displayMessage("error", "BusinessTransaction_noCorrelation", "",
            string.substitute(NLS.messages.BusinessTransaction_noCorrelationDescription, [this.btName]));
          return false;
        }
        
        // Business events that are currently disabled (not active)
        var events = this.btEditor.btModel.getDisabledBusinessEventsList(validationModel);
        if (events !=="") {
          window.smallMessage.displayMessage("warning", "BusinessTransaction_DisabledEvents", "",
            string.substitute(NLS.messages.BusinessTransaction_DisabledEventsDescription, [this.btName, events]));
          return false;
        }

        // global ID missing from flagged events
        events = this.btEditor.btModel.getMissingCorrelationEventsList(validationModel);
        if (events !=="") {
          window.smallMessage.displayMessage("warning", "BusinessTransaction_MissingCorrelation", "",
            string.substitute(NLS.messages.BusinessTransaction_MissingCorrelationDescription, [this.btName, events]));
          return false;
        }

        // missing flows
        var flowsUris = this.btEditor.btModel.flowsNotFound;
        if (flowsUris && flowsUris.length >0) {
          var result ="";
          var l = flowsUris.length;
          for (var i=0; i< l-1; i++) {
            result += (new RestUri(flowsUris[i])).getMessageFlowName()+", ";
          }
          result += (new RestUri(flowsUris[l-1])).getMessageFlowName(); 
          if (result!="") {
            window.smallMessage.displayMessage("warning", "BusinessTransaction_flowsNotFoundValidation", "",
                string.substitute(NLS.messages.BusinessTransaction_flowsNotFoundValidationDescription, [this.btName,result]));
            return false;
          }
        }
        
        // flows without any flagged events
        var flows = this.btEditor.btModel.getFlowsWithoutBusinessEvents();
        if (flows!=="") {
          window.smallMessage.displayMessage("warning", "BusinessTransaction_flowNoBusinessEvents", "",
              string.substitute(NLS.messages.BusinessTransaction_flowNoBusinessEventsDescription, [this.btName,flows]));
            return false;
        }
          
        return true;
      },

      onHelpClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onHelpClick");

        window.open(Resources.help.businessTransactionConcept);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onHelpClick");
      },

      onDefinitionUnsavedChanges: function() {
        attr.set("_infoPaneTitleID", "innerHTML", this.btName + " *  - " + NLS.businessTransactionTitle);
        this.toolbar.getButton("save").set("disabled", false);
        this.toolbar.getButton("cancel").set("disabled", false);
        //this.validate();        

      },

      deleteBusinessTransaction : function(bTXUri) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "deleteBusinessTransaction");

        var btName = new RestUri(bTXUri).getBusinessTransactionName() || "";

        var deleteText = string.substitute(NLS.btConfirmDeleteBTX, [btName]);

        var confirmCallback = lang.hitch(this, function() {
          // REST Call to delete the BTx
          xhr.del(
            bTXUri,
            {
              handleAs : "json",
              headers : {
                 "Accept" : "application/json"
              }
            }
          ).then(
            lang.hitch(this, function() {
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Business transaction delete success");

              // Display success message for deleting BTX
              window.smallMessage.displayMessage("success", "BusinessTransaction_deleteSuccess", "",
                  string.substitute(NLS.messages.BusinessTransaction_deleteSuccessDescription, [btName]));

              var previousHash = hash();

              // On successful delete check whether the hash is currently pointing at the deleted object.
              // If match then move to parent (for now the Node, but this will be the BTX overview - so only temporary for now)
              var refreshHashCallback;
              if(this.isHashCurrentBusinessTransactionObject(bTXUri)) {
                refreshHashCallback = lang.hitch(this, function() {

                  // If the user has navigated in the meantime, do
                  // not overrule them.
                  if(hash() !== previousHash) {
                    return;
                  }

                  hash(encodeURI(Resources.REST.nodeHome));
                });
              }

              // Publish to notify the tree that content under the business transactions has changed
              Topic.publish(Resources.pubSubTopic.businessTransactionsUpdated, {btxUri: bTXUri, del: true, updateHashCallback: refreshHashCallback});
            }),
            lang.hitch(this, function(error) {
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Response: " + error.response.response);

              window.smallMessage.displayMessage("error", "BusinessTransaction_deleteFailure", "", error.response.status + ": " + error.response.text);
            })
          );
        });

        // Cancel should do nothing, user resumes their activities
        window.wmbConsole.showConfirmationDialog("btConfirmDelete", "information", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, deleteText, confirmCallback, null);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "deleteBusinessTransaction");
      },

      // Returns true if the current hash is pointed to the object
      isHashCurrentBusinessTransactionObject: function(objectUri) {
        var curUri = new WebUiHash(hash()).getRestUri().toString();
        return objectUri === curUri;
      },
      
      _setFlowProfileLoading: function() {
        this._setFlowProfileContent(construct.create("div", {
          innerHTML : "<div class='_common_propertyLoading'></div>"
        }));
      },
      
      _removeFlowProfileContent: function() {
        this._setFlowProfileContent("");
      },
      
      _setFlowProfileContent: function(content) {
        if(this.flowTp.open) {
          var container = dijit.byId(this.messageFlowProfileId);
          if(container != null) {
            container.set("content", content);
          }
        }
      },

      tabBlur: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
      },

      showLoading: function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "showLoading");
        if(this.loadingDiv){
          domStyle.set( this.loadingDiv, {display: 'block'});
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "showLoading");
      },


      hideLoading: function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "hideLoading");

        if(this.loadingDiv){
          domStyle.set( this.loadingDiv, { display: 'none'});
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "hideLoading");
      },

      onRefreshClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onRefreshClick");
        if (this.btEditor.btModel.unsavedChanges) {
          var btConfirmRefreshBTXDialog = registry.byId("btConfirmRefreshBTX");
          if (typeof btConfirmRefreshBTXDialog === "undefined") {
            btConfirmRefreshBTXDialog = new ConfirmationDialog({
              type : "information",
              buttonLabel : NLS.btReloadLastSaved,
              cancelButtonLabel : NLS.action.cancel,
              closeButtonLabel : NLS.action.close,
              text : NLS.btLeaveOrStay
            }, "btConfirmRefreshBTX");
          }
          // User clicks "confirm" -> override and try again
          btConfirmRefreshBTXDialog.confirm(lang.hitch(this, function() {
            // when refreshing, initiate a recomputation of the flows
            this.computeAllFlowsForBroker();
            this.tabRemove();
            this.tabFocus();
          }));

          btConfirmRefreshBTXDialog.onCancel = lang.hitch(this, function() {
            // do nothing
            btConfirmRefreshBTXDialog.hide();
          });

          on(btConfirmRefreshBTXDialog, "keydown", lang.hitch(this, function (event){
            // Move the focus accordingly if the arrow keys are pressed
            var key = event.keyCode;
            if ((key == keys.LEFT_ARROW) && btConfirmRefreshBTXDialog.closeAction.focused) {
              btConfirmRefreshBTXDialog.confirmAction.focus();
            }
            else if ((key == keys.RIGHT_ARROW) && btConfirmRefreshBTXDialog.confirmAction.focused){
              btConfirmRefreshBTXDialog.closeAction.focusNode.focus();
            }
            // Extend confirm/close function to close on Enter key press
            if (key == keys.ENTER) {
              if(btConfirmRefreshBTXDialog.confirmAction.focused) {
	            // when refreshing, initiate a recomputation of the flows
                this.computeAllFlowsForBroker();
                this.tabRemove();
                this.tabFocus();
                btConfirmRefreshBTXDialog.hide();
              } else {
                if(btConfirmRefreshBTXDialog.closeAction.focused) {
                  btConfirmRefreshBTXDialog.onCancel();
                }
              }
            }
            // Stop the keyboard event propagating i.e. moving a flow on the canvas
            event.stopPropagation();
          }));
          btConfirmRefreshBTXDialog.show();
        }
        else {
          this.tabRemove();
          this.tabFocus();
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onRefreshClick");
      },

      getNLSRole: function (role, defaultRole) {
        if(typeof role !== "undefined") {
          var results = array.filter(this.roleOptions,function(item){
            return (item.value== role);
          });
          if (results.length >0) {
            return results[0].label;
          }
          return ""; 
        }
        else {
          return defaultRole;
        }
      },
      
      canHaveFlowDiagram: function (type) {
        // Only draw a flow diagram if this isn't a Service or a REST API        
        if((type === Resources.REST.servicesType) || (type === Resources.REST.restApisTypeUri)) {
          return false;
        } 

        return true;   
      },

      /**
       * This method is called when the hash changes while this
       * tab widget is one of the (potentially several) tab widgets currently
       * visible. If you're okay with this hash change, return true. If there's
       * unsaved work, return false and provide a popup which will push the
       * change through.
       */
      canChangeHash: function(oldHash, newHash) {

    	  //if user clicked Cancel button, then return true
    	 if (this._clickedCancel){
    		 return true;
    	 }//if
    	 
        // This method is sometimes called before btModel exists, so handle that
        if (
          !this.btEditor ||
          !this.btEditor.btModel ||
          this.btEditor.btModel.unsavedChanges === false
        ) {
          return true;
        }

        // You might want to examine oldHash and newHash at this point, maybe
        // see whether we're just flipping between tabs?

        var btConfirmLeaveBTXDialog = registry.byId("btConfirmLeaveBTX");
        if (typeof btConfirmLeaveBTXDialog === "undefined") {
          btConfirmLeaveBTXDialog = new ConfirmationDialog({
            type : "information",
            buttonLabel : NLS.btLeaveSave,
            cancelButtonLabel : NLS.btStayOnPage,
            closeButtonLabel : NLS.btStayOnPage,
            text : NLS.btLeaveOrStay
          }, "btConfirmLeaveBTX");
        }

        // User clicks "confirm" -> override and try again
        btConfirmLeaveBTXDialog.confirm(lang.hitch(this, function() {
          this.btEditor.btModel.unsavedChanges = false;
          hash(newHash);
        }));

        btConfirmLeaveBTXDialog.onCancel = lang.hitch(this, function() {
          // Don't change the hash, but an item in the tree has been selected and focused upon.
          // Make sure the current item retains its focus, previous selected node, with no hash change/refresh.
          window.wmbConsole.expandTreeAndRefreshHash(oldHash, false);
          btConfirmLeaveBTXDialog.hide();
        });

        on(btConfirmLeaveBTXDialog, "keydown", lang.hitch(this, function (event){
          // Move the focus accordingly if the arrow keys are pressed
          var key = event.keyCode;
          if ((key == keys.LEFT_ARROW) && btConfirmLeaveBTXDialog.closeAction.focused) {
            btConfirmLeaveBTXDialog.confirmAction.focus();
          }
          else if ((key == keys.RIGHT_ARROW) && btConfirmLeaveBTXDialog.confirmAction.focused){
            btConfirmLeaveBTXDialog.closeAction.focusNode.focus();
          }
          // Extend confirm/close function to close on Enter key press
          if (key == keys.ENTER) {
            if(btConfirmLeaveBTXDialog.confirmAction.focused) {
              btConfirmLeaveBTXDialog.hide();
              this.btEditor.btModel.unsavedChanges = false;
              hash(newHash);
            } else {
              if(btConfirmLeaveBTXDialog.closeAction.focused) {
                btConfirmLeaveBTXDialog.onCancel();
              }
            }
          }
          // Stop the keyboard event propagating i.e. moving a flow on the canvas
          event.stopPropagation();
        }));

        btConfirmLeaveBTXDialog.show();

        // cancelAction i.e. stay on the page  do nothing

        // Veto the hash change, user will decide
        return false;
      }

    });
    return businesstransactionOverview;
  }
);

},
'webui/widgets/executiongroup/eg_overview':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="298665688" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/executiongroup/templates/eg_overview.html",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/array",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/dom-construct",
  "dojo/hash",
  "dojo/keys",
  "dojo/on",
  "dojo/query",
  "dojo/request/xhr",
  "dojo/string",
  "dojo/topic",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase",
  "dijit/_WidgetsInTemplateMixin",
  "dijit/registry",
  "idx/widget/ConfirmationDialog",
  "webui/config/Resources",
  "webui/utils/RestUri",
  "webui/utils/WebUiHash",
  "webui/widgets/common/AttributesStore",
  "webui/widgets/common/HasContextMenu",
  "webui/widgets/common/PropertiesStore",
  "webui/widgets/common/QuickAndAdvancedProperties",
  "webui/widgets/common/Trace",
  "webui/widgets/common/Toolbar",
  "webui/widgets/common/UIUtils",
  "webui/widgets/executiongroup/DeployBARDialog",
  "webui/widgets/executiongroup/ExecutionGroupPropertiesEditor",
  "webui/widgets/executiongroup/NewExecutionGroupDialog",
  "webui/widgets/restapi/BulkRESTApiPushDialog",
], function(
  template,
  NLS,
  array,
  declare,
  lang,
  domAttr,
  domConstruct,
  hash,
  keys,
  on,
  query,
  xhr,
  string,
  Topic,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  registry,
  ConfirmationDialog,
  Resources,
  RestUri,
  WebUiHash,
  AttributesStore,
  HasContextMenu,
  PropertiesStore,
  QuickAndAdvancedProperties,
  Trace,
  Toolbar,
  UIUtils,
  DeployBARDialog,
  ExecutionGroupPropertiesEditor,
  NewExecutionGroupDialog,
  BulkRESTApiPushDialog
) {
    /**
     * eg_overview.js represents the first tab widget for an integration server. It
     * contains a Toolbar and a QuickAndAdvancedProperties object.
     * Exactly one eg_overview widget exists for the whole lifetime of the web UI
     * console. It is reused for various integration servers over the course of its
     * lifetime.
     */
    var egOverview = declare("webui.widgets.executiongroup.eg_overview", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
      templateString: template,
      toolbar: null,
      properties: null,
      _contextMenu: null,
      _propertiesStore: new PropertiesStore(),
      _attributesStore : new AttributesStore(),
      _newDialog : null,
      _deployBARDialog : null,
      _bulkRESTApiPushDialog : null, 
      _objectURI: "",
      _adminHandlers: [],
      _doesUserHaveWritePermission: false,
      
      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
        this.inherited(arguments);

        // Create toolbar
        this.toolbar = new Toolbar();
        domConstruct.place(this.toolbar.domNode, this._toolbar);
        this.toolbar.addLeftAlignButtons("title");

        // Add Edit button to the right side of the toolbar if the user has write permission:
        this._doesUserHaveWritePermission = window.currentuser.userPermission("broker", "write");
        if (this._doesUserHaveWritePermission) {
          var buttons = ["edit"];
          this.toolbar.addRightAlignButtons(buttons);
          this.toolbar.addRightAlignButtons("spacer");
    
          // Add an event handler for the Edit button:
          this.toolbar.connectButtons("edit", "click", this, "_onEditClick");
          // set the enabled, disabled status once we get the properties
          
        }
                
        this.properties = new QuickAndAdvancedProperties("executionGroup");
        this.properties.createPropertiesContainer(this._propertyTitlePane);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
      },

      toggleEditButton: function(enable) {
        if (this.toolbar.getButton("edit")) {        
          if (enable && this._doesUserHaveWritePermission) {
            this.toolbar.getButton("edit").set("disabled", false);
            this.toolbar.getButton("edit").set('iconClass', "infoPaneButton_edit");
          } else {
              this.toolbar.getButton("edit").set("disabled", true);
              this.toolbar.getButton("edit").set('iconClass', "infoPaneButton_editDisabled");
          }
        }
      },
      

      // Hides the read-only view of the properties:
      _hideReadOnlyProperties: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_hideReadOnlyProperties");
        //this._csOverview_borderContainer.style.display = "none";
        this._egOverview_borderContainer.style.display = "none";

        this._toolbar.style.display = "none";
        this._propertyTitlePane.style.display = "none";
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_hideReadOnlyProperties");
      },
      
      // Checks whether the properties editor is open:
      _isPropertyEditorOpen: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_isPropertyEditorOpen");
        var returnValue = this.propertiesEditor !== null && this.propertiesEditor !== undefined;
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_isPropertyEditorOpen");
        return returnValue;
      },
      
      // Destroys the properties editor if one exists and removes the associated listeners.
      // Called when the user saves or cancels the properties editor, or when the user
      // navigates away from the editor:
      _destroypropertiesEditor: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_destroypropertiesEditor");
       
        // Remove listeners:
        if (this.editorUpdatedSubscription !== undefined && this.editorUpdatedSubscription !== null) {
          this.editorUpdatedSubscription.remove();
        }
        if (this.editorCancelSubscription !== undefined && this.editorCancelSubscription !== null) {
          this.editorCancelSubscription.remove();
        }
         
        // Destroy the properties editor widget if it exists:
        if (this._isPropertyEditorOpen()) {
          //Clear the current message (as there may be a message associated with editor that is not longer applicable):
          window.smallMessage.hideMessage();
          this.propertiesEditor.destroy();
          this.propertiesEditor = null;
        }
 
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_destroypropertiesEditor");
      },
      
      // Shows the read-only view of the properties:
      _showReadOnlyProperties: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showReadOnlyProperties");
        this._egOverview_borderContainer.style.display = "";
        this._toolbar.style.display = "";
        this._propertyTitlePane.style.display = "";
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showReadOnlyProperties");
      },
      
      // Called when the user clicks the Edit button:
      _onEditClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onEditClick");

        // Hide the existing read-only properties pane and associated title and toolbar:
        this._hideReadOnlyProperties();
        
        var webUiHash = new WebUiHash(hash());
        var egName = webUiHash.getArtifactName();
        var egType = webUiHash.getArtifactType();
       
        // Show the properties editor:
        if (!this._isPropertyEditorOpen()) {
          this.propertiesEditor = new ExecutionGroupPropertiesEditor({
            mode: 'edit',
            name: egName,
            type: egType
          });
          
          // Subscribe to the properties editor's update event:
          this.editorUpdatedSubscription = Topic.subscribe(Resources.pubSubTopic.egPropertiesUpdated, lang.hitch(this, function() {
            // Destroy editor:
            this._destroypropertiesEditor();
          
            // Re-populate the properties because the read-only properties will be out of date after the update:
            this.properties.populateProperties();
          
            // Re-show the read-only properties pane and associated title and toolbar if hidden:
            this._showReadOnlyProperties();
          }));
          
          // Subscribe to the properties editor's cancel event:
          this.editorCancelSubscription = Topic.subscribe(Resources.pubSubTopic.egPropertiesEditCancelled, lang.hitch(this, function() {
            // If the editor is not dirty, just proceed with the cancel:
            if (this._isPropertyEditorOpen() && !this.propertiesEditor.isDirty()) {
              // Destroy editor:
              this._destroypropertiesEditor();
            
              // Re-show the read-only properties pane and associated title and toolbar if hidden:
              this._showReadOnlyProperties();
            
              return;
            }
            
            // Create the confirmation dialog if it does not already exist:
            var egEditConfirmCancelDialog = registry.byId("egEditConfirmCancelDialog");
            if (typeof egEditConfirmCancelDialog === 'undefined') {
              egEditConfirmCancelDialog = new ConfirmationDialog({
                type : "information",
                buttonLabel : NLS.btLeaveSave,
                cancelButtonLabel : NLS.btStayOnPage,
                closeButtonLabel : NLS.btStayOnPage,
                text : NLS.messages.PropertiesUpdate_ConfirmNavigateAwayFromEditorConfirmationMessage
              }, "egEditConfirmCancelDialog");
            }
            
            // Callback handler for when the user clicks 'confirm' on the dialog:
            egEditConfirmCancelDialog.confirm(lang.hitch(this, function() {
              // Destroy editor:
              this._destroypropertiesEditor();
            
              // Re-show the read-only properties pane and associated title and toolbar if hidden:
              this._showReadOnlyProperties();
            }));
            
            // Callback handler for when the user clicks 'cancel' on the dialog:
            egEditConfirmCancelDialog.onCancel = lang.hitch(this, function() {
              egEditConfirmCancelDialog.hide();
            });
            
            on(egEditConfirmCancelDialog, "keydown", lang.hitch(this, function (event){
              // Move the focus accordingly if the arrow keys are pressed
              var key = event.keyCode;
              if ((key == keys.LEFT_ARROW) && egEditConfirmCancelDialog.closeAction.focused) {
                egEditConfirmCancelDialog.confirmAction.focus();
              } 
              else if ((key == keys.RIGHT_ARROW) && egEditConfirmCancelDialog.confirmAction.focused){
               egEditConfirmCancelDialog.closeAction.focusNode.focus();
              }
              // Extend confirm/close function to close on Enter key press
              if (key == keys.ENTER) {
                if(egEditConfirmCancelDialog.confirmAction.focused) {
                  egEditConfirmCancelDialog.hide();
               
                  // Destroy editor:
                  this._destroypropertiesEditor();
            
                  // Re-show the read-only properties pane and associated title and toolbar if hidden:
                  this._showReadOnlyProperties();
                } else {
                  if(egEditConfirmCancelDialog.closeAction.focused) {
                   egEditConfirmCancelDialog.onCancel();
                  }
                }
              } 
              // Stop the keyboard event propagating i.e. moving a flow on the canvas
              event.stopPropagation();
            }));
            
            // Open the dialog and ask the user if they are sure that they want to cancel:
            egEditConfirmCancelDialog.show();
          }));
          
          this.propertiesEditor.placeAt(this._egEditEditor);
          this.propertiesEditor.startup();
        }
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onEditClick");
      },
      
      resize: function() {
        this._egOverview_borderContainer.resize();
      },

      // This function is called manually when we need to remove this tab.
      tabRemove: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");

        this.properties.unsubscribeAll();
        
        this.destroyNewDialogIfItExists();

        if(this.propertiesEditor) {
          this.propertiesEditor.uninitialize();
        }
        
        if(this._bulkRESTApiPushDialog != null) {
          this._bulkRESTApiPushDialog.destroy();
          this._bulkRESTApiPushDialog = null;
        }
        
        UIUtils.removeAdminHandlers(this._adminHandlers);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
      },

      /*
       * Listen for admin notification. For EG's will only listen to updates about itself and ignore others
       * If the notification is about this object, reread the properties, in particular the running state
       * and update the state of the button
       */
      processAdminHandlers: function (message) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "processAdminHandlers");
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Received admin notification for "+message.destinationName);

        // if the notification is about this object only
        var restUri = new RestUri(this._objectURI);
        if  (restUri.isAdminNotificationForThisObjectOnly(message)) {
          // reread the properties
          var populatAttributesPromise = this._attributesStore.populateAttributesStore(); 
          populatAttributesPromise.then(lang.hitch(this, function() {
            var enable = this._attributesStore.getAttribute("isRunning");
            this.toggleEditButton(enable);
          }));
        }
        // else Ignore other notifications
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "processAdminHandlers");

      },
      
      contextButtonsClicks : function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks", [event]);

        // Get the URI and action from the event:
        var uriAndAction = UIUtils.getURIAndAction(event, true);
        var itemURI = uriAndAction.uri;
        var buttonType = uriAndAction.action;
        
        if(
          buttonType === "statsOn" ||
          buttonType === "statsOff" ||
          buttonType === "resourceStatsOn" ||
          buttonType === "resourceStatsOff"
        ) {
          this.actionButtonSetStatsContainer(itemURI, buttonType);
        } else {
          this._actionEG(itemURI, buttonType);
        }
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
      },

      actionButtonSetStatsContainer : function(itemURI,buttonType) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionButtonSetStatsContainer",[itemURI,buttonType]);

        // Extract the base URI
        var targetUri = itemURI.substring(0, (itemURI.length - (buttonType.length+1)));        
        
        /*
         *  Work out whether we are working with message flow statistics or
         *  resource statistics
         */
        var uriStatsparam;
        if(buttonType === "statsOn" || buttonType === "statsOff"){
          uriStatsparam = "setStatistics";
        } else if (buttonType === "resourceStatsOn" || buttonType === "resourceStatsOff"){
          uriStatsparam = "setResourceStatistics";
        } else {
          throw new Error("buttonType not recognised: '" + buttonType + "'");
        }
        
        // Work out if we enabling or disabling statistics
        var uriStatsparamValue;
        if(buttonType === "statsOn" || buttonType === "resourceStatsOn"){
          uriStatsparamValue = "on";
        } else if(buttonType === "statsOff" || buttonType === "resourceStatsOff"){
          uriStatsparamValue = "off";
        } else {
          throw new Error("buttonType not recognised: '" + buttonType + "'");
        }

        // Add loading icon to tree
        var tree = registry.byId('_explorerTree_ID');
        var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
        var oldIcon = domAttr.get(treeImgs[0],"class");
        domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");

        xhr.put(
          targetUri + "?action=setStatistics&" + uriStatsparam + "=" + uriStatsparamValue,
          {
            handleAs:"json",
            headers : {
               "Accept" : "application/json"
            }
          }
        ).response.then(
          lang.hitch(this, function(response){
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionButtonSetStatsContainer.xhrLoad",[response]);

            //reset old icon
            domAttr.set(treeImgs[0],"class",oldIcon);
            
            var msgId = {
              "statsOn" : "FlowStatsAction_successstatsOn",
              "statsOff" : "FlowStatsAction_successstatsOff",
              "resourceStatsOn" : "EGResourceStatsAction_successresourceStatsOn",
              "resourceStatsOff" : "EGResourceStatsAction_successresourceStatsOff"
            }[buttonType];
            
            if(!msgId) {
              throw new Error("buttonType not recognised: '" + buttonType + "'");
            }
            
            window.smallMessage.displayMessage("success", msgId);

            Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionButtonSetStatsContainer.xhrLoad");
          }),
          lang.hitch(this,function(error){
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionButtonSetStatsContainer.xhrError",[error]);

            //reset old icon
            domAttr.set(treeImgs[0],"class",oldIcon);
            //show error message
            var response = JSON.parse(error.response.text);
            
            var msgId = {
              "statsOn" : "msgflowstatsOn_5XX",
              "statsOff" : "msgflowstatsOff_5XX",
              "resourceStatsOn" : "EGResourceStatsActionresourceStatsOn_5XX",
              "resourceStatsOff" : "EGResourceStatsActionresourceStatsOff_5XX"
            }[buttonType];
            
            if(!msgId) {
              throw new Error("buttonType not recognised: '" + buttonType + "'");
            }
            
            window.smallMessage.displayMessage("error", msgId, response.bipNumber, response.description);

            Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionButtonSetStatsContainer.xhrError");
          })
        );
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionButtonSetStatsContainer");
      },
      
      _askNewExecutionGroup : function() {
          
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_askNewExecutionGroup");
        
        this.destroyNewDialogIfItExists();//ensures we don't create multiple dialogs in memory
        
        this._newDialog = new NewExecutionGroupDialog({
          currentValue : "",
          cback : lang.hitch(this, this._createExecutionGroup)
        });
        
        this._newDialog.startup();
        this._newDialog.show();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_askNewExecutionGroup");
      },
          
      destroyNewDialogIfItExists : function() {
        if (this._newDialog) {
          this._newDialog.destroy();
          this._newDialog=null;
        }
      },

      _showDeployBARDialog : function(uri) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showDeployBARDialog");
          
        if (this._deployBARDialog) {
          this._deployBARDialog.destroy();
          this._deployBARDialog = null;
        }    
          
        this._deployBARDialog = new DeployBARDialog({
          actionURI : uri,
          cback     : lang.hitch(this, this._deployBARFile)
        });

        this._deployBARDialog.startup();
        this._deployBARDialog.show();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showDeployBARDialog");
      },

      _deployBARFile : function(action, barFileName, overridesFileName) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_deployBARFile");
        
        var jsonData = {"filename" : barFileName, "overridesfilename": overridesFileName};
        xhr.post(
          action,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json"
            },
            data : JSON.stringify(jsonData)
          }
        ).then(
          lang.hitch(this, function() {
            window.smallMessage.displayPlainMessage("success", "BARDeploySuccessful_2XX", [barFileName]);
          }),
          lang.hitch(this, function(error) {
            if (error.response.text) {
              var response = JSON.parse(error.response.text);
              if (response.bipNumber == "1039") {
                window.smallMessage.displayMessage("information", "BARDeploySubmitted_2XX", response.bipNumber, null, [response.bipInserts[0], response.bipInserts[1]]);
              }
              else {
                window.smallMessage.displayMessage("error", "BARDeployFailed_5XX", response.bipNumber, response.description, [response.bipInserts[0], response.bipInserts[1]]);
              }
            }
          })
        );

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_deployBARFile");
      },
      
      _showBulkRESTApiPushDialog : function(uri) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showBulkRESTApiPushDialog");
        
        if (this._bulkRESTApiPushDialog) {
          this._bulkRESTApiPushDialog.destroy();
          this._bulkRESTApiPushDialog = null;
        }
          
        this._bulkRESTApiPushDialog = new BulkRESTApiPushDialog({
          actionUri : uri
        });

        this._bulkRESTApiPushDialog.startup();
        this._bulkRESTApiPushDialog.show();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showBulkRESTApiPushDialog");
      },
        
      _createExecutionGroup : function(newEGName) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createExecutionGroup");

        var uri = RestUri.forIntegrationServer(newEGName); 
          
        //this can be used to call other functions in this file.
        // e.g. this.buttonState(action, uri);

        //  Add loading icon to tree
        var tree = registry.byId('_explorerTree_ID');
        var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
        var oldIcon = domAttr.get(treeImgs[0],"class");
        domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");          
      
        xhr.put(
          uri,
          {
            "handleAs":"json",
            "headers" : {
              "Accept" : "application/json"
            }
          }
        ).response.then(
          lang.hitch(this, function(response){
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createExecutionGroup.xhrPut()",[response]);

            // This causes new user permissions to be created!
            // We must refresh them.
            window.currentuser.populatePermissions().then(
              lang.hitch(this, function() {
                //reset old icon
                domAttr.set(treeImgs[0],"class",oldIcon);
                
                window.smallMessage.displayPlainMessage("success", "CreateEGAction_successEGCreated", [ newEGName ] );
              })
            );
  
            Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createExecutionGroup.xhrPut()");
          }),
          lang.hitch(this,function(error){
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createExecutionGroup.xhrPutError()",[error]);

            //reset old icon
            domAttr.set(treeImgs[0],"class",oldIcon);
            
            Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrPut to " + uri + " failed.", [error]);
            //show error message
            var response = JSON.parse(error.response.text);
            window.smallMessage.displayMessage("error", "egcreate_5XX",response.bipNumber, response.description);
            
            Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createExecutionGroup.xhrPutError()");
          })
        );
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createExecutionGroup");
      },
        
      _actionEG : function(uri, action){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_actionEG",[uri, action]);
        
        var uriArray = uri.split("_");
        var buttonType = uriArray[uriArray.length - 1];
        uri = uri.substr(0,uri.length - buttonType.length - 1);

        var tree = registry.byId('_explorerTree_ID');
        
        var egName;
        var confirmationMessage;
        var confirmCallback;
        
        if ( action == "create" ){
          this._askNewExecutionGroup();
        }

        else if (action == "delete") {

          egName = tree.selectedNode.item.name;//label can be truncated, so use name instead
            
          confirmationMessage = string.substitute(NLS.messages.DeleteEGAction_confirmation, [egName] );
            
          confirmCallback = lang.hitch(this, function() {
          
            //  Add loading icon to tree
            var tree = registry.byId('_explorerTree_ID');
            var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
            var oldIcon = domAttr.get(treeImgs[0],"class");
            domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");          

            // REST Call to delete the execution group
            tree.model.remove(uri).then(
              lang.hitch(this, function() {
                Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Integration server delete success");
  
                //reset old icon
                domAttr.set(treeImgs[0],"class",oldIcon);

                // Display success message for deleting execution group
                window.smallMessage.displayPlainMessage("success", "DeleteEGAction_successEGDeleted", [egName]);
              }),
              lang.hitch(this, function(error) {
                
                Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrDel to " + uri + " failed.", [error]);

                //reset old icon
                domAttr.set(treeImgs[0],"class",oldIcon);

                //show error message
                var response = JSON.parse(error.response.text);

                window.smallMessage.displayMessage("error", "egdelete_5XX",response.bipNumber, response.description);
              })
            );
          });
            
          window.wmbConsole.showConfirmationDialog("btConfirmDelete", "question", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, confirmationMessage, confirmCallback, null);
        }
        else if (action == "deleteAll"){

          egName = tree.selectedNode.item.name;//label can be truncated, so use name instead
            
          confirmationMessage = string.substitute(NLS.messages.DeleteEGContentsAllAction_confirmation, [egName] );
            
          // Callback subscription topic
          var updateSubTopic = RestUri.forIntegrationServer(egName).getNotificationTopic();

          var previousHash = hash();
          
          confirmCallback = lang.hitch(this, function() {
            
            //  Add loading icon to tree
            var tree = registry.byId('_explorerTree_ID');
            var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
            var oldIcon = domAttr.get(treeImgs[0],"class");
            domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");          

            // REST Call to delete all contents from the execution group
            xhr.put(
              uri + "?action=" + action,
              {
                handleAs : "json",
                headers : {
                  "Accept" : "application/json"
                }
              }
            ).then(
              lang.hitch(this, function() {
                Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Integration server contents delete success");
  
                // Subscription Handler
                var deleteAllSub = null;
                
                var completeDeleteAllCB = function() {
                  window.smallMessage.displayPlainMessage("success", "DeleteEGContentsAllAction_success", [egName]);
                    
                  // Remove the subscription
                  if(deleteAllSub) {
                    deleteAllSub.remove();
                  }
                  
                  //reset old icon
                  domAttr.set(treeImgs[0],"class",oldIcon);
                  
                  // If the user has navigated, leave them where they are
                  if(hash() !== previousHash) {
                    return;
                  }
                  
                  // Otherwise redirect to the root node
                  hash(Resources.REST.nodeHome);
                };
                deleteAllSub = Topic.subscribe(updateSubTopic, lang.hitch(this, completeDeleteAllCB));
              }),
              lang.hitch(this, function(error) {
                
                Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrPut to " + uri + "?action=" + action + " failed.", [error]);

                //reset old icon
                domAttr.set(treeImgs[0],"class",oldIcon);
                  
                //show error message
                var response = JSON.parse(error.response.text);
                window.smallMessage.displayMessage("error", "eg_all_contents_delete_5XX",response.bipNumber, response.description);

                // If the user has navigated, leave them where they are
                if(hash() !== previousHash) {
                  return;
                }
                
                // Otherwise redirect to the root node
                hash(Resources.REST.nodeHome);
              })
            );
          });
            
          window.wmbConsole.showConfirmationDialog("btConfirmDelete", "question", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, confirmationMessage, confirmCallback, null);
        }
        else if (action == "stopAllApplicationTypes"){

          egName = tree.selectedNode.item.name;//label can be truncated, so use name instead
            
          confirmationMessage = string.substitute(NLS.messages.StopAllApplicationTypes_confirmation, [egName] );
            
          confirmCallback = lang.hitch(this, function() {
            
            //  Add loading icon to tree
            var tree = registry.byId('_explorerTree_ID');
            var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
            var oldIcon = domAttr.get(treeImgs[0],"class");
            domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");          

            // REST Call to stop all application types (apps and services) on integration server
            xhr.put(
              uri + "?action=" + action,
              {
                handleAs : "json",
                headers : {
                  "Accept" : "application/json"
                }
              }
            ).then( lang.hitch(this, function() {
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Integration server application types stopped successfully");
  
              //reset old icon
              domAttr.set(treeImgs[0],"class",oldIcon);
                  
              window.smallMessage.displayPlainMessage("success", "StopAllApplicationTypes_success", [egName]);
          
            }), lang.hitch(this, function(error) {
                
              Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrPut to " + uri + "?action=" + action + " failed.", [error]);

              //reset old icon
              domAttr.set(treeImgs[0],"class",oldIcon);
                  
              //show error message
              var response = JSON.parse(error.response.text);
              window.smallMessage.displayMessage("error", "eg_all_application_types_stopped_5XX",response.bipNumber, response.description);
            }));
          });
            
          window.wmbConsole.showConfirmationDialog("btConfirmDelete", "question", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, confirmationMessage, confirmCallback, null);

        }
        else if (action == "stopAllMessageFlows"){

          egName = tree.selectedNode.item.name;//label can be truncated, so use name instead
            
          confirmationMessage = string.substitute(NLS.messages.StopAllFlows_confirmation, [egName] );

          confirmCallback = lang.hitch(this, function() {
            
            //  Add loading icon to tree
            var tree = registry.byId('_explorerTree_ID');
            var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
            var oldIcon = domAttr.get(treeImgs[0],"class");
            domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");          

            // REST Call to stop all flows on integration server
            xhr.put(
              uri + "?action=" + action,
              {
                handleAs : "json",
                headers : {
                  "Accept" : "application/json"
                }
              }
            ).then(
              lang.hitch(this, function() {
                Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Integration server flows stopped successfully");
  
                //reset old icon
                domAttr.set(treeImgs[0],"class",oldIcon);
                  
                window.smallMessage.displayPlainMessage("success", "StopAllFlows_success", [egName]);
          
              }),
              lang.hitch(this, function(error) {
                
                Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrPut to " + uri + "?action=" + action + " failed.", [error]);

                //reset old icon
                domAttr.set(treeImgs[0],"class",oldIcon);
                  
                //show error message
                var response = JSON.parse(error.response.text);
                window.smallMessage.displayMessage("error", "eg_all_flows_stopped_5XX",response.bipNumber, response.description);
              })
            );
          });
            
          window.wmbConsole.showConfirmationDialog("btConfirmDelete", "question", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, confirmationMessage, confirmCallback, null);

        }
        else if (action == "startAllApplicationTypes"){


          egName = tree.selectedNode.item.name;//label can be truncated, so use name instead
            
          confirmationMessage = string.substitute(NLS.messages.StartAllApplicationTypes_confirmation, [egName] );
            
          confirmCallback = lang.hitch(this, function() {
            
            //  Add loading icon to tree
            var tree = registry.byId('_explorerTree_ID');
            var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
            var oldIcon = domAttr.get(treeImgs[0],"class");
            domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");          

            // REST Call to start all application types (apps and services) on integration server
            xhr.put(
              uri + "?action=" + action,
              {
                handleAs : "json",
                headers : {
                  "Accept" : "application/json"
                }
              }
            ).then(
              lang.hitch(this, function() {
                Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Integration server application types started successfully");
                
                //reset old icon
                domAttr.set(treeImgs[0],"class",oldIcon);
                    
                window.smallMessage.displayPlainMessage("success", "StartAllApplicationTypes_success", [egName]);
              }),
              lang.hitch(this, function(error) {
                
                Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrPut to " + uri + "?action=" + action + " failed.", [error]);

                //reset old icon
                domAttr.set(treeImgs[0],"class",oldIcon);
                
                //show error message
                var response = JSON.parse(error.response.text);
                window.smallMessage.displayMessage("error", "eg_all_application_types_started_5XX",response.bipNumber, response.description);
              })
            );
          });
            
          window.wmbConsole.showConfirmationDialog("btConfirmDelete", "question", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, confirmationMessage, confirmCallback, null);

        }
        else if (action == "startAllMessageFlows"){

          egName = tree.selectedNode.item.name;//label can be truncated, so use name instead
            
          confirmationMessage = string.substitute(NLS.messages.StartAllFlows_confirmation, [egName] );
            
          confirmCallback = lang.hitch(this, function() {
            
            //  Add loading icon to tree
            var tree = registry.byId('_explorerTree_ID');
            var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
            var oldIcon = domAttr.get(treeImgs[0],"class");
            domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");          

            // REST Call to start all message flows on integration server
            xhr.put(
               uri + "?action=" + action,
                {
                  handleAs : "json",
                  headers : {
                     "Accept" : "application/json"
                  }
                }
              ).then( lang.hitch(this, function() {
                Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Integration server flows started successfully");
  
                //reset old icon
                domAttr.set(treeImgs[0],"class",oldIcon);
                  
                // Display success message for deleting execution group
                window.smallMessage.displayPlainMessage("success", "StartAllFlows_success", [egName]);
                
              }),
              lang.hitch(this, function(error) {
                
                Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrPut to " + uri + "?action=" + action + " failed.", [error]);

                //reset old icon
                domAttr.set(treeImgs[0],"class",oldIcon);

                //show error message
                var response = JSON.parse(error.response.text);
                window.smallMessage.displayMessage("error", "eg_all_flows_started_5XX",response.bipNumber, response.description);
              })
            );
          });
            
          window.wmbConsole.showConfirmationDialog("btConfirmDelete", "question", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, confirmationMessage, confirmCallback, null);

        }          
        else if (action == "deploy") {
          this._showDeployBARDialog(uri,action);
        }
        else if (action == "pushRESTApis") {
          this._showBulkRESTApiPushDialog(uri);          
        }
        else {
          
          //  Add loading icon to tree
          var treeNodeID = tree.selectedNode.id;//store this for the call to this.buttonState()          
          var treeImgs = query('#' + treeNodeID + ' .dijitTreeIcon');
          domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");          
      
          xhr.put(
            uri + "?action=" + action,
            {
              handleAs:"json",
              headers : {
                 "Accept" : "application/json"
              }
            }
          ).response.then(
            lang.hitch(this, function(response){
              Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_actionEG.xhrLoad()",[response]);
  
              this.buttonState(action, uri,treeNodeID);

              var egName = tree.selectedNode.item.name;//label can be truncated, so use name instead
              if (action === "startFlowMonitoring") {
  	            window.smallMessage.displayPlainMessage("success", "FlowMonitoringStartedSuccessfully_EG", [egName]);
              } else if (action === "stopFlowMonitoring") {
            	window.smallMessage.displayPlainMessage("success", "FlowMonitoringStoppedSuccessfully_EG", [egName]);
              }
  
              Trace.trace(this.declaredClass, Trace.levels.EXIT, "_actionEG.xhrLoad()");
            }),
            lang.hitch(this,function(error){
              Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_actionEG.xhrError()",[error]);
  
              Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrPut to " + uri + " failed.", [error]);
              
              this.buttonState(action, uri,treeNodeID);//old icon restored in here
              
              //show error message
              var response = JSON.parse(error.response.text);
              if(action === "start"){
                window.smallMessage.displayMessage("error", "egstart_5XX",response.bipNumber, response.description);
              } else if (action === "stop") {
                window.smallMessage.displayMessage("error", "egstop_5XX",response.bipNumber, response.description);
              } else if (action === "startFlowMonitoring") {
  	            window.smallMessage.displayMessage("error", "FlowMonitoringFailedToStart");
              } else if (action === "stopFlowMonitoring") {
            	window.smallMessage.displayMessage("error", "FlowMonitoringFailedToStop");
              }
              
              Trace.trace(this.declaredClass, Trace.levels.EXIT, "_actionEG.xhrError()");
            })
          );
        }//endif
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_actionEG");
      },

      buttonState:function(action, uri,treeNodeID){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "buttonState", [action, uri]);

        // Disable and enable the relevant buttons
        var treeImgs = query('#' + treeNodeID + ' .dijitTreeIcon');

        var populateAttributesStore = this._attributesStore.populateAttributesStore(uri);
        var populatePropertiesStore = this._propertiesStore.populatePropertiesStore(uri);

        populatePropertiesStore.then(lang.hitch(this, function() {
          populateAttributesStore.then(lang.hitch(this, function() {
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "buttonState.then", [action, uri]);
            // Get the flow's running status
            var running = (this._propertiesStore.getProperty("basic", "isRunning") === "true");
            var name = this._attributesStore.getAttribute("name");

            // Set the TreeNode icon as appropriate
            if (running) {
              domAttr.set(treeImgs[0], "class", "dijitInline dijitIcon dijitTreeIcon explorer_executionGroup_running");
            } else {
              domAttr.set(treeImgs[0], "class", "dijitInline dijitIcon dijitTreeIcon explorer_executionGroup_stopped");
            }

            // Same for context menu
            this._updateContextMenuTitle(uri, name, "executionGroup", running);

            //Now show/hide the appropriate start/stop stats on/off buttons, but greying out as appropriate
            //Again iterating over all viewable buttons to find the ones which we have just changed
            array.forEach(this._getContextButtons(uri), function(button) {
              var tmp = button.id.split("_");
              var buttonType = tmp[tmp.length - 1];
              var thisButtonUri = button.id.substring(0,button.id.length - (buttonType.length+1));

              if( thisButtonUri === uri){
                switch(buttonType){
                  case "start":
                    button.set("disabled", running);
                    break;
                  case "stop":
                    button.set("disabled", !running);
                    break;
                }
              }
            }, this);
            Trace.trace(this.declaredClass, Trace.levels.EXIT, "buttonState.then");
          }));
        }));
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "buttonState");
      },

      tabFocus: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");

        this.properties.unsubscribeAll();
          // Get eg name and add to the toolbar title
        this.toolbar.setAttribute("title", "innerHTML", "");
        var populate = this._attributesStore.populateAttributesStore();
        populate.then(lang.hitch(this, function() {
          domAttr.set("_infoPaneTitleID", "innerHTML", this._attributesStore.getAttribute("name") + " - " + NLS.executionGroupTitle);
          this._objectURI = this._attributesStore.getAttribute("uri");
          var enable = this._attributesStore.getAttribute("isRunning");
          this.toggleEditButton(enable);

        }));
        
        UIUtils.setupAdminHandlers(this._adminHandlers, lang.hitch(this, this.processAdminHandlers));

        // Populate quick view and advanced properties
        this.properties.populateProperties();
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
      },

      tabBlur: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");

        this.properties.unsubscribeAll();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
      }
    });

    return egOverview;
  }
);

},
'webui/widgets/common/WMBConsole':function(){
/* <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="4034771261" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define(
  [
    "dojo/i18n!webui/nls/web",
    "dojo/text!webui/config/Layout.json",

    "dijit/_WidgetBase",
    "dijit/layout/ContentPane",
    "dijit/MenuItem",
    "dijit/registry",
    "dijit/layout/TabContainer",

    "dojo/_base/declare",
    "dojo/_base/lang",
    "dojo/dom-construct",
    "dojo/dom-geometry",
    "dojo/ready",
    "dojo/_base/array",
    "dojo/dom-attr",
    "dojo/on",
    "dojo/_base/fx",
    "dojo/dom-class",
    "dojo/topic",
    "dojo/dom-style",
    "dojo/fx",
    "dojo/fx/easing",
    "dojo/hash",
    "dojo/store/Observable",
    "idx/app/Header",
    "idx/widget/ConfirmationDialog",
    "idx/widget/Menu",

    "webui/widgets/adminlog/adminlog",
    "webui/widgets/common/Trace",
    "webui/config/Resources",
    "webui/utils/RestUri",
    "webui/utils/WebUiHash",
    "webui/widgets/common/AttributesStore",
    "webui/widgets/common/CustomJsonRest",
    "webui/widgets/common/CustomTree",
    "webui/widgets/common/PropertiesStore",
    "webui/widgets/common/SmallMessage",
    "webui/widgets/common/StatisticsContainer",
    "webui/widgets/common/wsHandler",
    "webui/widgets/application/app_overview",
    "webui/widgets/restapi/Overview",
    "webui/widgets/restapi/Api",
    "webui/widgets/libraries/lib_overview",
    "webui/widgets/sharedlibraries/shlib_overview",
    "webui/widgets/broker/broker_overview",
    "webui/widgets/executiongroup/eg_overview",
    "webui/widgets/executiongroup/eg_resource_statistics",
    "webui/widgets/msgflows/msgflow_overview",
    "webui/widgets/msgflows/msgflow_activityLog",
    "webui/widgets/msgflows/msgflow_statistics",
    "webui/widgets/my_profile/MyProfile_Properties",
    "webui/widgets/subflows/subflow_overview",
    "webui/widgets/resources/resource_overview",
    "webui/widgets/service/svc_overview",
    "webui/widgets/business/businesstransactions",
    "webui/widgets/business/businesstransaction_overview",
    "webui/widgets/business/businesstransaction_configuration",
    "webui/widgets/business/businesstransaction_results",
    "webui/widgets/policy/policy_overview",
    "webui/widgets/policy/policy_attach",
    "webui/widgets/configurableservice/cs_overview",
    "webui/widgets/configurableservice/cs_category_overview",
    "webui/widgets/dataviewer/DataViewer",
    "webui/widgets/dataviewer/Replay",
    "webui/widgets/operation/operation_overview",
    "dojo/dom",
    "webui/widgets/broker/FilteringOptionsDialog",
    "dojo/query"
  ],
  function(
    NLS,
    Layout,
    WidgetBase,
    ContentPane,
    MenuItem,
    registry,
    TabContainer,
    declare,
    lang,
    construct,
    domGeom,
    ready,
    array,
    attr,
    on,
    fx,
    domClass,
    topic,
    domStyle,
    coreFx,
    easing,
    hash,
    Observable,
    Header,
    ConfirmationDialog,
    Menu,
    adminlog,
    Trace,
    Resources,
    RestUri,
    WebUiHash,
    AttributesStore,
    CustomJsonRest,
    CustomTree,
    PropertiesStore,
    SmallMessage,
    StatisticsContainer,
    wsHandler,
    app_overview,
    restApi_Overview,
    restApi_Api,
    lib_overview,
    shlib_overview,
    broker_overview,
    eg_overview,
    eg_resource_statistics,
    msgflow_overview,
    msgflow_activityLog,
    msgflow_statistics,
    MyProfile_Properties,
    subflow_overview,
    resource_overview,
    svc_overview,
    businesstransactions,
    businesstransaction_overview,
    businesstransaction_configuration,
    businesstransaction_results,
    policy_overview,
    policy_attach,
    cs_overview,
    cs_category_overview,
    DataViewer,
    Replay,
    operation_overview,
    dom,
    FilteringOptionsDialog,
    dojoQuery
  ) {
    Layout = JSON.parse(Layout);

    var WMBConsole = declare("webui.widgets.common.WMBConsole",[WidgetBase],{

      _treeDivWidth: null,
      _originalTreeWidth: null,
      _divMoving: false,
      _treeHidden: "false",
      _explorerTree: null,
      filterResources : null, // public
      filterConfigServices : null, // public
      _tabContainer: null,
      _filteringOptionsDialog : null,
      // When the hash changes for any reason, we're navigating from viewing one
      // resource to viewing another. BUT we might want to revert that (e.g. if
      // you just tried to navigate away from an unsaved document). So, we
      // need to store the old hash until the move is confirmed.
      _oldHash: null,
      
      // There are occassions where user path may need to return to a previous hash value.
      // Storing this value for later retrieval can offer an instant redirect to such a location.
      previousHash: null,

      _ignoreNextHashChange: false,
      _attributesStore : new AttributesStore(),

      constructor: function() {
        // deliberate use of global variables
        window.smallMessage = new SmallMessage();
        window.brokerProperties = new PropertiesStore();

        // HEADER - Start ///////////////////////////////
        // Build the header and gather information to populate it
        var helpMenu = new Menu();
        helpMenu.addChild(new MenuItem({
          label: NLS.headerHelpText,
          onClick: lang.hitch(this,function(){
            window.open(Resources.help.url,"WMB_Help");
          })
        }));

        var actionsMenu = new Menu();
        actionsMenu.addChild(new MenuItem({
          label: NLS.headerProfile,
          onClick: function() {
            hash("currentUser/0/security/currentuser");
            // hashchange will handle the rest (i.e. show the right page)
          }
        }));
        actionsMenu.addChild(new MenuItem({
          label: NLS.headerLogOut,
          onClick: function() {
            window.location = Resources.logout.url;
          }
        }));
        window.currentuser.actions = actionsMenu;

        new Header({
          region:"top",
          primaryTitle:NLS.productName,
          primaryBannerType:"thin",
          user:window.currentuser,
          help:helpMenu,
          layoutType: "variable"
        },"header");
        // HEADER - End ///////////////////////////////
      },

      postCreate:function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");

        // Create global variable to hold all tab widgets
        window.tabWidgets = [];

        var populatePropertiesStore = window.brokerProperties.populatePropertiesStore(Resources.REST.root);

        // Save the broker name in global namespace
        populatePropertiesStore.then(lang.hitch(this, function() {
          // Update references where the broker/node name is used
          window.brokerName = window.brokerProperties.getProperty("basic", "name");
          window.document.title = window.brokerName + " - " + window.document.title;

          // Subscribe to administration notifications. We can only do this after
          // `brokerName` is known.
          if(window.WebSocket){
            var topicName = new RestUri(Resources.REST.root).getNotificationTopic(true); // append wildcard

            // Anyone who wants to use MQTT admin notifications can then receive them by doing a
            // Dojo subscribe. *Not* an MQTT subscribe (because we're doing it here).
            window.wsConnection.subscribe(topicName);
          }
        }));

        ///// FILTER - start  ////////////////
        this.initFilteringOptions();
        ///// FILTER - end    ////////////////

        /////
        // TREE - Start ///////////////////////////////
        var explorerTree_store = new Observable(new CustomJsonRest({
          target:"//" + window.location.host
        }));

        this._explorerTree = new CustomTree({ // create a tree
          model: explorerTree_store
        }, "explorerTree"); // target HTML element's id

        this._explorerTree.startup();
        // TREE - End ///////////////////////////////

        // Send any mouse click events to the tree slide bar to the _hideShowTree function.
        on(document, "._treeSlideBar:click,._treeSlideBar:touchend", lang.hitch(this,
          function(event){
            this._hideShowTree(event);
          }
        ));

        // Add hover effect when over the slider
        on(document, "._treeSlideBar:mouseover,._treeSlideBar:touchstart", lang.hitch(this, function(){
          if(this._treeHidden==="true") {
            domClass.add("_treeSlideBar", "_treeSlideBar_close_hover");
            domClass.remove("_treeSlideBar", "_treeSlideBar_open_hover");
            domClass.remove("_treeSlideBar", "_treeSlideBar_open");
            domClass.remove("_treeSlideBar", "_treeSlideBar_close");
          } else {
            domClass.remove("_treeSlideBar", "_treeSlideBar_close_hover");
            domClass.add("_treeSlideBar", "_treeSlideBar_open_hover");
            domClass.remove("_treeSlideBar", "_treeSlideBar_open");
            domClass.remove("_treeSlideBar", "_treeSlideBar_close");
          }
        }));

        // Remove hover effect when leaving the slider
        on(document, "._treeSlideBar:mouseout", lang.hitch(this, function(){
          if(this._treeHidden==="true") {
            domClass.remove("_treeSlideBar", "_treeSlideBar_close_hover");
            domClass.remove("_treeSlideBar", "_treeSlideBar_open_hover");
            domClass.remove("_treeSlideBar", "_treeSlideBar_open");
            domClass.add("_treeSlideBar", "_treeSlideBar_close");
          } else {
            domClass.remove("_treeSlideBar", "_treeSlideBar_close_hover");
            domClass.remove("_treeSlideBar", "_treeSlideBar_open_hover");
            domClass.add("_treeSlideBar", "_treeSlideBar_open");
            domClass.remove("_treeSlideBar", "_treeSlideBar_close");
          }
        }));

        // Create the tab container and create instances of each widget being used.
        this._createTabContainer();

        // These widgets are necessary because they handle clicks in the
        // explorer tree.
        window.tabWidgets.push(
          new app_overview({id: "webui.widgets.application.app_overview"}),
          new restApi_Overview({id: "webui.widgets.restapi.Overview"}),
          new lib_overview({id: "webui.widgets.libraries.lib_overview"}),
          new shlib_overview({id: "webui.widgets.sharedlibraries.shlib_overview"}),
          new broker_overview({id: "webui.widgets.broker.broker_overview"}),
          new eg_overview({id: "webui.widgets.executiongroup.eg_overview"}),
          new msgflow_overview({id: "webui.widgets.msgflows.msgflow_overview"}),
          new subflow_overview({id: "webui.widgets.subflows.subflow_overview"}),
          new resource_overview({id: "webui.widgets.resources.resource_overview"}),
          new svc_overview({id: "webui.widgets.service.svc_overview"}),
          new businesstransactions({id: "webui.widgets.business.businesstransactions"}),
          new businesstransaction_overview({id: "webui.widgets.business.businesstransaction_overview"}),
          new policy_overview({id: "webui.widgets.policy.policy_overview"}),

          // Need to create an instance here so we can add a context-menu to
          // configurable service nodes:
          new cs_overview({id: "webui.widgets.configurableservice.cs_overview"}),

          // Need to create an instance here so we can add a context-menu to
          // the configurable services node:
          new cs_category_overview({id: "webui.widgets.configurableservice.cs_category_overview"})
        );

        // If a webuser does not have broker permissions then in order to see this page they must
        // have permission for DC. Only show the Data Viewer by default.
        if(!window.currentuser.userPermission("broker", "read")){
          domStyle.set("_explorerTree_treeContainer", "opacity", "0");
          this._treeHidden = "true";
          attr.set("_explorerTree_treeContainer","style","width:0px");
        }

        // Run some functions after the page has loaded.
        ready(lang.hitch(this, function(){
          //Start web socket connection
          window.wsConnection = new wsHandler();

          domClass.add("_explorerTree_treeContainer_splitter","_treeSliderWrapper");
          construct.place(this._explorerTree.domNode, "_tree_ID");
          // Add a child div to the tab container's splitter
          var n = construct.create("div", { "class":"_treeSlideBar", "id":"_treeSlideBar" });
          construct.place(n, "_explorerTree_treeContainer_splitter");
          // Take the position of the tree after rendering so it can be used in the _hideShowTree function.
          this._treeDivWidth = domGeom.position('_explorerTree_treeContainer', true).w;
          domClass.add("_treeSlideBar","_treeSlideBar_open");
          attr.set("_infoPaneTitleID", "innerHTML", NLS.brokerTitle);
          domClass.replace("_infoPaneTitleImageID", "infoPaneTitle_broker");

          registry.byId("_explorerBorderContainer_ID").layout();

          // Detect any changes in the URI's hash
          topic.subscribe("/dojo/hashchange", lang.hitch(this, this._router));
          // Act on the initial value of hash().
          // If a webuser has broker permissions then show the tree and open the
          // broker page by default
          if(hash()){
            this._router("");
          } else if(window.currentuser.userPermission("broker", "read")){
            hash(Resources.REST.nodeHome);
          }
          else {
            hash("dataCaptureStores/0/data/datacapture");
            domStyle.set("_explorerTree_treeContainer", "opacity", "0");
            domClass.remove("_treeSlideBar","_treeSlideBar_open");
            domClass.add("_treeSlideBar","_treeSlideBar_close");
            domClass.remove("_treeSlideBar", "_treeSlideBar_close_hover");
            domClass.remove("_treeSlideBar", "_treeSlideBar_open_hover");
            domClass.remove("_explorerTree_treeContainer_splitter", "dijitSplitterHover");
          }

          // Detect when a tab (dijit.layout.ContentPane) is selected (focused) or
          // unselected (blurred) and inform the relevant widget. But not when the
          // tree has been clicked as the creation of the tabs can cause a false positive.
          // oval and nval are dijit.layout.ContentPane objects.
          // If we just selected a new object in the explorer tree, oval
          // is undefined.
          this._tabContainer.watch("selectedChildWidget", lang.hitch(this, function(name, oval, nval) {
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "?.selectedChildWidget.changed",[name, oval, nval]);

            // Update the tab ID number in the hash.
            // We assume that the rest of the hash is correct.
            var infoPaneTabs = nval.domNode.parentNode.parentNode.childNodes;
            var i;
            for(i = 0; i < infoPaneTabs.length; i++) {
              var tab = infoPaneTabs[i].firstChild;

              if (tab.id === nval.id) {
                var oldWebUiHash = new WebUiHash(hash());
                var newWebUiHash = new WebUiHash({
                  "type" : oldWebUiHash.getType(),
                  "tabNum" : i.toString(),
                  "components" : oldWebUiHash.getComponents()
                });

                var newHash = newWebUiHash.toString();
                this.safelyChangeHash(newHash);
                break;
              }
            }

            // If we just selected a new element from the explorer tree, "old ContentPane" is undefined.
            // Otherwise, we need to blur the old ContentPane:
            if ( oval ) {
              if (
                dom.byId(oval.id) &&
                dom.byId(oval.id).lastChild &&
                dom.byId(oval.id).lastChild.id
              ){
                var blurredWidget = registry.byId(dom.byId(oval.id).lastChild.id);
                if (blurredWidget) {
                  blurredWidget.tabBlur();
                }
              }//if
            }//if

            // Focus on the new ContentPane.
            if (
              dom.byId(nval.id) &&
              dom.byId(nval.id).lastChild &&
              dom.byId(nval.id).lastChild.id
            ){
              var focusedWidget = registry.byId(dom.byId(nval.id).lastChild.id);
              if (focusedWidget) {
                focusedWidget.tabFocus();
              }
            }//if

            Trace.trace(this.declaredClass, Trace.levels.EXIT, "?.selectedChildWidget.changed");
          }));

        }));

        var _tree_filtering_options = dom.byId("_tree_filtering_options");
        if (_tree_filtering_options !== undefined){
          var anchorText = NLS.filterOptions_label;
          construct.place("<a id='_filtering_anchor' href='javascript:;'>" +  anchorText + "</a>", _tree_filtering_options);

          var filter_anchor = dom.byId("_filtering_anchor");
          if (filter_anchor !== undefined){

            on(filter_anchor, "click", lang.hitch(this, function(){
              this._showFilteringOptionsDialog();
            }));

          }//if
        }//if

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
      },

      /**
       * "Routing" is the act of turning a URL (including its path, query string
       * and hash) into a rendered page.
       * This function is called when the hash changes (either changed by a
       * "hash('blah')" call or manually by the user typing in the address bar)
       */
      _router: function(message){

        // It is necessary to be able to change the hash without this routing
        // function being called, resulting in this slightly unpleasant approach
        // (see safelyChangeHash() for the other side).
        if(message === "ignoreNext") {
          this._ignoreNextHashChange = true;
          return;
        }

        var oldHash = this._oldHash;
        var newHash = hash();

        if(this._ignoreNextHashChange){
          // Do nothing
          this._ignoreNextHashChange = false;
          this._oldHash = newHash;
          return;
        }

        // Can we actually show new content right now? What if there's
        // unsaved work that would be lost?

        var tabWidgets = this._tabContainer.getChildren().map(
          function(contentPane) {
            return contentPane.content;
          }
        );

        var showNewContent = true;
        tabWidgets.forEach(
          function(tabWidget) {
            if(tabWidget.canChangeHash === undefined) {
              return;
            }

            // This call could cause a side-effect of a popup prompting for
            // confirmation. Or not.
            if(tabWidget.canChangeHash(oldHash, newHash) === true) {
              return;
            }

            showNewContent = false;
          }
        );

        // No popup, green light, show the new content
        if(showNewContent) {
          this._showContent(oldHash, newHash);
          // Retain previous hash
          this.previousHash = this._oldHash;
          this._oldHash = newHash;
          return;
        }

        // Can't show new content right now; one of the currently visible
        // tabs forbade it. (Safely) undo the change to the hash and await
        // further instructions
        this.safelyChangeHash(oldHash);
      },

      resize: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
      },

      _hideTree: function(/*optional*/ duration) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_hideTree");

        if(!this._divMoving){
          this._divMoving = true;  // Don't want to initiate another move until this one is completed
          this._treeDivWidth = domGeom.position('_explorerTree_treeContainer', true).w;
          this._originalTreeWidth = this._treeDivWidth;
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Slider closing from " + this._treeDivWidth + "px");

          duration = 1000;

          coreFx.combine([
            fx.animateProperty({
              node:"_explorerTree_treeContainer",
              properties: {
                width: 0
              },
              duration: duration,
              easing: easing.cubicIn,
              onAnimate: function() {
                registry.byId("_explorerBorderContainer_ID").layout();
              },
              onEnd: lang.hitch(this, function(){
                registry.byId("_explorerBorderContainer_ID").layout();
                domStyle.set("_explorerTree_treeContainer", "opacity", "0");

                domClass.remove("_treeSlideBar","_treeSlideBar_open");
                domClass.add("_treeSlideBar","_treeSlideBar_close");
                domClass.remove("_treeSlideBar", "_treeSlideBar_close_hover");
                domClass.remove("_treeSlideBar", "_treeSlideBar_open_hover");
                domClass.remove("_explorerTree_treeContainer_splitter", "dijitSplitterHover");

                this._treeHidden = "true";
                this._treeDivWidth = domGeom.position('_explorerTree_treeContainer', true).w;
              })
            }),
            fx.fadeOut({
              node: "_explorerTree_treeContainer",
              delay: 300,
              duration: 400
            })
          ]).play();
        }
        this._divMoving = false;

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_hideTree");
      },

      _showTree : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showTree");

        if(!this._divMoving){
          this._divMoving = true;  // Don't want to initiate another move until this one is completed
          var duration = 600;
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Slider opening to " + this._originalTreeWidth + "px");

          coreFx.combine([
            fx.animateProperty({
              node: "_explorerTree_treeContainer",
              //onBegin: domStyle.set("_explorerTree_treeContainer", "opacity", "100"),
              onAnimate: function() {
                registry.byId("_explorerBorderContainer_ID").layout();
              },
              properties: {
                width: this._originalTreeWidth
              },
              duration: duration,
              onEnd: lang.hitch(this, function(){
                domClass.add("_treeSlideBar","_treeSlideBar_open");
                domClass.remove("_treeSlideBar","_treeSlideBar_close");
                domClass.remove("_treeSlideBar", "_treeSlideBar_close_hover");
                domClass.remove("_treeSlideBar", "_treeSlideBar_open_hover");
                domClass.remove("_explorerTree_treeContainer_splitter", "dijitSplitterHover");

                domClass.add("_treeSlideBar", "_treeSlideBar_open");
                domClass.remove("_treeSlideBar", "_treeSlideBar_close");

                this._treeHidden = "false";
                this._treeDivWidth = domGeom.position('_explorerTree_treeContainer', true).w;
              })
            }),
            fx.fadeIn({
              node: "_explorerTree_treeContainer",
              delay: 300,
              duration: 300
            })
          ]).play();

        }
        this._divMoving = false;

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showTree");
      },

      _applyFilteringOptions : function(newResourceFilterOption,newConfigServicesFilterOption) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_applyFilteringOptions");

        this._saveFilteringOptions(newResourceFilterOption,newConfigServicesFilterOption);

        this._refreshTreeAfterViewOptionChange();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_applyFilteringOptions");
      },

      _showFilteringOptionsDialog : function() {

        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showFilteringOptionsDialog");

        this._destroyFilteringOptionsDialogIfItExists();
        //ensures we don't create multiple dialogs in memory

        this._filteringOptionsDialog = new FilteringOptionsDialog ({
          cback        : lang.hitch(this, this._applyFilteringOptions),
          filterResources : this.filterResources,
          filterConfigServices : this.filterConfigServices
        });

        this._filteringOptionsDialog.startup();
        this._filteringOptionsDialog.show();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showFilteringOptionsDialog");
      },

      _destroyFilteringOptionsDialogIfItExists : function() {
        if (this._filteringOptionsDialog) {
          this._filteringOptionsDialog.destroy();
          this._filteringOptionsDialog = null;
        }
      },

      /** Public */
      moveSlideBar : function() {
        // Move the Slide Bar to a designated position
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "moveSlideBar");

        var currentTreeWidth = domGeom.position('_explorerTree_ID', true).w;
        var treeDivWidth = registry.byId('_explorerTree_ID').domNode.scrollWidth;
        if((parseInt(currentTreeWidth, 10)<((parseInt(treeDivWidth, 10))))&&(this._treeHidden==="false")) {
          var newWidth = treeDivWidth + 10;

          if(!this._divMoving){
            this._divMoving = true;  // Don't want to initiate another move until this one is completed
            this.treeDivInfo = domGeom.position('_explorerTree_treeContainer', true);
            this.infoPaneDivInfo = domGeom.position('_explorerTree_infoPaneContainer', true);
            this.splitterDivInfo = domGeom.position('_explorerTree_treeContainer_splitter', true);
            this.newInfoPaneWidth = parseInt(this.infoPaneDivInfo.w, 10) - (newWidth - parseInt(this.treeDivInfo.w, 10));

            var duration = 600;
            var delay = 600;

            fx.animateProperty({
              delay: delay,
              node:"_explorerTree_treeContainer",
              onAnimate: function() {
                registry.byId("_explorerBorderContainer_ID").layout();
              },
              properties: {
                left: 0,
                width: newWidth
              },
              duration: duration,
              onEnd: lang.hitch(this, function() {
                this._treeDivWidth = domGeom.position('_explorerTree_treeContainer', true).w;
                Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Slider moved to " + this._treeDivWidth + "px");
              })
            }).play();
          }
          this._divMoving = false;
        } else {
          registry.byId("_explorerBorderContainer_ID").layout();
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "moveSlideBar");
      },

      /**
       * This function gets called when the user clicks an entry in the explorer
       * tree, and in a few other cases as well. The function creates the "info
       * pane" (central pane, containing one or more tabs widgets of information
       * about the selected entry).
       * "event.type" contains the type of entry which was clicked on, e.g.
       * "application", "broker". See Layout.json for the list of tab widgets
       * which get created in each case.
       * If "rebuild" is false, we just select a tab which is assumed to already
       * exist, rather than (re)creating it.
       * tabNumber: select this tab afterwards (0, 1, ...)
       * TODO: this method is called from numerous other places but it SHOULD NOT BE.
       */
      createInfoPane : function(event, /*boolean*/ rebuild, tabNumber) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createInfoPane");

        // Move the slider if needed
        this.moveSlideBar();

        // Using the 'type' defined in the tree's JSON, delete and add the relevant tabs in the info pane.
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Create InfoPane for: " + event.type + ": Rebuild: " + rebuild);
        if(event.type){
          // Need to store this for later, since the process of deleting/creating
          // tabs modifies the value.
          if(tabNumber === undefined) {
            tabNumber = new WebUiHash(hash()).getTabNum();
          }

          if(rebuild && Layout[event.type] !== undefined){

            this._deleteAllTabs();
            var widgetLayout = Layout[event.type];
            if(widgetLayout.title === undefined){
              console.error("Widget for " + event.type + " has no 'title' defined in the Layout.json");
              attr.set("_infoPaneTitleID", "innerHTML", "");
            } else {
              attr.set("_infoPaneTitleID", "innerHTML", NLS[widgetLayout.title]);
            }

            if (event.type === "resource"){

              var resource_infoPaneTitleImageID = "infoPaneTitle_resource_generic";

              var fileName = event.name;// a.wsdl
              var dotIndex = fileName.lastIndexOf(".");
              if ( dotIndex !== -1 ) {
                var extension = fileName.substring(dotIndex+1);
                extension = extension.toLowerCase();//important

                if (
                   ("rules"        === extension) ||
                   ("esql"         === extension) ||
                   ("jar"          === extension) ||
                   ("map"          === extension) ||
                   ("mar"          === extension) ||
                   ("php"          === extension) ||
                   ("xsl"          === extension) ||
                   ("xslt"         === extension) ||
                   ("xsd"          === extension) ||
                   ("wsdl"         === extension) ||
                   ("xsdzip"       === extension) ||
                   ("appdomainzip" === extension) ||
                   ("dictionary"   === extension) ||
                   ("inadapter"    === extension) ||
                   ("outadapter"   === extension)
                ){
                  resource_infoPaneTitleImageID = "infoPaneTitle_resource_" + extension;
                }

              }//if

              domClass.replace("_infoPaneTitleImageID", resource_infoPaneTitleImageID );

            }//if
            else {

              domClass.replace("_infoPaneTitleImageID", widgetLayout.icon);

            }//endif

            array.forEach(widgetLayout.widgets, lang.hitch(this, function(widget){
              var createTab = true;
              // Check for any permissions to determine if tab should be created
              if(widget.permissions){
                createTab = window.currentuser.userPermission(widget.permissions.split(",")[0], widget.permissions.split(",")[1]);
              }

              if(!createTab){
                return;
              }

              var tabWidget = null;
              if(widget.id === undefined){
                Trace.trace(this.declaredClass, Trace.levels.WARNING, event.type + " widget has no 'id' parameter defined in the Layout.json");
                widget.id = widget.widget;
              }
              if(widget.icon === undefined){
                Trace.trace(this.declaredClass, Trace.levels.WARNING, event.type + " widget has no 'icon' parameter defined in the Layout.json");
                widget.icon = null;
              }

              // Look through widget array to see if widget exists.
              // If it does not exist then create the widget and add it to the array
              Trace.trace(this.declaredClass, Trace.levels.DEBUG,"Look through widget array to see if "+ widget.widget+
                 " exists. If it does not exist then create the widget and add it to the array");
              array.forEach(window.tabWidgets, lang.hitch(this, function(loadedWidget){
                if(loadedWidget.id === widget.widget){
                  tabWidget = loadedWidget;
                }
              }));

              if(!tabWidget){

                // An explicit list of all our widgets.
                var constructors = {
                  "webui.widgets.adminlog.adminlog" : adminlog,
                  "webui.widgets.application.app_overview" : app_overview,
                  "webui.widgets.broker.broker_overview" : broker_overview,
                  "webui.widgets.business.businesstransactions" : businesstransactions,
                  "webui.widgets.business.businesstransaction_overview" : businesstransaction_overview,
                  "webui.widgets.business.businesstransaction_configuration" : businesstransaction_configuration,
                  "webui.widgets.business.businesstransaction_results" : businesstransaction_results,
                  "webui.widgets.common.StatisticsContainer" : StatisticsContainer,
                  "webui.widgets.configurableservice.cs_category_overview" : cs_category_overview,
                  "webui.widgets.configurableservice.cs_overview" : cs_overview,
                  "webui.widgets.dataviewer.DataViewer" : DataViewer,
                  "webui.widgets.dataviewer.Replay" : Replay,
                  "webui.widgets.executiongroup.eg_overview" : eg_overview,
                  "webui.widgets.executiongroup.eg_resource_statistics" : eg_resource_statistics,
                  "webui.widgets.libraries.lib_overview" : lib_overview,
                  "webui.widgets.msgflows.msgflow_overview" : msgflow_overview,
                  "webui.widgets.msgflows.msgflow_activityLog" : msgflow_activityLog,
                  "webui.widgets.msgflows.msgflow_statistics" : msgflow_statistics,
                  "webui.widgets.my_profile.MyProfile_Properties" : MyProfile_Properties,
                  "webui.widgets.operation.operation_overview" : operation_overview,
                  "webui.widgets.policy.policy_attach" : policy_attach,
                  "webui.widgets.policy.policy_overview" : policy_overview,
                  "webui.widgets.resources.resource_overview" : resource_overview,
                  "webui.widgets.restapi.Api" : restApi_Api,
                  "webui.widgets.restapi.Overview" : restApi_Overview,
                  "webui.widgets.service.svc_overview" : svc_overview,
                  "webui.widgets.sharedlibraries.shlib_overview" : shlib_overview,
                  "webui.widgets.subflows.subflow_overview" : subflow_overview
                };

                var Constructor = constructors[widget.widget];
                if(!Constructor) {
                  throw new Error("Widget not found: '" + widget.widget + "'");
                }

                tabWidget = new Constructor({
                  id: widget.widget,
                  event: event
                });
                Trace.trace(this.declaredClass, Trace.levels.DEBUG,"Get the object for new widget "+ tabWidget);

                window.tabWidgets.push(tabWidget);
              }

              this._createWidgetTab(widget.id, tabWidget, NLS[widget.title], widget.icon);
            }));
          }

          // Select the correct tab.
          this._selectTab(tabNumber);
        }
        registry.byId("_explorerBorderContainer_ID").layout();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "createInfoPane");
      },

      _createTabContainer : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createTabContainer");

        // Create the tab container
        var tc = new TabContainer({
          style: "height: 100%; width: 99%;",
          id: "_infoPaneTabContainer_ID"
        });
        construct.place(tc.domNode, "_explorerTree_infoPane", "only");
        tc.startup();

        this._tabContainer = tc;

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createTabContainer");
      },

      // This is called whenever we stop viewing one ContentPane (e.g. for a
      // broker) and start viewing a ContentPane for a different object in the
      // explorer tree (e.g. an execution group). We need to delete all of the
      // existing tab widgets before creating new ones.
      _deleteAllTabs : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_deleteAllTabs");

        var tabManager = this._tabContainer;
        var selectedTab = null;
        var traceWidgetName = this.declaredClass;

        //Remove all tabs except the current selected one (triggers a tab switch which creates new tabs - don't want that yet')
        array.forEach(tabManager.getChildren(), function(item){
          var tabObject = dom.byId(item.id);//convert from widget to dojo object

          if(item.selected && selectedTab === null ){
            Trace.trace(traceWidgetName, Trace.levels.DEBUG, "Tab "+tabObject.id+" is selected, skipping");
            selectedTab = item;
          }else{
            Trace.trace(traceWidgetName, Trace.levels.DEBUG, "Removing tab "+tabObject.id);

            if (  ( tabObject.lastChild) && (tabObject.lastChild.id) ){

              var widgetToRemove = registry.byId(tabObject.lastChild.id);

              if (widgetToRemove){
                widgetToRemove.tabRemove();
                tabManager.removeChild(item); // removes the tab, but don't destroy it.
              }//if

            }//if

          }
        });//end forEach

        //finally remove the selected tab
        if(selectedTab){
          var tabObject = dom.byId(selectedTab.id);
          Trace.trace(traceWidgetName, Trace.levels.DEBUG, "Removing tab "+selectedTab.id);

          if ( (tabObject.lastChild) && (tabObject.lastChild.id) ) {
            var widgetToRemove = registry.byId(tabObject.lastChild.id);
            widgetToRemove.tabRemove();
          }//if

          tabManager.removeChild(selectedTab); // removes the tab, not sure if we destroy the actual object behind it though...
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_deleteAllTabs");
      },

      // This is called whenever a new widgetTab is created. Most calls occur
      // inside createInfoPane() when you click something in the explorer
      // tree.
      // tabID : This can be any string and is used to determine if the tab already exists and therefore doesn't need to be re-created
      // tabWidget: The widget to be displayed in the tab
      // title: The title of the tab
      _createWidgetTab : function(tabID, tabWidget, title, /*optional*/iconClass) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createWidgetTab", arguments);

        if(!iconClass){
          iconClass = "dijitNoIcon";
        }
        // Check that the tabs to be displayed exist. If they do, show them. If they don't, create them.
        // We reuse the same tab widget on multiple pages. E.g. the statistics tab widget for one application
        // is the same statistics tab widget as for all other applications, and in fact other artifacts with
        // statistics tabs.
        var tabExists = registry.byId(tabID);
        if(!tabExists){
          this._validateTabWidget(tabWidget);
          tabExists = new ContentPane({
            content: tabWidget,
            title: title,
            style: "height: 100%; width: 100%; padding-left: 0px; padding-right: 0px;",
            closable: false,
            iconClass: iconClass,
            id: tabID
           });
           Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Created tab: " + tabID);
        }

        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Adding tab: " + tabID);
        this._tabContainer.addChild(tabExists);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createWidgetTab");
      },

      /** Validate that each tab widget has the minimum set of core methods */
      _validateTabWidget : function(tabWidget) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_validateTabWidget", [tabWidget]);

        var requiredMethods = ["tabRemove","postCreate", "resize", "tabFocus", "tabBlur"];

        array.forEach(requiredMethods, lang.hitch(this, function(method){
          if(tabWidget[method] === undefined){
            Trace.trace(this.declaredClass, Trace.levels.ERROR, "widget ''"+tabWidget.id+"' is missing the method "+method+"()");
          }
        }));

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_validateTabWidget", [tabWidget]);
       },

      // Typically there are several tabs in a ContentPane; select one of them.
      _selectTab : function(tabNumber) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_selectTab", [tabNumber]);

        var tabContainer = this._tabContainer;
        var children = tabContainer.getChildren();
        tabContainer.selectChild(children[tabNumber]);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_selectTab");
      },

      _hideShowTree : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_hideShowTree");

        // We only want to hide/show the tree if the click event is real (Not a drag event with the mouse then being released)
        // Detect if the scrollbar has moved. If is hasn't then hide/show the tree.
        var lastRecordedTreeWidth = this._treeDivWidth;
        var currentTreeWidth = domGeom.position('_explorerTree_treeContainer', true).w;
        if(Math.abs(currentTreeWidth - lastRecordedTreeWidth)<=5) {
          if(this._treeHidden==="true"){
            if(this._originalTreeWidth < 130){
              this._originalTreeWidth = 250;
            }
            this._showTree();
          } else {
            this._hideTree();
          }
        } else if ((domGeom.position('_explorerTree_treeContainer', true).w > 30)&&(this._treeHidden==="true")){
          this._showTree();
        } else if ((domGeom.position('_explorerTree_treeContainer', true).w < 130)&&(this._treeHidden==="false")){
          this._hideTree();
        }
        this._treeDivWidth = domGeom.position('_explorerTree_treeContainer', true).w;

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_hideShowTree");
      },

      /**
       * This method is called when a confirmation dialog is shown anywhere within the WebUI.
       * This method is public.
       */
      showConfirmationDialog : function(widgetId, type, confirmLabel, cancelLabel, message, confirmCallback, cancelCallback) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "showConfirmationDialog");

        var confirmationDialog = registry.byId(widgetId);

        if (typeof confirmationDialog === "undefined") {
          construct.create("div", { "id": widgetId }, document.body);
          confirmationDialog = new ConfirmationDialog({
            type : type,
            buttonLabel : confirmLabel,
            cancelButtonLabel : cancelLabel,
            text : message
          }, widgetId);
        } else {
          confirmationDialog._setTextAttr(message); // TODO: don't call private method of third-party obj
        }

        confirmationDialog.confirm(confirmCallback);
        confirmationDialog.cancel(cancelCallback);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "showConfirmationDialog");
      },

      showInfoDialog : function( message ) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "showConfirmationDialog");

          var widgetId = "myInfoDialog";
          var infoDialog = registry.byId(widgetId);
          
          var emptyCallBack = function() { };
          
          if (typeof infoDialog === "undefined") {
            construct.create("div", { "id": widgetId }, document.body);
            infoDialog = new ConfirmationDialog({
              type : "information",
              buttonLabel : NLS.okButtonLabel,
              cancelButtonLabel : NLS.cancelButtonLabel,
              text : message
            }, widgetId);
          } else {
        	  infoDialog._setTextAttr(message); // TODO: don't call private method of third-party obj
          }

          //workaround to hide the [x] button.
          domStyle.set( infoDialog.closeButtonNode,"display","none" );
          

          //workaround to find the two buttons of the dialog, and hide Cancel button
          dojoQuery(".messageAction > *").forEach(function(node, index){
        	  
        	  if (index==1){//hide Cancel button
        		  domStyle.set( node ,"display","none" );
        	  }

          });


          infoDialog.confirm(emptyCallBack);
          infoDialog.cancel(emptyCallBack);

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "showConfirmationDialog");
        },

      _supportsLocalStorage: function() {
        try {
          var name="test";
          var value = name + "Value";
          window.localStorage.setItem(name, value);
          window.localStorage.removeItem(name);
          return true;
        } catch (exception) {
          return false;
        }
      },

      initFilteringOptions: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "initFilteringOptions");

        if (!this._supportsLocalStorage() ){

          //
          // not possible to save these settings permanently
          //
          this.filterResources="all";// other option is "flows" for just message flows
          this.filterConfigServices= "ibm";// other option is "!ibm" for just message flows

        }//if
        else {

          //
          // set up  filterResources  value :
          //
          var name         = "wmbconsole_filter_resources";
          var defaultValue = "all";

          var currentValue = window.localStorage.getItem(name);
          if (!currentValue){
            //first time storing this value
            window.localStorage.setItem(name, defaultValue);
            this.filterResources = defaultValue;
          }//if
          else{
            // a value is already in storage
            this.filterResources = currentValue;
          }//endif

          //
          // set up  filterConfigServices  value :
          //
          name         = "wmbconsole_filter_config_services";
          defaultValue = "ibm";

          currentValue = window.localStorage.getItem(name);
          if (!currentValue){
            //first time storing this value
            window.localStorage.setItem(name, defaultValue);
            this.filterConfigServices = defaultValue;
          }//if
          else{
            // a value is already in storage
            this.filterConfigServices = currentValue;
          }//endif

        }//endif

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "initFilteringOptions");
      },

      _refreshTreeAfterViewOptionChange: function() {

        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_refreshTreeAfterViewOptionChange");

        //since recursiveNotifyChildren2 is recursive and likely makes asynchronous REST calls via
        //the JsonRest store, let's change the focus to the server node, and then ask the
        //tree to refresh itself

        hash(Resources.REST.nodeHome);

        var rootObjectPromise = this._explorerTree.model.get(Resources.REST.root);

        this._explorerTree.model.recursiveNotifyChildrenAfterFilterChange(rootObjectPromise);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_refreshTreeAfterViewOptionChange");
      },

      _saveFilteringOptions: function(resourceOption,configServicesOption) {

        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_saveFilteringOptions");

        if (!this._supportsLocalStorage() ){

          //
          // not possible to save these settings permanently
          //
          this.filterResources       = resourceOption;
          this.filterConfigServices  = configServicesOption;

        }//if
        else {

          this.filterResources       = resourceOption;
          this.filterConfigServices  = configServicesOption;

          //
          // save  filterResources  value :
          //
          var name         = "wmbconsole_filter_resources";
          window.localStorage.setItem(name, this.filterResources );


          //
          // save  filterConfigServices  value :
          //
          name         = "wmbconsole_filter_config_services";
          window.localStorage.setItem(name, this.filterConfigServices );

        }//endif

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_saveFilteringOptions");
      },

      // This visible method can be called if an object needs to be navigated to in the tree
      // and the hash safely updated, such that the page isn't refreshed.
      // This is typically useful for when a new object is created and stored to the broker.
      // Default behaviour is that the it should be pointed to by the WebUI, but no refresh is needed.
      expandTreeAndRefreshHash : function(newHash, changeHashRequired) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "expandTreeAndRefreshHash", [newHash]);

        var treePath = new WebUiHash(newHash).getRestUri().getTreePath();

        this._explorerTree.set('path', treePath).then(lang.hitch(this, function() {
          // Display the object to point to
          this._explorerTree.focusNode(this._explorerTree.get('selectedNode'));
          // Only update the hash if required, false maybe when hash is correct but focus has been lost on associated node in the tree
          if(changeHashRequired) {
            this.safelyChangeHash(newHash);
          }
        }));

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "expandTreeAndRefreshHash");
      },

      /**
       * This function should be called if we, the web UI, want to make a change
       * to the hash, but appropriate changes to the currently visible
       * ContentPane have already been made or are about to be made.
       * In general there are two such occasions: 1. when the user clicks in
       * the explorer tree; 2. when the user clicks on a new tab (ContentPane)
       */
      safelyChangeHash : function(newHash) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "safelyChangeHash", [newHash]);

        if(newHash !== hash()){

          // Update the hash but first temporarily disable the hashChange detection so we
          // don't end up invoking _showContent() in turn
          topic.publish("/dojo/hashchange", "ignoreNext");
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Setting hash: #" + newHash);
          hash(newHash);
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "safelyChangeHash");
      },

      /**
       * Take the current hash and use it to 1. highlight the appropriate
       * element in the explorer tree and 2. display the appropriate ContentPane
       * in the main TabContainer.
       * This is called when the hash is modified manually for any reason,
       * thanks to a subscription to /dojo/hashchange. It is also called once
       * when WMBConsole initially loads. See _router.
       */
      _showContent : function(oldHash, newHash) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showContent");

        // e.g. newHash is "executiongroup/0/executiongroups/default"

        var newWebUiHash = new WebUiHash(newHash);

        var newRestUri = newWebUiHash.getRestUri();

        var uriPath = newRestUri.toString();
        // "/apiv1/executiongroups/default"

        var uriArray = newRestUri.getTreePath();
        // [
        // "/apiv1",
        // "/apiv1/executiongroups",
        // "/apiv1/executiongroups/default"
        // ]

        this._explorerTree.set('path', uriArray);

        this._attributesStore.populateAttributesStore().then(lang.hitch(this, function() {

          // WMBConsole.createInfoPane() expects its first argument
          // to be the node in the explorer tree which the user just
          // selected. This object would be pulled directly out of the
          // explorer tree's backing store, and come complete with all
          // the information about it. Unfortunately if the user has
          // changed the URL manually, we don't know what the explorer
          // tree element is, exactly, so we need to add that
          // information manually:

          uriArray.type = newWebUiHash.getType();
          // e.g. "executiongroup"

          uriArray.name = newWebUiHash.getName();
          // e.g. "default"

          uriArray.uri = uriPath;
          // e.g. "/apiv1/executiongroups/default"

          // Only want to update the widget if it's required. Not when the tab
          // has changed.
          var reloadWidget = null;
          if(oldHash){
            var oldRestUri = new WebUiHash(oldHash).getRestUri();

            // Don't reload the widget if the widget has not changed.
            reloadWidget = (oldRestUri.toString() !== newRestUri.toString());
          } else {
            reloadWidget = true;
          }

          this.createInfoPane(uriArray, reloadWidget);
        }));

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showContent");
      }
    });
    return WMBConsole;
  }
);

},
'webui/widgets/common/StatisticsContainer':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="3832593933" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define(
  [
    "dojo/i18n!webui/nls/web",
    "dojo/text!./templates/StatisticsContainer.html",
    "dojo/text!webui/config/Layout.json",
    "dojo/_base/array",
    "dojo/_base/declare",
    "dojo/_base/lang",
    "dojo/data/ItemFileWriteStore",
    "dojo/date",
    "dojo/dom-attr",
    "dojo/dom-construct",
    "dojo/dom-style",
    "dojo/hash",
    "dojo/io-query",
    "dojo/number",
    "dojo/on",
    "dojo/query",
    "dojo/request/xhr",
    "dojo/string",
    "dojo/topic",
    "dijit/_WidgetBase",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/TitlePane",
    "dojox/grid/DataGrid",
    "dojox/grid/EnhancedGrid",
    "dojox/collections/Dictionary",
    "webui/config/Resources",
    "webui/utils/RestUri",
    "webui/utils/StatsUtils",
    "webui/utils/WebUiHash",
    "webui/widgets/common/Toolbar",
    "webui/widgets/common/Trace"
  ], function(
    NLS,
    template,
    Layout,
    array,
    declare,
    lang,
    ItemFileWriteStore,
    date,
    domAttr,
    domConstruct,
    domStyle,
    hash,
    ioQuery,
    number,
    on,
    query,
    xhr,
    string,
    topic,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    TitlePane,
    DataGrid,
    EnhancedGrid,
    Dictionary,
    Resources,
    RestUri,
    StatsUtils,
    WebUiHash,
    Toolbar,
    Trace
  ) {
    Layout = JSON.parse(Layout);

    return declare("webui.widgets.common.StatisticsContainer", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {

      templateString: template,
      _gridStore: null,
      _gridNodeStore: null,
      _messageFlowsArray: [],
      _updatedMessageFlowsArray: [],
      _statsTopicString: null,
      _statsTopicHandle: null,
      _messageSender: null,
      _tpStoreSet: null,
      _nodeStoreSet: null,
      _initialNotificationTopicNames: [],
      _initialNotificationTopicHandles: [],
      _notificationTopicNames : [],
      _notificationTopicHandles : [],
      _initNodesLoading : true,
      _anyFlowStatisticsOn: false, // true if there is at least one flow with statistics on
      _anyNodeStatisticsOn: false, // true if there is at least one flow with node statistics on
      _destroyMessageOnNewStats: true,
      _thresholdNodeNumbers : 200,
      _flowNodesNumbers : new Dictionary(),
      _nodesTablePresent : true, // becomes false if  too many nodes

      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");

        var gridLayout = [[{
          field : 'flowName',
          width : '300px',
          formatter : lang.hitch(this, this._insertFlow),
          name : NLS.statisticsFlow
        }, {
          field : 'messagesPerSecond',
          width : '100px',
          formatter : function(item){
            return number.format(item, {places: 2});
          },
          cellStyles: 'text-align: right',
          headerStyles: 'text-align: right',
          name : NLS.statistics.MessagesPerSecond
        }, {
          field : 'timePerMessage',
          width : '110px',
          formatter : this._formatNumber,
          cellStyles: 'text-align: right',
          headerStyles: 'text-align: right',
          name : NLS.statistics.TimePerMessage
        }, {
          field : 'avgCpuTime',
          width : '110px',
          formatter : this._formatNumber,
          cellStyles: 'text-align: right',
          headerStyles: 'text-align: right',
          name : NLS.statistics.CPU
        }, {
          field : 'messageCount',
          width : '80px',
          cellStyles: 'text-align: right',
          headerStyles: 'text-align: right',
          name : NLS.statistics.MessageCount
        }, {
          field : 'threadCount',
          width : '60px',
          cellStyles: 'text-align: right',
          headerStyles: 'text-align: right',
          formatter : lang.hitch(this, this._insertFlowThreadCount),
          name : NLS.statistics.ThreadCount
        }, {
          field : 'backouts',
          width : '67px',
          cellStyles: 'text-align: right',
          headerStyles: 'text-align: right',
          name : NLS.statistics.Backouts
        }, {
          field : 'containerName',
          width : '800px',
          formatter : lang.hitch(this, this._insertContainer),
          name : NLS.statisticsContainer
        }]];


        // setting width makes the table scrollable and easier to see longer flow names
        var gridLayoutNodes = [[{
          field : 'label',
          width : '300px',
          formatter : lang.hitch(this, this._formatFlowName),
          name : NLS.statisticsNode
        }, {
          field : 'avgElapsedTime',
          width : '105px',
          formatter : this._formatNumber,
          cellStyles: 'text-align: right',
          headerStyles: 'text-align: right',
          name : NLS.messageFlow_monitoring_elapsedtime_avg
        }, {
          field : 'avgCPUTime',
          width : '110px',
          formatter : this._formatNumber,
          cellStyles: 'text-align: right',
          headerStyles: 'text-align: right',
          name : NLS.messageFlow_monitoring_cputime_avg
        }, {
          field : 'totalElapsedTime',
          width : '90px',
          formatter : this._formatNumber,
          cellStyles: 'text-align: right',
          headerStyles: 'text-align: right',
          name : NLS.messageFlow_monitoring_elapsedtime
        }, {
          field : 'totalCPUTime',
          width : '90px',
          formatter : this._formatNumber,
          cellStyles: 'text-align: right',
          headerStyles: 'text-align: right',
          name : NLS.messageFlow_monitoring_cputime
        }, {
          field : 'invocationsCount',
          width : '78px',
          cellStyles: 'text-align: right',
          headerStyles: 'text-align: right',
          name : NLS.statistics.InvocationCount
        }, {
          field : 'nodeType',
          width : '200px',
          name : NLS.statisticsNodeType
        }, {
          field : 'parentFlow',
          width : '800px',
          formatter : lang.hitch(this, this._formatFlowName),
          name : NLS.statistics.parentFlow
        }]];


        // Create main toolbar
        this.toolbar = new Toolbar();
        domConstruct.place(this.toolbar.domNode, this._toolbar);

        this.toolbar.addLeftAlignButtons("title");

        if (!this.throughputTp) {
          this.throughputTp = new TitlePane({
            title : string.substitute(NLS.statisticsThroughputTitle, ["0"]),
            className : "_common_propertyTitle stats_titlePane claro"
          });
          this._statisticsTitlePane.appendChild(this.throughputTp.domNode);
          domAttr.set(this.throughputTp.domNode, "data-test-attrName", "statisticsThroughputTitlePane");
          domAttr.set(this.throughputTp.domNode, "class", "stats_titlePaneContainer");
        }
        var flowData = {
          identifier: "id",
          items: []
        };
        this._gridStore = new ItemFileWriteStore({
          data : flowData
        });

        this.throughputGrid = new EnhancedGrid({
          store : this._gridStore,
          structure : gridLayout,
          id : "statisticsThroughputGridID",
          height: "300px",
          className: "statisticsTable",
          escapeHTMLInData : true,
          keepSelection: true,
          fields:"",
          queryOptions: {cache: true},
          sortInfo: -2,
          clientSort: true,
          selectionMode: "single"
        }, document.createElement('div'));

        this.throughputGrid.canSort = function() {
          // all columns sortable
          return true;
        };

        this.throughputGrid.startup();

        var container = domConstruct.create("div");
        domConstruct.place(this.throughputGrid.domNode, container);

        // Add the grid to the titlePane
        this.throughputTp.set("content", container); //this.throughputGrid);

        if (!this.timePerNodeTp) {
          this.timePerNodeTp = new TitlePane({
            title : string.substitute(NLS.statisticsTimePerNodeTitle, [""]),
            className : "_common_propertyTitle stats_titlePane"
          });
          this._statisticsTitlePane.appendChild(this.timePerNodeTp.domNode);
          domAttr.set(this.timePerNodeTp.domNode, "data-test-attrName", "statisticsTimePerNodeTitlePane");
        }

        // Create time by node CPU grid
        var nodeData = {
          identifier: "id",
          items: []
        };
        this._gridNodeStore = new ItemFileWriteStore({
           data : nodeData
        });
        // grid for nodes
        this.nodesGrid = new DataGrid({
          store : this._gridNodeStore,
          id : "statisticsNodesGrid",
          structure : gridLayoutNodes,
          height: "300px",
          className: "statisticsTable",
          columnReordering : false,
          escapeHTMLInData : true,
          selectionMode: "multiple",
          keepSelection: true,
          queryOptions: {cache: true},
          sortInfo: -2,
          clientSort:true,
          selectable : true
        }, document.createElement('div'));
        this.nodesGrid.startup();

        // Create a div to contain the two grids for the time per node title pane
        var tpnGridContainer = domConstruct.create("div",{
          className: "stats_tpnGridContainer"
        });

        this.nodesGridSpan = domConstruct.create("span",{
          className: "stats_nodesGridSpan"
        });
        domConstruct.place(this.nodesGrid.domNode, this.nodesGridSpan);

        // Add the grid to the grid container
        domConstruct.place(this.nodesGridSpan, tpnGridContainer);

        // Add the container to the titlePane
        this.timePerNodeTp.set("content", tpnGridContainer);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
      },

      tabFocus: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");

        if (!this._checkStatisticsAvailable())  {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Statistics not available.");
          return;
        }

        this.handle1 = on(this.throughputGrid, "Click", lang.hitch(this, this._onMouseClickHandler));
        this.handle2 = on(this.nodesGrid, "Click", lang.hitch(this, this._onNodeMouseClickHandler));

        var loadingText = NLS.dataLoading;
        this.loadingDiv = domConstruct.create("div",{
            "class": "loadingOverlay pageOverlay",
            innerHTML: '<div class="loadingMessage">'+loadingText+'</div>'
        });

        this.throughputGrid.domNode.appendChild(this.loadingDiv);

        this.loadingNodesDiv = domConstruct.create("div",{
            "class": "loadingOverlay pageOverlay",
            innerHTML: '<div class="loadingMessage">'+loadingText+'</div>'
        });
        this.nodesGrid.domNode.appendChild(this.loadingNodesDiv);

        // will give up after 40 seconds
        setTimeout(lang.hitch(this, this._giveUp, "flows"), 40000);

        this._messageFlowsArray = [];

        // Clear the grid and old data
        var nodeData = {
          identifier: "id",
          items: []
        };
        this._gridNodeStore = new ItemFileWriteStore({
           data : nodeData
        });
        var flowData = {
          identifier: "id",
          items: []
        };
        this._gridStore = new ItemFileWriteStore({
          data : flowData
        });
        this.throughputGrid.setStore(this._gridStore);

        var pubSubEngine = true;    // does one exist?

        // Once the store has been loaded we now want to get the basic property values
        this.queueManagerName = window.brokerProperties.getProperty("advanced", "queueManager");
        //TODO: Check for MQTT not QM
        //if ((!this.queueManagerName) || (this.queueManagerName === "")) {
        //  window.smallMessage.displayMessage("error", "PubSub_unavailable", "",
        //    NLS.messages.PubSub_unavailableDescription);
        //  pubSubEngine = false;
        //}

        if (pubSubEngine) {
          // show loading for flows
          this._showLoading("flows");
          this._showLoading("nodes");

          // Once the store has been loaded we now want to get the basic property values
          var uri = new WebUiHash(hash()).getRestUri().toString();
          uri += Resources.REST.allFlowsDepth;

          xhr(
            uri,
            {
              handleAs : "json",
              headers : {
                 "Accept" : "application/json"
              }
            }
          ).then( lang.hitch(this, function(response) {
            this._populateThroughputGrid(response);
            this._performAllFlowsCheck();
          }));
        }

        // read in the URL nodes argument if any
        var urlParams = ioQuery.queryToObject(window.location.search.substr((document.location.search[0] === "?" ? 1 : 0)));
        this.maxNodesNumber = this._thresholdNodeNumbers;
        if(typeof urlParams.maxNodes == "string"){
          try {
            var param = parseInt(urlParams.maxNodes);
            if (!isNaN(param)) {
              this.maxNodesNumber = param;
            }
          }
          catch(Exception) {}
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
      },

      /**
       * add custom comparators to all numerical columns in the top table
       */
      _initCustomComparators: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_initCustomComparators");
        
        /**
         * `a` and `b` are two numerical values for message rates, cpu time etc. or `undefined`
         * Return positive if `a` is larger, negative if `b` is larger, 0 if equal
         */
        var comparatorFunction = lang.hitch(this, function (a, b) {
          // make `undefined` the smallest or largest, based on the sorting being done
          // this way, it's always at the bottom of the list and out of the way
          
          if (this.throughputGrid.getSortAsc()) {
            if(typeof a === 'undefined') { a = Infinity; }
            if(typeof b === 'undefined') { b = Infinity; }
          }
          else {
            if(typeof a === 'undefined') { a = -Infinity; }
            if(typeof b === 'undefined') { b = -Infinity; }
          }
          
          var result = Number(a) - Number(b);
          if(isNaN(result)) {
            // This happens if `a` and `b` are both `Infinity`, for example
            result = 0;
          }
          
          // ItemFileReadStore uses the dojo.data.util.sorter helper functions to implement item sorting.
          // The sorting function is expected to return 1, -1, or 0, base on whether the value for two items for the attribute was greater than, less than, or equal to, each other.
          // So let's ensure this happens by reverting larger/less than 1 or -1 to those respective values.
          if(result === Infinity) {
            result = 1;
          } else {
            if(result === -Infinity) {
              result = -1;
            } else {
              if(result > 0) {
                result = 1;
              } else {
                if(result < 0) {
                  result = -1;
                }
              }
            }
          }

          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "comparing "+ a +" "+b + " ascending:"+ this.throughputGrid.getSortAsc() + " result "+ result);
          return result;
        });

        this._gridStore.comparatorMap = {
          "messagesPerSecond" : comparatorFunction,
          "timePerMessage"    : comparatorFunction,
          "avgCpuTime"        : comparatorFunction,
          "messageCount"      : comparatorFunction,
          "threadCount"       : comparatorFunction,
          "backouts"          : comparatorFunction
        };

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_initCustomComparators");
      },

      // Determine whether live statistics are even available or not. If not,
      // display an error and return false. If so, return true.
      _checkStatisticsAvailable:function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_checkStatisticsAvailable");
        if (!window.WebSocket) {
          window.smallMessage.displayMessage("warning", "WebSocket_unsupported", "",
            NLS.messages.WebSocket_unsupportedDescription);
          return false;
        }

        // check the value of the control in the top level toolbar (?!)
        var disconnectedNodes = query('.realtimeDisconnected'); // 0 or 1
        //var connectedNodes = query('.realtimeConnected'); //0 or 1;
        if (disconnectedNodes.length>0) {
          window.smallMessage.displayMessage("warning", "WebSocket_unconnected", "",
            NLS.realtimeDisconnected);
          return false;
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_checkStatisticsAvailable");
        return true;
      },

      // Check on startup, and then on flow property change, whether stats are enabled.
      // If they aren't, put up an alert.
      _performAllFlowsCheck: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_performAllFlowsCheck");

        if(this._messageFlowsArray.length > 0) {
          // Assume all test criteria are true, change to false (and no longer test for) once one test disproves
          var flowNotRunning = true;
          var statsOff = true;
          var statsNotJson = true;
          var nodeStatsOff = true;
          var testMode = StatsUtils.isTestingOn();

          // Iterate around all the message flows, only when all meet the test criteria do we show the appropriate warning message
          array.forEach(this._messageFlowsArray, lang.hitch(this, function (messageFlow) {
            var isRunning = messageFlow.isRunning;
            var statsOn = messageFlow.snapshotStatistics && messageFlow.snapshotStatistics.enabled;
            var outputFormat = messageFlow.snapshotStatistics && messageFlow.snapshotStatistics.outputFormat;
            var nodeLevel = messageFlow.snapshotStatistics && messageFlow.snapshotStatistics.nodeLevel;

            // show error message if flow is not running, statistics are off or not in json mode (and not testing mode)
            if (flowNotRunning && (!isRunning && !testMode)) {
              // Flow is not running
              return;
            }

            // Set to flow not running to false, at least one flow is running
            if(flowNotRunning) {
              flowNotRunning = false;
            }

            if (statsOff && (!statsOn && !testMode)) {
              // Statistics are off
              return;
            }

            // Set stats off to false, at least one flow has stats on
            if(statsOff) {
              statsOff = false;
            }

            if (statsNotJson && (outputFormat && !outputFormat.json)) {
              // Format not json
              return;
            }

            // Set json stats to false, at least one flow has json stats on
            if(statsNotJson) {
              statsNotJson = false;
            }

            if (nodeStatsOff && (nodeLevel && nodeLevel==="none")) {
              // Node stats are not switched on
              return;
            }

            // Set node stats off to false, at least one flow has node stats on
            if(nodeStatsOff) {
              nodeStatsOff = false;
            }
          }));

          // Now that all message flows have been checked, establish if any warning message needs to be shown
          var multiple = this._messageFlowsArray.length > 1 ? true : false;

          // show error message if all flows are not running, statistics are off or not in json mode (and not testing mode)
          if (flowNotRunning && !testMode) {
            // Flow is not running
            if(multiple) {
              window.smallMessage.displayMessage("warning", "FlowsNotRunning_XX", "", NLS.messages.FlowMultipleNotRunningDescription);
            } else {
              window.smallMessage.displayMessage("warning", "FlowNotRunning_XX", "", NLS.messages.FlowNotRunningDescription);
            }
          } else if (statsOff && !testMode) {
            // Statistics are off
            if(multiple) {
              window.smallMessage.displayMessage("warning", "StatsOffMultiple_XX", "", NLS.messages.NodeStatsOffAllFlows_XX);
            } else {
              window.smallMessage.displayMessage("warning", "StatsOff_XX", "", NLS.messages.NodeStatsOffSingleFlow_XX);
            }
          } else if (statsNotJson) {
            // show error message if format not json - for now as we only control JSON statistics in the WebUI, have the same consistent error message shown
            if(multiple) {
              window.smallMessage.displayMessage("warning", "StatsOffMultiple_XX", "", NLS.messages.NodeStatsOffAllFlows_XX);
            } else {
              window.smallMessage.displayMessage("warning", "StatsOff_XX", "", NLS.messages.NodeStatsOffSingleFlow_XX);
            }
          } else if (nodeStatsOff) {
            if(multiple) {
              window.smallMessage.displayMessage("warning", "NodeStatsOffAllFlows_XX", "", NLS.messages.NodeStatsMultipleOffDescription);
            } else {
              // show warning message if node stats are not switched on
              var flowName = this._messageFlowsArray[0].name;
              window.smallMessage.displayMessage("warning", "NodeStatsOffSingleFlow_XX", "", string.substitute(NLS.messages.NodeStatsOffDescription, [flowName]));
            }
          } else {
            // Looks good - cancel any previous
            window.smallMessage.hideMessage();
          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_performAllFlowsCheck");
       },

      // This function is called manually when we stop looking at this tab.
      tabBlur: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");

        window.smallMessage.hideMessage();
        // do not unsubscribe on tabBlur
        if (this.loadingDiv) {
          this.throughputGrid.domNode.removeChild(this.loadingDiv);
          this.loadingDiv = null;
        }

        if (this.loadingNodesDiv) {
          if (this._nodesTablePresent) {
            this.nodesGrid.domNode.removeChild(this.loadingNodesDiv);
          }
          this.loadingNodesDiv = null;
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
      },

      // This function is called manually when we need to remove this tab.
      tabRemove: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
        // clear the tables before leaving s.t. when coming back to statistics tab you don't see stale data

        var nodeData = {
          identifier: "id",
          items: []
        };
        this._gridNodeStore = new ItemFileWriteStore({
          data : nodeData
        });
        var flowData = {
          identifier: "id",
          items: []
        };
        this._gridStore = new ItemFileWriteStore({
          data : flowData
        });
        this.throughputGrid.setStore(this._gridStore);
        if (this._nodesTablePresent) {
          this.nodesGrid.setStore(this._gridNodeStore);
        }

        // Inform the wsHandler to unsubscribe
        if(this._statsTopicString) {
          window.wsConnection.unsubscribe(this._statsTopicString);
          this._statsTopicString = null;
        }

        // Remove the subscribe handle
        if(this._statsTopicHandle){
          this._statsTopicHandle.remove();
        }

        // Remove the initial notification topic handles:
        this._removeInitialNotificationTopicHandles();

        for (var i=0; i < this._notificationTopicHandles.length; i++) {
          var handle = this._notificationTopicHandles[i];
          handle.remove();
        }

        this._notificationTopicNames = [];
        this.throughputTp.set('title', string.substitute(NLS.statisticsThroughputTitle, ["0"]));
        window.smallMessage.hideMessage();
        if (this.loadingNodesDiv && this._nodesTablePresent) {
          this.nodesGrid.domNode.removeChild(this.loadingNodesDiv);
          this.loadingNodesDiv = null;
        }
        if (this.loadingDiv) {
          this.throughputGrid.domNode.removeChild(this.loadingDiv);
          this.loadingDiv = null;
        }

        if (this.handle1) {
          this.handle1.remove();
        }
        if (this.handle2) {
          this.handle2.remove();
        }
        if (this.handle3) {
          this.handle3.remove();
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
      },


      _onMouseClickHandler: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onMouseClickHandler");

        /*
         * Future: if we want to change hash() with this onclick handler, use this:
         * if(event.srcElement.className == "stats_goTo"){
         *   //TODO: build proper hash
         *   hash("messageFlow/0/executiongroups/eg1/messageflows/FanIn");
         * }
         */
        if (!this._nodesTablePresent){
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onMouseClickHandler");
          return;
        }

        var index = this.throughputGrid.selection.selectedIndex;
        if (index<0) { // empty table
          return;
        }
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "selected "+ index);

        var rowData = this.throughputGrid.getItem(index);
        if (rowData) {
          //We need the index in the _messageFlowsArray, not the row, as it may have been sorted
          if (rowData.MessageFlowIndex && lang.isArray(rowData.MessageFlowIndex)){
            var selectedItem = this._messageFlowsArray[rowData.MessageFlowIndex[0]];

            // clear selection in bottom tables
            this.nodesGrid.selection.clear();
            var restUri = new RestUri(selectedItem.uri);

            Trace.trace(this.declaredClass, Trace.levels.DEBUG, " Searching nodes for with rest uri "+ restUri);


            this._showSelectionForNodeTable(this.nodesGrid, restUri);

          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onMouseClickHandler");
      },

      _showSelectionForNodeTable: function (grid, flowUri) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showSelectionForNodeTable");
        var containerName = flowUri;
        containerName = containerName.toString().replace("/apiv1/executiongroups/","");
        for (var i=0;i<grid.rowCount;i++) {
          var item = grid.getItem(i);
          if (!item) { continue; }
          if (item.parentFlow[0] == containerName) {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "For "+ flowUri+" select "+i +" "+ item.label);
            grid.selection.addToSelection(i);
          }

        }

        this._scrollToFirstSelection(grid);
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Selected "+ grid.selection.getSelectedCount()+" elements.");
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showSelectionForNodeTable");

      },

      _scrollToFirstSelection: function (grid) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_scrollToFirstSelection");
        var selection = grid.selection;
        if (selection) {
          var first = selection.getFirstSelected();
          if (first) {
            var index = grid.getItemIndex(first);
            if (index >=0) {
              grid.scrollToRow(index);
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "scroll to "+ index);
             }
          }
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_scrollToFirstSelection");
      },

      _onNodeMouseClickHandler: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onNodeMouseClickHandler");
        if (!this._nodesTablePresent) {
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onNodeMouseClickHandler");
          return;
        }
        var nodeIndex = -1;

        nodeIndex = this.nodesGrid.selection.selectedIndex;
        // clear the selections in bottom tables
        this.nodesGrid.selection.deselectAll();
        
        // select the node again
        this.nodesGrid.selection.addToSelection(nodeIndex);

        if (nodeIndex<0) { return; }
        // clear the top level table
        this.throughputGrid.selection.deselectAll();

        var selectedNode = this.nodesGrid.getItem(nodeIndex);
        var longParentName = selectedNode.parentFlow[0]; // parent flow in the shape <EG>/ <App>/ <Flow>
        var i = longParentName.lastIndexOf("/");
        var j = 1;
        if (i>=0) {
          for (var throughputGridIndex=0;throughputGridIndex<this.throughputGrid.rowCount;throughputGridIndex++) {

            var rowData = this.throughputGrid.getItem(throughputGridIndex);
            // rowData.containerName[0] contains a # !!
            // For example it might have AddressSampleConsumer#executionGroup
            // So we need to get the substring up to the first # !!!
            var rowContainer = rowData.containerName[0];
            var hashIndex = rowContainer.indexOf("#");
            if (hashIndex>0) {
              rowContainer = rowContainer.substring(0, hashIndex);
            }
            //console.log("This flow row container is " + rowContainer +" and is row number " + j);
            // Check if the entry in the flows table matches the entry in the nodes table
            if (rowContainer == longParentName){
              this.throughputGrid.selection.setSelected(throughputGridIndex, true);
              this.throughputGrid.scrollToRow(throughputGridIndex);
            }
            else {
                j++;
            }
          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onNodeMouseClickHandler");
      },

      _populateThroughputGrid: function(response){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_populateThroughputGrid");

        // Recurse the response and add any message flows to the _messageFlowsArray
        this._anyNodeStatisticsOn = false;
        this._destroyMessageOnNewStats = true;
        this._recurseTree(response);

        this._checkAndInitializeStatisticsData();

        this._statsTopicString = this._generateTopicName();

        this._nodeStoreSet = null;
        this._tpStoreSet = null;

        // Subscribe to the topic topicName
        this._statsTopicHandle = topic.subscribe(this._statsTopicString, lang.hitch(this, function(message) {
          var sender = message.destinationName;
          try {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Received subscription from "+this._statsTopicString +" "+message.payloadString);
          }
          catch (Exception) {}

          if(this._destroyMessageOnNewStats) {
            window.smallMessage.hideMessage();
          }

          var message2 = message.payloadString;
          this._messageSender = sender;
          var jsonData = JSON.parse(message2).WMQIStatisticsAccounting;
          var nodeData = {
            identifier: "id",
            items: []
          };

          array.forEach(this._messageFlowsArray, lang.hitch(this, function(messageFlow, i) {
            var gridMessageFlowsObj = {};
            gridMessageFlowsObj.statisticsEnabled = false;
            if (
              messageFlow.snapshotStatistics &&
              messageFlow.snapshotStatistics.enabled &&
              messageFlow.snapshotStatistics.outputFormat &&
              messageFlow.snapshotStatistics.outputFormat.json
            ) {
              gridMessageFlowsObj.statisticsEnabled = true;
            }

            try {
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "statisticsEnabled for "+ messageFlow.name+
                " enabled:"+ messageFlow.snapshotStatistics.enabled +
                " format:"+ messageFlow.snapshotStatistics.outputFormat.json +
                " nodeLevel:"+ messageFlow.snapshotStatistics.nodeLevel + " set to "+ gridMessageFlowsObj.statisticsEnabled);
            }
            catch (exc) {}

            gridMessageFlowsObj.id = messageFlow.uri;
            gridMessageFlowsObj.flowName = messageFlow.name;
            if (!messageFlow.isRunning) {
              gridMessageFlowsObj.flowName = gridMessageFlowsObj.flowName + "#stopped";
            }
            //store in the containerName field of the datastore both the name and the type.
            //gridMessageFlowsObj.containerName = decodeURIComponent(messageFlow.containerName)+"#"+messageFlow.containerType;

            var containerName = messageFlow.uri;
            containerName = containerName.replace("/apiv1/executiongroups/","");
            gridMessageFlowsObj.containerName = containerName;

            // Find which messageFlow (row in the grid) applies to the received stats message
            var senderStr = this._statsTopicString.split("SnapShot/")[1].replace("#","") + this._messageSender.replace(this._statsTopicString.replace("#", ""), "");
            var msgFlowStr = decodeURIComponent(messageFlow.uri).replace(Resources.REST.allFlowsURI + "/", "");

            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Comparing sender "+senderStr+ " to messageFlow "+ msgFlowStr);

            if (senderStr == msgFlowStr) {
              // Calculate the values for each column in the grid
              var TotalInputMessages = jsonData.MessageFlow.TotalInputMessages;

              var durationMs;
              try{
                var startDateObj = StatsUtils.parseStatsStartTime(jsonData.MessageFlow);
                var endDateObj   = StatsUtils.parseStatsEndTime(jsonData.MessageFlow);

                durationMs = date.difference(startDateObj, endDateObj, "millisecond");
                var durationSecond = date.difference(startDateObj, endDateObj, "second");
                this.throughputTp.set('title', string.substitute(NLS.statisticsThroughputFlowsTitle, [durationSecond, StatsUtils.formatToTime(endDateObj)]));
              }
              catch (Exc) {
                 Trace.trace(this.declaredClass, Trace.levels.ERROR, "Exception caught while parsing dates "+Exc +" start:"+
                 startDateObj +" end:"+ endDateObj);
              }
              if (durationMs >0) {
                gridMessageFlowsObj.messagesPerSecond = StatsUtils.formatToMillis(TotalInputMessages / durationMs * 1000 * 1000,2);
              }
              else {
                gridMessageFlowsObj.messagesPerSecond = 0;
              }
              if (TotalInputMessages > 0) {
                gridMessageFlowsObj.timePerMessage = StatsUtils.formatToMillis(jsonData.MessageFlow.TotalElapsedTime / TotalInputMessages);
                gridMessageFlowsObj.avgCpuTime = StatsUtils.formatToMillis(jsonData.MessageFlow.TotalCPUTime/TotalInputMessages);
                Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Computing cpu avg  " +jsonData.MessageFlow.TotalCPUTime +" "+TotalInputMessages +" "+gridMessageFlowsObj.avgCpuTime);
              }
              else {
                gridMessageFlowsObj.timePerMessage = 0;
                gridMessageFlowsObj.avgCpuTime = 0;
              }

              gridMessageFlowsObj.messageCount = TotalInputMessages;
              gridMessageFlowsObj.threadCount = jsonData.NumberOfThreads;
              gridMessageFlowsObj.backouts = String(jsonData.MessageFlow.TotalNumberOfBackouts);

              // the store has been created with names and containers for flows
              // now set the numbers
              this._gridStore.fetch({
                query: { id: messageFlow.uri },
                onComplete: lang.hitch(this, function(items) {
                  var newFlowObj = gridMessageFlowsObj;
                  var ii = i;
                  // stopped flows have flowName attribute like <flowName>#stopped
                  var index = newFlowObj.flowName.indexOf("#stopped");
                  // if the flow is stopped, do not get retained data
                   if((items.length > 0) &&(index<0)){ // flow found and running
                      // Id had been found to update the item
                    try {
                      var item = items[0];
                      this._gridStore.setValue(item, 'threadCount', newFlowObj.threadCount);
                      this._gridStore.setValue(item, 'messageCount', newFlowObj.messageCount);
                      this._gridStore.setValue(item, 'backouts', newFlowObj.backouts);
                      this._gridStore.setValue(item, 'timePerMessage',newFlowObj.timePerMessage);
                      this._gridStore.setValue(item, 'avgCpuTime', newFlowObj.avgCpuTime);
                      this._gridStore.setValue(item, 'messagesPerSecond', StatsUtils.formatToMillis(TotalInputMessages / durationMs * 1000 * 1000,2));
                      //for testing
                      if (this.throughputGrid.getRowNode(ii)) {
                        domAttr.set(this.throughputGrid.getRowNode(ii), "data-test-attrname", item.id);
                      }
                      //Add the index to the message flow array incase we get sorted and can't rely on our location
                      this._gridStore.setValue(item, 'MessageFlowIndex', ii);
                    }
                    catch (exc) {
                       Trace.trace(this.declaredClass, Trace.levels.ERROR, "Exception caught while updating flows store "+exc);
                    }
                  }
                })
              });

              if(this._nodeStoreSet){
                // We add to add a single line (id = 0) at the start which we should not remove
                this._gridNodeStore.fetch({
                  query: { id: 0},
                  onItem: lang.hitch(this, function(item){
                    this._gridNodeStore.deleteItem(item);
                  })
                });

                if (this._nodesTablePresent) {

                  if (this._flowNodesNumbers.entry(gridMessageFlowsObj.id) == 0) {// not initialised
                    this._flowNodesNumbers.add(gridMessageFlowsObj.id, jsonData.Nodes.length);
                  }
                  // adding the new nodes, would the maximum be reached
                  if (this._maxNodesReached()) {
                    this._clearOutNodesTables();
                    this._nodesTablePresent = false;
                  }
                }
                if (this._nodesTablePresent) {

                  // Gather information for each node
                  array.forEach(jsonData.Nodes, lang.hitch(this, function(node, j){
                    Trace.trace(this.declaredClass, Trace.levels.DEBUG, "receivedStatistics for "+node.Label);

                    var parentName = this._buildParentNameFromJson(jsonData.MessageFlow);
                    this._gridNodeStore.fetch({
                      query: { id: parentName + "_" + node.Label },
                      onComplete: lang.hitch(this, function(item) {
                        var avgCPU = 0;
                        var avgElapsed = 0;
                        if (node.CountOfInvocations >0) {
                          avgCPU = StatsUtils.formatToMillis(node.TotalCPUTime/node.CountOfInvocations);
                          avgElapsed = StatsUtils.formatToMillis(node.TotalElapsedTime/node.CountOfInvocations);
                        }
                        //console.log(" Parent name"+ parentName);
                        //console.dir(jsonData.MessageFlow);
                        if(item.length > 0){
                          // Id had been found to update the item
                          this._gridNodeStore.setValue(item[0], 'label', node.Label);
                          // mode.totalCPUTime and totalElapsedTime are in microseconds, convert to milliseconds

                          this._gridNodeStore.setValue(item[0], 'totalCPUTime',  StatsUtils.formatToMillis(node.TotalCPUTime));
                          this._gridNodeStore.setValue(item[0], 'totalElapsedTime', StatsUtils.formatToMillis(node.TotalElapsedTime));
                          this._gridNodeStore.setValue(item[0], 'nodeType', node.Type);
                          this._gridNodeStore.setValue(item[0], 'invocationsCount', node.CountOfInvocations);
                          this._gridNodeStore.setValue(item[0], 'avgCPUTime', avgCPU);
                          this._gridNodeStore.setValue(item[0], 'avgElapsedTime', avgElapsed);

                          this._gridNodeStore.setValue(item[0], 'parentFlow', parentName);
                        } else {
                          // Id has not been found so create new items
                          // mode.totalCPUTime and totalElapsedTime are in microseconds, convert to milliseconds
                          this._gridNodeStore.newItem({id: parentName + "_" + node.Label,
                            label: node.Label,
                            totalCPUTime: StatsUtils.formatToMillis(node.TotalCPUTime),
                            totalElapsedTime: StatsUtils.formatToMillis(node.TotalElapsedTime),
                            invocationsCount: node.CountOfInvocations,
                            avgCPUTime: avgCPU,
                            avgElapsedTime:avgElapsed,
                            nodeType: node.Type,
                            parentFlow: parentName
                          });
                        }
                      }),
                      onError: lang.hitch(this, function(){
                        Trace.trace(this.declaredClass, Trace.levels.ERROR, "Unable to update stats node data");
                      })
                    });
                    if (j==0) { // as soon as we start getting the first data, end the loading
                      this._endLoading("nodes");
                    }
                  }));

                  /*
                   *  Verify that all the nodes in the table were updated.
                   *  If the number of nodes in the table is greater than the number of nodes we received stats data for,
                   *  then there are nodes in the table that are no longer showing data of the last snapshot.
                   *  This could be we got no data on the node, or more likely that node doesn't exist, or has been renamed (to which the new name would have been added).
                   */
                  var parentName = this._buildParentNameFromJson(jsonData.MessageFlow);

                  this._gridNodeStore.fetch( { query: { parentFlow: parentName },
                    onComplete: lang.hitch(this, function(items) {
                      // Update the table manually by removing "old" nodes if some nodes haven't had snapshot stats data supplied for them.
                      // If we have "out-of-date" node data in the table, then go and clean up.
                      // console.log(jsonData);
                      if(items.length > jsonData.Nodes.length) {
                        // Iterate around the nodes in the NCT and check that there is a corresponding node in the snapshot data.
                        var nodeStatsArray = jsonData.Nodes;
                        var found = false;
                        array.forEach(items, lang.hitch(this, function(tableNode){
                          found = false;
                          var j = 0;
                          var statsNodeID = "";
                          while((!found) && (j<nodeStatsArray.length)) {
                            statsNodeID = parentName + "_" + nodeStatsArray[j].Label;
                            // Match on node name, else iterate to next node
                            if(tableNode.id[0] === statsNodeID) {
                              found = true;
                            } else {
                              j++;
                            }
                          }
                          // If we haven't found a match for the node in the table, then we need to remove it
                          if(!found) {
                            this._gridNodeStore.deleteItem(tableNode);
                          }
                        }));
                      }
                    }),
                    onError: lang.hitch(this, function(){
                      Trace.trace(this.declaredClass, Trace.levels.ERROR, "Unable to update stats node data");
                    })
                  });
                }
              }
            }
          }));

          if (this._nodesTablePresent) {
            for (var i=0;i<this.nodesGrid.rowCount;i++) {
              var item = this.nodesGrid.getItem(i);
              var rowNode = this.nodesGrid.getRowNode(i);
              if (item && rowNode) {
                domAttr.set(rowNode, "data-test-attrname", item.id);
              }
            }
          }

          // Only set the grid store the first time. (After that we'll update the contents of the store)
          if (!this._tpStoreSet) {
            this._initCustomComparators();
            this._tpStoreSet = true;

            // Remove the initial notification topic handles as they are no longer needed since
            // we are going to be registering new notification topic handles below:
            this._removeInitialNotificationTopicHandles();

            // Register new notification topic handles:
            this._registerNotificationTopicHandles(this._notificationTopicNames, this._notificationTopicHandles);
          }

          // Only set the node grid store the first time. (After that we'll update the contents of the store)
          if (!this._nodeStoreSet) {
            this._gridNodeStore = new ItemFileWriteStore({
              data : nodeData
            });
            this.nodesGrid.setStore(this._gridNodeStore);
            this._nodeStoreSet = true;
          }

          if (this._nodesTablePresent) {
            if(this._gridNodeStore.isDirty()){
              this._gridNodeStore.save();
              // make the nodesGrid redraw. this will reset the selection
              this.nodesGrid.render();
              this._scrollToFirstSelection(this.nodesGrid);
            }
          }
          if (this._nodesTablePresent) {
            this.throughputGrid.render();
          }
          // ow. give up on sorting


        }));
        this._endLoading("flows");

        // Inform the wsHandler to subscribe to the new topicName
        window.wsConnection.subscribe(this._statsTopicString);

        // Subscribe to the topic that will look to refresh the tab if content has changed
        var refreshTopic = new WebUiHash(hash()).getNotificationTopic(true); // plus wildcard
        this._notificationTopicHandles.push(topic.subscribe(refreshTopic, lang.hitch(this, this._refreshThroughputGrid)));

        // Register initial notification topic handles. If this is not done and statistics is disabled, Web UI may not
        // receive statistics updates when statistics is enabled without refreshing the Statistics tab first:
        this._registerNotificationTopicHandles(this._initialNotificationTopicNames, this._initialNotificationTopicHandles);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_populateThroughputGrid");
      },

      /**
       * Registers topic handles for the message flows in the store. Called when the statistics container
       * is initially created to register initial handles, and then called again when a message of
       * the IBM/IntegrationBus/<INTEGRATION_NODE_NAME>/Statistics/JSON/SnapShot/<INTEGRATION_SERVER_NAME>/#
       * topic is published:
       */
      _registerNotificationTopicHandles : function(notificationTopicNames, notificationTopicHandles) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_registerNotificationTopicHandles");

        this._gridStore.fetch({
          "query": { "id": '*' },
          "onItem": lang.hitch(this, function(item) {

            var restUri = new RestUri(item.id[0]);

            var notificationsTopicName = restUri.getNotificationTopic();
            if(notificationsTopicName) {
              notificationTopicNames.push(notificationsTopicName);
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "registering for notifications on topic "+notificationsTopicName);
              notificationTopicHandles.push(topic.subscribe(notificationsTopicName, lang.hitch(this, function() {
                this._refreshFlowDetails(restUri.toString());
              })));
            }

            // Register for notifications for all ancestor containers of this flow.

            var ancestorRestUris = [];
            var parentRestUri = restUri.getParentArtifactRestUri(); // becomes `null` at the top level
            while(parentRestUri) {
              ancestorRestUris.push(parentRestUri);
              parentRestUri = parentRestUri.getParentArtifactRestUri();
            }

            ancestorRestUris.forEach(lang.hitch(this, function(ancestorRestUri) {
              var t = ancestorRestUri.getNotificationTopic();
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "registering for notifications on container topic " + t);
              notificationTopicHandles.push(topic.subscribe(t, lang.hitch(this, function() {
                this._refreshContainerDetails(ancestorRestUri.toString());
              })));
            }));
          })
        });

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_registerNotificationTopicHandles");
      },

      // Removes the initial topic handles. Called when the tab is closing and after an
      // IBM/IntegrationBus/<INTEGRATION_NODE_NAME>/Statistics/JSON/SnapShot/<INTEGRATION_SERVER_NAME>/#
      // message is published:
      _removeInitialNotificationTopicHandles: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_removeInitialNotificationTopicHandles");

        // Remove initial handles:
        if (this._initialNotificationTopicHandles !== undefined && this._initialNotificationTopicHandles !== null) {
          for (var i = 0; i < this._initialNotificationTopicHandles.length; i++) {
            var handle = this._initialNotificationTopicHandles[i];
            handle.remove();
          }
          this._initialNotificationTopicHandles = [];
          this._initialNotificationTopicNames = [];
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_removeInitialNotificationTopicHandles");
      },

      _refreshContainerDetails : function(newUri) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_refreshContainerDetails", arguments);

        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "get URI:"+ newUri);

        xhr(
          newUri,
          {
            handleAs : "json",
            headers : {
               "Accept" : "application/json"
            }
          }
        ).then( lang.hitch(this, function(message) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_refreshContainerDetails.xhrLoad()", arguments);

          var messageFlows = message.messageFlow || [];
          for (var i=0; i<messageFlows.length;i++) {

            var restUri = new RestUri(messageFlows[i].uri);

            // Use the _refreshFlowDetails method directly to update the flow details table
            this._refreshFlowDetails(restUri.toString());

            // Call the check to see if within the container the flow status
            this._performAllFlowsCheck();
          }
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "_refreshContainerDetails.xhrLoad()");
        }));

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_refreshContainerDetails");
      },

      _refreshThroughputGrid : function(message) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_refreshThroughputGrid");

        // There is no way to subscribe to deployment changes without also receiving these pesky, numerous
        // admin notifications as well. These are so numerous that we want to ignore them. Defect 48765
        if(
          message.destinationName === "IBM/IntegrationBus/" + window.brokerName + "/AdminNotifications/Broker/" + window.brokerName + "/Log/Log" ||
          message.destinationName === "IBM/IntegrationBus/" + window.brokerName + "/AdminNotifications/Broker/" + window.brokerName + "/AdminQueue/AdminQueue"
        ) {
          return;
        }

        if (hash()) {
          var uri = new WebUiHash(hash()).getRestUri().toString();
          uri += Resources.REST.allFlowsDepth;

          xhr(
            uri,
            {
              "handleAs" : "json",
              "headers" : {
                "Accept" : "application/json"
              }
            }
          ).then( lang.hitch(this, function(response) {
            this._repopulateThroughputGrid(response);
            // Call the check to see if within the container the flow status
            this._performAllFlowsCheck();
          }));
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_refreshThroughputGrid");
      },

      _repopulateThroughputGrid: function(response){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_repopulateThroughputGrid");

        //Check whether any alterations has been made to child objects of the parent being viewed in the flow comparison table.
        this._updatedMessageFlowsArray = [];

        // Recurse the response to get at the flow data in our temp flows array
        this._recurseUpdatedTree(response);

        /*
         * We have been notified that the entries in the table could have changed (could be more or fewer).
         * So we need to check which entries have changes and update the table accordingly without
         * performing a full refresh (as we already have the data).
         * An update of an existing flow (as opposed to an addition or deletion of a flow) will be
         * handled by the already subscribed topic calling to the _refreshFlowDetails function.
         */

        // Get all of the current data in the gridStore to compare to the latest message flows.
        this._gridStore.fetch( { query: { id: "*" },
          onComplete: lang.hitch(this, function(fetchedItems) {
            // Arrays to track the items in the table to be removed or added
            var itemsToRemove = [];
            var itemsToAdd = [];

            /*
             * Let's iterate around every flow in the latest snapshot and check the following.
             * 1. Check if the flow is currently already in the message flow table.
             * If not add the array index to the add array whilst making a note that this flow has been processed, using the tracker array.
             *
             * 2. After handling new flows, we need to check that there aren't any flows that need removing.
             * Check all the existing FCT flows to see if it was in the latest snapshot.
             * If not the add it to the delete array.
             *
             * As there might be a combination of updates from a single notification, e.g updating an Application that has 3 flows.
             * Which has updated one, removed one, and added a new one, so we have to check for all possibilities of updating the table.
             */

            // Declare an array of size of message flows in the table to be used to track if the flow is found/processed in both snapshots.
            var trackerArray = new Array(fetchedItems.length);

            // Perform flow discovery using the recent (updated) flows array (i.e. flows that need to be added to the FCT)
            array.forEach(this._updatedMessageFlowsArray, lang.hitch(this, function(curFlow) {
              // Fetch the flow from grid store, if none are found then we need to add the new flow to the add array.
              this._gridStore.fetch( { query: { id: curFlow.uri },
                onComplete: lang.hitch(this, function(items) {
                  // If found the update trackerArray, noting that a match has been found
                  if(items.length > 0) {
                    // Identify the flow by its message flow index
                    trackerArray[items[0].MessageFlowIndex[0]] = true;
                  }
                  // Else push to add array
                  else {
                    itemsToAdd.push(curFlow);
                  }
                })
              });
            }));

            // Now we know all the flows we have to add, we need to check if there are any flows we need to remove.
            // The index in the tracker array refers to the MessageFlowIndex for each flow in the grid store, so we can use this to query and check if it needs removing from the table.
            array.forEach(trackerArray, lang.hitch(this, function(nextItem, i) {
              // If not true, i.e. not found then test if we need to add to remove array
              if(!nextItem) {
                // Fetch the flow from grid store, if found then we need to add the old flow to the delete array (as it wasn't in the latest snapshot of data).
                this._gridStore.fetch( { query: { MessageFlowIndex: i },
                  onComplete: lang.hitch(this, function(items) {
                    if(items.length > 0) {
                      itemsToRemove.push(items[0]);
                    }
                  })
                });
              }
            }));

            /*
             * If difference has been detected in message flow data.
             * We need to update the flow table using the arrays we have created to track the differences
             */
            if((itemsToRemove.length > 0) || (itemsToAdd.length > 0)) {
              this._refreshFlowComparison(itemsToRemove, itemsToAdd);
            }
          }),

          onError: lang.hitch(this, function(){
            Trace.trace(this.declaredClass, Trace.levels.ERROR, "Unable to update message flow table");
          })
        });

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_repopulateThroughputGrid");
      },

      _recurseUpdatedTree: function(response) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_recurseUpdatedTree");

        Object.keys(response).forEach(lang.hitch(this, function(key) {
          var value = response[key];
          if (lang.isArray(value)) {
            array.forEach(value, lang.hitch(this, function(arrayItem) {
              if(arrayItem.type == "messageFlow") {
                var parentInfo = new RestUri(arrayItem.uri).getParentArtifactRestUri().getArtifact();
                arrayItem.containerName = parentInfo.name;
                arrayItem.containerType = parentInfo.type;
                // Add messageFlow to the updatedMessageFlowArray
                arrayItem.parent = false;
                this._updatedMessageFlowsArray.push(arrayItem);
              }
              this._recurseUpdatedTree(arrayItem);
            }));
          } else {
            // Ensure references aren't double counted in array
            if (( typeof value == "object")  && (!this._descendantOfReferencesOrReferents(key))) {
              this._recurseUpdatedTree(value);
            }
          }
        }));

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_recurseUpdatedTree");
      },

      _refreshFlowComparison: function(itemsToRemove, itemsToAdd) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_refreshFlowComparison");

        // Booleans to track whether a save has been made to the flow tables.
        // If it has then we track it so we know to render the table at the end, as the store won't be detectable no longer as having been updated.
        var savedFCT = false;
        var savedNCT = true;

        // Iterate through all the objects to be deleted from the FCT
        if(itemsToRemove.length > 0) {
          array.forEach(itemsToRemove, lang.hitch(this, function (item) {
            this._gridStore.deleteItem(item);
            this._removeNodesForFlow(item.id[0], item.flowName[0], false);
          }));
        }

        // Saving the store so that the id's are clean, in case we need to re-add an updated flow that will have the same URI (used as the ID in the store).
        if(this._gridStore.isDirty()) {
          this._gridStore.save();
          savedFCT = true;
        }

        if(this._gridNodeStore.isDirty()) {
          this._gridNodeStore.save();
          savedNCT = true;
        }

        // Iterate through all the objets to be added to the FCT
        if(itemsToAdd.length > 0) {
          array.forEach(itemsToAdd, lang.hitch(this, function(messageFlow) {
            var gridMessageFlowsObj = {};
            gridMessageFlowsObj.statisticsEnabled = false;
            if (messageFlow.snapshotStatistics){
              if (messageFlow.snapshotStatistics.enabled && messageFlow.snapshotStatistics.outputFormat) {
                if (messageFlow.snapshotStatistics.outputFormat.json) {
                  gridMessageFlowsObj.statisticsEnabled = true;
                  // if at least one flow has statistics on, show the nodes as loading
                  // ow. nothing to expect
                   if (this._initNodesLoading) {
                    this._showLoading("nodes");
                    this._initNodesLoading = false;
                    // will give up after 40 seconds
                    setTimeout(lang.hitch(this, this._giveUp, "nodes"), 40000);
                  }
                }
                if (messageFlow.snapshotStatistics.nodeLevel=="none") {
                  window.smallMessage.displayMessage("warning", "NodeStatsOffMultipleFlows_XX", "", string.substitute(NLS.messages.NodeStatsOffDescription, [messageFlow.name]));
                  this._destroyMessageOnNewStats = false;
                  if(!this._anyNodeStatisticsOn){
                    this._endLoading("nodes");
                  }
                }
              }
            }
            gridMessageFlowsObj.id = messageFlow.uri;
            gridMessageFlowsObj.flowName = messageFlow.name;
            if (!messageFlow.isRunning) {
              gridMessageFlowsObj.flowName = gridMessageFlowsObj.flowName + "#stopped";
            }

            var containerName = messageFlow.uri;
            containerName = containerName.replace("/apiv1/executiongroups/","");
            gridMessageFlowsObj.containerName = containerName;

            // Add the items to the store
            this._gridStore.newItem(gridMessageFlowsObj);
            this._flowNodesNumbers.add(gridMessageFlowsObj.id, 0); // to start with, no nodes per flow;

            // Check whether the FCT store has been set yet.
            // If it has then we won't get to call out again to setup the topic registering, so we must do this manually for each flow we are adding.
            if (this._tpStoreSet) {
              var restUri = new RestUri(messageFlow.uri);
              var notificationsTopicName = restUri.getNotificationTopic();
              this._notificationTopicNames.push(notificationsTopicName);
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "registering for notifications on topic "+notificationsTopicName);
              this._notificationTopicHandles.push(topic.subscribe(notificationsTopicName, lang.hitch(this, function() {
                this._refreshFlowDetails(restUri.toString());
              })));
              var results = WebUiHash._generateNotificationsContainersTopicName(messageFlow.uri);
              results.forEach(lang.hitch(this, function(result) {
                if (array.indexOf(this._notificationTopicHandles, result) <0) {
                  Trace.trace(this.declaredClass, Trace.levels.DEBUG, "registering for notifications on container topic "+result);
                  this._notificationTopicHandles.push(topic.subscribe(result, lang.hitch(this, function() {
                    this._refreshContainerDetails(result);
                  })));
                }
              }));
            }
          }));
        }

        // Ensure the latest representation of the message flows are set
        this._messageFlowsArray = this._updatedMessageFlowsArray;

        // Clear out messages now the FCT has been updated
        if (this._messageFlowsArray.length==0) {
          window.smallMessage.displayMessage("warning", "AllStatsOff_XX", "", NLS.messages.StatsOffDescription);
        }

        // Update the message flow index values for all the flows after the index that has been deleted from the array.
        this._messageFlowsArray.forEach(function(itemToUpdate, i) {
          // Get the grid store object item and then set the latest message flows array index so that we are kept in sync
          this._gridStore.fetch( { query: { id: itemToUpdate.uri },
            onComplete: lang.hitch(this, function(fetchedItems) {
              if(fetchedItems.length > 0) {
                this._gridStore.setValue(fetchedItems[0], 'MessageFlowIndex', i);
              }
            })
          });
        });

        if(this._gridStore.isDirty()) {
          this._gridStore.save();
          savedFCT = true;
        }

        // If we have saved the Flow Comparison table
        if(savedFCT) {
          this.throughputGrid.render();
        }

        if(this._gridNodeStore.isDirty()) {
          this._gridNodeStore.save();
          savedNCT = true;
        }

        // If we have saved the Flow Comparison table
        if(savedNCT) {
          this.nodesGrid.render();
          this._scrollToFirstSelection(this.nodesGrid);
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_refreshFlowComparison");
      },

      _maxNodesReached: function() {
        var total = 0;
        var nodesNumbers = this._flowNodesNumbers.getValueList();
        array.forEach(nodesNumbers, lang.hitch(this, function (item) {
            total += item;
        }));
        if (total>=this.maxNodesNumber) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "No max reached. total:"+ total + " max: "+this.maxNodesNumber);
          return true;
        }
        else {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Max reached. total:"+ total + " max: "+this.maxNodesNumber);
          return false;
        }
      },

      _clearOutNodesTables : function() {
        this._gridNodeStore = new ItemFileWriteStore({
        data : {
          identifier: "id",
          items: []
        }
        });
        this.nodesGrid.setStore(this._gridNodeStore);
        this.nodesGridSpan.removeChild(this.nodesGrid.domNode);

        var container = domConstruct.create("div");
        container.innerHTML = string.substitute(NLS.statistics.maxNodesReached, [this.maxNodesNumber]);
        domConstruct.place(container, this.nodesGridSpan);
      },

      _refreshFlowDetails: function(newUri) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_refreshFlowDetails", arguments);

        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "get URI:"+ newUri);

        xhr(
          newUri,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json"
            }
          }
        ).then( lang.hitch(this, function(message) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_refreshFlowDetails.xhrLoad()", arguments);
          var flowUri = message.uri;
          this._gridStore.fetch( { query: { id: flowUri },
            onItem: lang.hitch(this, function(flow) {
              var names = flow.flowName;
              var ourFlow = message;
              var oldFlowName="";
              var newFlowName ="";
              if (lang.isArray(names)) {
                oldFlowName = names[0];
              }
              if (!ourFlow.isRunning) {
                newFlowName = oldFlowName+"#stopped";
              }
              else {
              newFlowName = oldFlowName;
                var j = oldFlowName.indexOf("#stopped");
                if (j>0) {
                  newFlowName = oldFlowName.substring(0, j);
                }
              }
              var statisticsOn = false;
              if (ourFlow.snapshotStatistics.enabled && ourFlow.snapshotStatistics.outputFormat) {
                if (ourFlow.snapshotStatistics.outputFormat.json) {
                  statisticsOn = true;
                }
                else {
                  Trace.trace(this.declaredClass, Trace.levels.WARNING, "Statistics enabled, format not json for "+ ourFlow.uri);
                }
              }

              //flow.flowName needs to be an array
              flow.flowName =[newFlowName];
              flow.statisticsEnabled =[statisticsOn];
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "The new flowName:" +flow.flowName +" and "+flow.statisticsEnabled);

              var i =this.throughputGrid.getItemIndex(flow);
              if (i>=0) {
                if (!statisticsOn || !ourFlow.isRunning || (!StatsUtils.isTestingOn()))  {
                  // safer to unset the attributes to make the topgrid show the default dojo ...
                  this._gridStore.unsetAttribute(flow, 'threadCount');
                  this._gridStore.unsetAttribute(flow, 'messageCount');
                  this._gridStore.unsetAttribute(flow, 'timePerMessage');
                  this._gridStore.unsetAttribute(flow, 'avgCpuTime');
                  this._gridStore.unsetAttribute(flow, 'messagesPerSecond');
                  this._removeNodesForFlow(message.uri, flow.flowName[0], true);
                }
                else {
                  // set the other columns to 0 the next update will reset
                  //flow.threadCount = [0];
                  flow.messageCount = [0];
                  flow.backouts = [0];
                  flow.timePerMessage = [0];
                  flow.avgCpuTime = [0];
                  flow.messagesPerSecond = [0];
                }
                Trace.trace(this.declaredClass, Trace.levels.DEBUG, "updated row "+i);
                this._gridStore.save();
                //forces an update of the row
                this.throughputGrid.updateRow(i);
              }
              Trace.trace(this.declaredClass, Trace.levels.EXIT, "_refreshFlowDetails.xhrLoad()");
            })
          });
        }));
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_refreshFlowDetails");
      },

      _removeNodesForFlow: function(uri, flowName, update) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_removeNodesForFlow");
        if (!this._nodesTablePresent) {
          return;
        }
        var parentInfo = new RestUri(uri).getParentArtifactRestUri().getArtifact();
        var parent = parentInfo.name;
        var fullFlowName = parent+"/"+flowName;
        var i = fullFlowName.indexOf('#'); // the flow might be stopped then the flow name has the #stopped suffix
        if (i>0) {
          fullFlowName = fullFlowName.substring(0, i);
        }
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Removing nodes for "+fullFlowName);
        this._gridNodeStore.fetch({
          "query": {
            "parentFlow": fullFlowName
          },
          "onError": lang.hitch(this, function(){
            Trace.trace(this.declaredClass, Trace.levels.ERROR, "Unable to fetch nodes for "+fullFlowName);
          }),
          "onComplete": lang.hitch(this, function(nodes) {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Removing nodes ");
            array.forEach(nodes, lang.hitch(this, function(entry){
              this._gridNodeStore.deleteItem(entry);
            }));
          })
        });

        // Only update the node comparison table if specified
        if(update) {
          if (this._gridNodeStore.isDirty()) {
             this._gridNodeStore.save();
            // make the nodesGrid redraw. this will reset the selection
             this.nodesGrid.render();
             this._scrollToFirstSelection(this.nodesGrid);
          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_removeNodesForFlow");

      },

      _formatFlowName: function(item){
        var result;
        if (!item) { result =""; }
        else { result = "<div class='stats_treeParentFlow'  />"+ item; }
        return result;
      },

      // Format all our stats numbers to 1 decimal place
      _formatNumber: function(item){
        return number.format(item, {places: 1});
      },

      /** Formatter for the "Flow name" column */
      _insertFlow: function(item, row){
        // "item" is the message flow name e.g. "QueueToQueue". Unless the flow
        // is stopped, in which case it's e.g. "QueueToQueue#stopped".

        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_insertFlow");

        var i = item.indexOf("#");
        var running = i<0;
        var result;
        if (running) {
           result = "<span  class='stats_goTo stats_treeAppServiceFlow explorer_messageFlow_running' "+
             " ></span>" + item;
        }
        else {
           result = "<span  class='stats_goTo stats_treeAppServiceFlow explorer_messageFlow_stopped' "+
             " ></span>" + item.substring(0,i);
        }
        //only show statistics info for running flows
        if (running) {
          var rowData = this.throughputGrid.getItem(row); // ?
          if (rowData) {
            if (rowData.statisticsEnabled && lang.isArray(rowData.statisticsEnabled)) {
              if (rowData.statisticsEnabled[0]) {
                //We need the index in the _messageFlowsArray not the row as it may have been sorted
                if (rowData.MessageFlowIndex && lang.isArray(rowData.MessageFlowIndex))
                {
                  var url = this._computeFlowUrl(this._messageFlowsArray[rowData.MessageFlowIndex[0]]);

                  //Not ideal - we'd rather change this via hash(), but some issues in WMBConsole mean that the tree
                  //updates and splats the hash, so the widget initialises wrong :(
                  result += '<span class="stats_link">' +
                    '<a href="' + url + '" target="_new" title="' + NLS.action.flowView + '">'+
                      ' <img src=\'/webui/widgets/common/images/drillDown4.png\'>'+
                    '</a>' +
                  '</span>';
                }
              }
              else {
                result += '<span class="stats_noLink" title="'+NLS.action.noFlowView+'">  ('+NLS.action.statsOff+')</span>';
              }
            }
          }
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_insertFlow");

        return result;
      },

      // Formatter for the "Active Threads" column
      _insertFlowThreadCount: function(item, row){ // jshint ignore:line
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_insertFlowThreadCount");

        var result;
        var rowData = this.throughputGrid.getItem(row);

        // Check whether thread statistics have been received.
        // If there are none, but the flow is running then add the warning message that thread statistics are disabled.
        if (rowData) {
          if (rowData.statisticsEnabled && lang.isArray(rowData.statisticsEnabled)) {
            if (rowData.statisticsEnabled[0]) {
              if(rowData.threadCount && lang.isArray(rowData.threadCount)) {
                if(rowData.threadCount[0] > 0) {
                  result = rowData.threadCount[0];
                } else {
                  result = '<span class="stats_noLink" title="'+NLS.statisticsNoThreadsInfo+'">'  +NLS.statisticsNoThreads+'</span>';
                }
              } else {
                result  = undefined;
              }
            }
            else {
              result  = undefined;
            }
          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_insertFlowThreadCount");
        return result;
      },

      // Formatter for the "Container" column
      _insertContainer: function(item){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_insertContainer");
        // Argument "item" is a string containing the path followed by the
        // type. Examples:
        // "default#executionGroup"
        //   an integration server named "default"
        // "default/driver#application"
        //   an application named "driver" on an integration server named "default"

        // Add the icon to the front of the item depending on it's type.
        var i = item.indexOf("#");
        if (i<0) {
          return item;
        }

        var result = item.substring(0, i);
        var type = item.substring(i+1);

        if (type =="library") {
        // special case for library as there is no icon for library_running
          result = "<div class='stats_treeAppServiceFlow explorer_library'></div>" +
          decodeURIComponent(result);

        }
        else {
        result = "<div class='stats_treeAppServiceFlow explorer_" +
          type + "_running'></div>" +
          decodeURIComponent(result);
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_insertContainer");

        return result;
      },

      /**
       * Return e.g. "http://localhost:4415/#messageFlow/1/executiongroups/ScribbleExecutionGroup/applications/MBApp/messageflows/flow1"
       */
      _computeFlowUrl: function (selectedItem) {

        var currentURL = document.URL;
        var i = currentURL.indexOf("#");
        if (i>0) {
          var prefix = currentURL.substring(0, i);

          var restUri = new RestUri(selectedItem.uri);
          var webUiHash = WebUiHash.fromRestUri(restUri);

          // Figure out which tab to select by inspecting the Layout.
          // Because Layout could change over time, see?
          var type = webUiHash.getType(); // probably "messageFlow"
          var widgets = (Layout[type] && Layout[type].widgets) || [];
          var tabNum;
          widgets.forEach(function(widget, i) {
            if(!tabNum && widget.widget === "webui.widgets.msgflows.msgflow_statistics") {
              tabNum = String(i); // e.g. "1"
            }
          });
          if(tabNum === undefined) {
            console.error("Could not find the tab number for the statistics view for a '" + type + "'");
            tabNum = "0";
          }

          // Make new web UI hash with altered tab number
          webUiHash = webUiHash.withTabNum(tabNum);

          var suffix = webUiHash.toString();
          return prefix+"#"+suffix;
        }
        return "";
      },

      _recurseTree: function(response) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_recurseTree");

        Object.keys(response).forEach(lang.hitch(this, function(key) {
          var value = response[key];
          if (lang.isArray(value)) {
            array.forEach(value, lang.hitch(this, function(arrayItem) {
              if(arrayItem.type == "messageFlow") {
                var parentInfo = new RestUri(arrayItem.uri).getParentArtifactRestUri().getArtifact();
                arrayItem.containerName = parentInfo.name;
                arrayItem.containerType = parentInfo.type;
                // Add messageFlow to the messageFlowArray
                arrayItem.parent = false;
                this._messageFlowsArray.push(arrayItem);

                if (
                  !this._anyFlowStatisticsOn &&
                  arrayItem.snapshotStatistics &&
                  arrayItem.snapshotStatistics.enabled &&
                  arrayItem.snapshotStatistics.outputFormat &&
                  arrayItem.snapshotStatistics.outputFormat.json
                ) {
                  this._anyFlowStatisticsOn = true;
                }

                if (
                  arrayItem.snapshotStatistics &&
                  arrayItem.snapshotStatistics.enabled &&
                  arrayItem.snapshotStatistics.outputFormat &&
                  arrayItem.snapshotStatistics.outputFormat.json &&
                  arrayItem.snapshotStatistics.nodeLevel != "none"
                ) {
                  this._anyNodeStatisticsOn = true;
                }
              }
              this._recurseTree(arrayItem);
            }));
          } else {
            // Ensure references aren't double counted in array
            if (( typeof value == "object") && (!this._descendantOfReferencesOrReferents(key))) {
              this._recurseTree(value);
            }
          }
        }));

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_recurseTree");
      },

      _buildParentNameFromJson: function(messageFlow) {
        //console.dir(messageFlow);
        //messageFlow is a jsonData.MessageFlow
        var result = messageFlow.ExecutionGroupName;
        if (messageFlow.ApplicationName) {
          result = result+"/applications/"+messageFlow.ApplicationName;
        }
        else if (messageFlow.ServiceName) {
          result = result+"/services/"+messageFlow.ServiceName;
        }
        else if (messageFlow.RestApiName) {
          result = result+"/restapis"+messageFlow.RestApiName;
        }
        if (messageFlow.LibraryName) {
          result = result+"/libraries/"+messageFlow.LibraryName;
        }
        result = result+"/messageflows/"+messageFlow.MessageFlowName;
        return result;
      },

      _generateTopicName: function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_generateTopicName");

        var topicName = "";
        // Calculate the topic name 'topicName' and populate the pages title
        if (hash()) {
          var webUiHash = new WebUiHash(hash());
          topicName = webUiHash.getStatsTopic(true); // append wildcard

          var title = webUiHash.getName() || window.brokerName;
          this.toolbar.setAttribute("title","innerHTML",NLS.statisticsSummary);
          this.timePerNodeTp.set('title',
            string.substitute(NLS.statisticsTimePerNodeTitle, [title]));
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_generateTopicName");

        return topicName;
      },

      _checkAndInitializeStatisticsData: function() {

        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_checkAndInitializeStatisticsData");

        if (this._messageFlowsArray.length==0) {
          window.smallMessage.displayMessage("warning", "AllStatsOff_XX", "", NLS.messages.StatsOffDescription);
           // nothing to show, clear the loading
          this._endLoading("flows");
          this._endLoading("nodes");
          return;
        }
        if (!this._anyFlowStatisticsOn) { // there are flows, but none has statistics on
          this._endLoading("nodes");
        }
        var flowData = {};
        flowData.items= [];
        // initialize throughput table for flow and container names
        // if any statistics is on, this data will be overwritten in response to statistics data being received
        // if not, it gives the user a clue as to what is wrong
        //this._gridStore.data  =  flowData;

        array.forEach(this._messageFlowsArray, lang.hitch(this, function(messageFlow, i) {
          var gridMessageFlowsObj = {};
          gridMessageFlowsObj.statisticsEnabled = false;
          if (messageFlow.snapshotStatistics){
            if (messageFlow.snapshotStatistics.enabled && messageFlow.snapshotStatistics.outputFormat) {
              if (messageFlow.snapshotStatistics.outputFormat.json) {
                gridMessageFlowsObj.statisticsEnabled = true;
                // if at least one flow has statistics on, show the nodes as loading
                // ow. nothing to expect
                 if (this._initNodesLoading) {
                  this._showLoading("nodes");
                  this._initNodesLoading = false;
                  // will give up after 40 seconds
                  setTimeout(lang.hitch(this, this._giveUp, "nodes"), 40000);
                }
              }
              if (messageFlow.snapshotStatistics.nodeLevel=="none") {
                window.smallMessage.displayMessage("warning", "NodeStatsOffMultipleFlows_XX", "", string.substitute(NLS.messages.NodeStatsOffDescription, [messageFlow.name]));
                this._destroyMessageOnNewStats = false;
                if(!this._anyNodeStatisticsOn){
                  this._endLoading("nodes");
                }
              }
            }
          }
          gridMessageFlowsObj.id = messageFlow.uri;
          gridMessageFlowsObj.flowName = messageFlow.name;
          gridMessageFlowsObj.MessageFlowIndex = i;
          if (!messageFlow.isRunning) {
            gridMessageFlowsObj.flowName = gridMessageFlowsObj.flowName + "#stopped";
          }
          var containerName = messageFlow.uri;
          containerName = containerName.replace("/apiv1/executiongroups/","");
          gridMessageFlowsObj.containerName = containerName;
          // Add the items to the store
          this._gridStore.newItem(gridMessageFlowsObj);
          this._flowNodesNumbers.add(gridMessageFlowsObj.id, 0); // to start with, no nodes per flow;
        }));

        this._gridStore.save();
        this.throughputGrid.render();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_checkAndInitializeStatisticsData");
      },

      _descendantOfReferencesOrReferents : function(objectType) {
        return objectType === "references" || objectType === "referents";
      },

      _showLoading: function(/*String*/ param){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showLoading");

        // show the overlay
        if (param === "flows") {
          if(this.loadingDiv && this.loadingDiv.style) {
            domStyle.set( this.loadingDiv, {
              display: 'block'
            });
          }
        } else {
          if(this.loadingNodesDiv && this.loadingNodesDiv.style) {
            domStyle.set( this.loadingNodesDiv, {
              display: 'block'
            });
          }
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showLoading");
      },

      _hideLoading: function(/*String*/ param){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_hideLoading");

        if (param === "flows") {
          if(this.loadingDiv && this.loadingDiv.style){
            domStyle.set( this.loadingDiv, {
              display: 'none'
            });
          }
        } else {
          if(this.loadingNodesDiv && this.loadingNodesDiv.style){
            domStyle.set( this.loadingNodesDiv, {
              display: 'none'
            });
          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_hideLoading");
      },

      _giveUp : function(param) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_giveUp");
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "timed out waiting for "+ param);
        this._endLoading(param);
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_giveUp");
      },

      _endLoading: function(/*String*/ param){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_endLoading");
        this._hideLoading(param);
        //We used to fade here, but it didn't like doing it after the upgade, so don't bother for now
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_endLoading");
      },

      resize: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");
        this._statisticsContainer_borderContainer.resize();
        this.throughputGrid.resize();
        if (this._nodesTablePresent) {
          this.nodesGrid.resize();
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
      }
    });
  }
);

},
'webui/widgets/msgflows/MessageFlowStatisticsGrid':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2013,2016" 
 * crc="1195428145" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/_base/array",
  "dojo/_base/lang",
  "dojo/_base/declare", 
  "dojo/data/ItemFileWriteStore",
  "dojo/number",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase", 
  "dijit/_WidgetsInTemplateMixin",
  "dojox/grid/DataGrid",
  "webui/widgets/common/Trace", 
  "dojo/text!webui/widgets/msgflows/templates/MessageFlowStatisticsGrid.html",
  "dojo/i18n!webui/nls/web",
  "webui/utils/StatsUtils",
  "dojo/domReady!"
], function(
  array,
  lang,
  declare,
  ItemFileWriteStore,
  number,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,  
  DataGrid,
  Trace,
  template,
  NLS,
  StatsUtils) {
    
  return declare("webui.widgets.msgflows.MessageFlowStatisticsGrid", [ _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin  ], {
    templateString: template,
    mode: "avg", // min or max are the other modes
    _initialContentRendered: false,

    // Default grid layout
    _gridLayout: [[
      {
        field : "label",
        width : "40%",
        formatter : this._formatFlowName,
        name : NLS.statisticsNode
      }, {
        field : "avgElapsedTime",
        width : "10%",
        formatter : this._formatNumber,
        cellStyles: "text-align: right",
        headerStyles: "text-align: right",
        name : NLS.messageFlow_monitoring_elapsedtime_avg
      }, {
        field : "avgCPUTime",
        width : "10%",
        formatter : this._formatNumber,
        cellStyles: "text-align: right",
        headerStyles: "text-align: right",
        name : NLS.messageFlow_monitoring_cputime_avg
      }, {
        field : "nodeType",
        width : "40%",
        name : NLS.statisticsNodeType
      }
    ]],
    _minElapsedTimeCellDefinition: {
      field : "minimumElapsedTime",
      width : "10%",
      formatter : this._formatNumber,
      cellStyles: "text-align: right",
      headerStyles: "text-align: right",
      name : NLS.messageFlow_monitoring_elapsedtime_min
    },
    _minCPUTimeCellDefinition: {
      field : "minimumCPUTime",
      width : "10%",
      formatter : this._formatNumber,
      cellStyles: "text-align: right",
      headerStyles: "text-align: right",
      name : NLS.messageFlow_monitoring_cputime_min
    },
    _maxElapsedTimeCellDefinition: {
      field : "maximumElapsedTime",
      width : "10%",
      formatter : this._formatNumber,
      cellStyles: "text-align: right",
      headerStyles: "text-align: right",
      name : NLS.messageFlow_monitoring_elapsedtime_max
    },
    _maxCPUTimeCellDefinition: {
      field : "maximumCPUTime",
      width : "10%",
      formatter : this._formatNumber,
      cellStyles: "text-align: right",
      headerStyles: "text-align: right",
      name : NLS.messageFlow_monitoring_cputime_max
    },
    _avgElapsedTimeCellDefinition: {
      field : "avgElapsedTime",
      width : "10%",
      formatter : this._formatNumber,
      cellStyles: "text-align: right",
      headerStyles: "text-align: right",
      name : NLS.messageFlow_monitoring_elapsedtime_avg
    },
    _avgCPUTimeCellDefinition: {
      field : "avgCPUTime",
      width : "10%",
      formatter : this._formatNumber,
      cellStyles: "text-align: right",
      headerStyles: "text-align: right",
      name : NLS.messageFlow_monitoring_cputime_avg
    },

    /**
     * The constructor initializes the grid layout configuration for the dojo
     * data grid widget.  It adds the relevant translations to each field.
     */
    constructor: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");

      /*
       * Associate the NLS resources with this widget so that we can
       * declaratively reference resources in the template markup.
       */
      this.NLS = NLS;
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
    },
    
    /**
     * The postCreate function creates and initializes the dojo data grid. 
     */
    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      /*
       * Create a Dojo data store for the grid.  We use the "id" attribute 
       * to uniquely identify each entry in the store.
       */
      var nodeData = {
        identifier: "id",
        items: []
      };
      this._gridNodeStore = new ItemFileWriteStore({
        data : nodeData
      });
      this._messageFlowStatsGrid = new DataGrid({
        store : this._gridNodeStore,
        id : "flow_timePerNodeGrid",
        structure : this._gridLayout,
        autoHeight: true,
        className: "statisticsTable",
        sortInfo: "-2",
        columnReordering : false,
        escapeHTMLInData : true,
        selectable : true
      }, this._messageFlowStatsGridDiv);
      this._messageFlowStatsGrid.startup();
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },

    /**
     * The removeNodesFromTable function removes all of the ndoes from the grid
     * widget.  It does this by creating a clean data store for use by
     * the grid widget, setting this as the store for the widget and forcing the
     * widget to render.
     */
    removeNodesFromTable: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "removeNodesFromTable");

      var nodeData = {identifier: "id", items: []};
      this._gridNodeStore = new ItemFileWriteStore({data : nodeData});
      this._messageFlowStatsGrid.setStore(this._gridNodeStore);
      this._messageFlowStatsGrid.render();
      this._initialContentRendered = false;
                        
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "removeNodesFromTable");
    },

    /**
     * The resize function forces the grid widget to resize.
     */
    resize: function(){
      // Resize the grid widget
      this._messageFlowStatsGrid.resize();
    },

    /**
     * The updateMessageFlowStatsData function updates the data that is 
     * currently being displayed by the grid widget with the values passed in. 
     */
    updateMessageFlowStatsData: function(statsData) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "updateMessageFlowStatsData");

      /*
       * Iterate over the statistics for each node.  For each node, update the
       * corresponding entry in the data store, creating an entry if one does
       * not already exist. 
       */ 
      array.forEach(statsData.WMQIStatisticsAccounting.Nodes, lang.hitch(this, function(node){
        this._gridNodeStore.fetch( { query: { id: node.Label },
          onComplete: lang.hitch(this, function(item) {
          
            var cpuSnapshotAvg;
            var elapsedSnapshotAvg;
            var minCPUTime;
            var maxCPUTime;
            var minElapsedTime;
            var maxElapsedTime;
            if(item.length > 0) {
              // Id has been found to update the item
              this._gridNodeStore.setValue(item[0], 'label', node.Label);
                                
              // mode.totalCPUTime and totalElapsedTime are in microseconds, convert to milliseconds
              cpuSnapshotAvg = 0;
              elapsedSnapshotAvg = 0;
              if (node.CountOfInvocations > 0) {
                cpuSnapshotAvg = StatsUtils.formatToMillis(node.TotalCPUTime / node.CountOfInvocations);
                elapsedSnapshotAvg = StatsUtils.formatToMillis(node.TotalElapsedTime / node.CountOfInvocations);
              } else {
                cpuSnapshotAvg = 0;
                elapsedSnapshotAvg = 0;
              }
              
              this._gridNodeStore.setValue(item[0], 'avgCPUTime',  cpuSnapshotAvg);
              this._gridNodeStore.setValue(item[0], 'avgElapsedTime', elapsedSnapshotAvg);
              minCPUTime = StatsUtils.formatToMillis(node.MinimumCPUTime);
              maxCPUTime = StatsUtils.formatToMillis(node.MaximumCPUTime);
              minElapsedTime = StatsUtils.formatToMillis(node.MinimumElapsedTime);
              maxElapsedTime = StatsUtils.formatToMillis(node.MaximumElapsedTime);
                      
              this._gridNodeStore.setValue(item[0], 'minimumCPUTime',  minCPUTime);
              this._gridNodeStore.setValue(item[0], 'maximumCPUTime', maxCPUTime);
              this._gridNodeStore.setValue(item[0], 'minimumElapsedTime',  minElapsedTime);
              this._gridNodeStore.setValue(item[0], 'maximumElapsedTime', maxElapsedTime);
              this._gridNodeStore.setValue(item[0], 'nodeType', node.Type);
            } else { // IF - item.length > 0
              cpuSnapshotAvg = 0;
              elapsedSnapshotAvg = 0;
              if (statsData.WMQIStatisticsAccounting.MessageFlow.TotalInputMessages > 0) {
                cpuSnapshotAvg = StatsUtils.formatToMillis(statsData.WMQIStatisticsAccounting.MessageFlow.TotalCPUTime / statsData.WMQIStatisticsAccounting.MessageFlow.TotalInputMessages);
                elapsedSnapshotAvg = StatsUtils.formatToMillis(statsData.WMQIStatisticsAccounting.MessageFlow.TotalElapsedTime / statsData.WMQIStatisticsAccounting.MessageFlow.TotalInputMessages);
              }
              minCPUTime = StatsUtils.formatToMillis(node.MinimumCPUTime);
              maxCPUTime = StatsUtils.formatToMillis(node.MaximumCPUTime);
              minElapsedTime = StatsUtils.formatToMillis(node.MinimumElapsedTime);
              maxElapsedTime = StatsUtils.formatToMillis(node.MaximumElapsedTime);
                              
              // Id has not been found so create new items
              // mode.totalCPUTime and totalElapsedTime are in microseconds, convert to milliseconds
              this._gridNodeStore.newItem({
                id: node.Label,
                label: node.Label,
                avgCPUTime: cpuSnapshotAvg,
                avgElapsedTime: elapsedSnapshotAvg,
                minumimCPUTime:  minCPUTime,
                maximumCPUTime: maxCPUTime,
                minimumElapsedTime: minElapsedTime,
                maximumElapsedTime: maxElapsedTime,
                nodeType :node.Type
              });
            }
          }),
          onError: lang.hitch(this, function(){
            Trace.trace(this.declaredClass, Trace.levels.ERROR, "Unable to update stats node data");
          })
        });
      })); 

      // Save & redraw if changed
      if(this._gridNodeStore.isDirty()) {
        this._gridNodeStore.save();
        
        /*
         * Only perform a refresh if this is the first time that we have added
         * entries to it.  This avoids resetting the column widths if the user
         * has resized them.
         */
        if (!this._initialContentRendered) {
          this._refresh();
          this._initialContentRendered = true;
        }
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "updateResourceStatsData");
    },

    /**
     * The setDisplayMode function sets the mode of display for the 
     * _messageFlowStatsGrid widget.
     *
     * @return String
     *           The display mode to set.  The value should be one of:
     *           
     *             avg
     *             min
     *             max
     */
    setDisplayMode: function(mode) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "setDisplayMode");

      if (this.mode != mode) {
        switch (mode) {
        case "avg":
          this.mode = mode;
          this._gridLayout[0][1] = this._avgElapsedTimeCellDefinition;
          this._gridLayout[0][2] = this._avgCPUTimeCellDefinition;
          break;
        
        case "min":
          this.mode = mode;
          this._gridLayout[0][1] = this._minElapsedTimeCellDefinition;
          this._gridLayout[0][2] = this._minCPUTimeCellDefinition;
          break;
          
        case "max":
          this.mode = mode;
          this._gridLayout[0][1] = this._maxElapsedTimeCellDefinition;
          this._gridLayout[0][2] = this._maxCPUTimeCellDefinition;
          break;
          
        default:
          this.mode = "avg";
          this._gridLayout[0][1] = this._avgElapsedTimeCellDefinition;
          this._gridLayout[0][2] = this._avgCPUTimeCellDefinition;
          break;
        } // SWITCH
        
        this._refresh();
      } // IF - this.mode != mode
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "setDisplayMode");
    },

    /**
     * The refresh function refreshes the contents of the grid widget.
     */
    _refresh : function() {
      this._messageFlowStatsGrid.set("structure", this._gridLayout);
      this._messageFlowStatsGrid.render();
    },
    
    _formatFlowName: function(item){
      var result = "<div class='stats_treeParentFlow'  />" + item ;
      return result;
    },
    
    // Format all our stats numbers to 2 decimal places
    _formatNumber: function(item){
      return number.format(item, {places: 2});
    }
  });// end declare
});// end define

},
'webui/widgets/msgflows/MessageFlowPropertiesEditor':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 */

/**
 * This widget represents a properties editor for integration node level properties.
 *
 * The widget has:
 * - A Save and Cancel button at the top right.
 * - A property table widget that allows the user to change the values.
 *
 * Most of the widget is internal (private). The only public method provided is the isDirty
 * method.
 */
define(
  "webui/widgets/msgflows/MessageFlowPropertiesEditor",
  [
    "dojo/text!webui/widgets/msgflows/templates/MessageFlowPropertiesEditor.html",
    "dojo/i18n!webui/nls/web",
    "dojo/_base/declare",
    "dijit/_WidgetBase",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/registry",
    "webui/widgets/common/Trace",
    "dojo/dom",
    "dojo/dom-construct",
    "dojo/store/Memory",
    "dojo/_base/lang",
    "dojo/request/xhr",
    "webui/config/Resources",
    "webui/utils/WebUiHash",
    "webui/widgets/common/AttributesStore",
    "webui/widgets/common/EditTextPropertyValueDialog",
    "webui/widgets/common/EditBooleanPropertyValueDialog",
    "webui/widgets/common/EditNumericPropertyValueDialog",
    "webui/widgets/common/Toolbar",
    "dojo/dom-attr",
    "dojo/topic",
    "dojo/query",
    "dojox/html/entities",

    // Grid X
    "gridx/Grid",
    "gridx/core/model/cache/Sync",
    "gridx/modules/select/Row",
    "gridx/modules/ColumnResizer",
    "gridx/modules/CellWidget",
    "gridx/modules/Edit"
  ],
  function(
    template,
    NLS,
    declare,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    registry,
    Trace,
    dom,
    construct,
    Memory,
    lang,
    xhr,
    Resources,
    WebUiHash,
    AttributesStore,
    EditTextPropertyValueDialog,
    EditBooleanPropertyValueDialog,
    EditNumericPropertyValueDialog,
    Toolbar,
    attr,
    topic,
    query,
    HTMLEntities,

    // GridX
    Grid,
    Cache,
    SelectRow,
    ColumnResizer,
    CellWidget,
    Edit
  ) {
    var messageFlowPropertyEditor = declare("webui.widgets.msgflows.MessageFlowPropertiesEditor", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
      templateString: template, // points js to the html template to use
      _messageFlowNameLabel: NLS.nameLabel,
      _messageFlowTypeLabel: NLS.typeLabel,
      _attributesStore : new AttributesStore(),

      /**
       * Constructor
       */
      constructor: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");
        this.inherited(arguments);
      	if (arguments.length > 0) {
      	  this._hash = arguments[0].hash;
      	}
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
      },


      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");

        // Call postCreate on _TemplatedMixin:
        this.inherited(arguments);

        // Build URI
        // hash is e.g. "messageFlow/0/executiongroups/sdgkajsh/messageflows/MQInputMQReply"
        // result: "/apiv1/executiongroups/sdgkajsh/messageflows/MQInputMQReply"
        this._uri = new WebUiHash(this.hash).getRestUri().toString();
        this._uri += "/properties";

        this.propertyData = [];

        // Create the toolbar at the top of the UI:
        this.toolbar = new Toolbar();
        construct.place(this.toolbar.domNode, this._toolbar);
        this.toolbar.addLeftAlignButtons("title");

        // Add Save and Cancel button to the right side of the toolbar:
        var buttons = ["save", "cancel"];
     	this.toolbar.addRightAlignButtons(buttons);
      	this.toolbar.addRightAlignButtons("spacer");
      	this.toolbar.getButton("save").set("disabled", true);
        this.toolbar.getButton("cancel").set("disabled", false);

        this._createPropertiesTable();

        // Add button event handlers:
        this.toolbar.connectButtons("save", "click", this, "_onSaveClick");
        this.toolbar.connectButtons("cancel", "click", this, "_onCancelClick");

      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
     },

     _createPropertiesTable: function() {
    	 Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createPropertiesTable");

    	 // Define the properties table structure
         var propertiesTableStructure = [
           { id: 'id', field: 'displayName', name: NLS.nameLabel, width: '30%', editable: false},
           { id: 'value', field: 'value', name: NLS.valueLabel, width: '60%', editable: true,
             decorator: function(cellData) {
              // Encode value before showing it in the table to prevent code injection:
              return HTMLEntities.encode(cellData);
            }
           },
           { id: 'valueDialog', field: 'edit', name: '', width: '10%', widgetsInCell: true,
             decorator: function() {
               // Embed a button in the value column (label for screen reader also provided so more information can be provided other than just '...'):
               return "<div data-dojo-type='dijit.form.Button' type='button' data-dojo-attach-point='messageFlowEditValueButton' aria-label='" + NLS.editValueDialogButtonText + "'>...</div>";
             },
             getCellWidgetConnects: function(cellWidget, cell) {
               // Add a handler for when the embedded button is pressed:
               return [[
                 cellWidget.messageFlowEditValueButton,
                 'onClick',
                 function() {
                   var confirmCallback = lang.hitch(this, function() {
                     var propertyValue = editPropertyValueDialog.editPropertyValueArea.get("value");
                     
                     var propertyType = editPropertyValueDialog._dialogType();
                     if (propertyType === "boolean") {
                       if (propertyValue === "on") {
                         propertyValue = "true";
                       }
                       else if (propertyValue === "off"){
                         propertyValue = "false";
                       }
                     }
                     
                     // Set value from dialog into the table (need to begin and apply edit so an onApply event is fired):
                     editPropertyValueDialog.cell.beginEdit();
                     editPropertyValueDialog.cell.setRawData(propertyValue.toString()); // call toString() as property value could be a number
                     editPropertyValueDialog.cell.applyEdit();
                   });

                   var editPropertyValueDialog = registry.byId("editPropertyValueDialog");
                   // Clear any old dialog in case we need one of a different type
                   if (editPropertyValueDialog) {
                     editPropertyValueDialog.destroy();
                     editPropertyValueDialog = null;
                   }

                   var nameCell = cell.grid.cell(cell.row.id, "id");
                   var propName = nameCell.rawData();
                   var propertyType = cell.grid.model.store.get(propName).propertyType;

                   if (propertyType === 'text') {
                     if (!editPropertyValueDialog) {
                       editPropertyValueDialog = new EditTextPropertyValueDialog({
                         id : "editPropertyValueDialog",
                         createCallback : confirmCallback
                       });
                       editPropertyValueDialog.startup();
                     }
                   } else if (propertyType === 'boolean') {
                     if (!editPropertyValueDialog) {
                       editPropertyValueDialog = new EditBooleanPropertyValueDialog({
                         id : "editPropertyValueDialog",
                         createCallback : confirmCallback
                       });
                       editPropertyValueDialog.startup();
                     }
                   } else if (propertyType === 'numeric') {
                     if (!editPropertyValueDialog) {
                       editPropertyValueDialog = new EditNumericPropertyValueDialog({
                         id : "editPropertyValueDialog",
                         createCallback : confirmCallback
                       });
                       editPropertyValueDialog.startup();
                     }
                   }

                   // Set appropriate values on the dialog and then open it:
                   attr.set(editPropertyValueDialog.titleNode, "innerHTML", NLS.editValueLabel);
                   var valueCell = cell.grid.cell(cell.row.id, "value");
                   editPropertyValueDialog.cell = valueCell; // pass in the value cell; needed above when setting the value in the table
                   editPropertyValueDialog.currentValue = valueCell.rawData(); // pass in the value text
                   editPropertyValueDialog.refresh();
                   editPropertyValueDialog.show();
                 }
               ]];
             }
           }
         ];

         // Create the store for the properties table:
         var messageFlowPropertiesTableStore = new Memory({data: [], idProperty: "id"});

         // Create the property table widget:
         this._propertiesTable = Grid({
             id: 'messageFlowPropertiesTable',
             cacheClass: Cache,
             store: messageFlowPropertiesTableStore,
             structure: propertiesTableStructure,
             autoHeight: true,
             modules: [
               SelectRow,
               CellWidget,
               Edit,
               ColumnResizer
             ],
             editLazySave: false // Needs to be set to false because using query on the store
         });

         // Put the property table widget into the DOM tree:
         this._propertiesTable.placeAt(this._messageFlowProperties);

         // Start up the property table widget:
         this._propertiesTable.startup();

         // Populate store and then initialize values when store is populated:
         var populate = this._attributesStore.populateAttributesStore();
         populate.then(lang.hitch(this, function() {
        		// have to wait until to initialize until after the populate completes
        		// as we will need the URI from the properties store:
         	this._initialize();
       	}));

         Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createPropertiesTable");
     },


     // Called after the properties store is initialized:
     _initialize: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_initialize");

        // Flag to indicate that the user has made a change:
        this._hasUserMadeAChange = false;

        // Add a handler for when a property value is changed in the property table (it is
        // preferred to use the event handling of the grid control so using that here):
        this._getPropertiesTable().edit.connect(this._getPropertiesTable().edit, "onApply", lang.hitch(this, this._handlePropertyValueChanged));

        // Add a handler for when the selection changes in the property table (it is
        // preferred to use the event handling of the grid control so using that here):
        this._getPropertiesTable().select.row.connect(this._getPropertiesTable().select.row, "onSelected", lang.hitch(this, this._handleRowSelectionChanged));
        this._getPropertiesTable().select.row.connect(this._getPropertiesTable().select.row, "onDeselected", lang.hitch(this, this._handleRowSelectionChanged));

        // Populate the properties table with the properties of the flow:
      	this._populateTableWithProperties();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_initialize");
      },


      _getType: function() {
      	return this._getTypeWidget().get("displayedValue");
      },


      _getTypeWidget: function() {
      	return this._messageFlowTypeName;
      },


      _getURI: function() {
      	return this._uri;
      },


      _getPropertiesTable: function() {
      	return this._propertiesTable;
      },


      resize: function() {
         Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");
         this._messageFlowEditor_borderContainer.resize();
         Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
      },


      // Called when the user clicks the Save button:
      _onSaveClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onSaveClick");

        this._saveProperties();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onSaveClick");
      },


      // Called after the user clicks the Save button:
      _saveProperties: function() {

        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_saveProperties");

        var uri = this._getURI();

        var propertiesObject = {};
        var basicProperties = [];
        var userDefinedProperties = [];

        // Add the properties to the object:
        var numberOfRows = this._getPropertiesTable().rowCount();
      	if (numberOfRows > 0) {
      	  for (var i = 0; i < numberOfRows; i++) {
      	  	var property = {};
      	  	property.name = this._getPropertiesTable().cell(i, 0).rawData();
          	property.value = this._getPropertiesTable().cell(i, 1).rawData();

      		//if (this._getPropertiesTable().cell(i, 1).isEditing()) {
          	    var propertyType = this._getPropertiesTable().model.store.get(property.name).type;
          	    var internalName = this._getPropertiesTable().model.store.get(property.name).internalName;

          	    if (propertyType === "basic") {
          	    	if ((internalName === "shortDesc") || (internalName === "longDesc")) {
              	    	basicProperties.push({
              	    		"name"  : internalName,
              	    		"value" : property.value
              	    	});
          	    	}
          	    } else if (propertyType === "userDefined") {
          	    	userDefinedProperties.push({
          	    		"name"  : internalName,
          	    		"value" : property.value
          	    	});
          	    }

          	    //this._getPropertiesTable().cell(i, 1).cancelEdit();
      		//}
          }
      	  propertiesObject.basicProperties = basicProperties;
      	  propertiesObject.userDefinedProperties = userDefinedProperties;
        }

        // Add loading icon to tree:
        var tree = registry.byId('_explorerTree_ID');
        var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
        var oldIcon = attr.get(treeImgs[0],"class");
        attr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");

        window.smallMessage.displayPlainMessage("information", "PropertiesUpdate_SavingProperties");

        // Change the modified flag to false (as we are going to save the changes and we do not want isDirty() to return true):
        this._hasUserMadeAChange = false;

        // Disable the save and cancel buttons (to prevent the user from pressing them again while saving):
        this.toolbar.getButton("save").set("disabled", true);
        this.toolbar.getButton("cancel").set("disabled", true);

        // Call PUT to update the properties using the uri and object from above:
        xhr.put(
          uri,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json",
              "Content-type" : "application/json"
            },
            data : JSON.stringify(propertiesObject)
          }
        ).then(
          lang.hitch(this, function() {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Call to set properties was successful.");

            // Reset old icon (to remove loading icon):
            attr.set(treeImgs[0],"class",oldIcon);

            // Display a message that the creation was successful:
          	window.smallMessage.displayPlainMessage("success", "PropertiesUpdate_SaveSuccess");

            // Publish that the flow has been updated:
            topic.publish(Resources.pubSubTopic.messageFlowPropertiesUpdated, {uri: uri});

          }),
          lang.hitch(this, function(error) {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Text: " + error.response.text);

            // Reset old icon (to remove loading icon):
            attr.set(treeImgs[0],"class",oldIcon);

			      // Display a message that the creation was unsuccessful:
            window.smallMessage.displayPlainMessage("error", "PropertiesUpdate_SaveError");

            // Re-enable the modify flag, and re-enable the save and cancel buttons (as the user may want to continue working in the editor):
            this.toolbar.getButton("save").set("disabled", false);
            this.toolbar.getButton("cancel").set("disabled", false);
          })
          );
        // end put

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_saveProperties");
      },


      // Called when the user clicks the Cancel button:
      _onCancelClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onCancelClick");

        // Publish that the editor has been cancelled:
        topic.publish(Resources.pubSubTopic.messageFlowPropertiesEditCancelled, {editor: this});

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onCancelClick");
      },

      // Populates the provided widget with the properties of the flow:
      _populateTableWithProperties: function() {
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_populateTableWithProperties");

        // Set the text that will be read out by a screen reader for the '...' column header of the properties
      	// table. This has to be done or a screen reader will just read out that the column is read-only (or
      	// nothing will be said at all). The reason that this is being done here is so we can be sure that the
      	// messageFlowPropertiesTable-valueDialog DOM element is available:
      	var elementThatIsTheAriaLabelForTheValueDialogColumn = dom.byId("messageFlowPropertiesTable-valueDialog");
        if (elementThatIsTheAriaLabelForTheValueDialogColumn !== undefined) {
          attr.set(elementThatIsTheAriaLabelForTheValueDialogColumn, "aria-label", NLS.editValueDialogColumnHeaderText);
        }

        xhr.get(
          this._getURI(),
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json"
            }
          }
        ).then( lang.hitch(this, function(response) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Call to get the properties for message flow was successful.");

          // Populate table with properties:
          var shortDescSet = false;
          var longDescSet = false;

          var i;
          var name;
          var value;
          if ( response !== undefined  ) {
            if (response.basicProperties !== undefined){
              for (i = 0; i < response.basicProperties.length; i++) {
                name = response.basicProperties[i].name;
                if (name === "shortDesc") {
                  value = response.basicProperties[i].value;
                  this.propertyData.push(
                    {
                      id: NLS.messageFlow.shortDesc,
                      internalName: name,
                      displayName: NLS.messageFlow.shortDesc,
                      propertyType : "text",
                      value: value,
                      type: "basic"
                    });
                  shortDescSet = true;
                } else if (name === "longDesc") {
                  value = response.basicProperties[i].value;
                  this.propertyData.push(
                    {
                      id: NLS.messageFlow.longDesc,
                      internalName: name,
                      displayName: NLS.messageFlow.longDesc,
                      propertyType : "text",
                      value: value,
                      type: "basic"
                    });
                  longDescSet = true;
                }
              }
            }

            // Make sure long/short description are available for editing
            if (!shortDescSet) {
              this.propertyData.push({
                id: NLS.messageFlow.shortDesc,
             		internalName: "shortDesc",
             		displayName: NLS.messageFlow.shortDesc,
                propertyType : "text",
              	value: "",
              	type: "basic"
              });
            }

            if (!longDescSet) {
              this.propertyData.push({
            		id: NLS.messageFlow.longDesc,
            		internalName: "longDesc",
            		displayName: NLS.messageFlow.longDesc,
                propertyType : "text",
            		value: "",
            		type: "basic"
            	});
            }

            if (response.userDefinedProperties !== undefined){
              for (i = 0; i < response.userDefinedProperties.length; i++) {
                name = response.userDefinedProperties[i].name;
                value = response.userDefinedProperties[i].value;
                this.propertyData.push({
                  id: name,
                  internalName: name,
                  displayName: name,
                  propertyType : "text",
                  value: value,
                  type: "userDefined"
                });
              }
            }

            this._getPropertiesTable().select.row.clear(); // clear any selections first
            this._getPropertiesTable().model.clearLazyData(); // clear off any edits that may exist
            this._getPropertiesTable().model.clearCache();
            this._getPropertiesTable().model.store.setData(this.propertyData);
            this._getPropertiesTable().body.refresh();
          }
        }), lang.hitch(this, function(error) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Text: " + error.response.text);

          // Display a message that the properties could not be obtained:
          window.smallMessage.displayPlainMessage("error", "_errorGettingProperties");
        }));

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_populateTableWithProperties");
      },
      
            
      // Called when the user changes the value of a property in the property table:
      _handlePropertyValueChanged: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handlePropertyValueChanged");
      
        // Set the change flag:
        if (!this._hasUserMadeAChange) {
      	  this._hasUserMadeAChange = true;
      	}
      	
      	// Validate:
      	this._validate();
      	
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handlePropertyValueChanged");
      },
      
      // Validates the widget. Called when the user makes a change to a property value in the UI.
      _validate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_validate");
        
        // Don't need to check any of the property values for invalid characters
        
        // If we have gotten this far everything is good, so hide current message and enable the save button:
        window.smallMessage.hideMessage();
        this.toolbar.getButton("save").set("disabled", false);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_validate");
      },
      
      // Returns true if the editor is dirty, false otherwise.
      isDirty: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "isDirty");
        // Check if the editor is dirty by checking the state of the save button or the change flag:
        var result = false;
        if (this.toolbar !== undefined && this.toolbar.getButton("save") !== undefined && !this.toolbar.getButton("save").get("disabled")) {
        	result = true;
        }
        else if (this._hasUserMadeAChange) {
        	result = true;
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "isDirty");
        return result;
      },

      // Called by dojo when this widget is being destroyed:
      uninitialize: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "uninitialize");
        // Destroy the property value edit dialog if it exists:
      	var editPropertyValueDialog = registry.byId("editPropertyValueDialog");
      	if (editPropertyValueDialog !== null && editPropertyValueDialog !== undefined) {
      		editPropertyValueDialog.destroy();
      	}
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "uninitialize");
      }

    });
    return messageFlowPropertyEditor;
  }
);

},
'webui/utils/WebUiHash':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="392431026" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */

/**
 * A WebUiHash object is a thin wrapper for a string representing a hash string,
 * e.g. "executionGroup/0/executiongroups/default", "broker/0", "",
 * "dataCaptureStore/0/data/datacapture/MyStore", ...
 * WebUiHash objects are intended to be immutable.
 */
define(
  [
    "dojo/_base/declare",
    "webui/utils/RestUri"
  ],
  function(
    declare,
    RestUri
  ) {
    var WebUiHash = declare("webui.utils.WebUiHash", [], {
      
      /** The original hash, in string form */
      "_string" : null,
      
      /** e.g. "policy" */
      "_type" : null,
      
      /** A string e.g. "0" */
      "_tabNum" : null,
      
      /** e.g. ["executiongroups", "default", "messageflows", "flow1"] */
      "_components" : null,
      
      /**
       * new WebUiHash("a/0/b/c/d"),
       * new WebUiHash({"string" : "a/0/b/c/d"}),
       * new WebUiHash({"type" : "a", "tabNum" : "0", "components" : ["b", "c", "d"]})
       */
      "constructor" : function(args) {
        if(typeof args === "string") {
          args = {
            "string" : args
          };
        }

        // Constructor 1: from string
        if(args.string) {
          if(args.components) {
            throw new Error("Can't pass both `string` and `components` into this constructor");
          }

          // The hash should never have two slashes in a row.
          if(args.string.indexOf("//") >= 0) {
            //args.string.replace(/\/{2,}/g, "/");
            throw new Error("A hash should never have two slashes in a row: '" + args.string + "'");
          }

          // Or end with a slash.
          if(args.string.charAt(args.string.length - 1) === "/") {
            //args.string = args.string.substring(0, args.string.length - "/".length)
            throw new Error("A hash should never end with a slash: '" + args.string + "'");
          }

          this._string = args.string;
          
          var components = this._string.split("/").map(decodeURIComponent);
          // e.g. ["broker", "0"]
          // e.g. ["executionGroup", "0", "executiongroups", "default", ...]
          // e.g. []

          this._type = components.shift() || "broker"; // "subFlow" or "broker" by default
          
          // The above logic of setting the type based on the first component does not work if the hash is the configurable services
          // hash (for example, configurableService/0/policy/configurableservices). Check for this case and set the re-set the type
          // if necessary:
          if (this._type === "configurableService" && components.length > 0 && components[components.length - 1] === "configurableservices") {
          	this._type = "configurableservices";
          }
          // same problem for business recorders
          if (this._type === "businessRecorder" && components.length > 0 && components[components.length - 1] === "businessrecorders") {
            this._type = "businessrecorders";
          }
          
          // To cope with old bookmarks:
          // If the second part of the URI hash is not the tab
          // number, then splice it in.
          if(
            components[0] === "executiongroups" ||
            components[0] === "policy" ||
            components[0] === "data" ||
            components[0] === "security" ||
            components[0] === "monitoring"
          ) {
            this._tabNum = "0";
          } else {
            this._tabNum = components.shift() || "0"; // string "0", "1", ...
          }

          this._components = components;
          return;
        }
        
        // Constructor 2: from type, tab number and path components
        if(args.components) {
          this._type = args.type;
          this._tabNum = args.tabNum;
          this._components = args.components.slice();

          var string = encodeURIComponent(this._type);
          string += "/" + encodeURIComponent(this._tabNum);
          this._components.forEach(function(pathComponent) {
            string += "/" + encodeURIComponent(pathComponent);
          });
          this._string = string;

          return;
        }
        
        throw new Error("Must pass at least one of `string` and `components` into this constructor");
      },
      
      "toString" : function() {
        return this._string;
      },
      
      "getType" : function() {
        return this._type;
      },
      
      "getTabNum" : function() {
        return this._tabNum;
      },
      
      "getComponents" : function() {
        // Make a copy in case the caller modifies it
        return this._components.slice();
      },
      
      // This isn't necessarily the name of anything in particular
      "getName" : function() {
        return this._components[this._components.length - 1];
      },
      
      "getRestUri" : function() {
        return new RestUri({"components" : this._components});
      },
      
      "getNotificationTopic" : function(appendWildcard) {
        return this.getRestUri().getNotificationTopic(appendWildcard);
      },
      
      "getArtifactName" : function() {
        return this.getRestUri().getArtifactName();
      },
      
      "getUserName" : function() {
          return this.getRestUri().getUsername();
        },
      
      "isBusinessTransactions" : function() {
        return this.getRestUri().isBusinessTransactions();
      },
      
      "getArtifactType" : function() {
        return this.getRestUri().getArtifactType();
      },
      
      "getConfigurableServiceType" : function() {
        return this.getRestUri().getConfigurableServiceType();
      },
      
      "getConfigurableServiceName" : function() {
        return this.getRestUri().getConfigurableServiceName();
      },
      
      "getIntegrationServerName" : function() {
        return this.getRestUri().getIntegrationServerName();
      },
      
      "getPolicyName" : function() {
        return this.getRestUri().getPolicyName();
      },
      
      "getPolicyType" : function() {
        return this.getRestUri().getPolicyType();
      },
      
      "getStatsTopic" : function(appendWildcard) {
        return this.getRestUri().getStatsTopic(appendWildcard);
      },
      
      "getResourceStatsTopic" : function() {
        return this.getRestUri().getResourceStatsTopic();
      },
      
      "isBusinessTransactionRecorder" : function() {
        return this.getRestUri().isBusinessTransactionRecorder();
      },
      
      /**
       * Return a new WebUiHash object with a different tab
       * number. This is provided instead of a setTabNum() method
       * because WebUiHash objects are intended to be immutable.
       */
      "withTabNum" : function(tabNum) {
        return new WebUiHash({
          "type" : this.getType(),
          "tabNum" : tabNum,
          "components" : this.getComponents()
        });
      }
    });
    
    // Methods delegated to RestUri's implementation
    
    // Static methods

    /**
     * Convert a REST URI e.g.
     * "/apiv1/executiongroups/default2/applications/app1/libraries/lib1/messageflows/flow1"
     * to a hash e.g.
     * "messageFlow/0/executiongroups/default2/applications/app1/libraries/lib1/messageflows/flow1".
     * `restUri` can be a string or a RestUri object.
     */
    WebUiHash.fromRestUri = function(restUri) {
      if(typeof restUri === "string") {
        restUri = new RestUri(restUri);
      }

      var components = restUri.getComponents();

      var tabNum = "0";
      
      var hashType;

      // E.g. rest URI "/apiv1" which points to the integration node and has
      // hash "" or "broker/0", so hashType is "broker".
      if(restUri.isIntegrationNode()) {
        hashType = "broker";
      }
      
      // e.g. "/apiv1/policy/businesstransactionrecorders"
      // has hash "businessTransactionRecorder/0/..."
      else if(restUri.isBusinessTransactionRecorder()) {
        hashType = "businessTransactionRecorder";
      }

      // e.g. the REST URI "/apiv1/policy/configurableservices/ActivityLog/A123"
      // has hash "configurableService/0/policy/configurableservices/ActivityLog/A123"
      else if(restUri.isConfigurableService()) {
        hashType = "configurableService";
      }
      
      // E.g. the REST URI "/apiv1/policy/WorkloadManagement/MyPolicy1"
      // has hash "policy/0/policy/WorkloadManagement/MyPolicy1"
      // and "/apiv1/policy/WorkloadManagement"
      // becomes "policy/0/policy/WorkloadManagement"
      // so hashType is "policy"
      else if(restUri.isPolicyType() || restUri.isPolicy()) {
        hashType = "policy";
      }
      
      // E.g. the REST URI "/apiv1/data"
      // has hash "data/0/data"
      // so hashType is "data"
      else if(components[0] === "data") {
        hashType = "data";
      }
      
      else if(restUri.isBusinessTransactions()) {
        hashType = "businessTransaction";
      }

      // E.g. the REST URI "/apiv1/executiongroups/default/messageflows/flow1"
      // has a hash "messageFlow/0/executiongroups/default/messageflows/flow1" which yields
      // the hash type "messageFlow" (note capitalisation).
      else if(restUri.isArtifact()) {
        var artifactType = restUri.getArtifactType();
        
        var lookup = {
          "messageflows" : "messageFlow",
          "libraries" : "library",
          "applications" : "application",
          "executiongroups" : "executionGroup",
          "subflows" : "subFlow",
          "sharedlibraries" : "sharedLibrary"
        };
        
        if(!(artifactType in lookup)) {
          throw new Error("hashType for artifactType '" + artifactType + "' not found.");
        }

        hashType = lookup[artifactType];
      }
      
      else {
        throw new Error("Don't know how to get hashType for URI '" + restUri.toString() + "'");
      }

      return new WebUiHash({
        "type" : hashType,
        "tabNum" : tabNum,
        "components" : components
      });
    };
    
    WebUiHash.forPolicy = function(policyType, policyName) {
      return WebUiHash.fromRestUri(RestUri.forPolicy(policyType, policyName));
    };
    
    WebUiHash.forConfigurableService = function(csType, csName) {
      return WebUiHash.fromRestUri(RestUri.forConfigurableService(csType, csName));
    };
    
    return WebUiHash;
  }
);

},
'webui/widgets/dataviewer/Pagination':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="1067411821" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/i18n!webui/nls/web",
	"dojo/text!webui/widgets/dataviewer/templates/Pagination.html",
	"dojo/_base/declare", 
	"dojo/dom-attr",
	"dojo/dom-class",
	"dijit/_TemplatedMixin",
	"dijit/_WidgetBase", 
  "dijit/_WidgetsInTemplateMixin",
	"webui/widgets/common/Trace" 
], function(
  NLS,
  template,
  declare,
  domAttr,
  domClass,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  Trace
) {
	var Pagination = declare("webui.widgets.dataviewer.Pagination", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
		
		templateString: template,
		
		currentPage: "",
		totalPages: "",
		
		_setTotalSelectedAttr: function (totalResults,numberSelected) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setTotalSelectedAttr"); 
			this._createLeftString(totalResults, numberSelected);			
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setTotalSelectedAttr"); 
		},
		

		_setPageNumbersAttr: function (currentPage,totalPages) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setPageNumbersAttr"); 
			this._createCentreString(currentPage, totalPages);			
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setPageNumbersAttr"); 
		},
		
		_setNumberDisplayedAttr: function (totalResults,displayNumber) {
			 Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setTotalSelectedAttr"); 
			 this._createRightString(totalResults, displayNumber);			
			 Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setTotalSelectedAttr"); 
		},
		
		_getCurrentPageAttr: function () {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_getCurrentPageAttr"); 
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "_getCurrentPageAttr"); 
			return this.currentPage;
		},
		
		_getTotalPagesAttr: function () {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_getTotalPagesAttr"); 
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "_getTotalPagesAttr"); 
			return this.totalPages;
		},
    
		postCreate: function() {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate"); 
     
		  //on(this._goToPageDialog, "click", lang.hitch(this, this._showGoToPageDialog));	
     
		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate"); 
		},
    	
    	_createLeftString: function(totalResults,numberSelected) {
		    Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createLeftString"); 
    	    	
    						// var _selectedResults = 0;
			if (totalResults == -1) {
			  domAttr.set(this.paginationLeft, "innerHTML", "");
						// dom.byId("_rrr_dataViewerToolBar_paginationFooterLeft_ID").innerHTML = "";
			} else {
			  domAttr.set(this.paginationLeft, "innerHTML", NLS.rrrPaginationTotal + ": " + totalResults + " " + NLS.rrrPaginationSelected + ": " + numberSelected);
						// dom.byId("_rrr_dataViewerToolBar_paginationFooterLeft_ID").innerHTML = NLS.rrrPaginationTotal + ": " + this._totalNumberOfResults + " " + NLS.rrrPaginationSelected + ": " + _selectedResults;
			}
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "createLeftString"); 
    	},
    	
    	_createCentreString: function(currentPage, totalPages) {
    		Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createCentreString"); 
    		
    		var paginationString;
    		if(currentPage==1){
    			paginationString = "<a alt='Previous button disabled' class='_paginationPreviousInactive'></a>";
    		} else {
    			paginationString = "<a alt='previous' title='" + NLS.paginationPreviousPage + "' class='_paginationPreviousActive'></a>";
    		}
        var delimiter = "..."; 
        var spanInactiveStart = "<span class='_paginationInactive'>"; 
        var spanInactiveEnd = "</span>";
        var spanActiveStart = "<a alt='number' class='_paginationActive'>"; 
        var spanActiveEnd = "</a>"; 
          	
        var pageCount;
        var j;
        	if(totalPages <= 1) {
        		paginationString = "";
        	} else if(totalPages <= 5){
        		//Add the page numbers before current page, each as a link
        		pageCount=1;
        		for (j=0;j<totalPages;j++){
        			if(pageCount == currentPage){
        				paginationString = paginationString + " " + spanInactiveStart + pageCount + spanInactiveEnd;
        			} else {
        				paginationString = paginationString + " " + spanActiveStart + pageCount + spanActiveEnd;
        			}
        			pageCount++;
        		}
        		if(currentPage==totalPages){
        		  paginationString = paginationString + "<a alt='Next button disabled' class='_paginationNextInactive'></a>";
        		} else {
        		  paginationString = paginationString + "<a alt='next' title='" +  NLS.paginationNextPage + "' class='_paginationNextActive'></a>";
        		}
        	} else {
        		//If the current page number is 3 or less then join the first three numbers together
        		//paginationString = "";
        		pageCount=0;
        		if(currentPage <= 3){
        			for (j=1;j<String(currentPage);j++){
        				pageCount++;
        				paginationString = paginationString + " " + spanActiveStart + pageCount + spanActiveEnd;	
        			}
        			pageCount++;
        			paginationString = paginationString + " " + spanInactiveStart + pageCount + spanInactiveEnd;
        			for (j=currentPage;j<3;j++){
        				pageCount++;
        				paginationString = paginationString + " " + spanActiveStart + pageCount + spanActiveEnd;	
        			}
        			if(pageCount == currentPage){
        				pageCount++;
        				paginationString = paginationString + " " + spanActiveStart + pageCount + spanActiveEnd;
        			}
        			paginationString = paginationString + delimiter + spanActiveStart + totalPages + spanActiveEnd;
        		} else {
        			paginationString = paginationString + spanActiveStart + "1" + spanActiveEnd + delimiter;
        			if(currentPage < (totalPages-2)){
        				pageCount = currentPage;
        				paginationString = paginationString + spanActiveStart + (parseInt(pageCount)-1) + spanActiveEnd;
        				paginationString = paginationString+ " " + spanInactiveStart + pageCount + spanInactiveEnd;
        				paginationString = paginationString + " " + spanActiveStart + (parseInt(pageCount)+1) + spanActiveEnd + delimiter;
        				paginationString = paginationString + spanActiveStart + totalPages + spanActiveEnd;	
        			} else {
        				pageCount = currentPage - 1;
        				for(j=0;j<(totalPages - currentPage + 2);j++){
        					if(pageCount == currentPage){
        						paginationString = paginationString + " " + spanInactiveStart + pageCount + spanInactiveEnd;
        					} else {
        						paginationString = paginationString + " " + spanActiveStart + pageCount + spanActiveEnd;
        					}
        					pageCount++;	
        				}
        			}
        		}
        		if(currentPage==totalPages){
					paginationString = paginationString + "<a alt='Next button disabled' class='_paginationNextInactive'></a>";
        		} else {
					paginationString = paginationString + "<a alt='next' title='" + NLS.paginationNextPage + "' class='_paginationNextActive'></a>";
        		}	
        	}
        	
        	// if(totalPages >= 25) {
        		// paginationString = paginationString + "<a alt='gotopage' title='" + NLS.paginationGoToPage + "' class='_paginationGoToPage'></a>"
        		// paginationString = paginationString + "<div id='_goToPageDialog' class='goToPageDialog _common_hideDiv' data-dojo-attach-point='_goToPageDialog'></div>";
        	// }
        	
        	domAttr.set(this.paginationCentre, "innerHTML", paginationString);
    		
    		Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createCentreString"); 
    	},
    	
    	_createRightString: function(totalResults, displayNumber) {
    		Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createRightString"); 
    		var displayNumberString = "";
 	    	
	    	if(totalResults>10){
	    		if(displayNumber == 10){
	    			displayNumberString = "<span class='_paginationInactive'>10 | </span>"; 
	    		} else {
	    			displayNumberString = "<span class='_paginationActive'><a alt='displayNumber'>10</a></span><span class='_paginationInactive'> | </span>"; 
	    		}
	    	} 
	    	
	    	if (totalResults>20){
	    		if(displayNumber == 20){
	    			displayNumberString = displayNumberString + "<span class='_paginationInactive'>20 | </span>"; 
	    		} else {
	    			displayNumberString = displayNumberString + "<span class='_paginationActive'><a alt='displayNumber'>20</a></span><span class='_paginationInactive'> | </span>"; 
	    		}
	    	}
	    	
	    	if (totalResults>50){
	    		if(displayNumber == 50){
	    			displayNumberString = displayNumberString + "<span class='_paginationInactive'>50 | </span>"; 
	    		} else {
	    			displayNumberString = displayNumberString + "<span class='_paginationActive'><a alt='displayNumber'>50</a></span><span class='_paginationInactive'> | </span>"; 
	    		}
	    	}
	    	
	    	if (totalResults>100){
	    		if(displayNumber == 100){
	    			displayNumberString = displayNumberString + "<span class='_paginationInactive'>100</span>"; 
	    		} else {
	    			displayNumberString = displayNumberString + "<span class='_paginationActive'><a alt='displayNumber'>100</a></span><span class='_paginationInactive'> | </span>"; 
	    		}
	    	}
			
  			if (totalResults<=100){
  				if(displayNumber == ""){		
  					displayNumberString = displayNumberString + "<span class='_paginationInactive'>" + NLS.paginationAll + "</span>";
  				} else {
  					displayNumberString = displayNumberString + "<span class='_paginationActive'><a alt='all'>" + NLS.paginationAll + "</a>	</span>";
  				}
  			}
  			domAttr.set(this.paginationRight, "innerHTML", displayNumberString);		

  			Trace.trace(this.declaredClass, Trace.levels.EXIT, "createRightString"); 
    	},
    	
    	_showGoToPageDialog : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showGoToPageDialog");
			
			domClass.add("this._goToPageDialog","_common_hideDiv");
		
		//	 domAttr.set(this._goToPageDialog, "class", "_common_hideDiv");	
			// if(this._filterVisible) {
				// this._closeFilterDialog();		
			// } else {
				// this._closeReplayDialog();
				// var fadeArgs = {
					// node: "_rrr_dataViewer_filter_ID",
					// duration: 300,
					// beforeBegin: function() {
	        			// domClass.remove("_rrr_dataViewer_filter_ID","_common_hideDiv");    			     
	      			// }
				// };
				// fx.fadeIn(fadeArgs).play();
				// this._filterVisible = true;
			// }
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showGoToPageDialog");
		}
	});

  return Pagination;
});

},
'webui/widgets/restapi/Overview':function(){
/*
 * <copyright
 * notice="lm-source"
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2"
 * years="2011,2016"
 * crc="912155494" >
 * Licensed Materials - Property of IBM
 *
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2
 *
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.
 * </copyright>
 */
define([
  "dojo/text!webui/widgets/restapi/templates/Overview.html",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/array",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/dom-construct",
  "dojo/query",
  "dojo/request/xhr",
  "dojo/string",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase",
  "dijit/_WidgetsInTemplateMixin",
  "dijit/registry",
  "webui/widgets/common/AttributesStore",
  "webui/widgets/common/HasContextMenu",
  "webui/widgets/common/QuickAndAdvancedProperties",
  "webui/widgets/common/PropertiesStore",
  "webui/widgets/common/Toolbar",
  "webui/widgets/common/Trace"
], function(
  template,
  NLS,
  array,
  declare,
  lang,
  domAttr,
  domConstruct,
  query,
  xhr,
  string,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  registry,
  AttributesStore,
  HasContextMenu,
  QuickAndAdvancedProperties,
  PropertiesStore,
  Toolbar,
  Trace
) {
    var restApiOverview = declare("webui.widgets.restapi.Overview", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
        templateString: template,
        toolbar: null,
        _propertiesStore: new PropertiesStore(),
        _attributesStore : new AttributesStore(),

				// Filter out the baseURL and definitionsURL properties.
        _filterProperty: function(name, value) {
          if (name === "baseURL" || name === "definitionsURL") {
            return false;
          }
          return true;
        },

				// Translate the localBaseURL and localDefinitionsURL properties into baseURL and definitionsURL.
				// At the same time, replace localhost with the hostname used to access the web UI.
        _translateProperty: function(name, value) {
          if (name === "localBaseURL") {
            name = "baseURL";
            value = value.replace("//localhost", "//" + window.location.hostname);
          } else if (name === "localDefinitionsURL") {
            name = "definitionsURL";
            value = value.replace("//localhost", "//" + window.location.hostname);
          }
          return {
            name: name,
            value: value
          };
        },

        postCreate: function() {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
          this.inherited(arguments);

          // Create toolbar
          this.toolbar = new Toolbar();
          domConstruct.place(this.toolbar.domNode, this._toolbar);
          this.toolbar.addLeftAlignButtons("title");

          this.properties = new QuickAndAdvancedProperties("restApi");
          this.properties.setFilterProperty(this._filterProperty);
          this.properties.setTranslateProperty(this._translateProperty);
          this.properties.createPropertiesContainer(this._propertyTitlePane);

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
        },

        resize: function() {
          this._restApiOverview_borderContainer.resize();
        },

        // This function is called manually when we need to remove this tab.
        tabRemove: function() {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");

          this.properties.unsubscribeAll();

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
        },

        contextButtonsClicks : function(event) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks", [event]);

          var buttonNode;
          var buttonType;
          var itemURI;
          var tmp = [];

          if(event.type == "keyup"){
            tmp = event.target.id.split("_");
            buttonType = tmp[tmp.length - 1];
            itemURI = event.target.id;
          } else {
            buttonNode = event.target.parentNode;
            if (buttonNode.id == '') {
              tmp = buttonNode.parentNode.id.split("_");
              buttonType = tmp[tmp.length - 1];
              itemURI = buttonNode.parentNode.id;
            } else {
              tmp = buttonNode.id.split("_");
              buttonType = tmp[tmp.length - 1];
              itemURI = buttonNode.id;
            }
          }

          if(buttonType == "statsOn" || buttonType == "statsOff"){
            this.actionButtonSetStatsContainer(itemURI, buttonType);
          }else{
            this.actionRestApi(itemURI, buttonType);
          }

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
        },

        actionButtonSetStatsContainer : function(itemURI,buttonType){
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionButtonSetStatsContainer",[itemURI,buttonType]);
          var targetUri = itemURI.substring(0, (itemURI.length - (buttonType.length+1)));
          var uriStatsparam;
          if(buttonType == "statsOn"){
            uriStatsparam="on";
          }else if(buttonType == "statsOff"){
            uriStatsparam="off";
          }

          // Add loading icon to tree
          var tree = registry.byId('_explorerTree_ID');
          var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
          var oldIcon = domAttr.get(treeImgs[0],"class");
          domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");

          xhr.put(
            targetUri + "?action=setStatistics&setStatistics=" + uriStatsparam,
            {
              handleAs:"json",
              headers : {
                 "Accept" : "application/json"
              }
            }
          ).response.then(
            lang.hitch(this, function(response){
              Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionButtonSetStatsContainer.xhrLoad",[response]);

              //reset old icon
              domAttr.set(treeImgs[0],"class",oldIcon);

              if(buttonType == "statsOn"){
                window.smallMessage.displayMessage("success", "FlowStatsAction_successstatsOn");
              } else {
                window.smallMessage.displayMessage("success", "FlowStatsAction_successstatsOff");
              }

              Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionButtonSetStatsContainer.xhrLoad");
            }),
            lang.hitch(this,function(error){
              Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionButtonSetStatsContainer.xhrError",[error]);

              //reset old icon
              domAttr.set(treeImgs[0],"class",oldIcon);
              //show error message
              var response = JSON.parse(error.response.text);
              if(buttonType == "statsOn") {
                window.smallMessage.displayMessage("error", "msgflowstatsOn_5XX", response.bipNumber, response.description);
              } else {
                window.smallMessage.displayMessage("error", "msgflowstatsOff_5XX", response.bipNumber, response.description);
              }

              Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionButtonSetStatsContainer.xhrError");
            })
          );

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionButtonSetStatsContainer");
        },

        actionRestApi : function(uri, action){

          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionRestApi", [uri,action]);

          var uriArray = uri.split("_");
          var buttonType = uriArray[uriArray.length - 1];
          uri = uri.substr(0,uri.length - buttonType.length - 1);

          var tree;
          if (null!=action && action === "delete" ) {

            tree = registry.byId('_explorerTree_ID');
            var restApiName = tree.selectedNode.item.name;//label can be truncated, so use name instead

            var confirmationMessage = string.substitute(NLS.messages.DeleteRestApiAction_confirmation, [restApiName] );

  	        var confirmCallback = lang.hitch(this, function() {

  	          //	Add loading icon to tree
  	          var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
  	          var oldIcon = domAttr.get(treeImgs[0],"class");
  	          domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");

  	          // REST Call to delete the REST API
  	          xhr.del(
  	              uri,
  	              {
  	                handleAs : "json",
  	                headers : {
  	                   "Accept" : "application/json"
  	                }
  	              }
  	            ).then( lang.hitch(this, function() {
  	              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "REST API delete success");

  	              //reset old icon
  	              domAttr.set(treeImgs[0],"class",oldIcon);

  	              // Display success message for deleting an REST API
  	              window.smallMessage.displayPlainMessage("success", "DeleteRestApiAction_successRestApiDeleted", [restApiName]);
  	            }),
  	            lang.hitch(this, function(error) {

  	              Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrDel to " + uri + " failed.", [error]);

  	              //reset old icon
  	              domAttr.set(treeImgs[0],"class",oldIcon);

  	              //show error message
  	              var response = JSON.parse(error.response.text);
  	              window.smallMessage.displayMessage("error", "restapidelete_5XX",response.bipNumber, response.description);
  	            })
  	          );
  	        });

  	        window.wmbConsole.showConfirmationDialog("btConfirmDelete", "question", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, confirmationMessage, confirmCallback, null);



          }//if
          else {

              // Add loading icon to tree
              tree = registry.byId('_explorerTree_ID');
              var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
              var oldIcon = domAttr.get(treeImgs[0],"class");
              domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");

              xhr.put(
                uri + "?action=" + action,
                {
                  handleAs:"json",
                  headers : {
                     "Accept" : "application/json"
                  }
                }
              ).response.then(
                lang.hitch(this, function(response){
                  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionRestApi.xhrLoad()",[response]);

                  this.buttonState(action, uri);

                  var restApiName = tree.selectedNode.item.name;//label can be truncated, so use name instead
                  if (action === "startFlowMonitoring") {
      	            window.smallMessage.displayPlainMessage("success", "FlowMonitoringStartedSuccessfully_RestApi", [restApiName]);
                  } else if (action === "stopFlowMonitoring") {
                	window.smallMessage.displayPlainMessage("success", "FlowMonitoringStoppedSuccessfully_RestApi", [restApiName]);
                  }

                  Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionRestApi.xhrLoad()");
                }),
                lang.hitch(this,function(error){
                  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionRestApi.xhrError()",[error]);

                  Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrPut to " + uri + " failed.", [error]);
                  //reset old icon
                  domAttr.set(treeImgs[0],"class",oldIcon);
                  //show error message
                  var response = JSON.parse(error.response.text);
                  if(action == "start"){
                    window.smallMessage.displayMessage("error", "restapistart_5XX",response.bipNumber, response.description);
                  } else if (action === "stop") {
                    window.smallMessage.displayMessage("error", "restapistop_5XX",response.bipNumber, response.description);
                  } else if (action === "startFlowMonitoring") {
        	        window.smallMessage.displayMessage("error", "FlowMonitoringFailedToStart");
                  } else if (action === "stopFlowMonitoring") {
                	window.smallMessage.displayMessage("error", "FlowMonitoringFailedToStop");
                  }
                  Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionRestApi.xhrError()");
                })
              );

          }//endif


          Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionRestApi");
        },

        buttonState:function(action, uri){
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "buttonState", [action, uri]);

          // Disable and enable the relevant buttons
          var tree = registry.byId('_explorerTree_ID');
          var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');

          var populateAttributesStore = this._attributesStore.populateAttributesStore(uri);
          var populatePropertiesStore = this._propertiesStore.populatePropertiesStore(uri);

          populatePropertiesStore.then(lang.hitch(this, function() {
            populateAttributesStore.then(lang.hitch(this, function() {
              Trace.trace(this.declaredClass, Trace.levels.ENTRY, "buttonState.then", [action, uri]);
              // Get the flow's running status
              var running = (this._propertiesStore.getProperty("basic", "isRunning") == "true");
              var name = this._attributesStore.getAttribute("name");

              // Set the TreeNode icon as appropriate
              if (running) {
                domAttr.set(treeImgs[0], "class", "dijitInline dijitIcon dijitTreeIcon explorer_restApi_running");
              } else {
                domAttr.set(treeImgs[0], "class", "dijitInline dijitIcon dijitTreeIcon explorer_restApi_stopped");
              }

              // Same for context menu
              this._updateContextMenuTitle(uri, name, "restApi", running);

              //Now show/hide the appropriate start/stop stats on/off buttons, but greying out as appropriate
              //Again iterating over all viewable buttons to find the ones which we have just changed
              array.forEach(this._getContextButtons(uri), function(button) {
                var tmp = button.id.split("_");
                var buttonType = tmp[tmp.length - 1];
                var thisButtonUri = button.id.substring(0,button.id.length - (buttonType.length+1));

                if( thisButtonUri == uri){
                  switch(buttonType){
                    case "start":
                      button.set("disabled", running);
                      break;
                    case "stop":
                      button.set("disabled", !running);
                      break;
                  }
                }
              }, this);
              Trace.trace(this.declaredClass, Trace.levels.EXIT, "buttonState.then");
            }));
          }));
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "buttonState");
        },

        tabFocus: function() {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");

          this.properties.unsubscribeAll();

          // Get REST API name and add to the toolbar title
          this.toolbar.setAttribute("title", "innerHTML", "");
          var populate = this._attributesStore.populateAttributesStore();
          populate.then(lang.hitch(this, function() {
            domAttr.set("_infoPaneTitleID", "innerHTML", this._attributesStore.getAttribute("name") + " - " + NLS.restApiTitle);
          }));

          // Populate quick view and advanced properties
          this.properties.populateProperties();

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
        },

        // This function is called manually when we need to remove this tab.
        tabBlur: function() {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");

          this.properties.unsubscribeAll();

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
        }
      }
    );
    return restApiOverview;
  }
);

},
'webui/login/widgets/SignIn':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="3417708379" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!./SignIn.html",
  "dojo/i18n!webui/login/nls/web", 
  "dojo/_base/declare", 
  "dojo/dom",
  "dojo/dom-attr",
  "dojo/dom-class",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase",
  "dijit/_WidgetsInTemplateMixin",
  "dijit/focus",
  "webui/widgets/common/Trace", 
  "dojo/domReady!"
], function(
  templateHtml,
  NLS,
  declare,
  dom,
  domAttr,
  domClass,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  focus,
  Trace
) {
  declare("webui.login.widgets.SignIn", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
		
		templateString : templateHtml,

		postCreate: function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate"); 
			
			// NLS Strings
			domAttr.set(this.login_productName, "innerHTML", NLS.loginPageTitle);
			domAttr.set(this.login_id, "innerHTML", NLS.loginId);
			domAttr.set(this.login_password, "innerHTML", NLS.loginPassword);
			domAttr.set(this.login_buttonLabel, "value", NLS.loginButtonLabel);
			domAttr.set(this.login_legalText, "innerHTML", NLS.legalText);
			domAttr.set(this.login_failure, "innerHTML", NLS.loginFailure);
			
			// If login has failed then show the error message
			if (window.location.pathname=='/j_security_check'){ // !!!
				domClass.remove("login_failure_icon","_common_hideDiv");	
				domClass.remove("login_failure","_common_hideDiv");	
			}
			
			// Set automatic focus to the user id field
			focus.focus(dom.byId("login_id"));
	        	        
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate"); 
		}
  });
});

},
'webui/widgets/executiongroup/NewExecutionGroupDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="763384209" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/executiongroup/templates/NewExecutionGroupDialog.html",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/array",
  "dojo/_base/declare",
  "dojo/_base/event",
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/keys",
  "dojo/on",
  "dojo/request/xhr",
  "dijit/Dialog",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetsInTemplateMixin",
  "webui/config/Resources",
  "webui/widgets/common/Trace"
], function(
  template,
  NLS,
  array,
  declare,
  event,
  lang,
  domAttr,
  keys,
  on,
  xhr,
  Dialog,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  Resources,
  Trace
) {
	var executionGroupNewDialog = declare("webui.widgets.executiongroup.NewExecutionGroupDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
		templateString: template,
		_namesInUse: [],
		_nameChangedEventHandle: null,
    _value: null,
    _beginNameValidation: false,
        
    //need to pass in this info because we need to pass it along to the callback method for an ajax call.
  	constructor: function(args){
  	  if(!args) {
  	    throw new Error("No arguments passed");
  	  }
	    this._value = args.currentValue;
	  	this._callback = args.cback;
  	},

		_onKey : function(evt) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onKey");
			this.inherited(arguments);
			if (evt.charOrCode) {
				if (evt.charOrCode === keys.ENTER) {
					if ( !this._okButton.get("disabled" ) ) {
						event.stop(evt);
						this.onExecute();
					}
				}
			}
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onKey");
		},

		postCreate : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			this.inherited(arguments);

			domAttr.set(this.titleNode, "innerHTML", NLS.newExecutionGroupTitle );
			this.titleNode.setAttribute("tabIndex", -1);
			domAttr.set(this.instructionNode, "innerHTML", NLS.newExecutionGroupMsg );
			this.instructionNode.setAttribute("tabIndex", -1);
			domAttr.set(this._nameLabel, "innerHTML", NLS.newExecutionGroupLbl );
			this._nameText.set("value", this._value);
			domAttr.set(this._okButton, "label", NLS.okButtonLabel);
			domAttr.set(this._cancelButton, "label", NLS.cancelButtonLabel);


			this._nameText.focus();
			
			this._okButton.set("disabled", true);
			this.instructionDiv.style.color = "black";

			//make an ajax call to get list of existing execution groups
			xhr(Resources.REST.root + "/executiongroups", {
			  handleAs : "json",
        headers : {
          "Accept" : "application/json"
        }
			}).then( lang.hitch(this, function(resp) {
			  this._namesInUse = [];
			  array.forEach(resp.executionGroup , lang.hitch(this, function(item) {
			    this._namesInUse.push(item.name);
			  }));
			}));

			on(this, "execute", lang.hitch(this, function() {
				this._callback(this._nameText.get("value"));
				this.hide();
			}));
			on(this._cancelButton, "click", lang.hitch(this, function() {
				this.hide();
			}));

			this._nameChangedEventHandle = on(this._nameText, "change", lang.hitch(this, this.nameChanged));
				
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},

    show : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "show");	
      this.inherited(arguments);
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "show");
    },
	    
	      executionGroupNameCharactersValid : function(executionGroupName) {

	    	  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "executionGroupNameCharactersValid");

	    	  var invalidChars = "|^<>=*`\\/?:;\"$()'{}";//for all platforms
	    	  var char1 = String.fromCharCode(0x0A3);//'?'
	    	  var char2 = String.fromCharCode(0x0AC);//'?'
	    	  var char3 = String.fromCharCode(0x0A6);//'?'
	    	  var char4 = String.fromCharCode(0x20ac);//'?'
	    	  
	    	  invalidChars = invalidChars + char1 + char2 + char3 + char4;

	    	  var invalidCharFound = false;
	    	  
	    	  var i;
	    	  for (i = 0; i < invalidChars.length; i++) { 
	    		  if (  executionGroupName.indexOf( invalidChars[i] ) != -1 ){
	    			  invalidCharFound = true;
	    			  break;
	    		  }//if  
	    	  }//for
	    	  
	    	  Trace.trace(this.declaredClass, Trace.levels.EXIT, "executionGroupNameCharactersValid");
	    	  
	    	  return !invalidCharFound;
	      },
	      
	    
		// This gets called every time the content of the name box changes, i.e.
		// whenever a keystroke is pressed
		nameChanged : function() {
			
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "nameChanged");
			
            if (!this._beginNameValidation){
            	this._beginNameValidation = true;
            	return;
            }	
		    
			var value = this._nameText.get("value");
			domAttr.set(this.instructionNode, "innerHTML", NLS.nameExecutionGroupNameMsg );
			this.instructionDiv.style.color = "black";

			if (value == "") {

					this._okButton.set("disabled", true);
					//Only set the error message when the dialog is not displayed for the first time
					domAttr.set(this.instructionNode, "innerHTML", NLS.executionGroupNameEmptyErrorMsg );
					this.instructionDiv.style.color = "red";

			} else {
				var inUse = false;

				array.forEach(this._namesInUse, function(item) {
					if (value == item) {
						inUse = true;
					}
				});
				this._okButton.set("disabled", inUse);
				if (inUse) 
				{
						
					//Only set the error message when the dialog is not displayed for the first time
						domAttr.set(this.instructionNode, "innerHTML", NLS.executionGroupNameDuplicateErrorMsg );
						this.instructionDiv.style.color = "red";
						
				} else {
					
					
					if ( !this.executionGroupNameCharactersValid( value ) ) {
					    domAttr.set(this.instructionNode, "innerHTML", NLS.executionGroupNameInvalidErrorMsg );
						this.instructionDiv.style.color = "red";
						this._okButton.set("disabled", true);
					}//if
				}
			}
			

			Trace.trace(this.declaredClass, Trace.levels.EXIT, "nameChanged");
		}

	});
	return executionGroupNewDialog;
});

},
'webui/widgets/restapi/Operation':function(){
/*   
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2015,2016" 
 * crc="857113219" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.  
 * </copyright> 
 */

define([
  "dojo/i18n!webui/nls/web",
  "dojo/text!./templates/Operation.html",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/dom-class",
  "dojo/dom-construct",
  "dojo/fx",
  "dojo/fx/Toggler",
  "dojo/keys",
  "dojo/on",
  "dojo/string",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase",
  "dijit/_WidgetsInTemplateMixin",
  "webui/widgets/common/Trace"
], function(
  NLS,
  template,
  declare,
  lang,
  domAttr,
  domClass,
  domConstruct,
  coreFx,
  Toggler,
  keys,
  on,
  string,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  Trace
) {
      return declare("webui.widgets.restapi.Operation", [ _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin ], {

            templateString : template,
            operation : null,
            NLS : null,
            toggler : null,
            isHidden : false,

            constructor : function() {

              // We need the NLS messages for the template.
              this.NLS = NLS;

              // Save the operation for later.
              this.operation = arguments.operation;

            },

            postCreate : function() {
              Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
              this.inherited(arguments);

              // Add the operation method and name to the widget.
              domClass.add(this._operation, this.operation.method);
              this._expando = domConstruct.create('span', { className: 'restApis_operationExpando' }, this._method);
              domConstruct.create('span', { innerHTML: this.operation.method, className: 'restApis_operationMethodName' }, this._method);
              domClass.add(this._expando, this.operation.method);
              domClass.add(this._method, this.operation.method);
              domClass.add(this._container, this.operation.method);
              this._name.innerHTML = this.operation.name;
              if (this.operation.description) {
                this._description.innerHTML = this.operation.description;
              }
              this._isImplemented.innerHTML = this.operation.implemented ? NLS.restApis_implemented
                  : NLS.restApis_notImplemented;

              // Create a toggler.
              this.toggler = new Toggler({
                node : this._container,
                showFunc : coreFx.wipeIn,
                hideFunc : coreFx.wipeOut
              });
              on(this._operation, 'click', lang.hitch(this, 'toggle'));
              on(this._operation, 'keypress', lang.hitch(this, function(evt) {
                var charOrCode = evt.charCode || evt.keyCode;
                switch (charOrCode) {
                case keys.ENTER:
                case keys.SPACE:
                  this.toggle();
                  break;
                case keys.LEFT_ARROW:
                  this.close();
                  break;
                case keys.RIGHT_ARROW:
                  this.open();
                  break;
                }
              }));
              this.toggle();

              // If there are no parameters, then hide the table.
              if (this.operation.parameters.length === 0) {
                this._table.style.display = 'none';
                var span = domConstruct.create('span', {
                  innerHTML: NLS.restApis_noParameters,
                  tabIndex: 0
                }, this._container);
                domClass.add(span, 'restApis_noParameters');
                domAttr.set(span, 'aria-label', NLS.restApis_noParameters);
              } else {

                // Sort the parameters depending on their name.
                this.operation.parameters.sort(function(a, b) {
                  return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
                });

                // For each parameter ...
                var tbody = domConstruct.create('tbody', null, this._table);
                this.operation.parameters.forEach(lang.hitch(this, function(
                    parameter) {

                  // ... create a new row in the parameter table.
                  var tr = domConstruct.create('tr', { tabIndex: 0 }, tbody);
                  domConstruct.create('td', {
                    innerHTML : parameter.name
                  }, tr);
                  domConstruct.create('td', {
                    innerHTML : NLS.restApis_parameterTypes[parameter.type]
                  }, tr);
                  domConstruct.create('td', {
                    innerHTML : NLS.restApis_parameterRequired_answer[parameter.required]
                  }, tr);
                  domConstruct.create('td', {
                    innerHTML : parameter.description
                  }, tr).colSpan = 3;
                  var label;
                  var type = NLS.restApis_parameterTypes[parameter.type];
                  var args = [ type, parameter.name, parameter.description ];
                  if (parameter.required) {
                    if (parameter.description) {
                      label = string.substitute(NLS.restApis_requiredParameterWithDescription, args); 
                    } else {
                      label = string.substitute(NLS.restApis_requiredParameterWithoutDescription, args); 
                    }
                  } else {
                    if (parameter.description) {
                      label = string.substitute(NLS.restApis_optionalParameterWithDescription, args); 
                    } else {
                      label = string.substitute(NLS.restApis_optionalParameterWithoutDescription, args); 
                    }
                  }
                  domAttr.set(tr, 'aria-label', label);

                }));

              }

              Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
            },
            
            open : function() {
              if (this.isHidden === true) {
                this.toggler.show();
                this.isHidden = false;
                domClass.add(this._expando, 'open');
                domClass.remove(this._expando, 'closed');
              }
              this.updateLabel();
              domAttr.set(this._container, 'aria-expanded', 'true');
            },
            
            close : function() {
              if (this.isHidden === false) {
                this.toggler.hide();
                this.isHidden = true;
                domClass.remove(this._expando, 'open');
                domClass.add(this._expando, 'closed');
              }
              this.updateLabel();
              domAttr.set(this._container, 'aria-expanded', 'false');
            },

            toggle : function() {
              if (this.isHidden) {
                this.open();
              } else {
                this.close();
              }
            },
            
            expandAll : function() {
              this.open();
              domAttr.set(this._container, 'aria-expanded', 'true');
            },
            
            collapseAll : function() {
              this.close();
              domAttr.set(this._container, 'aria-expanded', 'false');
            },
            
            updateLabel : function() {
              var label;
              var open = this.isHidden ? NLS.restApis_closed : NLS.restApis_open;
              var implemented = this.operation.implemented ? NLS.restApis_implemented : NLS.restApis_notImplemented;
              var args = [ this.operation.name, this.operation.method, implemented.toLowerCase(), open.toLowerCase(), this.operation.description ];
              if (this.operation.description) {
                label = string.substitute(NLS.restApis_operationWithDescription, args); 
              } else {
                label = string.substitute(NLS.restApis_operationWithoutDescription, args);
              }
              domAttr.set(this._operation, 'aria-label', label);
            }

          });
    });

},
'webui/widgets/application/app_overview':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="912155494" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define(
  [
    "dojo/text!webui/widgets/application/templates/app_overview.html",
    "dojo/i18n!webui/nls/web",
    "dojo/_base/array",
    "dojo/_base/declare",
    "dojo/_base/lang",
    "dojo/dom-attr",
    "dojo/dom-construct",
    "dojo/query",
    "dojo/request/xhr",
    "dojo/string",
    "dijit/_WidgetBase",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/registry",
    "webui/widgets/common/AttributesStore",
    "webui/widgets/common/HasContextMenu",
    "webui/widgets/common/PropertiesStore",
    "webui/widgets/common/QuickAndAdvancedProperties",
    "webui/widgets/common/Toolbar",
    "webui/widgets/common/Trace",
    "webui/widgets/common/UIUtils"
  ], function(
    template,
    NLS,
    array,
    declare,
    lang,
    domAttr,
    domConstruct,
    query,
    xhr,
    string,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    registry,
    AttributesStore,
    HasContextMenu,
    PropertiesStore,
    QuickAndAdvancedProperties,
    Toolbar,
    Trace,
    UIUtils
  ) {
    var appOverview = declare(
      "webui.widgets.application.app_overview",
      [_WidgetBase, _TemplatedMixin, HasContextMenu, _WidgetsInTemplateMixin],
      {
        templateString: template,
        toolbar: null,
        _propertiesStore: new PropertiesStore(),
        _attributesStore: new AttributesStore(),

        postCreate: function() {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
          this.inherited(arguments);

          // Create toolbar
          this.toolbar = new Toolbar();
          domConstruct.place(this.toolbar.domNode, this._toolbar);
          this.toolbar.addLeftAlignButtons("title");

          this.properties = new QuickAndAdvancedProperties("application");
          this.properties.createPropertiesContainer(this._propertyTitlePane);

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
        },

        resize: function() {
          this._appOverview_borderContainer.resize();
        },

        // This function is called manually when we need to remove this tab.
        tabRemove: function() {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");

          this.properties.unsubscribeAll();

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
        },

        contextButtonsClicks : function(event) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks", [event]);

          // Get the URI and action from the event:
          var uriAndAction = UIUtils.getURIAndAction(event, true);
          var itemURI = uriAndAction.uri;
          var buttonType = uriAndAction.action;
		  
          if(buttonType == "statsOn" || buttonType == "statsOff"){
            this.actionButtonSetStatsContainer(itemURI, buttonType);
          }else{
            this.actionApp(itemURI, buttonType);
          }

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
        },

        actionButtonSetStatsContainer : function(itemURI,buttonType){
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionButtonSetStatsContainer",[itemURI,buttonType]);
          var targetUri = itemURI.substring(0, (itemURI.length - (buttonType.length+1)));
          var uriStatsparam;
          if(buttonType == "statsOn"){
            uriStatsparam="on";
          }else if(buttonType == "statsOff"){
            uriStatsparam="off";
          }

          // Add loading icon to tree
          var tree = registry.byId('_explorerTree_ID');
          var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
          var oldIcon = domAttr.get(treeImgs[0],"class");
          domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");

          xhr.put(
            targetUri + "?action=setStatistics&setStatistics=" + uriStatsparam,
            {
              handleAs:"json",
              headers : {
                 "Accept" : "application/json"
              }
            }
          ).response.then(
            lang.hitch(this, function(response){
              Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionButtonSetStatsContainer.xhrLoad",[response]);

              //reset old icon
              domAttr.set(treeImgs[0],"class",oldIcon);

              if(buttonType == "statsOn"){
                window.smallMessage.displayMessage("success", "FlowStatsAction_successstatsOn");
              } else {
                window.smallMessage.displayMessage("success", "FlowStatsAction_successstatsOff");
              }

              Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionButtonSetStatsContainer.xhrLoad");
            }),
            lang.hitch(this,function(error){
              Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionButtonSetStatsContainer.xhrError",[error]);

              //reset old icon
              domAttr.set(treeImgs[0],"class",oldIcon);
              //show error message
              var response = JSON.parse(error.response.text);
              if(buttonType == "statsOn") {
                window.smallMessage.displayMessage("error", "msgflowstatsOn_5XX", response.bipNumber, response.description);
              } else {
                window.smallMessage.displayMessage("error", "msgflowstatsOff_5XX", response.bipNumber, response.description);
              }

              Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionButtonSetStatsContainer.xhrError");
            })
          );

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionButtonSetStatsContainer");
        },

        actionApp : function(uri, action){
        	
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionApp", [uri,action]);

          var uriArray = uri.split("_");
          var buttonType = uriArray[uriArray.length - 1];
          uri = uri.substr(0,uri.length - buttonType.length - 1);

          var tree;
          if (null!=action && action === "delete" ) {

            tree = registry.byId('_explorerTree_ID');
            var appName = tree.selectedNode.item.name;//label can be truncated, so use name instead
              
            var confirmationMessage = string.substitute(NLS.messages.DeleteApplicationAction_confirmation, [appName] );
            var confirmCallback = lang.hitch(this, function() {

              //	Add loading icon to tree
              var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
              var oldIcon = domAttr.get(treeImgs[0],"class");
              domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");        	

  	          // REST Call to delete the application
  	          xhr.del(
  	            uri,
  	            {
  	              handleAs : "json",
  	              headers : {
  	                "Accept" : "application/json"
                  }
  	            }
  	          ).then( lang.hitch(this, function() {
  	            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Application delete success");
  	
  	            //reset old icon
  	            domAttr.set(treeImgs[0],"class",oldIcon);

  	            // Display success message for deleting an application
  	            window.smallMessage.displayPlainMessage("success", "DeleteApplicationAction_successApplicationDeleted", [appName]);
  	          }),
  	          lang.hitch(this, function(error) {
  	            	
  	            Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrDel to " + uri + " failed.", [error]);

  	            //reset old icon
  	            domAttr.set(treeImgs[0],"class",oldIcon);

  	            //show error message
  	            var response = JSON.parse(error.response.text);
  	            window.smallMessage.displayMessage("error", "appdelete_5XX",response.bipNumber, response.description);
  	          }));
  	        });
              
  	        window.wmbConsole.showConfirmationDialog("btConfirmDelete", "question", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, confirmationMessage, confirmCallback, null);
          }//if
          else {

              // Add loading icon to tree
              tree = registry.byId('_explorerTree_ID');
              var treeNodeID = tree.selectedNode.id;//store this for the call to this.buttonState()
              var treeImgs = query('#' + treeNodeID + ' .dijitTreeIcon');
              var oldIcon = domAttr.get(treeImgs[0],"class");
              domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");

              xhr.put(
                uri + "?action=" + action,
                {
                  handleAs:"json",
                  headers : {
                     "Accept" : "application/json"
                  }
                }
              ).response.then(
                lang.hitch(this, function(response){
                  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionApp.xhrLoad()",[response]);

                  this.buttonState(action, uri,treeNodeID);

                  var appName = tree.selectedNode.item.name;//label can be truncated, so use name instead
                  if (action === "startFlowMonitoring") {
      	            window.smallMessage.displayPlainMessage("success", "FlowMonitoringStartedSuccessfully_App", [appName]);
                  } else if (action === "stopFlowMonitoring") {
                	window.smallMessage.displayPlainMessage("success", "FlowMonitoringStoppedSuccessfully_App", [appName]);
                  }

                  Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionApp.xhrLoad()");
                }),
                lang.hitch(this,function(error){
                  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionApp.xhrError()",[error]);

                  Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrPut to " + uri + " failed.", [error]);
                  //reset old icon
                  domAttr.set(treeImgs[0],"class",oldIcon);
                  //show error message
                  var response = JSON.parse(error.response.text);
                  if(action == "start"){
                    window.smallMessage.displayMessage("error", "appstart_5XX",response.bipNumber, response.description);
                  } else if (action === "stop") {
                    window.smallMessage.displayMessage("error", "appstop_5XX",response.bipNumber, response.description);
                  } else if (action === "startFlowMonitoring") {
        	        window.smallMessage.displayMessage("error", "FlowMonitoringFailedToStart");
                  } else if (action === "stopFlowMonitoring") {
                	window.smallMessage.displayMessage("error", "FlowMonitoringFailedToStop");
                  }
                  Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionApp.xhrError()");
                })
              );
        	  
          }//endif          

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionApp");
        },
        
        buttonState:function(action, uri,treeNodeID){
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "buttonState", [action, uri]);

          // Disable and enable the relevant buttons
          var treeImgs = query('#' + treeNodeID + ' .dijitTreeIcon');
          var populateAttributesStore = this._attributesStore.populateAttributesStore(uri);
          var populatePropertiesStore = this._propertiesStore.populatePropertiesStore(uri);

          populatePropertiesStore.then(lang.hitch(this, function() {
            populateAttributesStore.then(lang.hitch(this, function() {
              Trace.trace(this.declaredClass, Trace.levels.ENTRY, "buttonState.then", [action, uri]);
              // Get the flow's running status
              var running = (this._propertiesStore.getProperty("basic", "isRunning") == "true");
              var name = this._attributesStore.getAttribute("name");

              // Set the TreeNode icon as appropriate
              if (running) {
                domAttr.set(treeImgs[0], "class", "dijitInline dijitIcon dijitTreeIcon explorer_application_running");
              } else {
                domAttr.set(treeImgs[0], "class", "dijitInline dijitIcon dijitTreeIcon explorer_application_stopped");
              }

              // Same for context menu
              this._updateContextMenuTitle(uri, name, "application", running);

              //Now show/hide the appropriate start/stop stats on/off buttons, but greying out as appropriate
              //Again iterating over all viewable buttons to find the ones which we have just changed
              array.forEach(this._getContextButtons(uri), function(button) {
                var tmp = button.id.split("_");
                var buttonType = tmp[tmp.length - 1];
                var thisButtonUri = button.id.substring(0,button.id.length - (buttonType.length+1));

                if( thisButtonUri == uri){
                  switch(buttonType){
                    case "start":
                      button.set("disabled", running);
                      break;
                    case "stop":
                      button.set("disabled", !running);
                      break;
                  }
                }
              }, this);
              Trace.trace(this.declaredClass, Trace.levels.EXIT, "buttonState.then");
            }));
          }));
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "buttonState");
        },

        tabFocus: function() {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");

          this.properties.unsubscribeAll();

          // Get app name and add to the toolbar title
          this.toolbar.setAttribute("title", "innerHTML", "");
          var populate = this._attributesStore.populateAttributesStore();
          populate.then(lang.hitch(this, function() {
            domAttr.set("_infoPaneTitleID", "innerHTML", this._attributesStore.getAttribute("name") + " - " + NLS.applicationTitle);
          }));

          // Populate quick view and advanced properties
          this.properties.populateProperties();

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
        },

        // This function is called manually when we need to remove this tab.
        tabBlur: function() {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");

          this.properties.unsubscribeAll();

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
        }
      }
    );
    return appOverview;
  }
);

},
'webui/widgets/subflows/subflow_overview':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="3356849190" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define(
  "webui/widgets/subflows/subflow_overview",
  [
    "dojo/text!webui/widgets/subflows/templates/subflow_overview.html",
    "dojo/i18n!webui/nls/web",

    "dojo/dom-attr",
    "dojo/dom-construct",
    "dojo/query",
    "dojo/_base/declare",
    "dojo/_base/lang",
    "dojo/request/xhr",
    "dojo/string",

    "dijit/_WidgetBase",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/registry",

    "webui/widgets/common/AttributesStore",
    "webui/widgets/common/HasContextMenu",
    "webui/widgets/common/QuickAndAdvancedProperties",
    "webui/widgets/common/Toolbar",
    "webui/widgets/common/Trace",
    "webui/widgets/common/UIUtils"
  ],
  function(
    template,
    NLS,
    attr,
    construct,
    query,
    declare,
    lang,
    xhr,
    string,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    registry,
    AttributesStore,
    HasContextMenu,
    QuickAndAdvancedProperties,
    Toolbar,
    Trace,
    UIUtils
  ) {

    var subflowOverview = declare("webui.widgets.subflows.subflow_overview", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
      templateString: template,
      toolbar: null,
      _attributesStore : new AttributesStore(),

      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
        this.inherited(arguments);

        // Create toolbar
        this.toolbar = new Toolbar();
        construct.place(this.toolbar.domNode, this._toolbar);
        this.toolbar.addLeftAlignButtons("title");

        this.properties = new QuickAndAdvancedProperties("subFlow");
        this.properties.createPropertiesContainer(this._propertyTitlePane);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
      },

      startup: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "startup");
        this.inherited(arguments);

        // Get subflow name and add to the toolbar title
        this.toolbar.setAttribute("title", "innerHTML", "");

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "startup");
      },

      tabSelected: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabSelected");

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabSelected");
      },

      contextButtonsClicks : function(event) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks");

		  // Get the URI and action from the event:
		  var uriAndAction = UIUtils.getURIAndAction(event, true);
		  var itemURI = uriAndAction.uri;
		  var buttonType = uriAndAction.action;

          if( buttonType === "delete" ){
            this.actionSubFlow(itemURI, buttonType);
          }

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
        },

        actionSubFlow : function(uri, action){
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionSubFlow");


          var uriArray = uri.split("_");
          var buttonType = uriArray[uriArray.length - 1];
          uri = uri.substr(0,uri.length - buttonType.length - 1);

          if (null!=action && action === "delete" ) {

            var tree = registry.byId('_explorerTree_ID');
            var subflowName = tree.selectedNode.item.name;//label can be truncated, so use name instead
            
            var confirmationMessage = string.substitute(NLS.messages.DeleteSubFlowAction_confirmation, [subflowName] );
              
            var confirmCallback = lang.hitch(this, function() {

              //	Add loading icon to tree
              var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
              var oldIcon = attr.get(treeImgs[0],"class");
              attr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");        	

  	          // REST Call to delete the subflow
  	          xhr.del(
  	              uri,
  	              {
  	                handleAs : "json",
  	                headers : {
  	                   "Accept" : "application/json"
  	                }
  	              }
  	            ).then( lang.hitch(this, function() {
  	              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Subflow delete success");
  	
  	              //reset old icon
  	              attr.set(treeImgs[0],"class",oldIcon);

  	              // Display success message for deleting a subflow
  	              window.smallMessage.displayPlainMessage("success", "DeleteSubFlowAction_successFlowDeleted", [subflowName]);
  	            }),
  	            lang.hitch(this, function(error) {
  	            	
  	              Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrDel to " + uri + " failed.", [error]);

  	              //reset old icon
  	              attr.set(treeImgs[0],"class",oldIcon);

  	              //show error message
  	              var response = JSON.parse(error.response.text);
  	              window.smallMessage.displayMessage("error", "subflowdelete_5XX",response.bipNumber, response.description);
  	            })
  	          );
  	        });

            window.wmbConsole.showConfirmationDialog("btConfirmDelete", "question", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, confirmationMessage, confirmCallback, null);
          }//if
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionSubFlow");
        },

      tabFocus : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");
        
        // If we switch back to the overview tab, attempt to reload the properties
        var populate = this._attributesStore.populateAttributesStore();
        populate.then(lang.hitch(this, function() {
          attr.set("_infoPaneTitleID", "innerHTML", this._attributesStore.getAttribute("name") + " - " + NLS.subflowTitle);
        }));

        // Populate quick view and advanced properties
        this.properties.populateProperties();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
       },

      resize: function() {
        this._msgflowOverview_borderContainer.resize();
      },

      // This function is called manually when we need to remove this tab.
      tabRemove: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");

        this.properties.unsubscribeAll();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
      },

      tabBlur: function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
      }

    });
    return subflowOverview;
  }
);

},
'webui/widgets/restapi/BulkRESTApiPushFeedbackDialog':function(){
/*
 * <copyright
 * notice="lm-source"
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2"
 * years="2015,2016"
 * crc="763384209" >
 * Licensed Materials - Property of IBM
 *
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2
 *
 * (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.
 * </copyright>
 */
define([
  "dojo/text!webui/widgets/restapi/templates/BulkRESTApiPushFeedbackDialog.html",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/array",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom",
  "dojo/dom-class",
  "dojo/dom-construct",
  "dojo/on",
  "dojo/request/xhr",
  "dojo/string",
  "dijit/Dialog",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetsInTemplateMixin",
  "webui/config/Resources",
  "webui/widgets/common/Trace"
], function(
  template,
  NLS,
  array,
  declare,
  lang,
  dom,
  domClass,
  domConstruct,
  on,
  xhr,
  string,
  Dialog,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  Resources,
  Trace
) {
  var bulkRESTApiPushFeedbackNewDialog = declare("webui.widgets.restapi.BulkRESTApiPushFeedbackDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
    templateString: template,

    _pushParameters: null,
    _initialized: false,
    _egUri: null,

    _pushSuccess: false,

    // NLS
    _pushApisFeedbackTitle: NLS.pushApiFeedbackTitle,
    _pushApisCloseLabel: NLS.closeButtonLabel,
    _pushApisCancelLabel: NLS.cancelButtonLabel,
    _pushApisBackLabel: NLS.previousButtonLabel,

    _loading : "Loading",
    _success : "Success",
    _failed : "Failed",

    _feedbackRowCount: 0,
    _pushAPISuccessCount: 0,

    //need to pass in this info because we need to pass it along to the callback method for an ajax call.
    constructor: function(args){
      if(!args) {
        throw new Error("No arguments passed");
      }
      this._callback = args.cback;
      this._egUri = args.egUri;
      this._pushParameters = args.pushParameters;
    },

    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      this._setFeedbackButtonBehaviour(true, true, false);

      on(this._closeButton, "click", lang.hitch(this, function() {
        this.destroy();
        this._callback();
      }));

      on(this._cancelButton, "click", lang.hitch(this, function() {
        this.destroy();
      }));

      on(this._backButton, "click", lang.hitch(this, function() {
        this.destroy();
      }));

      this._initialized = true;

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },

    show : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "show");

      this.inherited(arguments);
      this._performPush();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "show");
    },

    _performPush : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_performPush");

      // Reset row count for output
      this._feedbackRowCount = 0;

      // Check there are restapis to push
      if(this._pushParameters.restApis.length < 1) {
        this._cancelButton.set('label', NLS.previousButtonLabel);
        this._setFeedbackSummary(NLS.pushApiFeedbackSummaryNoSelectedApisFail);
        this._setFeedbackButtonBehaviour(false, false, true);
        return;
      }

      // Start the first call, that will then recursively call itself until all REST Apis have been handled
      this._pushRestApi(this._pushParameters.restApis[0], 0, this._pushParameters.productTitle, this._pushParameters.productName, this._pushParameters.productVersion, null);

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_performPush");
    },

    _pushRestApi : function(restApi, index, productTitle, productName, productVersion, productId) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_pushRestApi");

      var connectionParameters = {
          host : this._pushParameters.host,
          port : this._pushParameters.port,
          username : this._pushParameters.user,
          password: this._pushParameters.password,
          organizationId : this._pushParameters.organizationId,
          restApi : restApi,
          productTitle : productTitle,
          productName : productName,
          productVersion : productVersion,
          productId : productId
      };

      // Update the connection parameters with the optional overrides
      if (this._pushParameters.httpHost != null) {
        connectionParameters.httpHost = this._pushParameters.httpHost;
      }
      if (this._pushParameters.httpPort != null) {
        connectionParameters.httpPort = this._pushParameters.httpPort;
      }
      if (this._pushParameters.httpsHost != null) {
        connectionParameters.httpsHost = this._pushParameters.httpsHost;
      }
      if (this._pushParameters.httpsPort != null) {
        connectionParameters.httpsPort = this._pushParameters.httpsPort;
      }

      var pushRestApiUri = this._egUri + "/" + Resources.REST.pushApisPush;

      this._addFeedbackRowEntry(this._loading, string.substitute(NLS.pushApiFeedbackPushApiProgress, [restApi]), this._feedbackRowCount++);
      this._addFeedbackRowEntry(this._loading, string.substitute(NLS.pushApiFeedbackAssociateApiProgress, [restApi, productTitle]), this._feedbackRowCount++);

      xhr.post(pushRestApiUri, {
        handleAs : "json",
        headers : {
          "Accept" : "application/json",
          "Content-type" : "application/json"
        },
        data : JSON.stringify(connectionParameters)
      }).then(
        lang.hitch(this, function(response) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "API Connect pushed RestAPI '" + restApi + "'");

          this._handlePushRestApiResponse(response, index, restApi, productTitle, productName, productVersion, productId, true);
        }),
        lang.hitch(this, function(error) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "API Connect push RestAPI '" + restApi + "' Error: " + error.response.status + " Response: " + error.response.text);
          // If failed, still attempt next one...
          this._handlePushRestApiResponse(error, index, restApi, productTitle, productName, productVersion, productId, false);
        })
      );

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_pushRestApi");
    },

    _handlePushRestApiResponse : function(response, index, restApi, productTitle, productName, productVersion, productId, success) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handlePushRestApiResponse");

      var productId = null;
      var indexAdjust =  2;
      var failPush = false;

      // Handle success response code (but all actions may not have been successful, inspect them)
      if(success) {
        if(response && response.pushSuccess) {
          this._updateFeedbackRowEntry(this._success, string.substitute(NLS.pushApiFeedbackPushApiComplete, [restApi]), this._feedbackRowCount - indexAdjust--);
        } else {
          var pushErrorText = "";
          if (typeof response.pushErrorText != 'undefined') {
            pushErrorText = response.pushErrorText;
          }
          this._updateFeedbackRowEntry(this._failed, string.substitute(NLS.pushApiFeedbackPushApiFail, [restApi, pushErrorText]), this._feedbackRowCount - indexAdjust--);
        }

        if(response && response.associationSuccess) {
          if(response && response.creatingProduct) {
            this._updateFeedbackRowEntry(this._success, string.substitute(NLS.pushApiFeedbackCreateProductApiComplete, [productTitle, restApi]), this._feedbackRowCount - indexAdjust--);
          } else {
            this._updateFeedbackRowEntry(this._success, string.substitute(NLS.pushApiFeedbackUpdateProductApiComplete, [productTitle, restApi]), this._feedbackRowCount - indexAdjust--);
          }
          this._pushAPISuccessCount++;
        } else {
          var associateErrorText = "";
          if (typeof response.associateErrorText != 'undefined') {
            associateErrorText = response.associateErrorText;
          }
          if(response && response.creatingProduct) {
            this._updateFeedbackRowEntry(this._failed, string.substitute(NLS.pushApiFeedbackCreateProductApiFail, [productTitle, associateErrorText]), this._feedbackRowCount - indexAdjust--);
          } else {
            this._updateFeedbackRowEntry(this._failed, string.substitute(NLS.pushApiFeedbackUpdateProductApiFail, [productTitle, restApi, associateErrorText]), this._feedbackRowCount - indexAdjust--);
          }
        }

        if(response && response.productId && productId == null) {
          productId = response.productId;
        }
      } else {
        var additionalText="";
        if ((typeof response.response !== 'undefined') && (typeof response.response.data !== 'undefined') && (typeof response.response.data.bipNumber !== 'undefined')) {
          // We have an IIB Bip message number returned. See if we can
          // add some detail to the error.
          if (response.response.data.bipNumber === "9361") {
            additionalText=string.substitute(NLS.pushApiFeedbackApiNotDeployed, [restApi]);
          }
          else if (typeof response.response.data.descripton !== 'undefined') {
            additionalText = response.response.data.descripton;
          }
        }

        this._updateFeedbackRowEntry(this._failed, string.substitute(NLS.pushApiFeedbackPushApiFail, [restApi, additionalText]), this._feedbackRowCount - indexAdjust--);
        this._updateFeedbackRowEntry(this._failed, string.substitute(NLS.pushApiFeedbackUpdateProductApiFail, [productTitle, restApi, additionalText]), this._feedbackRowCount - indexAdjust--);
      }

      // Drive next call depending on place in loop
      if((++index  < this._pushParameters.restApis.length) && !failPush) {
        this._pushRestApi(this._pushParameters.restApis[index], index, productTitle, productName, productVersion, productId);
      } else {
        // Only stage product if we pushed at least one API successfully and we have been given a catalog
        if ((productId != null) && (this._pushAPISuccessCount !== 0)) {
          if (this._pushParameters.catalogId === Resources.REST.pushApisNoStageId) {
            // The user has selected not to Stage Product so just set the
            // complete status
            this._setCompletedStagingFeedback(false, productTitle, productName);
          } else {
            this._stageProduct(productTitle, productName, productId);
          }
        } else {
          // At least one failure occurred, so we do not stage
          this._setCompletedStagingFeedback(false, productTitle, productName);
        }
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_handlePushRestApiResponse");
    },

    _stageProduct : function(productTitle, productName, productId) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_stageProduct");

      var connectionParameters = {
          host : this._pushParameters.host,
          port : this._pushParameters.port,
          username : this._pushParameters.user,
          password: this._pushParameters.password,
          organizationId : this._pushParameters.organizationId,
          catalogId : this._pushParameters.catalogId,
          productId : productId
      };

      var testConnectionUri = this._egUri + "/" + Resources.REST.pushApisStage;

      this._addFeedbackRowEntry(this._loading, string.substitute(NLS.pushApiFeedbackStageProductProgress, [productTitle, this._pushParameters.catalogName]), this._feedbackRowCount++);

      xhr.post(testConnectionUri, {
        handleAs : "json",
        headers : {
          "Accept" : "application/json",
          "Content-type" : "application/json"
        },
        data : JSON.stringify(connectionParameters)
      }).then(
        lang.hitch(this, function(response) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "API Connect stage product '" + productName + "'");

          if(response && response.stageSuccess) {
            this._updateFeedbackRowEntry(this._success, string.substitute(NLS.pushApiFeedbackStageProductComplete, [productTitle, this._pushParameters.catalogName]), this._feedbackRowCount - 1);
          } else {
            this._updateFeedbackRowEntry(this._failed, string.substitute(NLS.pushApiFeedbackStageProductFail, [productTitle, this._pushParameters.catalogName]), this._feedbackRowCount - 1);
          }

          this._setCompletedStagingFeedback(response.stageSuccess, productTitle, productName);
        }),
        lang.hitch(this, function(error) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "API Connect stage product '" + productName + "' Error: " + error.response.status + " Response: " + error.response.text);

          var additonalText="";
          if ((typeof error.response !== 'undefined') && (typeof error.response.data !== 'undefined') && (typeof error.response.data.bipNumber !== 'undefined')) {
            // We have an IIB Bip message number returned. See if we can
            // add some detail to the error.
            if (error.response.data.bipNumber === "9364") {
              additionalText = error.response.data.bipInserts[0];
            }
            else if (typeof error.response.data.descripton !== 'undefined') {
              additionalText = error.response.data.descripton;
            }
          }

          this._updateFeedbackRowEntry(this._failed, string.substitute(NLS.pushApiFeedbackStageProductFail, [productTitle, this._pushParameters.catalogName, additionalText]), this._feedbackRowCount - 1);

          this._setCompletedStagingFeedback(false, productTitle, productName);
        })
      );

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_stageProduct");
    },

    _setCompletedStagingFeedback : function(stageSuccess, productTitle, productName) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setCompletedStagingFeedback");

      // Derive the feedback summary from completed tasks
      var message = "";
      var retry = false;

      if (this._pushAPISuccessCount == this._pushParameters.restApis.length) {
        if (this._pushParameters.catalogId === Resources.REST.pushApisNoStageId) {
          // All API's successfully pushed
          message = string.substitute(NLS.pushApiFeedbackSummarySuccess, [this._pushAPISuccessCount, productTitle]);

          this._setFeedbackSummary(message);
          this._setFeedbackButtonBehaviour(true, false, true);
        }
        else if (stageSuccess) {
          // All API's successfully pushed and product was staged to ...
          message = string.substitute(NLS.pushApiFeedbackSummaryStageSuccess, [this._pushAPISuccessCount, productTitle, this._pushParameters.catalogName]);

          this._setFeedbackSummary(message);
          this._setFeedbackButtonBehaviour(true, false, true);
        }
        else  {
          // All API's successfully pushed to draft but failed to stage product to ...
          message = string.substitute(NLS.pushApiFeedbackSummaryStageFail, [this._pushAPISuccessCount, productTitle, this._pushParameters.catalogName]);

          // Failure during stage, allow retry
          this._setFeedbackSummary(message);
          this._setFeedbackButtonBehaviour(false, false, true);
        }
      }
      else {
        var failCount = this._pushParameters.restApis.length - this._pushAPISuccessCount;

        if (this._pushAPISuccessCount == 0) {
          // No API's were pushed
          message = string.substitute(NLS.pushApiFeedbackSummaryAllFail, [productTitle]);
        }
        else if (this._pushParameters.catalogId === Resources.REST.pushApisNoStageId) {
          // 'n' APIs were added to product 'X'. 'm' APIs could not be pushed or could not be associated with the product
          message = string.substitute(NLS.pushApiFeedbackSummaryPartial, [this._pushAPISuccessCount, productTitle, failCount]);
        }
        else if (stageSuccess) {
          // 'n' APIs were added to product 'X' which has been staged in 'Y'. 'm' APIs could not be pushed or could not be associated with the product
          message = string.substitute(NLS.pushApiFeedbackSummaryStagePartial, [this._pushAPISuccessCount, productTitle, this._pushParameters.catalogName, failCount]);
        }
        else  {
          // 'n' APIs were added to product 'X' but staging in 'Y' failed. 'm' APIs could not be pushed or could not be associated with the product
          message = string.substitute(NLS.pushApiFeedbackSummaryPartialStageFail, [this._pushAPISuccessCount, productTitle, this._pushParameters.catalogName, failCount]);
        }

        // Failure during pushing of API's, allow retry
        this._setFeedbackSummary(message);
        this._setFeedbackButtonBehaviour(false, false, true);
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setCompletedStagingFeedback");
    },

    _addFeedbackRowEntry : function(type, message, index) {
      var row = domConstruct.create("tr", {}, "");
      var iconCell = domConstruct.create("td", {}, row);
      var textCell = domConstruct.create("td", {}, row);

      var feedbackIconContent = domConstruct.create("div", {
        'class' : "restApis_pushDialog_feedbackIcon " + this._getIconClass(type),
        'id' : "_pushFeedbackFeedbackTableIcon_" + index
      }, iconCell);

      var feedbackTextContent = domConstruct.create("div", {
        innerHTML : message,
        'class' : "restApis_pushDialog_feedback_table_text",
        'id' : "_pushFeedbackFeedbackTableText_" + index
      }, textCell);

      domConstruct.place(row, this._pushFeedbackDetailsTable, "last");
    },

    _updateFeedbackRowEntry : function(type, message, index) {
      var iconDiv = dom.byId("_pushFeedbackFeedbackTableIcon_" + index);

      // Update the icon
      domClass.remove(iconDiv, this._getIconClass(this._loading));
      domClass.add(iconDiv, this._getIconClass(type));

      var textDiv = dom.byId("_pushFeedbackFeedbackTableText_" + index);
      textDiv.innerHTML = message;
    },

    _setFeedbackSummary : function(message) {
      this._pushFeedbackResultSection.innerHTML = message;
    },

    _getIconClass : function(type) {
      var iconClass = "";

      // Switch on type - Progress, Success, Failure...
      switch(type) {
        case this._loading :
          iconClass = "validationIcon_loading";
          break;
        case this._success :
          iconClass = "validationIcon_valid";
          break;
        case this._failed :
          iconClass = "validationIcon_error";
          break;
      }

      return iconClass;
    },

    _setFeedbackButtonBehaviour : function(backButton, closeButton, cancelButton) {
      this._closeButton.setDisabled(closeButton);
      this._backButton.setDisabled(backButton);
      this._cancelButton.setDisabled(cancelButton);

      if (closeButton === false) {
          this._closeButton.focus();
      }
      else if (backButton === false) {
          this._backButton.focus();
      }
      else  {
          this._cancelButton.focus();
      }
    }

  });
  return bulkRESTApiPushFeedbackNewDialog;
});

},
'webui/login/nls/web':function(){
// NLS_CHARSET=UTF-8
/***********************************************************************
 * Source File Name: %W% 
 *
 * OCO Source Materials.
 *  ProgIds: 5724-J06 5724-J05 5724-J04 5697-J09 5655-M74 5655-M75 5648-C63
 *         
 *  (C) Copyright IBM Corporation 2011.
 *
 * The Source code for this program is not published or otherwise
 * divested of its trade secrets, irrespective of what has been
 * deposited with the U.S. Copyright office.
 *
 * Version %Z% %I% %W% %E% %U% [%H% %T%]
 **********************************************************************/

define({
  //begin v1.x content
  root: ({
    // START NON-TRANSLATABLE 
  	loginPageTitle: "IBM Integration",
  	// END NON-TRANSLATABLE

  	legalText: "Licensed Materials - Property of IBM Corp. Copyright by IBM Corp. and other(s) 2001, 2016. IBM, and the IBM logo are trademarks of International Business Machines Corporation, registered in many jurisdictions worldwide. Java and all Java-based marks and logos are trademarks or registered trademarks of Oracle and/or its affiliates. Other product or service names may be trademarks of IBM or other companies. Microsoft is a trademark of Microsoft Corporation in the United States, other countries, or both.",
  	loginButtonLabel: "Log In",
  	loginId: "User ID:",
  	loginPassword: "Password:",
    loginFailure: "Invalid user ID or password."
  }),

  "de": true,
  "es": true,
  "fr": true,
  "it": true,
  "ja": true,
  "ko": true,
  "pl": true,
  "pt": true,
  "ru": true,
  "tr": true,
  "zh-cn": true,
  "zh-tw": true
});
},
'webui/widgets/business/BTFlowRemovalDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 *
 * 
 * BTFlowRemovelDialog widget - dialog for removing flows.
 * 
 */
define(
  "webui/widgets/business/BTFlowRemovalDialog",
  [
    "dojo/text!webui/widgets/business/templates/BTFlowRemovalDialog.html", 
    "dojo/i18n!webui/nls/web", 
    "dojo/_base/declare", 
    "dijit/Dialog",
    "webui/config/Resources",
    "dijit/_TemplatedMixin", 
    "dijit/_WidgetsInTemplateMixin",
    "webui/widgets/common/Trace", 
    "dojo/string",
    "dojo/dom-attr",
    "dojo/hash",
    "dojo/keys",
    "dojo/_base/event",
    "dojo/on",
    "dojo/_base/lang",
    "dojo/dom-construct",
    "dojo/topic",    
    "dojo/_base/window",
    "webui/widgets/common/UIUtils",    
    // For the HTML template only
    "dijit/form/MultiSelect"
  ], 
  function( 
    template, 
    NLS, 
    declare,
    Dialog,
    Resources,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    Trace,
    string,
    attr,
    hash,
    keys,
    event,
    on,
    lang,
    construct,
    Topic,
    win,
    UIUtils
  ) {

  var btFlowRemovalDialog = declare("webui.widgets.business.BTFlowRemovalDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
    
    templateString : template,
    
    _btOKLabel:NLS.btRemoveFlowsButton,
    
    _btCancelLabel: NLS.cancelButtonLabel,
    
    _buttonCancel: NLS.cancelButtonLabel,
    
    _btdFlowListLabel: NLS.btRemoveListOfFlows,
    
    
    _onKey : function(evt) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onKey");
      this.inherited(arguments);
      if (evt.charOrCode) {
        if (evt.charOrCode === keys.ENTER) {
          if ( !this._okButton.get("disabled" ) ) {
            event.stop(evt);
            this.onExecute();
          }
        }
      }
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onKey");
    },

    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

        this.titleNode.setAttribute("tabIndex", -1);
        this.instructionNode.setAttribute("tabIndex", -1);
        
      on(this, "execute", lang.hitch(this, function() {
        var flowUris =this.getSelectedFlowsArray();
        for (var i=0; i<flowUris.length;i++) {
          this.btEditor.removeFlowFromBTD(flowUris[i]);
          Topic.publish(Resources.pubSubTopic.businessTransaction, {"deleted": true, "flowUri": flowUris[i], "callingHash": hash()});
        }        
        construct.empty("btFlowRemovalList");
        this.hide();
      }));

      on(this._cancelButton, "click", lang.hitch(this, function() {
        this.hide();
        construct.empty("btFlowRemovalList");
        construct.empty("flowRemovalSummary");
      }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },
    
    getSelectedFlowsArray: function () {
      var selectedFlows = this._flowListSelect.getSelected();  
      var l= selectedFlows.length;
      var flowUris =[];
      for (var i=0;i<l;i++) {
          flowUris.push(selectedFlows[i].value);
      }
      return flowUris;
    },
        
    setInitialValues: function(args) {
      //{"btEditor": this.btEditor}
     this.btName = args.btEditor.btModel.btName;
     var title = string.substitute(NLS.btRemoveFlowTitle, [this.btName]);
     attr.set(this.titleNode, "innerHTML", title);
     attr.set(this.instructionNode, "innerHTML", NLS.btRemoveFlowInfo);
     this.btModel = args.btEditor.btModel;
     this.btEditor = args.btEditor;
     
    },
    
    refresh : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "refresh");
      var flows = this.btModel.getElementsArray();
      // sort by names
      
      function compare(a,b) {
        if (a.name < b.name) {
          return -1;
        }
        if (a.name > b.name) {
          return 1;
        }
        return 0;
      }

      flows.sort(compare);
      for (var i=0;i<flows.length;i++) {
        var c = win.doc.createElement('option');
        c.innerHTML = UIUtils.deriveLabelValue(flows[i].uri)[0];
        c.value = flows[i].uri;
        this._flowListSelect.domNode.appendChild(c);
      }
      this._flowListSelect.focus();
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "refresh");
    }    
  });
  
	return btFlowRemovalDialog;
});

},
'webui/widgets/common/HasContextMenu':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2015,2016" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.  
 * </copyright> 
 */

/*
 * Provides common UI related utilities.
 */

/**
 * A tab widget fulfills the role of "HasContextMenu" if there is
 * a CustomTreeNode in the explorer tree corresponding to this artifact, with
 * a context menu attached to it (the little down arrow).
 * 
 * For example, webui.widgets.application.app_overview is the main tab
 * widget for a deployed application. In the explorer tree, the node for
 * the application has a context menu with "Start", "Stop", "Delete", etc.
 * So, app_overview extends HasContextMenu.
 */
define([
  "dijit/registry",
  "dojo/_base/declare",
  "dojo/dom-attr",
  "dojox/html/entities"
], function(
  registry,
  declare,
  domAttr,
  entities
) {

  return declare([/* no superclasses */], {
    
    /**
     * One tab widget (e.g. app_overview.js) carries responsibility for handling context
     * menu clicks for multiple artifacts (in this case, every application). This method
     * converts the artifact URI into the DropDownMenu widget for that artifact - `null`
     * if no such exists.
     */
    _getContextButtons: function(uri) {
      var id = uri + "_dropDownMenu";
      var dropDownMenu = registry.byId(id); // could be `null`
      if(!dropDownMenu) {
        return [];
      }
      return dropDownMenu.getChildren();
    },
    
    /**
     * The top context button is just a heading for the menu and includes the artifact
     * name and an icon. Sometimes we need to get this specific entry. It is identifiable
     * by its ID. E.g. if the current artifact is "/apiv1/executiongroups/eg1/messageflows/flow1"
     * the ID is "/apiv1/executiongroups/eg1/messageflows/flow1_contextMenu"
     */
    _getContextMenuTitleWidget : function(uri) {
      var id = uri + "_contextMenu";
      
      var menuItem = registry.byId(id);

      if(menuItem) {
        return menuItem;
      }
      
      throw new Error("MenuItem with ID '" + id + "' not found");
    },
    
    /**
     * The top context menu includes an icon indicating the run state of the artifact. This
     * method alters the icon to show a green up-arrow ("running") or a red down-arrow
     * ("stopped").
     * At present you have to pass in the artifact type, oh well
     */
    _updateContextMenuTitle : function(
      uri, // e.g. "/apiv1/executiongroups/eg1/messageflows/flow1"
      name, // e.g. "flow1"
      artifactType, // "service", "messageFlow", "restApi", "executionGroup", "application"
      running // true or false
    ) {
      var menuItemTitleWidget = this._getContextMenuTitleWidget(uri);

      var label = this._computeMenuItemLabel(name, artifactType, running);
      domAttr.set(menuItemTitleWidget, "label", label);
    },

    /**
     * This is the top (title) of the context menu of a CustomTreeNode.
     * TODO: use a Dojo template; unify with CustomTreeNode's implementation
     */
    _computeMenuItemLabel: function(
      name, // e.g. "Flow1"
      artifactType, // "service", "messageFlow", "restApi", "executionGroup", "application"
      running // true or false
    ) {
      // Truncate context menu names at 30 characters if need be
      // Check that if we have a really long name, that we truncate in a human readable manner of characters.
      var charLimit = 30;
      name = name.length > charLimit ? name.substr(0, charLimit) + "..." : name;
      name = entities.encode(name);

      var runState = running ? "running" : "stopped";

      return "<div class='explorerTree_contextMenu_headerIcon explorer_" + artifactType + "_" + runState + "'></div>" +
      "<div class='explorerTree_contextMenu_headerTitle'>" + name + "</div>";
    }

  });
});

},
'webui/widgets/business/BTFlowDiagram':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2013,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.  
 * </copyright> 
 *
 * 
 * Flow Diagram widget - displays the flow diagram profile as a visual graph representation.
 * 
 */
define([
  "dojo/i18n!webui/nls/web",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/dom-class",
  "dojo/dom-construct",
  "dojo/string",
  "dijit/_WidgetBase",
  "webui/config/Resources",
  "webui/widgets/business/BTEventTooltip",
  "webui/widgets/common/D3FlowDiagram",
	"webui/widgets/common/Trace",
  "d3js"
], function(
  NLS,
  declare,
  lang,
  domAttr,
  domClass,
  domConstruct,
  string,
  _WidgetBase,
  Resources,
  BTEventTooltip,
  D3FlowDiagram,
  Trace
) {
	return declare("webui.widgets.business.BTFlowDiagram", [_WidgetBase], {

		widgetContainer: null,
		topicName: null,
		flowDiagramWidget: null,
		eventIconPath: "/webui/widgets/business/images/icons/events/",
		eventTooltipId: "eventTooltip",

		postCreate : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},
		
		createFlowDiagram: function(target, flowDesignData, messageFlowURI, monitoringEvents){
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createFlowDiagram");
			
			this.widgetContainer = target;
			this.messageFlowURI = messageFlowURI;
			
		  //Create flow diagram widget
	    if(this.flowDiagramWidget != null){
            try{
            this.flowDiagramWidget.destroy();
            }
            catch(e) {}
            this.flowDiagramWidget = null;
        }
               
        try {
            this.flowDiagramWidget = new D3FlowDiagram({height: 350, width: 800, flowType: Resources.flowDiagram.businessTransaction});
        }
        catch(e) {
            Trace.trace(this.flowDiagramWidget.declaredClass, Trace.levels.DEBUG, "D3FlowDiagram Error: " + e);                    
        }
        
        if(this.flowDiagramWidget){       
            this.flowDiagramWidget.place(target, flowDesignData, messageFlowURI);
            // If monitoring events were passed to the diagram then render them
            if(typeof monitoringEvents !== "undefined") {
              this.addEventData(monitoringEvents, this.flowDiagramWidget.flowProfileWidget);
            }
        }
			
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "createFlowDiagram");
		},

    addEventData: function(monitoringEventData, flowProfileWidget) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "addEventData");

      flowProfileWidget.eventIconPath = this.eventIconPath;
      flowProfileWidget.messageFlowURI = this.messageFlowURI;
      
      // Now that all the event data is attached to the node, render on the flow profile.
      var node = flowProfileWidget.profileNodes();          
      var eventTooltip = new BTEventTooltip(true, this.eventTooltipId, this.messageFlowURI, this.flowDiagramWidget.flowProfileId);
      flowProfileWidget.eventTooltipId = this.eventTooltipId;

      // Add the initial starting state of the event dialog
      domClass.add(this.widgetContainer, "btx_flow_profile");

      // Add the tooltip to the main flow profile container.
      var toolTipContainer = d3.select("#"+this.widgetContainer);          							
      toolTipContainer.append("div")
      					.attr("id", this.eventTooltipId);

      domClass.add(this.eventTooltipId, "event_tooltip event_tooltip_hidden");
      
      // Add the hidden tooltip to the diagram, now prepared for rendering
      domConstruct.place(eventTooltip.domNode, this.eventTooltipId);
      
      // Add the tooltip reference to the flow diagram
      flowProfileWidget.eventTooltip = eventTooltip;
      
      if(typeof monitoringEventData !== "undefined") {
        // Go through each event policy, and match on the node that it applies to
        monitoringEventData.forEach(function(nodeEventPolicy) {
          // If there are predicates defined in the event policy
          if((typeof nodeEventPolicy.nodeMonitoringEvents !== "undefined") &&
              (nodeEventPolicy.nodeMonitoringEvents.length > 0)) {
            // Iterate round each node, if a match on node name then this event policy must apply to this node (in the context of the current flow)
            node.filter( function(d) { return d.name === nodeEventPolicy.nodeName; }) 
              .each( function(d) {
                d.policy.eventPolicy = nodeEventPolicy;
              });
            }
          }
        );
      }
      
      // Event handler for clicking on event on flow profile, or on event table. 
  	  flowProfileWidget.flowProfileEventSelectedHandler = function(nodeMonitorEvent) {
  		  if((typeof nodeMonitorEvent.selected === "undefined") || (!nodeMonitorEvent.selected)) {
  			  var nodeId = nodeMonitorEvent.nodeId;
  			  // Locate the nodeMonitorEvent entry
  			  flowProfileWidget.profileNodes().filter( function (d){ return d.name === nodeId; })
  			  .each(function(d) {
  				  // Iterate round on nodeMonitorEvents on this node
  				  for(var j=0; j<d.policy.eventPolicy.nodeMonitoringEvents.length; j++) {
  					  if(d.policy.eventPolicy.nodeMonitoringEvents[j].eventSourceAddress === nodeMonitorEvent.eventSourceAddress) {
  						  nodeMonitorEvent = d.policy.eventPolicy.nodeMonitoringEvents[j];

  						  // Get the x and y bounds that will be reference for the tooltip                  
  						  var divBounds = this.ownerSVGElement.parentNode.getBoundingClientRect();
                var yOffset = Math.max((flowProfileWidget.margins()[0]/2),((divBounds.width - flowProfileWidget.diagramSize()[0])/ 2) - flowProfileWidget.margins()[0]);
                
                var x = d.absoluteX + yOffset + (flowProfileWidget.nodeWidth() * (3/4));
                var y = d.absoluteY + flowProfileWidget.margins()[1] - (flowProfileWidget.nodeEventIconWidth() * (7/8));
                
  						  // Show the tooltip
  						  flowProfileWidget.eventTooltip.showTooltip(d, d.policy.eventPolicy, x, y);
  						  domAttr.set(flowProfileWidget.eventTooltipId, "data-node-id", d.name);
  						  flowProfileWidget.eventTooltip.tooltipEventSelectedHandler(nodeMonitorEvent, d.policy.eventPolicy);
  						  nodeMonitorEvent.selected = true;
  						  break;
  					  }
  				  }      				  
  			  });
  		  }
  	  };

      node.append("g")
      	  // Check that we have event predicates to render on the current node
      	  .filter(function(d) { return (typeof d.policy !== "undefined" ) &&
			  (typeof d.policy.eventPolicy !== "undefined" ) &&
		   (d.policy.eventPolicy.nodeMonitoringEvents.length > 0); })
          .each( function(d) {
    		  // If any of the predicates refer to a monitor event on the node (i.e. Tx Start, Rollback, End)
    		  // Add a highlight on the node and then add the event icon to the profile.
		  	  var g = d3.select(this);
		  	  
		  	  // First add the event icon (that events on defined on this node)
		  	  g.append("use")
  		      .attr("xlink:href","#flowDiagram_nodeEvent")
  		      .attr("y",  function(d) { 
              return (d.dy / 2) - (flowProfileWidget.nodeEventIconLength() * (7/4));
            })
            .attr("x", flowProfileWidget.nodeWidth() - (flowProfileWidget.nodeEventIconWidth() * (7/8)));
		      
		  	  g.append("rect")
			  		.attr("y",  function(d) {
			  		   return (d.dy / 2) - (flowProfileWidget.nodeEventIconLength() * (7/4)) - 1;
            })
            .attr("x", flowProfileWidget.nodeWidth() - (flowProfileWidget.nodeEventIconWidth() * (7/8)) - 1)
			  		.attr("class", "node-event-icon svg-use-coverage")
			  		.attr("width", 18)
            .attr("height", 18)
			  		.on("click", function(d){
			  		  // Get the x and y bounds that will be reference for the tooltip    			  		                   
              var divBounds = this.ownerSVGElement.parentNode.getBoundingClientRect();
              var yOffset = Math.max((flowProfileWidget.margins()[0]/2),((divBounds.width - flowProfileWidget.diagramSize()[0])/ 2) - flowProfileWidget.margins()[0]);
              
              var x = d.absoluteX + yOffset + (flowProfileWidget.nodeWidth() * (3/4));
              var y = d.absoluteY + flowProfileWidget.margins()[1] - (flowProfileWidget.nodeEventIconWidth() * (7/8));

			  		  eventTooltip.showTooltip(d, d.policy.eventPolicy, x, y);
			  		  
			  		  /* SVG Foreign Object - TBD on whether to replace hanging div
			  		  var htmlToAdd = eventTooltip.getTooltipContent(); 

			  		  var svgTooltip = d3.select("#messageFlowDiagram").select("#tooltip");
			  		  			  		  
			  		  svgTooltip
  			  		  .attr("x", d.absoluteX + (flowProfileWidget.nodeWidth() * (3/4)))
                .attr("y", d.absoluteY - (flowProfileWidget.nodeLength() * (3/4)))
                .attr("width", 225);
			  		  
			  		  // Add the class on rendering
			  		  svgTooltip.select("#tooltipDiv")
			  		    .attr("class", "event_tooltip")
			  		    .html(htmlToAdd);
			  		    */
			  		  
			  			domAttr.set(flowProfileWidget.eventTooltipId, "data-node-id", d.name);
			  			if (d3.event) {
                d3.event.stopPropagation();
              }
			  		})
            .append("title")
			  		.text(string.substitute(NLS.btEventTooltipTitleMonitoringEvents, [d.policy.eventPolicy.nodeName]));
      });
      
      /* SVG Foreign Object - TBD on whether to replace hanging div
      // Attach the event tooltip, render initially as empty
      var svg = d3.select("#messageFlowDiagram").append("foreignObject")
        .attr("id", "tooltip")
        .append("xhtml:div")
          .attr("id", "tooltipDiv")
          .html("");
			*/

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "addEventData");
    },
        
    resize: function(){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");
      
      // Resize the main container before altering node layout
      if(this.flowDiagramWidget != null) {
        this.flowDiagramWidget.resize();
      }
      
      var btFlowProfileWidget = this.flowDiagramWidget.flowProfileWidget;
      
      // Go through and update every absolute position on each node so that repositioning is working with the latest values      
      btFlowProfileWidget.profileNodes().each(lang.hitch(this, function(d) { 
        d.absoluteX = d.x + Number(d3.select("#nodeIcon_" + d.idValue).attr("x"));
        d.absoluteY = d.y + Number(d3.select("#nodeIcon_" + d.idValue).attr("y"));
      }));
      
      if((typeof btFlowProfileWidget.eventTooltipId !== "undefined") && 
          (!domClass.contains(btFlowProfileWidget.eventTooltipId, "event_tooltip_hidden"))) {
            var currentNode = domAttr.get(btFlowProfileWidget.eventTooltipId, "data-node-id");
            // Locate the predicate entry
            btFlowProfileWidget.profileNodes().filter( function (d){ return d.name === currentNode; })
              .each(function(d) {
                // Get the x and y bounds that will be reference for the tooltip                 
                var divBounds = this.ownerSVGElement.parentNode.getBoundingClientRect();
                var yOffset = Math.max((btFlowProfileWidget.margins()[0]/2),((divBounds.width - btFlowProfileWidget.diagramSize()[0])/ 2) - btFlowProfileWidget.margins()[0]);
                
                var x = d.absoluteX + yOffset + (btFlowProfileWidget.nodeWidth() * (3/4));
                var y = d.absoluteY + btFlowProfileWidget.margins()[1] - (btFlowProfileWidget.nodeEventIconWidth() * (7/8));

                btFlowProfileWidget.eventTooltip.updatePosition(x, y);
              });
        }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
    },

		destroy: function(){
	    Trace.trace(this.declaredClass, Trace.levels.ENTRY, "destroy");
      this.inherited(arguments);

	    // Destroy existing flow profile widget
	    if((this.flowDiagramWidget) && (this.flowDiagramWidget.flowProfileWidget != null)){
	    
	      // Destroy the tooltip widget
  			if(this.flowDiagramWidget.flowProfileWidget.eventTooltip != null) {
  			  this.flowDiagramWidget.flowProfileWidget.eventTooltip.destroy();
  			}
	    
	    	// Remove the child g which holds the diagram from the main flow profile template
	    	d3.select("#"+this.target).select("g").remove();
        this.flowDiagramWidget = null;
	    }

      domConstruct.empty(this.widgetContainer);
    
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "destroy");
		}
	}); // end dojo declare
});

},
'webui/widgets/dataviewer/DataViewer':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="1410152150" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define(
  [
    "dojo/i18n!webui/nls/web",
    "dojo/text!webui/widgets/dataviewer/templates/DataViewer.html",
    "dojo/on",
    "dojo/request/xhr",
    "dojo/_base/declare",
    "webui/widgets/common/Trace",
    "dijit/_WidgetBase",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/registry",
    "webui/config/Resources",
    "idx/form/ComboBox",
    "dojo/_base/lang",
    "dojo/dom-construct",
    "dojo/dom-class",
    "dojo/store/Memory",
    "dojox/grid/DataGrid",
    "dojo/data/ObjectStore",
    "dijit/form/Button",
    "dojo/query",
    "dojo/dom",
    "dojo/dom-attr",
    "dojo/_base/array",
    "dojo/_base/fx",
    "dijit/TooltipDialog",
    "dojo/_base/connect",
    "idx/form/TextBox",
    "webui/widgets/common/Toolbar",
    "webui/widgets/dataviewer/Pagination",
    "idx/form/DateTextBox",
    "idx/form/TimeTextBox",
    "idx/widget/ConfirmationDialog",
    "dojo/number",
    "dojo/date/locale",
    "dojo/date/stamp",
    "dojo/string",
    "dojo/keys",
    "dijit/form/CheckBox"
  ],
  function(
    NLS,
    template,
    on,
    xhr,
    declare,
    Trace,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    registry,
    Resources,
    ComboBox,
    lang,
    domConstruct,
    domClass,
    Memory,
    DataGrid,
    ObjectStore,
    Button,
    query,
    dom,
    domAttr,
    array,
    fx,
    TooltipDialog,
    connect,
    TextBox,
    Toolbar,
    Pagination,
    DateTextBox,
    TimeTextBox,
    ConfirmationDialog,
    number,
    locale,
    stamp,
    string,
    keys,
    CheckBox
  ) {

    var dataviewer = declare("webui.widgets.dataviewer.DataViewer", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {

      // This is the name of the widget that will be used in trace.

      templateString: template,

      _grid : null,
      _customiseGrid : null,
      replayGrid : null,
      _gridStore: null,
      _gridData: null,
      _filterVisible: false,
      _replayVisible: false,
      _changeGridHeaderFilter: null,
      _totalPreFilteredResults: null,
      dataComboValue: null,
      publicReplayItems: null,
      replayTab: null,

      // spinner widget
      _gridStandby: null,
      _replayStandby: null,

      _gridHeader: null,
      _layout: null,
      emptyLayout: [[{
        field : 'msgKey',
        width : '20px',
        hidden : true
      }]],

      _checkBoxLayout: null,
      defaultLayout: null,
      _replayLayout: null,
      _customiseDialog: null,

      _filter_EVENT_TYPE: null,
      _escapedString : "",

      _sortstr: "",
      _filterstr: "",
      _sync: null,
      _successCount: 0,
      toolbar: null,

      canViewMessages: false,
      canEditMessages: false,
      canReplayMessages: false,

      selectedRows: [],
      _privateReplayItems: [],
      filterArray: [],
      customiseGridData: [],
      //_columnLayout: [],
      selectedItems: 0,
      selectColumnClick: "false",
      selectClickSignal: null,
      _filterRow: null,
      _timer: null,
      _filterDialog: null,

      comboStore: null,
      _numberOfFilters: 1,
      entriesToReturn: null,
      gridHeight: null,
      borderHeight: null,
      gridDivMoving: false,

      showAsLocalTime: false, // use local time of the browser for the event time.
      ////////////////////////////////////////////////////////
      // DEFAULTS
      //
      _currentNumberOfEntriesPerPage : 20,
      _currentPageNumber : 1,
      _lastPage : 1,
      _defaultNumberOfFilters : 3,
      //
      ////////////////////////////////////////////////////////

      constructor : function(args) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");
        this.inherited(arguments);
        
        var event = args.event;

        var getStoreName = function(event){
        // If this event length is less than 4, we haven't havent got to a DCS yet
        // The user just clicked 'Data Capture Stores' in the tree!
          if (event.length < 4){
            return undefined;
          }
          return event.name;
        };

        this._dataCaptureStoreCsName = getStoreName(event);

        this._checkBoxLayout = [[{
          field : 'SELECTED',
          name : "<div class='dataviewerSelectColumnHeader SelectDisabled'></div>",
          width : '18px',
          formatter : lang.hitch(this, this._insertSelectCheckbox),
          hidden : false
        }]];

        this.defaultLayout = this._checkBoxLayout[0];
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
      },
      
      postCreate : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
        this.inherited(arguments);

        // Get the current user's permissions
        // Deliberate use of global variable
        this.canViewMessages = window.currentuser.userPermission("datacapture", "read");
        this.canEditMessages = window.currentuser.userPermission("datacapture", "write");
        this.canReplayMessages = window.currentuser.userPermission("datacapture", "execute");

        // Create toolbar
        this.toolbar = new Toolbar();
        domConstruct.place(this.toolbar.domNode, this._toolbar);
        var buttons;
        if(window.currentuser.userPermission("broker", "write")) {
          buttons = ["customiseColumns", "filter","localTimeSelect","localTime", "refresh"];
        } else {
          buttons = ["filter","localTimeSelect","localTime", "refresh"];
        }

        this.toolbar.addRightAlignButtons(buttons);
        this.toolbar.addRightAlignButtons("spacer");
        this.toolbar.setButtonState("disable", buttons);
        this.toolbar.connectButtons("refresh", "click", this, "_updateGrid");

        if(window.currentuser.userPermission("datacapture", "execute")) {
          buttons = ["combo", "sendToReplayViewer"];
          var names = ["dataStore", undefined]; // use default name for "sendToReplayViewer" button
          this.toolbar.addLeftAlignButtons(buttons, names);
          this.toolbar.setButtonState("disable", "sendToReplayViewer");
          this.toolbar.connectButtons("sendToReplayViewer", "click", this, "_sendToReplayViewer");
        } else {
          this.toolbar.addLeftAlignButtons("combo", "dataStore");
        }

        // // Set some attributes on the combo box (value and store)
        this.toolbar.setAttribute("combo", "value", NLS.dataViewComboDefaultValue, "dataStore");
        this.toolbar.connectButtons("combo", "change", this, "_resetGrid", "dataStore");
        // Set local time/UTC time drop down
        this.toolbar.connectButtons("localTimeSelect", "click", this, "_localTimeSelect");

        xhr(
          Resources.REST.dataCaptureStore,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json"
            }
          }
        ).then(
          lang.hitch(this, function(response) {
            var comboData = {
              items : response.dataCaptureStore
            };
            this.toolbar.setAttribute("combo", "store", comboData.items, "dataStore");
          })
        );

        //NLS Strings
        domAttr.set(this.dataviewerNoData, "innerHTML", NLS.rrrGridStandbyNoStoreSelected);

        if(window.currentuser.userPermission("broker", "write")) {
          var customiseContainer = domConstruct.create("div", {
            className : "customiseGridDialogContainer",
            innerHTML : "<div class='customiseDialogTitle pageHeader2'>" + NLS.customiseColumnsTitle + "</div>" +
            "<div class='customiseDialogSubTitle'>" + NLS.customiseColumnsSubText + "</div>" +
            "<div class='customiseGridContainer claro'>" +
              "<div id='customiseDataGrid_ID' class='customiseDataGrid'></div>" +
            "</div>" +
            "<div class='dialogDivider'></div>" +
            "<div id='customiseGridButtons_ID' class='customisationButtons'></div>"
          });

          this._customiseDialog = new TooltipDialog({
            id : "customiseDialog_ID",
            content : customiseContainer
          });

          this.toolbar.setAttribute("customiseColumns", "dropDown", this._customiseDialog);
          this.toolbar.connectButtons("customiseColumns", "click", this, "customiseColumns");
        }

        var filterContainer = domConstruct.create("div", {
          className : "filterDialogContainer",
          innerHTML : "<div class='filterDialogTitle filterDialogTitle pageHeader2'>" + NLS.buildFilter + "</div>" +
          "<div id='filterDialogSubTitle' class='filterDialogSubTitle portletHeader1'>" + NLS.filterRules + "</div>" +
          "<div id='filterDialog_Row1'>" +
            "<div class='filterDialog_logicOperatorLabel'></div>" +
            "<div class='filterDialogColumn' id='filterDialog_Column1'></div>" +
            "<div class='filterDialogMode' id='filterDialog_Mode1'></div>" +
            "<div class='filterDialogField' id='filterDialog_Field1'></div>" +
            "<div class='_common_hideDiv' id='filterDialog_Date1'></div>" +
            "<div class='_common_hideDiv' id='filterDialog_Time1'></div>" +
            "<div class='_common_hideDiv' id='filterDialog_Blank1'></div>" +
            "<div class='filterDialogButton_subtractDisabled' id='filterDialog_Subtract1'></div>" +
            "<div title='" + NLS.filterAddRow + "' class='filterDialogButton_add' id='filterDialog_Add1'></div>" +
      		"</div>" +
          "<div id='filterDialog_Row2' class='_common_hideDiv'>" +
            "<div class='filterDialog_logicOperatorLabel'>" + NLS.filterAnd + "</div>" +
        		"<div class='filterDialogColumn' id='filterDialog_Column2'></div>" +
        		"<div class='filterDialogMode' id='filterDialog_Mode2'></div>" +
        		"<div class='filterDialogField' id='filterDialog_Field2'></div>" +
        		"<div class='_common_hideDiv' id='filterDialog_Date2'></div>" +
        		"<div class='_common_hideDiv' id='filterDialog_Time2'></div>" +
        		"<div class='_common_hideDiv' id='filterDialog_Blank2'></div>" +
        		"<div title='" + NLS.filterSubtractRow + "' class='filterDialogButton_subtract' id='filterDialog_Subtract2'></div>" +
    				"<div title='" + NLS.filterAddRow + "' class='filterDialogButton_add' id='filterDialog_Add2'></div>" +
					"</div>" +
					"<div id='filterDialog_Row3' class='_common_hideDiv'>" +
					  "<div class='filterDialog_logicOperatorLabel'>" + NLS.filterAnd + "</div>" +
						"<div class='filterDialogColumn' id='filterDialog_Column3'></div>" +
						"<div class='filterDialogMode' id='filterDialog_Mode3'></div>" +
						"<div class='filterDialogField' id='filterDialog_Field3'></div>" +
						"<div class='_common_hideDiv' id='filterDialog_Date3'></div>" +
						"<div class='_common_hideDiv' id='filterDialog_Time3'></div>" +
						"<div class='_common_hideDiv' id='filterDialog_Blank3'></div>" +
						"<div title='" + NLS.filterSubtractRow + "' class='filterDialogButton_subtract' id='filterDialog_Subtract3'></div>" +
					"</div>" +
					"<div class='dialogDivider'></div>" +
					"<div id='filterButtons_ID' class='filterButtons'></div>"
        });

        this._filterDialog = new TooltipDialog({
          id : "filterDialog_ID",
          content : filterContainer
        });

        this.toolbar.setAttribute("filter", "dropDown", this._filterDialog);

        // DATA GRID
        this._layout = lang.clone(this.emptyLayout);

        this._grid = new DataGrid({
          store : this._gridStore = new ObjectStore({
            objectStore : new Memory({
              data : []
            })
          }),
          structure : this._layout,
          escapeHTMLInData : false,
          id : "dataViewerGridID",
          height : "100%",
          columnReordering : true,
          onHeaderCellClick : lang.hitch(this, this._getSortedTable),
          selectable : true
        }, document.createElement('div'));

        /* append the new grid to the div */
        this._rrr_gridStandby_grid.appendChild(this._grid.domNode);

        /* Call startup() to render the grid */
        this._grid.startup();

        // Create pagination widget
        this.paginationFooter = new Pagination();
        domConstruct.place(this.paginationFooter.domNode, this._rrr_paginationFooter);
        on(this.paginationFooter, "click", lang.hitch(this, this._changeGridPage));

        this.selectClickSignal = on(document, ".dataviewerSelectColumnHeader:click, .dataviewerSelectRow:click", lang.hitch(this, function(event) {
          this.selectColumnHeader(event);
        }));
        // domAttr.set(this.dataviewerFilterBarText, "innerHTML", NLS.filterNoFilterApplied);

        this.toolbar.connectButtons("filter", "click", this, "_buildFilters");

        on(this.dataviewerFilterClearText, "click", lang.hitch(this, this._clearFilter));

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
      },

      _loadDataViewer : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_loadDataViewer");

        var dataCaptureStore = this._dataCaptureStoreCsName;

        xhr(
          Resources.REST.dataCaptureStore,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json"
            }
          }
        ).then(
          lang.hitch(this, function(data) {
            var comboData = {
              items : data.dataCaptureStore
            };
            this.toolbar.setAttribute("combo", "store", comboData.items, "dataStore");
            if(dataCaptureStore) {
              this.toolbar.setAttribute("combo", "value", dataCaptureStore, "dataStore");
              this._resetGrid();
            }
          })
        );
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_loadDataViewer");
      },

      // Reset and then update the grid and pagination numbers when a new data store is selected.
      _resetGrid : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_resetGrid");

        if((this.toolbar.getComboValue("dataStore") !== NLS.dataViewComboDefaultValue)&&(this.toolbar.getComboValue("dataStore") !== "")) {
          // Update the URI hash
          var newHash = "dataCaptureStore/0/data/datacapture/" + this.toolbar.getComboValue("dataStore");
          window.wmbConsole.safelyChangeHash(newHash);

          // Hide the "no data" message disappear if it's visible
          if(!domClass.contains(this.dataviewerNoData, "_common_hideDiv")) {
            var fadeArgs = {
              node : "dataviewerNoData_ID",
              duration : 300,
              onEnd : function() {
                domClass.add("dataviewerNoData_ID", "_common_hideDiv");
              }
            };
            fx.fadeOut(fadeArgs).play();
          }
          this._currentPageNumber = 1;
          this._clearFilter(true);
          this._updateGrid(true);
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_resetGrid");
      },


      // Update the grid.
      _updateGrid : function(reset) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_updateGrid");
        // Disable the refresh button
        this.toolbar.setAttribute("refresh", "iconClass", "infoPaneButton_refreshLoading");
        domClass.remove(this.dataviewerFilterBarIcon, "infoPaneButton_refreshLoading");
        domClass.remove(this.dataviewerFilterBarIcon, "infoPaneButton_refreshLoadingDisabled");
        domClass.add(this.dataviewerFilterBarIcon, "dataviewerFilterBarRefreshLoading");

        domAttr.set(this.dataviewerFilterBarText, "innerHTML", NLS.dataLoading);

        // Clear the table so it's obvious that a refresh has occurred
        var _gridStore = new ObjectStore({
          objectStore : new Memory({
            data : []
          })
        });
        this._grid.setStore(_gridStore);

        // Fetch new source and refresh grid.
        this.dataComboValue = this.toolbar.getComboValue("dataStore");

        if(this.dataComboValue !== "") {

          // Hide the "No Data Store Selected" message
          if(!domClass.contains(this.dataviewerNoData, "_common_hideDiv")) {
            var fadeArgs = {
              node : "dataviewerNoData_ID",
              duration : 300,
              onEnd : function() {
                domClass.add("dataviewerNoData_ID", "_common_hideDiv");
              }
            };
            fx.fadeOut(fadeArgs).play();
          }

          this._grid.startup();
          this._grid.store.close();

          this._pageSize = this._currentNumberOfEntriesPerPage;
          //_pageSize is -1 when "All" is selected
          // if _pageSize is -1, i.e. all has been selected then set to return all entries
          if(this._pageSize !== "") {
            this.entriesToReturn = "&" + Resources.REST.dataEntriesReturned + this._pageSize;
          } else {
            this.entriesToReturn = "&" + Resources.REST.dataEntriesReturned + "-1";
          }

          var uri = Resources.REST.dataCaptureStore + this.dataComboValue + "/?" + Resources.REST.dataPageNumber + this._currentPageNumber + this.entriesToReturn + this._filterstr + this._sortstr;

          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "_updateGrid : uri = " + uri);

          xhr(
            uri,
            {
              handleAs : "json",
              headers : {
                "Accept" : "application/json"
              }
            }
          ).then(
            lang.hitch(this, function(response) {
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "_updateGrid : data.totalResults = " + response.totalResults);

              if(window.currentuser.userPermission("broker", "write")) {
                // Enable the customize columns button
                this.toolbar.setButtonState("enable", "customiseColumns");
              }

              this.defaultLayout = this._checkBoxLayout[0];
              array.forEach(response.customizations, lang.hitch(this, function(customization) {
                // Build the layout for the grid structure
                // First build an object for each column

                // Set 'hidden' to true by default unless specified as false
                var hidden = customization.isHidden !== false;

                // Check field names exist and add fieldFormatters is required
                var fieldName;
                var fieldFormatter;
                if(customization.fieldName !== undefined) {
                  fieldName = customization.fieldName;
                  if(fieldName === "hasBitstream") {
                    fieldFormatter = lang.hitch(this, this.insertBitstreamLink);
                  } else if(fieldName === "hasException") {
                    fieldFormatter = lang.hitch(this, this.insertExceptionLink);
                  } else if (fieldName === "eventTimestamp") {
                    fieldFormatter = lang.hitch(this, this._eventTimeStampFormatter);
                  } else {
                    fieldFormatter = null;
                  }
                } else {
                  fieldName = "";
                  hidden = true;
                  fieldFormatter = null;
                }

                // Replace customisedName with the NLS version of the field name if it's blank
                var customizedName = customization.customizedName || NLS.dataViewerColumn[fieldName];
                var fieldWidth;
                if(customization.fieldWidth === 0) {
                  fieldWidth = "auto";
                } else {
                  fieldWidth = customization.fieldWidth + "px";
                }

                this.defaultLayout = this.defaultLayout.concat([{
                  field : fieldName,
                  width : fieldWidth,
                  name : customizedName,
                  hidden : hidden,
                  formatter : fieldFormatter
                }]);
              }));

              this._grid.setStructure(this.defaultLayout);

              // Enable buttons
              this.toolbar.setButtonState("enable", "refresh");
              this.toolbar.setAttribute("refresh", "iconClass", "infoPaneButton_refresh");
              this.toolbar.setButtonState("enable", "filter");

              this.toolbar.setButtonState("enable", "localTime");
              this.toolbar.setButtonState("enable", "localTimeSelect");
              if(response.totalResults > 0) {
                this._totalNumberOfResults = response.totalResults;
              } else {
                this._totalNumberOfResults = 0;
                domAttr.set(this.dataviewerNoData, "innerHTML", NLS.rrrGridStandbyNoDataReturned);
                if(domClass.contains(this.dataviewerNoData, "_common_hideDiv")) {
                  var fadeArgs = {
                    node : "dataviewerNoData_ID",
                    duration : 300,
                    onBegin : function() {
                      domClass.remove("dataviewerNoData_ID", "_common_hideDiv");
                    }
                  };
                  fx.fadeIn(fadeArgs).play();
                }
              }

              if(this._filterstr === "") {
                this._totalPreFilteredResults = this._totalNumberOfResults;
              }

              var _gridData = {
                items : response.data,
                identifier : "msgKey",
                label : "msgKey"
              };
              var _gridStore = new ObjectStore({
                objectStore : new Memory({
                  data : _gridData
                })
              });

              this._grid.setStore(_gridStore);
              //force a redraw of the grid and data
              this.resize();

              // Set pagination numbers
              if(this._pageSize) {
                this._lastPage = Math.floor((this._totalNumberOfResults - 1) / this._pageSize) + 1;
              } else {
                this._lastPage = "";
              }
              this.paginationFooter.set("PageNumbers", this._currentPageNumber, this._lastPage);
              this.paginationFooter.set("TotalSelected", this._totalPreFilteredResults, "0");
              this.paginationFooter.set("NumberDisplayed", this._totalNumberOfResults, this._pageSize);

              if(this._filterstr !== "") {

                if (this._currentPageNumber < this._lastPage) {
                  domAttr.set(this.dataviewerFilterBarText, "innerHTML", string.substitute(NLS.filterResults, [this._pageSize, this._totalNumberOfResults]));
                }
                else  {
                  var lastPageNumber = 0;
                  if (this._lastPage <0) {// "All"  is selected
                    lastPageNumber = this._totalNumberOfResults;
                  } else if (this._totalNumberOfResults >0) {
                    lastPageNumber = this._totalNumberOfResults - this._pageSize * (this._lastPage -1);
                  }
                  domAttr.set(this.dataviewerFilterBarText, "innerHTML", string.substitute(NLS.filterResults, [lastPageNumber, this._totalNumberOfResults]));
                }
                domAttr.set(this.dataviewerFilterClearText, "innerHTML", NLS.filterClearFilter);
                domClass.remove(this.dataviewerFilterBarIcon, "dataviewerFilterBarRefreshLoading");
                // domClass.add(this.dataviewerFilterBarIcon, "dataviewerFilterBarIcon");
              } else {
                domAttr.set(this.dataviewerFilterBarText, "innerHTML", NLS.filterNoFilterApplied);
                domAttr.set(this.dataviewerFilterClearText, "innerHTML", "");
                domClass.remove(this.dataviewerFilterBarIcon, "dataviewerFilterBarRefreshLoading");
                domClass.add(this.dataviewerFilterBarIcon, "dataviewerFilterBarIconDisabled");
              }

              this.changeSelectColumnHeader("AllNone");

              if(reset){
                // Repopulate filter combos
                this._populateFilterCombos();
              }
            }),
            lang.hitch(this, function(error) {
              var response = JSON.parse(error.response.text);
              window.smallMessage.displayMessage("error", "DataViewer_5XX", response.bipNumber, response.description);
              domAttr.set(this.dataviewerNoData, "innerHTML", NLS.rrrGridStandbyNoDataReturned);
              if(domClass.contains(this.dataviewerNoData, "_common_hideDiv")) {
                var fadeArgs = {
                  node : "dataviewerNoData_ID",
                  duration : 300,
                  onBegin : function() {
                    domClass.remove("dataviewerNoData_ID", "_common_hideDiv");
                  }
                };
                fx.fadeIn(fadeArgs).play();
              }
              this.toolbar.setButtonState("enable", "refresh");
              this.toolbar.setAttribute("refresh", "iconClass", "infoPaneButton_refresh");
              domAttr.set(this.dataviewerFilterBarText, "innerHTML", "");
              domAttr.set(this.dataviewerFilterClearText, "innerHTML", "");
              // domClass.add(this.dataviewerFilterBarIcon, "dataviewerFilterBarIcon");
              domClass.remove(this.dataviewerFilterBarIcon, "dataviewerFilterBarRefreshLoading");
            })
          );
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_updateGrid");
      },

      sortGrid: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "sortGrid");

        array.forEach(this._layout, lang.hitch(this,function(_layoutData){
          if((this._grid.sortInfo-1)<0){
            this._sortstr = "&orderBy=" + _layoutData[(-1*this._grid.sortInfo)-1].field + "&order=DESC";
          } else {
            this._sortstr = "&orderBy=" + _layoutData[(this._grid.sortInfo)-1].field + "&order=ASC";
          }
        }));
        this._updateGrid();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "sortGrid");
      },

      insertBitstreamLink : function(name, rowIndex) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "insertBitstreamLink");

        var MsgKey = this._grid.getItem(rowIndex).msgKey;
        var result = "";
        var dataCaptureStore = this.toolbar.getComboValue("dataStore");
        if(name) {
          if(this.canViewMessages) {
            result = "<center><a target='_blank' href='" + Resources.REST.dataCaptureStore + dataCaptureStore + "/" + MsgKey + "'><div title='" + NLS.replayDownload + "' class='replayDownload'></div></a></center>";
          } else {
            result = "<center><div title='" + NLS.replayDownloadLocked + "' class='replayDownloadLocked'></div></center>";
          }
        } else {
          result = "<center><div title='" + NLS.replayDownloadDisabled + "' class='replayDownloadDisabled'></div></center>";
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "insertBitstreamLink");
        return result;
      },

      insertExceptionLink : function(name, rowIndex) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "insertExceptionLink");

        var MsgKey = this._grid.getItem(rowIndex).msgKey;
        var result = "";
        var dataCaptureStore = this.toolbar.getComboValue("dataStore");
        if(name) {
          if(this.canViewMessages) {
            result = "<center><a target='_blank' href='" + Resources.REST.dataCaptureStore + dataCaptureStore + "/" + MsgKey + "?payload=exceptionList'><img src='/webui/widgets/dataviewer/images/exception.gif'></a></center>";
          } else {
            result = "<center><img src='/webui/widgets/dataviewer/images/exception_inactive.gif'></center>";
          }
        } else {
          result = "<center>-</center>";
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "insertExceptionLink");
        return result;
      },

      _escapeChars : function (tmp) {
        var str;
        if(tmp !== undefined) {
          str = tmp.replace(/&/g, "&amp;");
          str = str.replace(/</g, "&lt;");
          str = str.replace(/>/g, "&gt;");
          str = str.replace(/"/g, "&quot;");
          str = str.replace(/\?/g, "&#63;");
        } else {
          str = "";
        }
        return (str);
      },

      _eventTimeStampFormatter : function(name, rowIndex) { // jshint ignore:line
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_eventTimeStampFormatter");
        var timeStamp = this._grid.getItem(rowIndex).eventTimestamp;
        if (this.showAsLocalTime === false) {
          // return value with UTC on the end to show that it is UTC !
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "_eventTimeStampFormatter");
          return timeStamp + " UTC";
        }
        //convert to the local browser time zone
        var date = timeStamp.substring(0,10);
        var time = timeStamp.substring(11);
        var utc = date + 'T' + time + '+00:00';
        var localeDate = stamp.fromISOString(utc);
        // convert offset e.g. UTC+10 gives negative offset and -10 positive offset
        var offset = localeDate.getTimezoneOffset() * -1;
        var hours = number.format(Math.abs(offset - (offset % 60)) / 60, { pattern: "00" });
        var minutes = number.format(Math.abs(offset) % 60, { pattern: "00" });
        var result;
        if (offset >= 0) {
          result = locale.format(localeDate, { selector: "date", datePattern: "yyyy-MM-dd HH:mm:ss.SSS '+"+hours+":"+minutes+"'" });
        }
        else {
          result = locale.format(localeDate, { selector: "date", datePattern: "yyyy-MM-dd HH:mm:ss.SSS '-"+hours+":"+minutes+"'" });
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_eventTimeStampFormatter");
        return result;
      },
      convertToUTC : function(value) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "convertToUTC");
        var date = value.substring(0,10);
        var time = value.substring(11);
        var year = date.substring(0,4);
        var month = date.substring (5,7) -1;
        var day = date.substring(8,10);
        var hours = time.substring(0,2);
        var mins = time.substring(3,5);
        var secs = time.substring(6,8);
        var milliseconds = time.substring(9);
        var localeDate = new Date(year,month,day,hours,mins,secs,milliseconds);
        var UTCHours = String(localeDate.getUTCHours());
        if (UTCHours.length === 1) {
          UTCHours = '0'+UTCHours;
        }
        var UTCMins= String(localeDate.getUTCMinutes());
        if (UTCMins.length === 1) {
          UTCMins = '0'+UTCMins;
        }
        var UTCYear = localeDate.getUTCFullYear();
        var UTCMonths = String(localeDate.getUTCMonth() + 1);
        if (UTCMonths.length === 1) {
          UTCMonths = '0'+UTCMonths;
        }
        var UTCDay  = String(localeDate.getUTCDate());
        if (UTCDay.length === 1) {
          UTCDay = '0'+UTCDay;
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "convertToUTC");
        return UTCYear + '-' + UTCMonths +'-' + UTCDay + ' ' +UTCHours + ':' + UTCMins + ':' + secs +'.'+ milliseconds;
      },

      _localTimeSelect: function()
      {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_localTimeSelect");
        if (this.showAsLocalTime === false) {
          this.showAsLocalTime = true;
          this.toolbar.setAttribute("localTimeSelect","label",NLS.localTimeUTC);
        }
        else
        {
          this.showAsLocalTime = false;
          this.toolbar.setAttribute("localTimeSelect","label",NLS.localTimeBrowser);
        }
        this._updateGrid();
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_localTimeSelect");
      },

      _insertSelectCheckbox : function(name, rowIndex) { // jshint ignore:line
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_insertSelectCheckbox");

        var result = "";

        var MsgKey = this._grid.getItem(rowIndex).msgKey;
        var checked = "None";
        var replay = "";

        var title = NLS.replayRowCheckboxMark;
        array.forEach(this.selectedRows, lang.hitch(this, function(selectedItem) {
          if(selectedItem === MsgKey) {
            checked = "";
            title = NLS.replayRowCheckboxUnMark;
          }
        }));

        if(this.publicReplayItems){
          array.forEach(this.publicReplayItems.items, lang.hitch(this, function(replayItem) {
            if(replayItem && (replayItem.msgKey === MsgKey)) {
              replay = "ReplayDV";
              title = NLS.replayRowCheckboxUnMark;
            }
          }));
        }

        var checkBoxIcon = "<div value='" + MsgKey + "' title='" + title + "' class='dataviewerSelectRow Select" + replay + checked + "'></div>";
        result = checkBoxIcon;

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_insertSelectCheckbox");
        return result;
      },

      onReplayRowClickHandler : function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onReplayRowClickHandler");
        // Check the 'Single Replay' column was selected
        if(event.cell.index === 1) {
          // Run replay only on that row
          this._submitReplayDialog(event.rowIndex);
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onReplayRowClickHandler");
      },

      _getSortedTable : function(e) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_getSortedTable");

        if((this._totalNumberOfResults > 0) && (e.cell.index !== 0)) {
          var headerIndex = e.cell.index;
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "_getSortedTable : headerIndex = " + headerIndex);
          if(this._grid.getSortAsc()) {
            this._grid.setSortIndex(headerIndex, false);
            this._sortstr = "&orderBy=" + e.cell.field + "&order=DESC";
          } else {
            this._grid.setSortIndex(headerIndex, true);
            this._sortstr = "&orderBy=" + e.cell.field + "&order=ASC";
          }
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "_getSortedTable : this._sortstr = " + this._sortstr);
          this._updateGrid();
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_getSortedTable");
      },

      resize : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");

        this.inherited(arguments);
        this._grid.setStructure(this.defaultLayout);
        this._dataviewer_borderContainer.resize();
        this._grid.resize();
        this._grid.update();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
      },

      _changeGridPage : function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_changeGridPage");

        var clickType = "";
        array.forEach(event.target.attributes, lang.hitch(this, function(attribute) {
          if(attribute.name === "alt") {
            clickType = attribute.value;
          }
        }));
        switch(clickType) {
          case "number":
            this._currentPageNumber = event.target.innerHTML;
            this._updateGrid();
            break;
          case "previous":
            this._currentPageNumber--;
            this._updateGrid();
            break;
          case "next":
            this._currentPageNumber++;
            this._updateGrid();
            break;
          case "gotopage":
            domClass.toggleClass("_goToPageDialog", "_common_hideDiv");
            break;
          case "displayNumber":
            this._currentNumberOfEntriesPerPage = event.target.innerHTML;
            this._currentPageNumber = 1;
            this._updateGrid();
            break;
          case "all":
            this._currentNumberOfEntriesPerPage = "-1";
            this._currentPageNumber = 1;
            this._updateGrid();
            break;
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_changeGridPage");
      },

      changeSelectColumnHeader: function(mode) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "changeSelectColumnHeader");

        // mode is either Disabled, All, None or Mixed
        var str = "<div class='dataviewerSelectColumnHeader Select" + mode + "'></div>";
        this.defaultLayout[0].name = str;

        // Update the grid with the new structure (updated header)
        this._grid.setStructure(this.defaultLayout);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "changeSelectColumnHeader");
      },

      selectColumnHeader : function(checkbox) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "selectColumnHeader");

        //	this.selectedItems = 0;
        // Determine which checkbox was clicked. Was it in the header or in a row?
        if(checkbox.target.className.match("dataviewerSelectColumnHeader")) {
          this.selectClickSignal.remove();
          if(this.selectedItems === 0) {
            // If no data items have been selected then a click on the select column should select all items.
            this.changeSelectColumnHeader("All");
            var rowNum = 0;
            for (rowNum=0; rowNum < this._grid.rowCount; rowNum++) {
              var row = this._grid.store.objectStore.data[rowNum];
              this.selectedRows.push(row.msgKey);
              this._privateReplayItems.push(row);
              this.selectedItems++;
            }
          } else {
            // If one or more, but not all, of the items are selected then a click on the select should deselect all.
            this.changeSelectColumnHeader("AllNone");
            this.selectedRows = [];
            this._privateReplayItems = [];
            this.selectedItems = 0;
          }

          // Activate the replay button when a row is selected and deactivate it when no rows are selected.
          if(window.currentuser.userPermission("datacapture", "execute")) {
            if(this.selectedItems !== 0) {
              this.toolbar.setButtonState("enable", "sendToReplayViewer");
            } else {
              this.toolbar.setButtonState("disable", "sendToReplayViewer");
            }
          }

          if(this._totalNumberOfResults !== -1) {
            this.paginationFooter.set("TotalSelected", this._totalNumberOfResults, this.selectedItems);
          }
          this.selectClickSignal = on(document, ".dataviewerSelectColumnHeader:click, .dataviewerSelectRow:click", lang.hitch(this, function(event) {
            this.selectColumnHeader(event);
          }));
        } else {
          if((checkbox.target.className.match("SelectNone"))||(checkbox.target.className.match("SelectReplayDVNone"))) {
            var checkBoxWidget = dijit.getEnclosingWidget(checkbox.target);
            this.selectedRows.push(domAttr.get(checkbox.target, "value"));
            this._privateReplayItems.push(this._grid._by_idx[checkBoxWidget.grid.selection.selectedIndex].item); // TODO: don't access private property
            this.selectedItems++;
          } else {
            // Find the item in the array and remove it
            array.forEach(this.selectedRows, lang.hitch(this, function(selectedItem, i) {
              if(selectedItem === domAttr.get(checkbox.target, "value")) {
                this.selectedRows.splice(i, 1);
                this._privateReplayItems.splice(i, 1);
                this.selectedItems--;
              }
            }));
          }

          // Activate the replay button when a row is selected and deactivate it when no rows are selected.
          if(window.currentuser.userPermission("datacapture", "execute")) {
            if(this.selectedItems !== 0) {
              this.toolbar.setButtonState("enable", "sendToReplayViewer");
            } else {
              this.toolbar.setButtonState("disable", "sendToReplayViewer");
            }
          }

          if(this._totalNumberOfResults !== -1) {
            this.paginationFooter.set("TotalSelected", this._totalNumberOfResults, this.selectedItems);

            // If one or more, but not all, data items are selected then change the select header to 'mixed'
            if(this.selectColumnClick === "false") {
              if((this._grid._by_idx.length > this.selectedItems) && (this.selectedItems > 0)) {
                this.changeSelectColumnHeader("Mixed");
              }
              if((this.selectedItems === 0)) {
                this.changeSelectColumnHeader("AllNone");
              }
              if((this.selectedItems === this._grid._by_idx.length)) {
                this.changeSelectColumnHeader("All");
              }
            }
          }
        }
        this._grid.update();

        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "selectColumnHeader");
      },

      removeRow : function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "removeRow");

        array.forEach(window.tabWidgets, lang.hitch(this, function(tabWidget){
          if(tabWidget.id === "webui.widgets.dataviewer.Replay"){
            this.replayTab = tabWidget;
          }
        }));

        if(this.publicReplayItems){
          if(event.rowNode !== undefined) {
            var fadeArgs = {
              node : event.rowNode,
              duration : 300,
              onEnd : lang.hitch(this, function() {
                var replayItems = lang.clone(this.publicReplayItems);
                array.forEach(replayItems.items, lang.hitch(this, function(replayItem, i) {
                  if(replayItem.msgKey === event.grid._by_idx[event.rowNode.gridRowIndex].item.msgKey) {
                    this.publicReplayItems.items.splice(i, 1);
                    this.replayTab.totalReplayItems--;
                  }
                }));
                this.replayTab.replayGridStore = new ObjectStore({
                  objectStore : new Memory({
                    data : this.publicReplayItems,
                    clearOnClose : true,
                    urlPreventCache : true
                  })
                });
                this.replayTab.replayGrid.setStore(this.replayTab.replayGridStore);
                // Now that publicReplayItems has been updated we need to rebuild this.addedReplayItems
                this.replayTab.addedReplayItems = JSON.stringify(this.publicReplayItems.items);
                this.replayTab.replayListFooter(this.replayTab.totalReplayItems, 0, 0, 0);
              })
            };
            fx.fadeOut(fadeArgs).play();
          } else {
            this.publicReplayItems.items = [];
            this.replayTab.totalReplayItems = 0;
            this.replayTab.replayGridStore = new ObjectStore({
              objectStore : new Memory({
                data : this.publicReplayItems,
                clearOnClose : true,
                urlPreventCache : true
              })
            });
            this.replayTab.replayGrid.setStore(this.replayTab.replayGridStore);
            // Now that dataviewerTab.publicReplayItems has been updated we need to rebuild this.addedReplayItems
            this.replayTab.addedReplayItems = JSON.stringify(this.publicReplayItems.items);
            this.replayTab.replayListFooter(this.replayTab.totalReplayItems, 0, 0, 0);
          }

        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "removeRow");
      },

      _sendToReplayViewer : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_sendToReplayViewer");

        array.forEach(window.tabWidgets, lang.hitch(this, function(tabWidget){
          if(tabWidget.id === "webui.widgets.dataviewer.Replay"){
            this.replayTab = tabWidget;
          }
        }));

        // Populate replay grid with data
        if(window.currentuser.userPermission("datacapture", "execute")) {
          this.replayTab.populateReplayGrid(this._privateReplayItems);
          //this.toolbar.setButtonState("disable", "sendToReplayViewer");
        }

        this.replayTab.startup();

        // Mark rows with replay selected icon
        var checkboxes = query('#_rrr_gridStandby_grid_ID .SelectAll');
        array.forEach(checkboxes, lang.hitch(this, function(node) {
          domAttr.set(node, "class", "dataviewerSelectRow SelectReplay");
        }));
        // Open Replay Tab
        if(window.currentuser.userPermission("datacapture", "execute")) {

          var tab = registry.byId("dataCaptureStore1");
          if (tab) {
            registry.byId('_infoPaneTabContainer_ID').selectChild(tab);
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Selecting Tab: dataCaptureStore1");
          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_sendToReplayViewer");
      },

      customiseColumns : function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "customiseColumns");


        domAttr.set(dom.byId("customiseDataGrid_ID"),"style","opacity:0");

        if(!this._customiseGrid){
          this._customiseGrid = new DataGrid( {
            "store" : new ObjectStore({"objectStore": new Memory({"data":[]})}),
            "structure" : [[{
              "field" : 'field',
              "width" : '200px',
              "name" : NLS.fieldID,
              "style" : "color:red"
            }, {
              "field" : 'visible',
              "width" : '16px',
              "name" : ' ',
              "formatter" : lang.hitch(this, this.__insertCustomiseSelectCheckbox)
            }, {
              "field" : 'name',
              "width" : 'auto',
              "name" : NLS.displayName,
              "editable" : true
            }, {
              "field" : 'width',
              "width" : '70px',
              "name" : NLS.widthPX,
              "editable" : true
            }]],
            escapeHTMLInData : false,
            onHeaderCellClick : lang.hitch(this, this._sortCustomisationGrid)
          }, document.createElement('div'));

          /* append the new grid to the div */
          var customiseGridDiv = dom.byId("customiseDataGrid_ID");
          customiseGridDiv.appendChild(this._customiseGrid.domNode);
          this._customiseGrid.startup();
        }

        var customiseButtonsDiv = dom.byId("customiseGridButtons_ID");
        if(!this._cancelButton){
          this._cancelButton = new Button({
            label: NLS.action.cancel,
            showLabel: true,
            layoutAlign: "right",
            disabled: false,
            iconClass: "infoPaneButton_cancel"
          });
          customiseButtonsDiv.appendChild(this._cancelButton.domNode);
          on(this._cancelButton, "click", lang.hitch(this, function() {
            // Close the Customisation dialog
            this.toolbar.getButton("customiseColumns").closeDropDown();
          }));
        }

        if(!this._applyButton){
          this._applyButton = new Button({
            label: NLS.action.apply,
            showLabel: true,
            layoutAlign: "right",
            disabled: false,
            iconClass: "infoPaneButton_apply"
          });
          customiseButtonsDiv.appendChild(this._applyButton.domNode);
          on(this._applyButton, "click", lang.hitch(this, this._applyCustomisation));
        }

        var items = [];
        array.forEach(this._grid.layout.cells, lang.hitch(this, function(object, i){
          // Build a JSON string for only the selected items.
          if(object.field === "msgKey" || object.field === "SELECTED") {
            return;
          }

          var visible = (object.hidden || false) ? "false" : "true";
          var unitWidth = "auto";
          if(object.unitWidth !== undefined) {
            unitWidth = String(Number(object.unitWidth.replace("px","")));
          }

          items.push({
            "visible" : visible, // string field
            "field" : object.field,
            "name" : object.name,
            "width" : unitWidth,
            "order" : i
          });
        }));

        var gridStore = new ObjectStore({
          "objectStore": new Memory({
            "data" : {
              "items": items,
              "identifier": "field",
              "label": "field"
            }
          })
        });
        this._customiseGrid.setStore(gridStore);

        // Apply a style to all the cells in the first column.
        query('#customiseDataGrid_ID td[idx="0"]').addClass("customiseDataGridFirstColumn");

        // Capture any changes to the checkboxes in the customisation grid
        on(query('.customiseCheckBox'), "click", lang.hitch(this, function(event){

          var visible = event.target.checked ? "true" : "false";
          var rowIndex = event.target.name.split("_")[1];
          this._customiseGrid.store.objectStore.data[rowIndex].visible = visible;
        }));

        var customiseDialogDiv = dom.byId("customiseDialog_ID");
        connect.connect(customiseDialogDiv, "onkeydown", this, this._customiseKeyPresses);

        // Fade in grid to avoid flicker as custom styling is applied
        var fadeArgs = {
          node: "customiseDataGrid_ID",
          duration: 300
        };
        fx.fadeIn(fadeArgs).play();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "customiseColumns");
      },

      _customiseKeyPresses : function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_customiseKeyPresses");

        switch(event.keyCode) {
          case keys.ENTER:
            this._applyCustomisation();
            break;
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_customiseKeyPresses");
      },

      _applyCustomisation : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_applyCustomisation");

        // Update the layout with the new data
        var customizations = [
          {
            "fieldName" : "msgKey",
            "fieldWidth" : "20",
            "customizedName" : "",
            "isHidden" : true
          }
        ];

        array.forEach(this._customiseGrid._by_idx, lang.hitch(this, function(data) {
          var customization = {
            "fieldName" : data.item.field,
            "fieldWidth" : data.item.width === "auto" ? 0 : parseInt(data.item.width, 10),
            "customizedName" : data.item.name,
            "isHidden" : (data.item.visible === "false")
          };

          customizations.push(customization);
        }));
        var updatedLayout = {
          "customizations" : customizations
        };

        // Send 'PUT' the updatedLayout to the server
        xhr.put(
          Resources.REST.dataCaptureStore + this.dataComboValue,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json",
              "Content-type" : "application/json"
            },
            data : JSON.stringify(updatedLayout)
          }
        ).response.then(
          lang.hitch(this, function() {
            window.smallMessage.displayMessage("success", "DataViewerCustomisation_2XX");
            this._resetGrid();
          }),
          lang.hitch(this, function() {
            window.smallMessage.displayMessage("error", "DataViewerCustomisation_5XX");
          })
        );

        // Disable the refresh button
        this.toolbar.setAttribute("refresh", "iconClass", "infoPaneButton_refreshLoading");
        domClass.remove(this.dataviewerFilterBarIcon, "infoPaneButton_refreshLoading");
        domClass.remove(this.dataviewerFilterBarIcon, "infoPaneButton_refreshLoadingDisabled");
        domClass.add(this.dataviewerFilterBarIcon, "dataviewerFilterBarRefreshLoading");

        domAttr.set(this.dataviewerFilterBarText, "innerHTML", NLS.dataLoading);

        // Clear the table so it's obvious that a refresh has occurred
        var _gridStore = new ObjectStore({
          objectStore : new Memory({
            data : []
          })
        });
        this._grid.setStore(_gridStore);
        this._grid.setStructure(this.emptyLayout);

        // Close the Customisation dialog
        this.toolbar.getButton("customiseColumns").closeDropDown();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_applyCustomisation");
      },

      moveCustomiseDataViewerRow : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "moveCustomiseDataViewerRow");

        var checkBoxIcon = "<div title='" + NLS.customiseReorderToolTip + "' class='customisationDragRow'></div>";

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "moveCustomiseDataViewerRow");
        return checkBoxIcon;
      },

      /** `visible` is a string "true" or "false" */
      __insertCustomiseSelectCheckbox : function(visible, rowIndex) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "__insertCustomiseSelectCheckbox");

        var checkBox = new CheckBox({
          name : "customiseCheckBox_" + rowIndex,
          checked : visible === "true",
          className : "customiseCheckBox"
        }, "checkBox");

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_insertCustomiseSelectCheckbox");
        return checkBox;
      },

      _sortCustomisationGrid : function(e) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_sortCustomisationGrid");

        if(e.cell.index !== 0) {
          var headerIndex = e.cell.index;
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "_sortCustomisationGrid : headerIndex = " + headerIndex);
          if(this._customiseGrid.getSortAsc()) {
            this._customiseGrid.setSortIndex(headerIndex, false);
            query('#customiseDataGrid_ID td[idx="0"]').addClass("customiseDataGridFirstColumn");
          } else {
            this._customiseGrid.setSortIndex(headerIndex, true);
            query('#customiseDataGrid_ID td[idx="0"]').addClass("customiseDataGridFirstColumn");
          }
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "_sortCustomisationGrid : this._sortstr = " + this._sortstr);
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_getSortedTable");
      },

      /**
       * Build just one filter entry.
       * Create and populate one of each of these things:
       */
      _buildFilter : function(i) {

        // filter column combobox for the filter dialog
        var comboItems = [];

        array.forEach(this._grid.layout.cells, function(object) {
          if(!object._props.hidden && object._props.field !== "msgKey" && object._props.field !== "SELECTED") {
            comboItems.push( {"name": object._props.name, "id": object._props.field} );
          }
        }, this);

        var comboStore = new Memory({
          data : comboItems
        });

        var comboButton = new ComboBox({
          store : comboStore,
          id : "filterColumnCombo" + (i + 1)
        });
        domClass.add(comboButton.domNode, "dataStoreCombo");
        domConstruct.place(comboButton.domNode, dom.byId("filterDialog_Column" + (i + 1)));

        on(registry.byId("filterColumnCombo" + (i + 1)), "change", lang.hitch(this, function(e) {
          this._filterComboChanged("filterColumnCombo" + (i + 1), e);
        }));


        // filter mode combobox for the filter dialog
        var modeComboStore = new Memory({
          data : {"items":[
            {"name": NLS.filterContains, "id": "contains"},
            {"name": NLS.filterStartsWith,"id": "startsWith"},
            {"name": NLS.filterEndsWith, "id": "endsWith"},
            {"name": NLS.filterMatches , "id": "matches"}
          ]}
        });
        var modeComboButton = new ComboBox({
          store : modeComboStore,
          id : "filterModeCombo" + (i + 1)
        });
        domClass.add(modeComboButton.domNode, "dataStoreCombo");
        domConstruct.place(modeComboButton.domNode, dom.byId("filterDialog_Mode" + (i + 1)));

        modeComboButton.set('value', NLS.filterContains);
        modeComboButton.item = modeComboButton.store.query({name:NLS.filterContains})[0];

        
        // filter field text box for the filter dialog
        var textBox = new TextBox({
          hint : NLS.filterEnterFilterValue,
          hintPosition : "inside",
          id : "filterTextBox" + (i + 1)
        });
        domClass.add(textBox.domNode, "filterTextBox");
        domConstruct.place(textBox.domNode, dom.byId("filterDialog_Field" + (i + 1)));

        on(registry.byId("filterTextBox" + (i + 1)), "change", lang.hitch(this, function(e) {
          this._filterTextChanged(e);
        }));


        // filter field date box for the filter dialog
        var dateTextBox = new DateTextBox({
          hint : "yyyy-mm-dd",
          forceWidth : false,
          constraints : {
            datePattern : "yyyy-MM-dd",
            selector : "date"
          },
          hasDownArrow : false,
          openOnClick : false,
          invalidMessage : "Invalid date: yyyy-mm-dd",
          promptMessage : "Enter a date: yyyy-mm-dd",
          tooltipPosition : ["above", "below"],
          hintPosition : "inside",
          id : "filterDateTextBox" + (i + 1)
        });
        domClass.add(dateTextBox.domNode, "filterDateTextBox");
        domConstruct.place(dateTextBox.domNode, dom.byId("filterDialog_Date" + (i + 1)));

        on(registry.byId("filterDateTextBox" + (i + 1)), "change", lang.hitch(this, function(e) {
          this._filterDateChanged("filterDateTextBox" + (i + 1), "filterTimeTextBox" + (i + 1), e);
        }));


        // filter field time box for the filter dialog
        var timeTextBox = new TimeTextBox({
          hint : "hh:mm:ss.sss",
          hintPosition : "inside",
          hasDownArrow : false,
          openOnClick : false,
          invalidMessage : "Invalid time: hh:mm:ss.sss",
          promptMessage : "Enter a time: hh:mm:ss.sss",
          tooltipPosition : ["above", "below"],
          constraints : {
            timePattern : "HH:mm:ss.SSS",
            selector : "time"
          },
          id : "filterTimeTextBox" + (i + 1)
        });
        domClass.add(timeTextBox.domNode, "filterTimeTextBox");
        domConstruct.place(timeTextBox.domNode, dom.byId("filterDialog_Time" + (i + 1)));

        on(registry.byId("filterTimeTextBox" + (i + 1)), "change", lang.hitch(this, function(e) {
          this._filterDateChanged("filterDateTextBox" + (i + 1), "filterTimeTextBox" + (i + 1), e);
        }));

      },
      
      _buildFilters : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_buildFilters");

        if(!dom.byId('filterColumnCombo1')) {

          for(var i = 0; i < this._defaultNumberOfFilters; i++) {
            this._buildFilter(i);
          }

          if(!this.filterFilterButton) {
            this.filterFilterButton = new Button({
              label : NLS.action.filter,
              showLabel : true,
              layoutAlign : "right",
              disabled : true
            });
            this.filterClearButton = new Button({
              label : NLS.action.clear,
              showLabel : true,
              layoutAlign : "right",
              disabled : true
            });
            this.filterCancelButton = new Button({
              label : NLS.action.cancel,
              showLabel : true,
              layoutAlign : "right",
              disabled : false
            });
            var filterButtonsDiv = dom.byId("filterButtons_ID");
            filterButtonsDiv.appendChild(this.filterFilterButton.domNode);
            filterButtonsDiv.appendChild(this.filterClearButton.domNode);
            filterButtonsDiv.appendChild(this.filterCancelButton.domNode);
            on(this.filterFilterButton, "click", lang.hitch(this, this._submitFilter));
            on(this.filterClearButton, "click", lang.hitch(this, this._clearFilter));
            on(this.filterCancelButton, "click", lang.hitch(this, function() {
              // Close the Customisation dialog
              this.toolbar.getButton("filter").closeDropDown();
            }));
          }

          on(query('.filterDialogButton_subtractDisabled, .filterDialogButton_subtract, .filterDialogButton_add'), "click", lang.hitch(this, this._manageFilters));
        }

        var filterDialogDiv = dom.byId("filterDialog_ID");
        connect.connect(filterDialogDiv, "onkeydown", this, this._filterKeyPresses);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_buildFilters");
      },

      _filterComboChanged : function(id) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_filterComboChanged");

        var value = "";
        if (registry.byId(id).item) {
          value = registry.byId(id).item.id;
        }
        var comboStore;
        switch(value) {
          case "hasBitstream":
            query('#filterDialog_Field' + id.substr(id.length - 1)).replaceClass("_common_hideDiv", "filterDialogField");
            query('#filterDialog_Date' + id.substr(id.length - 1)).replaceClass("_common_hideDiv", "filterDialogDate");
            query('#filterDialog_Time' + id.substr(id.length - 1)).replaceClass("_common_hideDiv", "filterDialogTime");
            query('#filterDialog_Blank' + id.substr(id.length - 1)).replaceClass("filterDialogBlank", "_common_hideDiv");
            comboStore = new Memory({
              data : {"items": [
                {"name": NLS.filterWithBitstream,"value": true},
                {"name": NLS.filterWithoutBitstream, "value": false}
              ]}
            });
            registry.byId("filterModeCombo" + id.substr(id.length - 1)).store = comboStore;
            registry.byId("filterModeCombo" + id.substr(id.length - 1)).set("value", NLS.filterWithBitstream);
            this.filterFilterButton.set("disabled", false);
            this.filterClearButton.set("disabled", false);
            break;
          case "hasException":
            query('#filterDialog_Field' + id.substr(id.length - 1)).replaceClass("_common_hideDiv", "filterDialogField");
            query('#filterDialog_Date' + id.substr(id.length - 1)).replaceClass("_common_hideDiv", "filterDialogDate");
            query('#filterDialog_Time' + id.substr(id.length - 1)).replaceClass("_common_hideDiv", "filterDialogTime");
            query('#filterDialog_Blank' + id.substr(id.length - 1)).replaceClass("filterDialogBlank", "_common_hideDiv");
            comboStore = new Memory({
              data : {"items": [
                {"name": NLS.filterWithExceptions, "value": true},
                {"name": NLS.filterWithoutExceptions, "value": false}
              ]}
            });
            registry.byId("filterModeCombo" + id.substr(id.length - 1)).store = comboStore;
            registry.byId("filterModeCombo" + id.substr(id.length - 1)).set("value", NLS.filterWithExceptions);
            this.filterFilterButton.set("disabled", false);
            this.filterClearButton.set("disabled", false);
            break;
          case "eventTimestamp":
            query('#filterDialog_Field' + id.substr(id.length - 1)).replaceClass("_common_hideDiv", "filterDialogField");
            query('#filterDialog_Date' + id.substr(id.length - 1)).replaceClass("filterDialogDate", "_common_hideDiv");
            query('#filterDialog_Time' + id.substr(id.length - 1)).replaceClass("filterDialogTime", "_common_hideDiv");
            query('#filterDialog_Blank' + id.substr(id.length - 1)).replaceClass("_common_hideDiv", "filterDialogBlank");
            comboStore = new Memory({
              data : {"items": [
                {"name": NLS.filterEventTimestampFrom, "value": "eventTimestampFrom"},
                {"name": NLS.filterEventTimestampTo, "value": "eventTimestampTo"}
              ]}
            });
            registry.byId("filterModeCombo" + id.substr(id.length - 1)).store = comboStore;
            registry.byId("filterModeCombo" + id.substr(id.length - 1)).set("value", NLS.filterEventTimestampFrom);
            registry.byId("filterDateTextBox" + id.substr(id.length - 1)).set("value", null);
            registry.byId("filterTimeTextBox" + id.substr(id.length - 1)).set("value", null);

            if((registry.byId("filterDateTextBox" + id.substr(id.length - 1)).displayedValue === "") || (registry.byId("filterTimeTextBox" + id.substr(id.length - 1)).displayedValue === "")) {
              this.filterFilterButton.set("disabled", true);
              this.filterClearButton.set("disabled", true);
            } else {
              this.filterFilterButton.set("disabled", false);
              this.filterClearButton.set("disabled", false);
            }
            break;
          default:
            query('#filterDialog_Field' + id.substr(id.length - 1)).replaceClass("filterDialogField", "_common_hideDiv");
            query('#filterDialog_Date' + id.substr(id.length - 1)).replaceClass("_common_hideDiv", "filterDialogDate");
            query('#filterDialog_Time' + id.substr(id.length - 1)).replaceClass("_common_hideDiv", "filterDialogTime");
            query('#filterDialog_Blank' + id.substr(id.length - 1)).replaceClass("_common_hideDiv", "filterDialogBlank");
            comboStore = new Memory({
              data : {"items": [
                {"id": "contains", "name": NLS.filterContains,"value": "contains"},
                {"id": "startsWith", "name": NLS.filterStartsWith, "value": "startsWith"},
                {"id": "endsWith", "name": NLS.filterEndsWith, "value": "endsWith"},
                {"id": "matches", "name": NLS.filterMatches, "value": "matches"}
              ]}
            });
            registry.byId("filterModeCombo" + id.substr(id.length - 1)).store = comboStore;
            registry.byId("filterModeCombo" + id.substr(id.length - 1)).set("value", NLS.filterContains);

            if(registry.byId("filterTextBox" + id.substr(id.length - 1)).value === "") {
              this.filterFilterButton.set("disabled", true);
              this.filterClearButton.set("disabled", true);
            } else {
              this.filterFilterButton.set("disabled", false);
              this.filterClearButton.set("disabled", false);
            }
            break;
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_filterComboChanged");
      },

      _filterDateChanged : function(dateId, timeId) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_filterDateChanged");

        if((registry.byId(dateId).state !== "Error") && (registry.byId(timeId).state !== "Error") && (registry.byId(dateId).displayedValue !== "") && (registry.byId(timeId).displayedValue !== "")) {
          this.filterClearButton.set("disabled", false);
          this.filterFilterButton.set("disabled", false);
        } else {
          this.filterFilterButton.set("disabled", true);
          this.filterClearButton.set("disabled", true);
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_filterDateChanged");
      },

      _filterTextChanged : function(value) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_filterDateChanged");

        if(value === "") {
          this.filterFilterButton.set("disabled", true);
          this.filterClearButton.set("disabled", true);
        } else {
          this.filterFilterButton.set("disabled", false);
          this.filterClearButton.set("disabled", false);
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_filterDateChanged");
      },

      _filterKeyPresses : function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_filterKeyPresses");

        switch(event.keyCode) {
          case keys.ENTER:
            this._submitFilter();
            break;
        }

        if(
          (event.target.value === NLS.filterWithBitstream)||
          (event.target.value === NLS.filterWithoutBitstream)||
          (event.target.value === NLS.filterWithExceptions)||
          (event.target.value === NLS.filterWithoutExceptions)
        ){
          this.filterFilterButton.set("disabled", false);
          this.filterClearButton.set("disabled", false);
        } else if(
          (event.target.value === "") ||
          (event.target.id.indexOf('filterMode') === "0") ||
          (event.target.id.indexOf('filterColumn') === "0")
        ){
          this.filterFilterButton.set("disabled", true);
          this.filterClearButton.set("disabled", true);
        } else {
          this.filterFilterButton.set("disabled", false);
          this.filterClearButton.set("disabled", false);
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_filterKeyPresses");
      },

      _populateFilterCombo : function(i) {
        var items = [];
        array.forEach(this._grid.layout.cells, lang.hitch(this, function(object) {
          if(!object._props.hidden) {
            switch(object._props.field) {
              case "msgKey":
              case "SELECTED":
                break;
              default:
                // some accessors for these items use value, some use id
                // see defect 45595
                items.push({
                  "name"  : object._props.name,
                  "value" : object._props.field,
                  "id"    : object._props.field
                });
            }
          }
        }));
        var comboItems = {"items" : items};
        var comboButton = registry.byId("filterColumnCombo" + (i + 1));

        var comboStore = new Memory({
          data : comboItems
        });
        comboButton.store = comboStore;
      },
      
      _populateFilterCombos : function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_populateFilterCombos");

        if(dom.byId('filterColumnCombo1')) {
          // Create and populate the three filter column comboboxes for the filter dialog
          for(var i = 0; i < this._defaultNumberOfFilters; i++) {
            this._populateFilterCombo(i);
          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_populateFilterCombos");
      },

      _manageFilters : function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_manageFilters");

        if(event.target.id.indexOf("Add") !== -1) {
          // Add Button
          if(this._numberOfFilters < this._defaultNumberOfFilters) {
            domClass.remove("filterDialog_Row" + (this._numberOfFilters + 1), "_common_hideDiv");
            domClass.replace("filterDialog_Subtract1", "filterDialogButton_subtract", "filterDialogButton_subtractDisabled");
            domAttr.set(dom.byId("filterDialog_Subtract1"), "title", NLS.filterSubtractRow);
            domClass.replace("filterDialog_Add" + (this._numberOfFilters), "filterDialogButton_addDisabled", "filterDialogButton_add");
            domAttr.set(dom.byId("filterDialog_Add" + (this._numberOfFilters)), "title", "");
            this._numberOfFilters++;
          }
        } else {
          // Subtract Button
          if(this._numberOfFilters > 1) {
            // Before deleting populate an array with values of each combo/field
            this.filterArray = [];
            var i;
            for( i = 0; i < this._numberOfFilters; i++) {
              if(registry.byId("filterColumnCombo" + (i + 1)).get("value") !== null) {
                this.filterArray.push(registry.byId("filterColumnCombo" + (i + 1)).get("value"));
              } else {
                this.filterArray.push("");
              }
              if(registry.byId("filterModeCombo" + (i + 1)).get("value") !== null) {
                this.filterArray.push(registry.byId("filterModeCombo" + (i + 1)).get("value"));
              } else {
                this.filterArray.push("");
              }
              if(registry.byId("filterTextBox" + (i + 1)).get("value") !== null) {
                this.filterArray.push(registry.byId("filterTextBox" + (i + 1)).get("value"));
              } else {
                this.filterArray.push("");
              }
            }

            // Re-populate the remaining combos/fields with the values in the array
            for( i = 0; i < this._numberOfFilters; i++) {
              if((event.target.id.substr(event.target.id.length - 1)) === (i + 1)) {
                this.filterArray.shift();
                this.filterArray.shift();
                this.filterArray.shift();
              }

              registry.byId("filterColumnCombo" + (i + 1)).set("value", this.filterArray.shift());
              registry.byId("filterModeCombo" + (i + 1)).set("value", this.filterArray.shift());
              registry.byId("filterTextBox" + (i + 1)).set("value", this.filterArray.shift());

              if(this._numberOfFilters === (i + 1)) {
                registry.byId("filterColumnCombo" + (i + 1)).set("value", "");
                registry.byId("filterModeCombo" + (i + 1)).set("value", "");
                registry.byId("filterTextBox" + (i + 1)).set("value", "");
              }
            }
            domClass.add("filterDialog_Row" + (this._numberOfFilters), "_common_hideDiv");
            domClass.replace("filterDialog_Add" + (this._numberOfFilters - 1), "filterDialogButton_add", "filterDialogButton_addDisabled");
            domAttr.set(dom.byId("filterDialog_Add" + (this._numberOfFilters - 1)), "title", NLS.filterAddRow);
            this._numberOfFilters--;

            if(this._numberOfFilters === 1) {
              domClass.replace("filterDialog_Subtract1", "filterDialogButton_subtractDisabled", "filterDialogButton_subtract");
              domAttr.set(dom.byId("filterDialog_Subtract1"), "title", "");
            }
          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_manageFilters");
      },

      _submitFilter : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_submitFilter");

        this.toolbar.getButton("filter").closeDropDown();
        this._filterstr = "";
        var i;
        var value;
        for(i = 0; i < this._defaultNumberOfFilters; i++) {
          var columnCombo = registry.byId("filterColumnCombo" + (i + 1));
          var modeCombo   = registry.byId("filterModeCombo" + (i + 1));
          var textBox     = registry.byId("filterTextBox" + (i + 1));
          var dateTextBox = registry.byId("filterDateTextBox" + (i + 1));
          var timeTextBox = registry.byId("filterTimeTextBox" + (i + 1));
          if((columnCombo.value)) {
            //Rather convoluted way to get back the key of the selected dropdown
            //the internet suggests it is a quirk of the dojo ComboBox though, so not sure we can fix it
            var name = columnCombo.store.query({"name":columnCombo.value})[0].id;
            switch(modeCombo.value) {
              case NLS.filterContains:
                value = this._escapeChars(textBox.value);
                break;
              case NLS.filterStartsWith:
                value = "\"" + this._escapeChars(textBox.value) + "*\"";
                break;
              case NLS.filterEndsWith:
                value = "\"*" + this._escapeChars(textBox.value) + "\"";
                break;
              case NLS.filterMatches:
                value = "\"" + this._escapeChars(textBox.value) + "\"";
                break;
              case NLS.filterWithBitstream:
              case NLS.filterWithoutBitstream:
              case NLS.filterWithExceptions:
              case NLS.filterWithoutExceptions:
                var selectedItem = modeCombo.store.query({name:modeCombo.value})[0];
                value = selectedItem.value;
                break;
              case NLS.filterEventTimestampFrom:
                name = "eventTimestampFrom";
                value = dateTextBox.displayedValue + " " + timeTextBox.displayedValue;
                if (this.showAsLocalTime === true) {
                  value = this.convertToUTC(value);
                }
                break;
              case NLS.filterEventTimestampTo:
                name = "eventTimestampTo";
                value = dateTextBox.displayedValue + " " + timeTextBox.displayedValue;
                if (this.showAsLocalTime === true) {
                  value = this.convertToUTC(value);
                }
                break;
            }
            this._filterstr = this._filterstr + "&" + name + "=" + value;
          }
        }
        this._currentPageNumber = 1;
        this._updateGrid();
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_submitFilter");
      },

      _clearFilter: function(noConfirm) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_clearFilter");

        if(dom.byId('filterColumnCombo1')) {
          if(noConfirm){
            var i;
            for(i = 0; i < this._numberOfFilters; i++) {
              registry.byId("filterColumnCombo" + (i + 1)).set("value", "");
              registry.byId("filterModeCombo" + (i + 1)).set("value", "");
              registry.byId("filterTextBox" + (i + 1)).set("value", "");
              registry.byId("filterTimeTextBox" + (i + 1)).set("value", null);
              registry.byId("filterDateTextBox" + (i + 1)).set("value", null);

              if(i<2){
                domClass.replace("filterDialog_Row" + (i + 2), "_common_hideDiv", "filterDialogDate");
                domClass.replace("filterDialog_Time" + (i + 2), "_common_hideDiv", "filterDialogTime");
                domClass.replace("filterDialog_Blank" + (i + 2), "_common_hideDiv", "filterDialogBlank");
              }
            }

            domClass.add("filterDialog_Row2", "_common_hideDiv");
            domClass.add("filterDialog_Row3", "_common_hideDiv");
            domClass.replace("filterDialog_Add1", "filterDialogButton_add", "filterDialogButton_addDisabled");
            domClass.replace("filterDialog_Subtract1", "filterDialogButton_subtractDisabled", "filterDialogButton_subtract");

            this._numberOfFilters = 1;
            // Don't clear the filter unless it's actually changed!
            if (this._filterstr !== "") {
              this._filterstr = "";
              this._updateGrid();
              // make the filter options update themselves
              this._populateFilterCombos();
            }
          } else {
            this.toolbar.getButton("filter").closeDropDown();
            var question = registry.byId("confirmationDialogQuestion");
            if(question === undefined) {
              question = new ConfirmationDialog({
                id : "confirmationDialogQuestion",
                info : NLS.filterConfirmationText,
                text : NLS.filterClearFilter,
                buttonLabel : NLS.action.clear,
                type : "question"
              }, "confirmationQuestion");
            }
            question.confirm(lang.hitch(this, function() {
              var i;
              for(i = 0; i < this._numberOfFilters; i++) {
                registry.byId("filterColumnCombo" + (i + 1)).set("value", "");
                registry.byId("filterModeCombo" + (i + 1)).set("value", "");
                registry.byId("filterTextBox" + (i + 1)).set("value", "");
                registry.byId("filterTimeTextBox" + (i + 1)).set("value", null);
                registry.byId("filterDateTextBox" + (i + 1)).set("value", null);

                domClass.replace("filterDialog_Row" + (i + 2), "_common_hideDiv", "filterDialogDate");
                domClass.replace("filterDialog_Time" + (i + 2), "_common_hideDiv", "filterDialogTime");
                domClass.replace("filterDialog_Blank" + (i + 2), "_common_hideDiv", "filterDialogBlank");
              }
              domClass.add("filterDialog_Row2", "_common_hideDiv");
              domClass.add("filterDialog_Row3", "_common_hideDiv");
              domClass.replace("filterDialog_Add1", "filterDialogButton_add", "filterDialogButton_addDisabled");
              domClass.replace("filterDialog_Subtract1", "filterDialogButton_subtractDisabled", "filterDialogButton_subtract");

              this._numberOfFilters = 1;
              this._filterstr = "";
              this._updateGrid();
            }));
          }
        }


        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_clearFilter");
      },

      tabRemove: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
      },

      tabFocus: function () {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");
        this._loadDataViewer();
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
      },

      tabBlur: function () {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
      }

    });
    return dataviewer;
  }
);

},
'webui/widgets/msgflows/msgflow_overview':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="3356849190" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/msgflows/templates/msgflow_overview.html",
  "dojo/i18n!webui/nls/web",

  "dojo/_base/array",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/dom-construct",
  "dojo/hash",
  "dojo/keys",
  "dojo/on",
  "dojo/query",
  "dojo/request/xhr",
  "dojo/string",
  "dojo/topic",

  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase",
  "dijit/_WidgetsInTemplateMixin",
  "dijit/registry",
  
  "idx/widget/ConfirmationDialog",

  "webui/config/Resources",
  "webui/widgets/common/AttributesStore",
  "webui/widgets/common/HasContextMenu",
  "webui/widgets/common/PropertiesStore",
  "webui/widgets/common/QuickAndAdvancedProperties",
  "webui/widgets/common/Toolbar",
  "webui/widgets/common/Trace",
  "webui/widgets/common/UIUtils",
  "webui/widgets/msgflows/MessageFlowPropertiesEditor"
], function(
  template,
  NLS,
  array,
  declare,
  lang,
  domAttr,
  domConstruct,
  hash,
  keys,
  on,
  query,
  xhr,
  string,
  Topic,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  registry,
  ConfirmationDialog,
  Resources,
  AttributesStore,
  HasContextMenu,
  PropertiesStore,
  QuickAndAdvancedProperties,
  Toolbar,
  Trace,
  UIUtils,
  MessageFlowPropertiesEditor
) {
    var msgflowsOverview = declare("webui.widgets.msgflows.msgflow_overview", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
      templateString: template,
      toolbar: null,
      _propertiesStore: new PropertiesStore(),
      _attributesStore : new AttributesStore(),            
      _objectURI: "",
      _adminHandlers: [],
      _doesUserHaveWritePermission: false,

      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
        this.inherited(arguments);

        // Create toolbar
        this.toolbar = new Toolbar();
        domConstruct.place(this.toolbar.domNode, this._toolbar);
        this.toolbar.addLeftAlignButtons("title");

        // Add Edit button to the right side of the toolbar if the user has write permission:
        this._doesUserHaveWritePermission = window.currentuser.userPermission("broker", "write");
        if (this._doesUserHaveWritePermission) {
          var buttons = ["edit"];
          this.toolbar.addRightAlignButtons(buttons);
          this.toolbar.addRightAlignButtons("spacer");
          // Add an event handler for the Edit button:
          this.toolbar.connectButtons("edit", "click", this, "_onEditClick");
          // set enabled, disabled status once we got the properties
        }
		
        this.properties = new QuickAndAdvancedProperties("messageFlow");
        this.properties.createPropertiesContainer(this._propertyTitlePane);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
      },
      
      toggleEditButton: function(enable) {
        if (this.toolbar.getButton("edit")) {        
          if (enable && this._doesUserHaveWritePermission) {
            this.toolbar.getButton("edit").set("disabled", false);
            this.toolbar.getButton("edit").set('iconClass', "infoPaneButton_edit");
          } else {
              this.toolbar.getButton("edit").set("disabled", true);
              this.toolbar.getButton("edit").set('iconClass', "infoPaneButton_editDisabled");
          }
        }
      },

      startup: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "startup");
        this.inherited(arguments);

        // Get msgflow name and add to the toolbar title
        this.toolbar.setAttribute("title", "innerHTML", "");

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "startup");
      },
      
      // Hides the read-only view of the properties:
      _hideReadOnlyProperties: function() {
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_hideReadOnlyProperties");
      	this._msgflowOverview_borderContainer.style.display = "none";

      	this._toolbar.style.display = "none";
      	this._propertyTitlePane.style.display = "none";
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_hideReadOnlyProperties");
      },
      
      // Checks whether the properties editor is open:
      _isPropertyEditorOpen: function() {
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_isPropertyEditorOpen");
      	var returnValue = this.propertiesEditor !== null && this.propertiesEditor !== undefined;
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_isPropertyEditorOpen");
      	return returnValue;
      },
      
      // Destroys the properties editor if one exists and removes the associated listeners.
      // Called when the user saves or cancels the properties editor, or when the user
      // navigates away from the editor:
      _destroypropertiesEditor: function() {
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_destroypropertiesEditor");
       
      	//Remove listeners:
      	if (this.editorUpdatedSubscription !== undefined && this.editorUpdatedSubscription !== null) {
      		this.editorUpdatedSubscription.remove();
      	}
      	
      	if (this.editorCancelSubscription !== undefined && this.editorCancelSubscription !== null) {
      		this.editorCancelSubscription.remove();
      	}
       
       	//Destroy the properties editor widget if it exists:
      	if (this._isPropertyEditorOpen()) {
      		this.propertiesEditor.destroy();
      		this.propertiesEditor = null;
      	}
        
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_destroypropertiesEditor");
      },
      
      // Shows the read-only view of the properties:
      _showReadOnlyProperties: function() {
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showReadOnlyProperties");
      	this._msgflowOverview_borderContainer.style.display = "";
      	this._toolbar.style.display = "";
      	this._propertyTitlePane.style.display = "";
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showReadOnlyProperties");
      },
      
  	  // Called when the user clicks the Edit button:
      _onEditClick: function() {
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onEditClick");

      	//Hide the existing read-only properties pane and associated title and toolbar:
      	this._hideReadOnlyProperties();
        
      	//Show the properties editor:
      	if (!this._isPropertyEditorOpen()) {
      		this.propertiesEditor = new MessageFlowPropertiesEditor({
      			mode: 'edit',
      			hash: hash()
      		});
          
      		//Subscribe to the properties editor's update event:
      		this.editorUpdatedSubscription = Topic.subscribe(Resources.pubSubTopic.messageFlowPropertiesUpdated, lang.hitch(this, function() {
      			// Destroy editor:
      			this._destroypropertiesEditor();
          
      			// Re-populate the properties because the read-only properties will be out of date after the update:
      			this.properties.populateProperties();
            
      			// Re-show the read-only properties pane and associated title and toolbar if hidden:
      			this._showReadOnlyProperties();
      		}));
          
      		// Subscribe to the properties editor's cancel event:
      		this.editorCancelSubscription = Topic.subscribe(Resources.pubSubTopic.messageFlowPropertiesEditCancelled, lang.hitch(this, function() {
      			// If the editor is not dirty, just proceed with the cancel:
      			if (this._isPropertyEditorOpen() && !this.propertiesEditor.isDirty()) {
      				// Destroy editor:
      				this._destroypropertiesEditor();
          	
      				//Re-show the read-only properties pane and associated title and toolbar if hidden:
      				this._showReadOnlyProperties();
  	  	    
      				return;
      			}
            
      			//Create the confirmation dialog if it does not already exist:
      			var messageFlowEditConfirmCancelDialog = registry.byId("messageFlowEditConfirmCancelDialog");
      			if (typeof messageFlowEditConfirmCancelDialog === 'undefined') {
      				messageFlowEditConfirmCancelDialog = new ConfirmationDialog({
      					type : "information",
      					buttonLabel : NLS.btLeaveSave,
      					cancelButtonLabel : NLS.btStayOnPage,
      					closeButtonLabel : NLS.btStayOnPage,
      					text : NLS.messages.PropertiesUpdate_ConfirmNavigateAwayFromEditorConfirmationMessage
      				}, "messageFlowEditConfirmCancelDialog");
      			}
            
      			//Callback handler for when the user clicks 'confirm' on the dialog:
      			messageFlowEditConfirmCancelDialog.confirm(lang.hitch(this, function() {
      				// Destroy editor:
      				this._destroypropertiesEditor();
          	
      				// Re-show the read-only properties pane and associated title and toolbar if hidden:
      				this._showReadOnlyProperties();
      			}));
            
      			// Callback handler for when the user clicks 'cancel' on the dialog:
      			messageFlowEditConfirmCancelDialog.onCancel = lang.hitch(this, function() {
      				messageFlowEditConfirmCancelDialog.hide();
      			});
            
      			// Keyboard handler for dialog
      			on(messageFlowEditConfirmCancelDialog, "keydown", lang.hitch(this, function (event){
      				// Move the focus accordingly if the arrow keys are pressed
      				var key = event.keyCode;
      				if ((key == keys.LEFT_ARROW) && messageFlowEditConfirmCancelDialog.closeAction.focused) {
      					messageFlowEditConfirmCancelDialog.confirmAction.focus();
      				} 
      				else if ((key == keys.RIGHT_ARROW) && messageFlowEditConfirmCancelDialog.confirmAction.focused){
      					messageFlowEditConfirmCancelDialog.closeAction.focusNode.focus();
      				}
      				
      				//Extend confirm/close function to close on Enter key press
      				if (key == keys.ENTER) {
      					if(messageFlowEditConfirmCancelDialog.confirmAction.focused) {
      						messageFlowEditConfirmCancelDialog.hide();
               
      						//Destroy editor:
      						this._destroypropertiesEditor();
          	
      						// Re-show the read-only properties pane and associated title and toolbar if hidden:
      						this._showReadOnlyProperties();
      					} else {
      						if(messageFlowEditConfirmCancelDialog.closeAction.focused) {
      							messageFlowEditConfirmCancelDialog.onCancel();
      						}
      					}
      				} 
      				
      				// Stop the keyboard event propagating i.e. moving a flow on the canvas
      				event.stopPropagation();
      			}));
            
      			//Open the dialog and ask the user if they are sure that they want to cancel:
      			messageFlowEditConfirmCancelDialog.show();
      		}));
          
      		this.propertiesEditor.placeAt(this._messageFlowEditEditor);
      		this.propertiesEditor.startup();
      	}
        
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onEditClick");
      },

      tabSelected: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabSelected");

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabSelected");
      },

      tabFocus : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");

        // If we switch back to the overview tab, attempt to reload the properties
        var populate = this._attributesStore.populateAttributesStore();
        populate.then(lang.hitch(this, function() {
          domAttr.set("_infoPaneTitleID", "innerHTML", this._attributesStore.getAttribute("name") + " - " + NLS.msgflowTitle);
          this._objectURI = this._attributesStore.getAttribute("uri");
          var enable = this._attributesStore.getAttribute("isRunning");
          this.toggleEditButton(enable);
        }));

        // Populate quick view and advanced properties
        this.properties.populateProperties();

        UIUtils.setupAdminHandlers(this._adminHandlers, lang.hitch(this, this.processAdminHandlers));

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
       },

      resize: function() {
        this._msgflowOverview_borderContainer.resize();
      },

      // This function is called manually when we need to remove this tab.
      tabRemove: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");

        // Destroy the properties editor if it exists:
        this._destroypropertiesEditor();
        
        // Re-show the read-only properties pane and associated title and toolbar if hidden:
        this._showReadOnlyProperties();
        
        this.properties.unsubscribeAll();

        if(this.propertiesEditor) {
          this.propertiesEditor.uninitialize();
        }
        UIUtils.removeAdminHandlers(this._adminHandlers);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
      },

      /*
       * Listen for admin notification
       * If the notification is about this object, reread the properties, in particular the running state
       * and update the state of the buttons
       */
      processAdminHandlers: function (message) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "processAdminHandlers");
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Received admin notification for "+message.destinationName);
        UIUtils.processAdminHandlers (message, this._objectURI, this._attributesStore, "isRunning", lang.hitch(this, this.toggleEditButton));      
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "processAdminHandlers");

      },

      contextButtonsClicks : function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks");

        // Get the URI and action from the event:
        var uriAndAction = UIUtils.getURIAndAction(event, true);
        var itemURI = uriAndAction.uri;
        var buttonType = uriAndAction.action;

        if( (buttonType === "start")|| (buttonType === "stop") || (buttonType === "delete") || (buttonType === "startFlowMonitoring") || (buttonType === "stopFlowMonitoring") ){
          this.actionFlow(itemURI, buttonType);
        }
        else if (buttonType === "disableTestRecordMode") {
            var confirmDisableTestRecordModeCallback = lang.hitch(this, function() {
    	        // User wants to disable record mode:
    	        this.actionFlow(itemURI, buttonType);
    	    });
    	      
    	    // Ask the user to confirm the stopping of record mode before proceeding:
    	    window.wmbConsole.showConfirmationDialog("confirmDisableTestRecordModeOnMessageFlow", "question", NLS.configurableserviceYesLabel, NLS.configurableserviceNoLabel, NLS.messages.MessageFlowStopRecording_confirmation, confirmDisableTestRecordModeCallback, null);
          
        } else if(buttonType === "stopWithRestartExecutionGroup") {
          var verifyStopWithEGRestart = registry.byId("confirmationStopFlowRestartEGDialogQuestion");
          if( verifyStopWithEGRestart === undefined) {
            verifyStopWithEGRestart = new ConfirmationDialog({
              id : "confirmationStopFlowRestartEGDialogQuestion",
              info : NLS.messages.StopFlowRestartEGInfo,
              text : NLS.messages.StopFlowRestartEGConfirmation,
              buttonLabel : NLS.confirmAction,
              type : "warning",
              nocheck : true
            });
          }

          verifyStopWithEGRestart.confirm(lang.hitch(this, function() {
            this.actionFlow(itemURI, buttonType);
          }));
        } else if((buttonType === "attachPolicy") || (buttonType === "detachPolicy")) {
          this.actionPolicy(itemURI, buttonType);
        } else {
          this.actionStats(itemURI, buttonType);
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
      },

      actionFlow : function(uri, action){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionFlow");


        var uriArray = uri.split("_");
        var buttonType = uriArray[uriArray.length - 1];
        uri = uri.substr(0,uri.length - buttonType.length - 1);

        var tree;
        if (null!=action && action === "delete" ) {

          tree = registry.byId('_explorerTree_ID');
          var flowName = tree.selectedNode.item.name;//label can be truncated, so use name instead
            
          var confirmationMessage = string.substitute(NLS.messages.DeleteFlowAction_confirmation, [flowName] );
            
	        var confirmCallback = lang.hitch(this, function() {

	          //	Add loading icon to tree
	          var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
	          var oldIcon = domAttr.get(treeImgs[0],"class");
	          domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");        	

	          // REST Call to delete the flow
	          xhr.del(
	            uri,
	            {
	              handleAs : "json",
	              headers : {
	                "Accept" : "application/json"
                }
              }
            ).then( lang.hitch(this, function() {
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Flow delete success");
	
              //reset old icon
              domAttr.set(treeImgs[0],"class",oldIcon);

              // Display success message for deleting a flow
              window.smallMessage.displayPlainMessage("success", "DeleteFlowAction_successFlowDeleted", [flowName]);
            }), lang.hitch(this, function(error) {
	            	
              Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrDel to " + uri + " failed.", [error]);

              //reset old icon
              domAttr.set(treeImgs[0],"class",oldIcon);

              //show error message
              var response = JSON.parse(error.response.text);
              window.smallMessage.displayMessage("error", "flowdelete_5XX",response.bipNumber, response.description);
	              
            }));
	        });

	        window.wmbConsole.showConfirmationDialog("btConfirmDelete", "question", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, confirmationMessage, confirmCallback, null);
        }//if
        else {
        	
          //	Add loading icon to tree
          tree = registry.byId('_explorerTree_ID');
          var treeNodeID = tree.selectedNode.id;//store this for the call to this.buttonState()
          var treeImgs = query('#' + treeNodeID + ' .dijitTreeIcon');
          var oldIcon = domAttr.get(treeImgs[0],"class");
          domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");        	

        	//
        	// not delete action
        	//
          xhr.put(
            uri + "?action=" + action,
            {
              handleAs:"json",
              headers : {
                "Accept" : "application/json"
              }
            }
          ).response.then(
            lang.hitch(this, function(response){
              Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionFlow.xhrLoad()",[response]);
              
              this._buttonState(action, uri, treeNodeID);//old icon reset in here

              var flowName = tree.selectedNode.item.name;//label can be truncated, so use name instead
              if (action === "startFlowMonitoring") {
  	            window.smallMessage.displayPlainMessage("success", "FlowMonitoringStartedSuccessfully_Flow", [flowName]);
              } else if (action === "stopFlowMonitoring") {
            	window.smallMessage.displayPlainMessage("success", "FlowMonitoringStoppedSuccessfully_Flow", [flowName]);
              }  else if (action === "disableTestRecordMode") {
            	window.smallMessage.displayPlainMessage("success", "MessageFlowStopRecording_success", [flowName]);
              }
              
              Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionFlow.xhrLoad()");
            }),
            lang.hitch(this,function(error){
              Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionFlow.xhrError()",[error]);

              Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrPut to " + uri + " failed.", [error]);
              //reset old icon
              domAttr.set(treeImgs[0],"class",oldIcon);
              //show error message
              var response = JSON.parse(error.response.text);
              //by default description text is just a response description
              var descText = response.description;
              if(action === "start")
              {
                //if response contains log entries we want to dsiplay all the log entries in the details to ensure that
                //we provide the same level of information as we do in the CL or Toolkit
                if(response != null && response.logEntries != null)
                {
                  //reset description text
                  descText = "";
                  var i = 0;
                  for (i=0;i<response.logEntries.length;i++)
                  {
                    //for each entry get the log entry value
                    var logEntryText = response.logEntries[i].value;
                    if (logEntryText != null)
                    {
                      if (i ==0) 
                      {
                        //For the first log entry just write it
                        descText += logEntryText;
                      }
                      else
                      {
                        //For every entry other than the first one add a line break
                        descText += "<br>" + logEntryText;
                      }
                    }
                  }
                }
                //populate the description text with the details if the details are available from the log entries
                window.smallMessage.displayMessage("error", "msgflowstart_5XX",response.bipNumber, descText);
		      } else if (action === "stop") {
                window.smallMessage.displayMessage("error", "msgflowstop_5XX",response.bipNumber, descText);
              } else if (action === "startFlowMonitoring") {
                window.smallMessage.displayMessage("error", "FlowMonitoringFailedToStart");
              } else if (action === "stopFlowMonitoring") {
                window.smallMessage.displayMessage("error", "FlowMonitoringFailedToStop");
              }
              Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionFlow.xhrError()");
            })
          );
        }//endif - ( not delete action )

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionFlow");
      },

      actionPolicy : function(uri, action) {
    	  
		var tree = registry.byId('_explorerTree_ID');	
        var treeNodeID = tree.selectedNode.id;//store this for the call to this.buttonState()
    	  
        // Calculate the URI for the flow's properties
        var uriArray = uri.split("_");
        var buttonType = uriArray[uriArray.length - 1];
        uri = uri.substr(0,uri.length - buttonType.length - 1);

        if(action === "detachPolicy") {
          var flowPropertiesObject = {
            "advancedProperties" : [
              {"name" : "wlmPolicy", "value" : ""}
            ]
          };

          var uriTarget = uri +"/properties";

          var attachedPolicy;
          var populateAdvancedPropertiesStore = this._propertiesStore.populatePropertiesStore(uri);
          populateAdvancedPropertiesStore.then(lang.hitch(this, function() {
            var attachedPolicyObject = this._propertiesStore.getProperty("advanced", "wlmPolicy");
            if(attachedPolicyObject !== undefined && attachedPolicyObject !== '') {
              attachedPolicy = attachedPolicyObject;
            }
            xhr.put(
              uriTarget,
              {
                handleAs : "json",
                headers : {
                  "Accept" : "application/json",
                  "Content-type" : "application/json"
                },
                data : JSON.stringify(flowPropertiesObject)
              }
            ).response.then(
              lang.hitch(this, function() {
                if(attachedPolicy !== undefined) {
                  window.smallMessage.displayMessage("success", "policyattach_successDetach", null, NLS.messages.policyattach_successDetach+", '"+attachedPolicy+"'");
                } else {
                  window.smallMessage.displayMessage("success", "policyattach_successDetach");
                }
  
                this._buttonState(action, uri, treeNodeID);
  
                var uriPath = uri;
                var newHash = "messageFlow/2" + uriPath.substr(Resources.REST.root.length);
                if(hash() === newHash) {
                  //As we are currently viewing the policies tab, refresh the infopane
                  var newEvent = { "type":"messageFlow" };
                  window.wmbConsole.createInfoPane(newEvent, true, "2");
                }
              }),
              lang.hitch(this, function(error) {
                Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.xhr.status + " Response: " + error.response.xhr.response);
  
                var response = JSON.parse(error.response.text);
                window.smallMessage.displayMessage("error", "policyattach_5XX", response.bipNumber, response.description);
              })
            );
          }));
        } else {
          var uriPath = uri;
          var newHash = "messageFlow/2" + uriPath.substr(Resources.REST.root.length);
          if(hash() !== newHash) {
            window.wmbConsole.safelyChangeHash(newHash);
            var newEvent = { "type":"messageFlow" };
            window.wmbConsole.createInfoPane(newEvent, true, "2");
          }
        }
      },

      actionStats : function(uri, action){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionStats");

        var obj = {};
        obj.snapshotStatistics = {};
        if(action === "statsOn"){
          obj.snapshotStatistics.enabled = true;
          obj.snapshotStatistics.nodeLevel = "basic";
          obj.snapshotStatistics.threadLevel = "basic";
          obj.snapshotStatistics.outputFormat = {};
          obj.snapshotStatistics.outputFormat.json = true;
        } else {
          obj.snapshotStatistics.enabled = false;
        }

        //  Add loading icon to tree
        var tree = registry.byId('_explorerTree_ID');
        var treeNodeID = tree.selectedNode.id;//store this for the call to this.buttonState()
        var treeImgs = query('#' + treeNodeID + ' .dijitTreeIcon');
        var oldIcon = domAttr.get(treeImgs[0],"class");
        domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");

        // Calulate the URI for the flow's properties
        var uriArray = uri.split("_");
        var buttonType = uriArray[uriArray.length - 1];
        uri = uri.substr(0,uri.length - buttonType.length - 1);

        xhr.put(
          uri,
          {
            handleAs:"json",
            data: JSON.stringify(obj),
            headers : {
              "Accept" : "application/json",
              "Content-type" : "application/json"
            }
          }
        ).response.then(
          lang.hitch(this, function(response){
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionStats.xhrLoad()",[response]);

            this._buttonState(action, uri, treeNodeID);

            if(action === "statsOn"){
              window.smallMessage.displayMessage("success", "FlowStatsAction_successstatsOn");
            } else {
              window.smallMessage.displayMessage("success", "FlowStatsAction_successstatsOff");
            }

            Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionStats.xhrLoad()");
          }),
          lang.hitch(this,function(error){
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionStats.xhrError()",[error]);

            Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrPut to " + uri + " failed.", [error]);
            //reset old icon
            domAttr.set(treeImgs[0],"class",oldIcon);
            //show error message
            var response = JSON.parse(error.response.text);
            if(action === "statsOn"){
              window.smallMessage.displayMessage("error", "FlowStatsAction_failurestatsOn",response.bipNumber, response.description);
            } else {
              window.smallMessage.displayMessage("error", "FlowStatsAction_failurestatsOff",response.bipNumber, response.description);
            }

            Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionStats.xhrError()");
          })
        );

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionStats");
      },

      _buttonState: function(action, uri, treeNodeID){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_buttonState", [action, uri]);

        // Disable and enable the relevant buttons
        var treeImgs = query('#' + treeNodeID + ' .dijitTreeIcon');

        var populateAttributesStore = this._attributesStore.populateAttributesStore(uri);
        var populatePropertiesStore = this._propertiesStore.populatePropertiesStore(uri);

        populatePropertiesStore.then(lang.hitch(this, function() {
          populateAttributesStore.then(lang.hitch(this, function() {
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_buttonState.then", [action, uri]);
            // Get the flow's running status
            var running = (this._propertiesStore.getProperty("basic", "isRunning") === "true");
            var isInTestRecordMode = (this._propertiesStore.getProperty("basic", "testRecordMode") === "Enabled");
            var name = this._attributesStore.getAttribute("name");

            // Get the flow's stats status
            var statsActive = this._attributesStore.getAttribute("snapshotStatistics").enabled;
            var outputFormat = this._attributesStore.getAttribute("snapshotStatistics").outputFormat;
            var statsOn = statsActive && outputFormat.json;

            // Get the flow's policy attachment status
            var attachedPolicy;
            var attachedPolicyObject = this._propertiesStore.getProperty("advanced", "wlmPolicy");
            if(attachedPolicyObject !== undefined && attachedPolicyObject !== '') {
              attachedPolicy = true;
            } else {
              attachedPolicy = false;
            }
            
            // Get the flow's flow monitoring status
            var flowMonitoringActive = this._attributesStore.getAttribute("flowMonitoringActive");

            // Set the TreeNode icon as appropriate
            if (running) {
              if (isInTestRecordMode) {
            	domAttr.set(treeImgs[0], "class", "dijitInline dijitIcon dijitTreeIcon explorer_messageFlow_running_testRecordMode");
              }
              else {
                domAttr.set(treeImgs[0], "class", "dijitInline dijitIcon dijitTreeIcon explorer_messageFlow_running");
              }
            } else {
              domAttr.set(treeImgs[0], "class", "dijitInline dijitIcon dijitTreeIcon explorer_messageFlow_stopped");
            }
            
            // Same for context menu
            this._updateContextMenuTitle(uri, name, "messageFlow", running);

            //Now show/hide the appropriate start/stop stats on/off buttons, but greying out as appropriate
            //Again iterating over all viewable buttons to find the ones which we have just changed
            array.forEach(this._getContextButtons(uri), function(button) {
              var tmp = button.id.split("_");
              var buttonType = tmp[tmp.length - 1];
              var thisButtonUri = button.id.substring(0,button.id.length - (buttonType.length+1));

              if( thisButtonUri === uri){
                switch(buttonType){
                case "start":
                  button.set("disabled", running);
                  break;
                case "stop":
                case "stopWithRestartExecutionGroup":
                  button.set("disabled", !running);
                  break;
                case "disableTestRecordMode":
                  button.set("disabled", !isInTestRecordMode);
                  break;
                case "statsOn":
                  button.set("disabled", statsOn);
                  break;
                case "statsOff":
                  button.set("disabled", !statsOn);
                  break;
                case "attachPolicy":
                  button.set("disabled", attachedPolicy);
                  break;
                case "detachPolicy":
                  button.set("disabled", !attachedPolicy);
                  break;
                case "startFlowMonitoring":
                  button.set("disabled", !flowMonitoringActive);
                  break;
                case "stopFlowMonitoring":
                  button.set("disabled", flowMonitoringActive);
                  break;
                }
              }
            }, this);
            Trace.trace(this.declaredClass, Trace.levels.EXIT, "_buttonState.then");
          }));
        }));
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_buttonState");
      },

      tabBlur: function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
      }

    });
   return msgflowsOverview;
  }
);

},
'webui/widgets/common/CurrentUser':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="361174968" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/i18n!webui/nls/web",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/on",
  "dojo/request/xhr",
  "dijit/registry",
  "dijit/_WidgetBase",
  "idx/widget/ConfirmationDialog",
  "webui/config/Resources",
  "webui/widgets/common/Trace"
], function(
  NLS,
  declare,
  lang,
  on,
  xhr,
  registry,
  _WidgetBase,
  ConfirmationDialog,
  Resources,
  Trace
){
  /**
   * This object represents the current user and all of their permissions to
   * do things. We consult with this object in order to know whether to show or
   * hide certain buttons allowing the user to do certain things. Of course, the
   * REST API itself is the actual gatekeeper if the user uses a REST client to
   * actually try to do these things in the absence of the web UI.
   *
   * This object has to be loaded asynchronously before WMBConsole does.
   * This object is also passed into the IDX Header widget, so it has some
   * attributes which the Header uses.
   *
   * Only one CurrentUser object should exist in the web UI.
   */
  return declare("webui.widgets.common.CurrentUser", [_WidgetBase], {

    property_userID: "",
    property_name: "",
    _permissionsUri: "",
    _currentUserPermissions: null,

    /** For idx.app.Header */
    actions: null,

    /** For idx.app.Header */
    displayName: function(){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "displayName");

      if(!this.property_name){
        this.property_name = this.property_userID;
      }

      var nameStr = this.property_userID ? NLS.headerUserWelcome + this.property_name : "";

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "displayName", [nameStr]);
      return nameStr;
    },

    /**
     * Returns a promise which completes once all the user's permissions
     * have been asynchronously recovered from the REST API. This function should
     * only be called once.
     */
    _populateCalled: false,
    populate: function() {

      if(this._populateCalled) {
        throw new Error("CurrentUser.populate() should only be called once");
      }
      this._populateCalled = true;

      return xhr(
        encodeURI(Resources.currentUser.url),
        {
          "handleAs":"json",
          "headers":{
            "Accept":"application/json"
          }
        }
      ).then(

        /**
         * Load the permissions
         */
        lang.hitch(this, function(response){
          this.property_userID = response.username;
          this.property_name = response.name;
          this._permissionsUri = response.permissionsUri;
          return this.populatePermissions();
        }),

        /**
         * Catastrophe, REST API is absent, log user out again
         */
        lang.hitch(this,function(error){
          Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhr.get from " + Resources.currentUser.url + " failed.",[error]);
          var errorDialog = registry.byId("errorDialog");
          if (!errorDialog) {
            errorDialog = new ConfirmationDialog({
              id : "errorDialog",
              type : "error",
              buttonLabel : NLS.headerLogOut,
              text : NLS.messages.NoPermissions,
              confirm : false,
              check : false
            }, "errorDialog");
          }
          errorDialog.show();
          errorDialog.closeAction.destroy();
          //errorDialog.checkbox.destroy();
          on(errorDialog.confirmAction,"click",function(){
            window.location = Resources.logout.url;
          });
          return false;
        })
      );
    },

    /** Public */
    populatePermissions: function(){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "populatePermissions");

      if(!this._permissionsUri) {
        throw new Error("Permissions URI not set for current user");
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "populatePermissions");
      return xhr(
        encodeURI(this._permissionsUri),
        {
          "handleAs":"json",
          "headers":{
            "Accept":"application/json"
          }
        }
      ).then(
        lang.hitch(this, function(response){
          this._currentUserPermissions = response;
          return true;
        }),
        lang.hitch(this,function(error){
          Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhr.get from " + this._permissionsUri + " failed.",[error]);
          return false;
        })
      );
    },

    /**
     * Find out whether the current user has permission to access a certain item
     * in a certain way. This is synchronous.
     * If a user permission does not exist, we fail safe and return `false`.
     */
    userPermission : function(
      itemName, // "broker", "datacapture", "eg.<egName>", ...
      accessType // "read", "write", "execute"
    ){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "userPermission", arguments);

      if(!this._currentUserPermissions) {
        throw new Error("Current user permissions have not been populated yet");
      }

      var item = this._currentUserPermissions.object.filter(function(item) {
        return item.name === itemName;
      })[0];

      if(!item) {
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "User permissions for {0} not found.", [itemName]);
        return false; // Fail safe
      }

      // This only happens if our code is broken
      if(accessType !== "read" && accessType !== "write" && accessType !== "execute") {
        throw new Error("Unrecognised accessType '" + accessType + "'");
      }

      if(!(accessType in item)) {
        console.error("Access type '" + accessType + "' not found.");
        return false; // Fail safe
      }

      var result = item[accessType];

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "userPermission", [result]);
      return result;
    }
  });
});

},
'webui/widgets/business/AddFlowDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 *
 * 
 * AddFlowDialog widget - Dialog for adding flows to a business transaction definition.
 * 
 */
define(
  "webui/widgets/business/AddFlowDialog",
  [
    "dojo/text!webui/widgets/business/templates/AddFlowDialog.html", 
    "dojo/i18n!webui/nls/web", 
    "dojo/_base/declare", 
    "dijit/Dialog",
    "webui/config/Resources",
    "dijit/_TemplatedMixin", 
    "dijit/_WidgetsInTemplateMixin",
    "webui/widgets/common/Trace", 
    "dojo/dom",
    "dojo/dom-attr",
    "dojo/hash",
    "dojo/keys",
    "dojo/_base/event",
    "dojo/on",
    "dojo/_base/lang",
    "dojo/dom-class",
    "dojo/dom-construct",
    "webui/widgets/business/FlowFilter",
    "dojo/string",
    "dojo/topic",
    
    // For the HTML template only
    "dijit/form/RadioButton",
    "dijit/layout/ContentPane",
    "dijit/form/Button"
  ], 
  function( 
    template, 
    NLS, 
    declare,
    Dialog,
    Resources,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    Trace,
    dom,
    attr,
    hash,
    keys,
    event,
    on,
    lang,
    domClass,
    construct,
    FlowFilter,
    string,
    Topic    
  ) {

  var addFlowDialog = declare("webui.widgets.business.AddFlowDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
    
    templateString : template,
    btNew : true,
    _btOKLabel:NLS.btAddFlowAction,
    _btCancelLabel: NLS.btAddFlowClose,
    _buttonCancel: NLS.btAddFlowClose,
    
    _btdFlowSelectionLabel: NLS.btSelectFlow,
    _btdAppSelectionLabel: NLS.btAppSelection,
    _btdServiceSelectionLabel: NLS.btServiceSelection,
    _btdRestApiSelectionLabel: NLS.btRestApiSelection,
    
    _messageFlowContentId : "messageFlowContent",
    _appMessageFlowContentId : "appMessageFlowContent",
    _serviceMessageFlowContentId : "serviceMessageFlowContent",
    _restApiMessageFlowContentId : "restApiMessageFlowContent",

    //filter widget for flows
    flowFilter :null,
    
    //filter widget for apps
    appFilter: null,
    
    //filter widget for integration services
    serviceFilter: null,
    
    //filter widget for REST APIs
    restApiFilter: null,
    
    // list of flows deployed on the broker
    flows : null,
    
    // list of applications deployed on the broker
    apps: null,
    
    // list of integrations services deployed on the broker (first class artifact)
    services: null,
    
    // list of REST APIs deployed on the broker (first class artifact)
    restApis: null,
    
    // Default message flow selection
    currentSelection: Resources.businessTransaction.btAddFlow, 

    _onKey : function(evt) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onKey");
      this.inherited(arguments);
      if (evt.charOrCode) {
        if (evt.charOrCode === keys.ENTER) {
          if ( !this._okButton.get("disabled" ) ) {
            event.stop(evt);
            this.onExecute();
          }
        }
      }
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onKey");
    },

    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);
      
      // On completing the add task
      on(this, "execute", lang.hitch(this, function() {      
        var flowUri;
        var results;
        var i;
        // Determine behaviour based on selection
        switch(this.currentSelection) {
          // Single flow to add
          case Resources.businessTransaction.btAddFlow:
            var item = this.flowFilter.getSelectedItem();
            if(item) {
              flowUri = item.id;
              results = this.flowFilter.queryStore({ id: flowUri });
              if(results.length > 0) {
                try {
                  // for the Editor
                  Topic.publish(Resources.pubSubTopic.businessTransactionFlowAdd, {"id": flowUri, "selected": true, "callingHash": hash()}); 
                  this.flowFilter.removeFlow(results[0]);  
                  this.flows = this.flowFilter.getResources();  
                } catch(exc) {
                  Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Add message flow Error: " + exc);                   
                }              
              }
            }
            break;
            
          case Resources.businessTransaction.btAddApp:
            // Add all new flows from the app - verify there are flows to add
            if(this.appFilter && this.appFilter.newFlows && lang.isArray(this.appFilter.newFlows)) {
              // Add one at a time
              for (i=0; i<this.appFilter.newFlows.length; i++) {
                flowUri = this.appFilter.newFlows[i].uri;
                results = this.flowFilter.queryStore({ id: flowUri });
                if(results.length > 0) {
                  try {
                    Topic.publish(Resources.pubSubTopic.businessTransactionFlowAdd, {"id": flowUri, "selected": false, "callingHash": hash()});
                    this.flowFilter.removeFlow(results[0]);
                    // As flows from an app have been added, so ensure they no longer appear in flows list
                    this.flows = this.flowFilter.getResources();  
                  } catch(exc) {
                    Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Add message flow Error: " + exc);
                  }
                }
              }  
              // Force a deselect 
              this.btEditor.deselectHandler(true);
              Topic.publish(Resources.pubSubTopic.businessTransaction, {"none":true, "callingHash": hash()});        
            }
            
            break;
          
          case Resources.businessTransaction.btAddService:
            // Add all new flows from the service (should only be one) - verify there are flows to add
            if(this.serviceFilter && this.serviceFilter.newFlows && lang.isArray(this.serviceFilter.newFlows)) {
              for(i=0; i<this.serviceFilter.newFlows.length; i++) {
                flowUri = this.serviceFilter.newFlows[i].uri;
                // Not in flow filter store so do direct publish to add
                try {
                  Topic.publish(Resources.pubSubTopic.businessTransactionFlowAdd, {"id": flowUri, "selected": true, "callingHash": hash()});
                } catch(exc) {
                  Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Add message flow Error: " + exc);
                }
              }        
            }
            break;
            
          case Resources.businessTransaction.btAddRestApi:
            // Add all new flows from the rest api (should only be one) - verify there are flows to add
            if(this.restApiFilter && this.restApiFilter.newFlows && lang.isArray(this.restApiFilter.newFlows)) {
              for(i=0; i<this.restApiFilter.newFlows.length; i++) {
                flowUri = this.restApiFilter.newFlows[i].uri;
                // Not in flow filter store so do direct publish to add
                try {
                  Topic.publish(Resources.pubSubTopic.businessTransactionFlowAdd, {"id": flowUri, "selected": true, "callingHash": hash()});
                } catch(exc) {
                  Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Add message flow Error: " + exc);
                }
              }        
            }
            break;
        }
        this.closeDialog();
      }));
      
      on(this._cancelButton, "click", lang.hitch(this, function() {
        this.closeDialog();       
      }));
      
      // Setup radio button interactions
      // If flows selected, but none specified don't allow to add
      on(this._flowsRadioButton, 'change', lang.hitch(this, function(value) {
        if(value) {
          this.currentSelection = Resources.businessTransaction.btAddFlow;
          this.setFlowsToAddValues(this.flowFilter);
        }
      }));

      // If apps selected, but none specified don't allow to add
      on(this._appsRadioButton, 'change', lang.hitch(this, function(value) {
        if(value) {
          this.currentSelection = Resources.businessTransaction.btAddApp;
          this.setFlowsToAddValues(this.appFilter);
        }
      }));
      
      // If services selected, but none specified don't allow to add
      on(this._servicesRadioButton, 'change', lang.hitch(this, function(value) {
        if(value) {
          this.currentSelection = Resources.businessTransaction.btAddService;
          this.setFlowsToAddValues(this.serviceFilter);
        }
      }));
      
      // If rest apis selected, but none specified don't allow to add
      on(this._restApisRadioButton, 'change', lang.hitch(this, function(value) {
        if(value) {
          this.currentSelection = Resources.businessTransaction.btAddRestApi;
          this.setFlowsToAddValues(this.restApiFilter);
        }
      }));
        
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },
        
    setInitialValues: function(args) {
      if (args.flows){
        this.flows = args.flows;        
      }         
      if (args.apps){
        this.apps = args.apps;        
      }
      if (args.services){
        this.services = args.services;        
      }
      if (args.restApis){
        this.restApis = args.restApis;        
      }
      if (args.btEditor){
        this.btEditor = args.btEditor;
        this.btModel = args.btEditor.btModel;
        this.btName = this.btEditor.btModel.btName;        
        attr.set(this.titleNode, "innerHTML", string.substitute(NLS.btAddFlowTitle, [this.btName]));  
      }
      if (!args.initialised) {
        this.updateRadioButtonClass(false);
      }
    },
    
    // Update based upon current selections (radio and dropdown)
    setFlowsToAddValues: function(filter) {
      
      var selectedFilterItem = null;
      var flowsToAdd = true;
      
      switch(this.currentSelection) {
        case Resources.businessTransaction.btAddFlow:
          selectedFilterItem = filter.getSelectedItem();
          break;
          
        default:
          selectedFilterItem = filter.filteringSelect.item;
          flowsToAdd = (typeof filter.newFlows !== "undefined") && (filter.newFlows.length > 0);
          break;
      }
      
      if(selectedFilterItem == null) {
        filter.removeFlowsAddedContent();
        this._okButton.setDisabled(true);
      } else {
        // Check whether the current value has any flows to add, if not then ensure ok button is disabled and update flows added message
        filter.constructFlowsToAdd();
        if(flowsToAdd) {
          this._okButton.setDisabled(false);
        } else {
          this._okButton.setDisabled(true);
        }
      }
      
    },
    
    resetOKButton : function() {
      this._okButton.setDisabled(true);              
    },
    
    resetRadioButtons: function(type) {
      switch(type) {
        case Resources.businessTransaction.btAddFlow:
          if(!this._flowsRadioButton.get('checked')) {
            this._flowsRadioButton.set('checked', true);
          } else {
            // Force a redraw of adding message flows - as selection change was made
            this.setFlowsToAddValues(this.flowFilter);
          }

          break;
          
        case Resources.businessTransaction.btAddApp:
          if(!this._appsRadioButton.get('checked')) {
            this._appsRadioButton.set('checked', true);
          } else {
            this.setFlowsToAddValues(this.appFilter);
          }

          break;
        
        case Resources.businessTransaction.btAddService:
          if(!this._servicesRadioButton.get('checked')) {
            this._servicesRadioButton.set('checked', true);
          } else {
            this.setFlowsToAddValues(this.serviceFilter);
          }

          break;
          
        case Resources.businessTransaction.btAddRestApi:
          if(!this._restApisRadioButton.get('checked')) {
            this._restApisRadioButton.set('checked', true);
          } else {
            this.setFlowsToAddValues(this.restApiFilter);
          }

          break;
      }
    },
    
    // Used to control radio input elements visibility, incase add flow dialog is requested before entire oneui styling and iamges have been returned.
    updateRadioButtonClass: function(addClass) {
      var className = "dijitCheckBoxInput";
      var flowRadio = dom.byId("bt_flows");
      var appRadio = dom.byId("bt_apps");
      var servicesRadio = dom.byId("bt_services");
      var restRadio = dom.byId("bt_restApis");
      
      if(addClass) {
        if(flowRadio) {
          domClass.add(flowRadio, className);
        }
        if(appRadio) {
          domClass.add(appRadio, className);
        }
        if(servicesRadio) {
          domClass.add(servicesRadio, className);
        }
        if(restRadio) {
          domClass.add(restRadio, className);
        }
      } else {
        if(flowRadio) {
          domClass.remove(flowRadio, className);
        }
        if(appRadio) {
          domClass.remove(appRadio, className);
        }
        if(servicesRadio) {
          domClass.remove(servicesRadio, className);
        }
        if(restRadio) {
          domClass.remove(restRadio, className);
        }
      }
    },
    
    refresh : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "refresh");

      // Do not allow add until a flow/app has been selected
      this._okButton.setDisabled(true);
      
      // Message Flow dropdown 
      var moreDiv = dom.byId(this._messageFlowContentId);
      if (moreDiv){
        construct.empty(this._messageFlowContentId);
        this.flowFilter = new FlowFilter({
         name: this.btName,
         parentId: this._messageFlowContentId,
         selectType: Resources.businessTransaction.btAddFlow,
         parent: this,
         resources: this.flows
        });
        this.flowFilter.refreshStore(this._messageFlowContentId);  
      }
      
      // Applications dropdown
      moreDiv = dom.byId(this._appMessageFlowContentId);
      if(moreDiv){
        construct.empty(this._appMessageFlowContentId);
        this.appFilter = new FlowFilter({
          name: this.btName,
          parentId: this._appMessageFlowContentId,
          selectType: Resources.businessTransaction.btAddApp,
          parent: this,
          btModel: this.btModel,
          resources: this.apps
        });
        this.appFilter.refreshStore(this._appMessageFlowContentId);
      }
      
      // Services dropdown
      moreDiv = dom.byId(this._serviceMessageFlowContentId);
      if(moreDiv){
        construct.empty(this._serviceMessageFlowContentId);
        this.serviceFilter = new FlowFilter({
          name: this.btName,
          parentId: this._serviceMessageFlowContentId,
          selectType: Resources.businessTransaction.btAddService,
          parent: this,
          btModel: this.btModel,
          resources: this.services
        });
        this.serviceFilter.refreshStore(this._serviceMessageFlowContentId);
      }

      // Rest APIs dropdown
      moreDiv = dom.byId(this._restApiMessageFlowContentId);
      if(moreDiv){
        construct.empty(this._restApiMessageFlowContentId);
        this.restApiFilter = new FlowFilter({
          name: this.btName,
          parentId: this._restApiMessageFlowContentId,
          selectType: Resources.businessTransaction.btAddRestApi,
          parent: this,
          btModel: this.btModel,
          resources: this.restApis
        });
        this.restApiFilter.refreshStore(this._restApiMessageFlowContentId);
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "refresh");
    },
    
    // Called to refresh the dropdowns for when the dialog is currently showing, only stores need to be updated and refreshed.
    refreshWhilstShowing: function(args) {
      if (args.flows){
        this.flows = args.flows;
        if(this.flowFilter) {
          this.flowFilter.updateAndRefresh(this.flows, this._messageFlowContentId);
        }
      }         
      if (args.apps){
        this.apps = args.apps;
        if(this.appFilter) {
          this.appFilter.updateAndRefresh(this.apps, this._appMessageFlowContentId);
        }
      }
      if (args.services){
        this.services = args.services;
        if(this.serviceFilter) {
          this.serviceFilter.updateAndRefresh(this.services, this._serviceMessageFlowContentId);
        }
      }
      if (args.restApis){
        this.restApis = args.restApis;
        if(this.restApiFilter) {
          this.restApiFilter.updateAndRefresh(this.restApis, this._restApiMessageFlowContentId);
        }
      }
    },
    
    closeDialog: function() {
      this.hide();
      dijit.hideTooltip("btFlowFilter");
      if (this.flowFilter) {
        this.flowFilter.destroy();  
      }       
      if (this.appFilter) {
        this.appFilter.destroy();  
      }
      if (this.serviceFilter) {
        this.serviceFilter.destroy();  
      }
      if (this.restApiFilter) {
        this.restApiFilter.destroy();  
      }
      this.currentSelection = Resources.businessTransaction.btAddFlow;
      this.resetRadioButtons(this.currentSelection);
    }
  });

  return addFlowDialog;
});

},
'webui/widgets/common/wsHandler':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="609566550" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/i18n!webui/nls/web",
  "dojo/_base/array",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom",
  "dojo/dom-attr",
  "dojo/dom-class",
  "dojo/dom-construct",
  "dojo/dom-style",
  "dojo/on",
  "dojo/query",
  "dojo/request/xhr",
  "dojo/topic",
  "dijit/_WidgetBase",
  "dijit/registry",
  "webui/config/Resources",
  "webui/widgets/common/Trace"
], function(
  NLS,
  array,
  declare,
  lang,
  dom,
  domAttr,
  domClass,
  domConstruct,
  domStyle,
  on,
  query,
  xhr,
  topic,
  _WidgetBase,
  registry,
  Resources,
  Trace
) {
    var wsHandler = declare("webui.widgets.common.wsHandler", [_WidgetBase], {

      _client: null,
      _connected: false,
      _topicSubUnsubQueue: null,
      _mqttConnection: null,
      _subscriptionList: null,
      _reconnectVariable: null,
      
      constructor : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");
        
        if(!window.WebSocket) {
          return;
        }

        this._subscriptionList = [];
        
        // This queue stores subscription and unsubscription requests
        this._topicSubUnsubQueue = [];
              
        // Create client object
        this._client = new Messaging.Client(window.location.hostname, parseInt(window.location.port), this._createUniqueID());
        this._client.onMessageArrived = lang.hitch(this, this._publishMessage);
        this._client.onMessageDelivered = lang.hitch(this, this._messageDelivered);
        this._client.onConnectionLost = lang.hitch(this, this._connectionLost);
        this._client.onFailure        = lang.hitch(this, this._connectionFailure);
              
        this._mqttConnection = {
          // Use secure web socket if using https
          "useSSL" : window.location.protocol == "https:",

          // On success callback
          "onSuccess" : lang.hitch(this, function() {
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor._mqttConnection.onSuccess()");
            
            Trace.trace(this.declaredClass, Trace.levels.INFO, "Connection success");
            // Update icon in header
            var selectedNodeWithActiveMenu = query('.realtimeDisconnected');
            array.forEach(selectedNodeWithActiveMenu, function(node){
              domClass.replace(node, "realtimeConnected", "realtimeDisconnected");
              domAttr.set(node.children[0].children[0], "title", NLS.realtimeConnected);
              domAttr.set(node.children[0].children[0], "alt", NLS.realtimeConnected);
            });
            
            window.clearInterval(this._reconnectVariable);
            this._connected = true;
            
            // remove the div containing the not connected message if present 
            var mainDiv = dom.byId("_explorerBorderContainer_ID");
            if (mainDiv && this.connectionLostDiv) {
              domStyle.set( this.connectionLostDiv, {
                display: 'none'
              });
              try {
                mainDiv.removeChild(this.connectionLostDiv);
              } catch (Exception) {}
            }
            mainDiv.setAttribute("title", "");    
            domClass.remove("_explorerBorderContainer_ID", "mainDivDisconnected");
            if (this.errorHandle) {
              this.errorHandle.remove();
            }
            
            var i = 0;
            for (i=0; i < this._subscriptionList.length; i++) {
              var topicName = this._subscriptionList[i];
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Resubscribing to " + topicName);
              this._client.subscribe(topicName);
            }
            
            this._subUnsub(); // Find any existing sub requests, process them now
            Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor._mqttConnection.onSuccess()");
          }),

          /**
           * An attempt to make a WebSocket connection can fail for several reasons.
           * One is that the server is down. Another is that the server returned a 401
           * error. In the case of the former we would like to ignore the failure and
           * try again repeatedly until the server comes back up again. In the case of
           * the latter, we need to prompt the user to log in again somehow.
           * 
           * Unfortunately, the WebSockets specification provides no mechanism for
           * clients to access this error or differentiate between the two. (Some
           * browsers manifest the 401 error as a prompt to the user for a username and
           * password, but most do not and this behaviour is unlikely to change.)
           * 
           * So, what we do instead is make an ordinary HTTP request to the server.
           * If the server is not present, nothing happens. If it *is* present and a
           * 401 comes back, a Basic Authentication prompt comes up, after which
           * everything goes back to normal.
           */
          "onFailure" : function() {
            xhr(
              Resources.REST.root,
              {
                "handleAs" : "json",
                "headers" : {
                  "Accept" : "application/json"
                }
              }
            );
          }
        };

        // Attempt to make the connection
        this._client.connect(this._mqttConnection);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
      },
      
      /**
       * Call this function to make the web socket subscribe via MQTT
       * to the named topic.
       */
      subscribe: function(topicName) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "subscribe", [topicName]);
        
        // Add the topicName to the _topicSubUnsubQueue
        this._topicSubUnsubQueue.push({"command" : "subscribe", "topicName" : topicName});
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Subscription request to " + topicName + " added to the queue");
        if(this._connected){
          this._subUnsub(); 
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "subscribe");
      },

      /**
       * Call this function to make the web socket unsubscribe via MQTT
       * from the named topic.
       */
      // Listen for any requests from widgets to unsubscribe
      unsubscribe: function(topicName) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "unsubscribe", [topicName]);
        
        // Add the topicName to the topicSubUnsubQueue
        this._topicSubUnsubQueue.push({"command" : "unsubscribe", "topicName" : topicName});
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Unsubscribing from " + topicName);
        if(this._connected){
          this._subUnsub(); 
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "unsubscribe");
      },

      _reconnect: function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_reconnect");
        Trace.trace(this.declaredClass, Trace.levels.INFO, "Attempting to reconnect...");                
        this._client.connect(this._mqttConnection);
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_reconnect");
      }, 
      
      _connectionLost: function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_connectionLost");
        Trace.trace(this.declaredClass, Trace.levels.ERROR, "Connection lost");
        // Update icon in header
        var selectedNodeWithActiveMenu = query('.realtimeConnected');
        array.forEach(selectedNodeWithActiveMenu, function(node){
          domClass.replace(node, "realtimeDisconnected", "realtimeConnected");
          domAttr.set(node.children[0].children[0], "title", NLS.realtimeDisconnected);
          domAttr.set(node.children[0].children[0], "alt", NLS.realtimeDisconnected);
        });
        // Attempt to re-establish the connection after 5000 milliseconds
        this._reconnectVariable = setInterval(lang.hitch(this, this._reconnect), 5000);
        
        this._showConnectionFailure();        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_connectionLost");
      },
        
      _showConnectionFailure: function () {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showConnectionFailure");
        var mainDiv = dom.byId("header");
        
        if (mainDiv){
          this.connectionLostDiv = domConstruct.create("div",{
            "class": "disconnectDiv",
            "id": "connectionLostDiv",
            
            "innerHTML": '<div class="disconnectMessage"> '+NLS.realtimeDisconnected+'</div>'
          });
          mainDiv.setAttribute("title", NLS.realtimeDisconnectedDescription);
          mainDiv.insertBefore(this.connectionLostDiv, mainDiv.firstChild);
          domStyle.set( this.connectionLostDiv, {
            display: 'block'
          });
          
          this.connectionLostDiv.onclick = function() {
            //capturing events
          };
          
          this.errorHandle = on(registry.byId("_explorerBorderContainer_ID"), "Click", 
            function() { // capturing events
            }
          );
          domClass.add("_explorerBorderContainer_ID", "mainDivDisconnected");
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showConnectionFailure");
      }, 
        
      _connectionFailure: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_connectionFailure");
        Trace.trace(this.declaredClass, Trace.levels.ERROR, "Connection failure");
        // Update icon in header
        var selectedNodeWithActiveMenu = query('.realtimeConnected');
        array.forEach(selectedNodeWithActiveMenu, function(node){
          domClass.replace(node, "realtimeDisconnected", "realtimeConnected");
          domAttr.set(node.children[0].children[0], "title", NLS.realtimeDisconnected);
          domAttr.set(node.children[0].children[0], "alt", NLS.realtimeDisconnected);
        });
        // Attempt to re-establish the connection after 5000 milliseconds
        this._reconnectVariable = setInterval(lang.hitch(this, this._reconnect), 5000);
        this._showConnectionFailure();        
            
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_connectionFailure");
      },

      _subUnsub: function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_subUnsub");
            
        while(this._topicSubUnsubQueue.length > 0){
          var instruction = this._topicSubUnsubQueue.shift();

          var command = instruction.command;
          var actualTopic = instruction.topicName;

          if(command === "subscribe"){
            // Subscribe to the topic
            this._client.subscribe(actualTopic);
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Subscribed to " + actualTopic);
                    
            // Add to the subscription list
            this._subscriptionList.push(actualTopic);
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Subscription List is now " + this._subscriptionList);
          }
          
          else if(command === "unsubscribe") {
            // Remove from my subscription list
            var toRemoveIndex = this._subscriptionList.indexOf(actualTopic);
            if (toRemoveIndex != -1) {
              // Remove 1 entry from the array at the index specified
              this._subscriptionList.splice(toRemoveIndex,1);
            }
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Subscription List is now " + this._subscriptionList);
            
            this._client.unsubscribe(actualTopic);
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Unsubscribed to " + actualTopic);
          }
          
          else {
            throw new Error("Command '" + command + "' not recognised");
          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_subUnsub");
      },
        
      _messageDelivered: function(message) {
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Message delivered. Topic: " + message.destinationName + " Message: " + message.payloadString);
      },
      
      _publishMessage: function(message){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_publishMessage", [message.destinationName]);
   
        topic.publish(message.destinationName, message);

        // Allow for wild-cards by publishing to every wild-card permutation.
        // E.g if original destinationName is "AAA/BBB/CCC/DDD",
        // then also publish to
        // "#"
        // "AAA/#"
        // "AAA/BBB/#"
        // "AAA/BBB/CCC/#"
        // but NOT
        // "AAa/BBB/CCC/DDD/#"

        var topicArray = message.destinationName.split("/");
        // ["AAA", "BBB", "CCC", "DDD"]

        for(var i = 0; i < topicArray.length; i++) {
          var topicArray2 = topicArray.slice(0, i);

          topicArray2.push("#");

          var topicString = topicArray2.join("/");

          topic.publish(topicString, message); // `message` still contains the original destinationName
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_publishMessage");
      },
        
      _disconnect: function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_disconnect");
            
        this._client.disconnect();
        // Update icon in header
        var selectedNodeWithActiveMenu = query('.realtimeConnected');
        array.forEach(selectedNodeWithActiveMenu, function(node){
          domClass.replace(node, "realtimeDisconnected", "realtimeConnected");
          domAttr.set(node.children[0].children[0], "title", NLS.realtimeDisconnected);
          domAttr.set(node.children[0].children[0], "alt", NLS.realtimeDisconnected);
        });
            
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_disconnect");
      },
        
      _createUniqueID: function(){
        var dateObject = new Date();
        return "Client" + dateObject.getTime();
      }
    });
    return wsHandler;
  }
);

},
'webui/widgets/business/BTSource':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 *
 * Widget representing the source from the tree for a business transaction, typically a flow 
 */
define([
	"dojo/_base/array",    
	"dojo/_base/declare",
	"dojo/dnd/Manager",
	"dojo/dom-class",    
  "dojo/hash",		
  "dijit/tree/dndSource",
  "webui/widgets/common/Trace"
], function(
  array,
  declare,
  DNDManager,
  domClass,
  hash,
  TreeSource,
  Trace
) {
  var BTSource = declare("webui.widgets.business.BTSource", [TreeSource], {

		constructor: function(){
		  this.inherited(arguments);
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");
			this.copyOnly = true;	
			this.generateText = false;
			this.viewIndex =1;
			this.creator = true;
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
		},

		onDndStart: function(source){
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onDndStart");
			// source might be another dndSource, such as the one that
			// handles re-ordering columns in the data viewer.
			
  			if (source instanceof BTSource) {
    			var node = source.getSelectedTreeNodes()[0];
  				if (!this.canDrag(node)) {  				 
  					// do nothing for dragging apps, libraries etc.
  					// or if you are not supposed to be dragging
  					var m = DNDManager.manager();
  					
  					m.stopDrag = function() {
  					  // overwrite this to check for a null avatar
            	// summary:
              //    stop the DnD in progress
              domClass.remove(document.body, ["dojoDndCopy", "dojoDndMove"]);
              array.forEach(m.events, function(handle){ handle.remove(); });
              m.events = [];
              if (m.avatar) {
                m.avatar.destroy();
              }
              m.avatar = null;
              m.source = m.target = null;
              m.nodes = [];
            };
          	m.stopDrag();  				
  				}
  				else {
  					this.inherited(arguments);
  				}
  			}
  			else {
  				this.inherited(arguments);
  			}
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "onDndStart");
		},
		
		postCreate : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},
		
		checkAcceptance: function(){
			return false;
		},
		
    canDrag:function(node) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "canDrag");
      var result = false;
      if (node && node.item && (node.item.type !="messageFlow")) {
        return result;
      }
      var currentHash = hash();
      var i1 = currentHash.lastIndexOf("businesstransactions");
      var i2 = currentHash.indexOf("/0/");
      var l = "businesstransactions".length;
      var end = i1+l;
      if ((i1>0)&& // looking at business transactions
         ((i2>0) || // on the event configuration page
          (end ==currentHash.length))) // hash ends with businessTransactions after create new business transaction definition
      {
         result = true;
      }      
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "canDrag");
      return result;
    },
		
    checkItemAcceptance: function(){
			return false;
		}
		
	}); // end dojo declare
  return BTSource;
});

},
'webui/widgets/executiongroup/ExecutionGroupPropertiesEditor':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 */

/**
 * This widget represents a properties editor for integration node level properties.
 *
 * The widget has:
 * - A Save and Cancel button at the top right.
 * - A property table widget that allows the user to change the values.
 *
 * Most of the widget is internal (private). The only public method provided is the isDirty
 * method.
 */
define([
    "dojo/text!webui/widgets/executiongroup/templates/ExecutionGroupPropertiesEditor.html",
    "dojo/i18n!webui/nls/web",
    "dojo/_base/declare",
    "dijit/_WidgetBase",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/registry",
    "webui/widgets/common/Trace",
    "dojo/dom",
    "dojo/dom-construct",
    "dojo/store/Memory",
    "dojo/_base/lang",
    "dojo/request/xhr",
    "webui/config/Resources",
    "webui/widgets/common/AttributesStore",
    "webui/widgets/common/EditTextPropertyValueDialog",
    "webui/widgets/common/EditBooleanPropertyValueDialog",
    "webui/widgets/common/EditNumericPropertyValueDialog",
    "webui/widgets/common/Toolbar",
    "dojo/dom-attr",
    "dojo/topic",
    "dojo/query",
    "dojox/html/entities",
    "webui/widgets/common/UIUtils",

    // Grid X
    "gridx/Grid",
    "gridx/core/model/cache/Sync",
    "gridx/modules/select/Row",
    "gridx/modules/ColumnResizer",
    "gridx/modules/CellWidget",
    "gridx/modules/Edit"
  ],
  function(
    template,
    NLS,
    declare,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    registry,
    Trace,
    dom,
    construct,
    Memory,
    lang,
    xhr,
    Resources,
    AttributesStore,
    EditTextPropertyValueDialog,
    EditBooleanPropertyValueDialog,
    EditNumericPropertyValueDialog,
    Toolbar,
    attr,
    topic,
    query,
    HTMLEntities,
    UIUtils,

    // GridX
    Grid,
    Cache,
    SelectRow,
    ColumnResizer,
    CellWidget,
    Edit
    ) {
    var egPropertyEditor = declare("webui.widgets.executiongroup.ExecutionGroupPropertiesEditor", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
      templateString: template, // points js to the html template to use
      _egNameLabel: NLS.nameLabel,
      _egTypeLabel: NLS.typeLabel,
      _attributesStore : new AttributesStore(),

      /**
       * Constructor
       */
      constructor: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");
        this.inherited(arguments);
      	if (arguments.length > 0) {
      	  this._name = arguments[0].name;
      	  this._type = arguments[0].type;
      	}
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
      },


      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");

        // Call postCreate on _TemplatedMixin:
        this.inherited(arguments);

        this.propertyData = [];

        // Create the toolbar at the top of the UI:
        this.toolbar = new Toolbar();
        construct.place(this.toolbar.domNode, this._toolbar);
        this.toolbar.addLeftAlignButtons("title");

        // Add Save and Cancel button to the right side of the toolbar:
        var buttons = ["save", "cancel"];
     	  this.toolbar.addRightAlignButtons(buttons);
      	this.toolbar.addRightAlignButtons("spacer");
      	this.toolbar.getButton("save").set("disabled", true);
        this.toolbar.getButton("cancel").set("disabled", false);

        this._createPropertiesTable();

        // Add button event handlers:
        this.toolbar.connectButtons("save", "click", this, "_onSaveClick");
        this.toolbar.connectButtons("cancel", "click", this, "_onCancelClick");

      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
     },

     _propertyDisplayName: function(name){
       return NLS.executionGroup[name] || name;
     },

     _createPropertiesTable: function() {
    	 Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createPropertiesTable");

    	 // Define the properties table structure
         var propertiesTableStructure = [
           { id: 'id', field: 'displayName', name: NLS.nameLabel, width: '30%', editable: false},
           { id: 'value', field: 'value', name: NLS.valueLabel, width: '60%', editable: true,
             decorator: function(cellData) {
              // Encode value before showing it in the table to prevent code injection:
              return HTMLEntities.encode(cellData);
            }
           },
           { id: 'valueDialog', field: 'edit', name: '', width: '10%', widgetsInCell: true,
             decorator: function() {
               // Embed a button in the value column (label for screen reader also provided so more information can be provided other than just '...'):
               return "<div data-dojo-type='dijit.form.Button' type='button' data-dojo-attach-point='egEditValueButton' aria-label='" + NLS.editValueDialogButtonText + "'>...</div>";
             },
             getCellWidgetConnects: function(cellWidget, cell) {
               // Add a handler for when the embedded button is pressed:
               return [[
                 cellWidget.egEditValueButton,
                 'onClick',
                 function() {
                   var confirmCallback = lang.hitch(this, function() {
                     var propertyValue = editPropertyValueDialog.editPropertyValueArea.get("value");
                     
                     var propertyType = editPropertyValueDialog._dialogType();
                     if (propertyType === "boolean") {
                       if (propertyValue === "on") {
                         propertyValue = "true";
                       }
                       else if (propertyValue === "off"){
                         propertyValue = "false";
                       }
                     }
                     
                     // Set value from dialog into the table (need to begin and apply edit so an onApply event is fired):
                     editPropertyValueDialog.cell.beginEdit();
                     editPropertyValueDialog.cell.setRawData(propertyValue.toString()); // call toString() as property value could be a number
                     editPropertyValueDialog.cell.applyEdit();
                   });

                   var editPropertyValueDialog = registry.byId("editPropertyValueDialog");
                   // Clear any old dialog in case we need one of a different type
                   if (editPropertyValueDialog) {
                     editPropertyValueDialog.destroy();
                     editPropertyValueDialog = null;
                   }

                   var nameCell = cell.grid.cell(cell.row.id, "id");
                   var propName = nameCell.rawData();
                   var propertyType = cell.grid.model.store.get(propName).type;

                   if (propertyType === 'text') {
                     if (!editPropertyValueDialog) {
                       editPropertyValueDialog = new EditTextPropertyValueDialog({
                         id : "editPropertyValueDialog",
                         createCallback : confirmCallback
                       });
                       editPropertyValueDialog.startup();
                     }
                   } else if (propertyType === 'boolean') {
                     if (!editPropertyValueDialog) {
                       editPropertyValueDialog = new EditBooleanPropertyValueDialog({
                         id : "editPropertyValueDialog",
                         createCallback : confirmCallback
                       });
                       editPropertyValueDialog.startup();
                     }
                   } else if (propertyType === 'numeric') {
                     if (!editPropertyValueDialog) {
                       editPropertyValueDialog = new EditNumericPropertyValueDialog({
                         id : "editPropertyValueDialog",
                         createCallback : confirmCallback
                       });
                       editPropertyValueDialog.startup();
                     }
                   }

                   // Set appropriate values on the dialog and then open it:
                   attr.set(editPropertyValueDialog.titleNode, "innerHTML", NLS.editValueLabel);
                   var valueCell = cell.grid.cell(cell.row.id, "value");
                   editPropertyValueDialog.cell = valueCell; // pass in the value cell; needed above when setting the value in the table
                   editPropertyValueDialog.currentValue = valueCell.rawData(); // pass in the value text
                   editPropertyValueDialog.refresh();
                   editPropertyValueDialog.show();
                 }
               ]];
             }
           }
         ];

         // Create the store for the properties table:
         var egPropertiesTableStore = new Memory({data: [], idProperty: "id"});

         // Create the property table widget:
         this._propertiesTable = Grid({
             id: 'egPropertiesTable',
             cacheClass: Cache,
             store: egPropertiesTableStore,
             structure: propertiesTableStructure,
             autoHeight: true,
             modules: [
               SelectRow,
               CellWidget,
               Edit,
               ColumnResizer
             ],
             editLazySave: false // Needs to be set to false because using query on the store
         });

         // Put the property table widget into the DOM tree:
         this._propertiesTable.placeAt(this._egProperties);

         // Start up the property table widget:
         this._propertiesTable.startup();

         // Populate store and then initialize values when store is populated:
         var populate = this._attributesStore.populateAttributesStore();
         populate.then(lang.hitch(this, function() {
        		// have to wait until to initialize until after the populate completes
        		// as we will need the URI from the properties store:
         	this._initialize();
       	 }));

         Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createPropertiesTable");
     },


     // Called after the properties store is initialized:
     _initialize: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_initialize");

        // Flag to indicate that the user has made a change:
        this._hasUserMadeAChange = false;

        // Add a handler for when a property value is changed in the property table (it is
        // preferred to use the event handling of the grid control so using that here):
        this._getPropertiesTable().edit.connect(this._getPropertiesTable().edit, "onApply", lang.hitch(this, this._handlePropertyValueChanged));

        // Add a handler for when the selection changes in the property table (it is
        // preferred to use the event handling of the grid control so using that here):
        this._getPropertiesTable().select.row.connect(this._getPropertiesTable().select.row, "onSelected", lang.hitch(this, this._handleRowSelectionChanged));
        this._getPropertiesTable().select.row.connect(this._getPropertiesTable().select.row, "onDeselected", lang.hitch(this, this._handleRowSelectionChanged));

        // Populate the properties table with the properties of the EG:
      	this._populateTableWithProperties();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_initialize");
      },


      _getType: function() {
      	return this._getTypeWidget().get("displayedValue");
      },


      _getTypeWidget: function() {
      	return this._egTypeName;
      },


      _getPropertiesTable: function() {
      	return this._propertiesTable;
      },


      resize: function() {
         Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");
         this._egEditor_borderContainer.resize();
         Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
      },


      // Called when the user clicks the Save button:
      _onSaveClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onSaveClick");

        this._saveProperties();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onSaveClick");
      },


      // Called after the user clicks the Save button:
      _saveProperties: function() {

        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_saveProperties");

        // Example URI: /apiv1/executiongroups/default/properties
        var uri = Resources.REST.root + "/" + this._type + "/" + this._name + "/properties";

        var propertiesObject = {};
        var basicProperties = [];
        var advancedProperties = [];

        // Add the properties to the object:
        var numberOfRows = this._getPropertiesTable().rowCount();
      	if (numberOfRows > 0) {
      	  for (var i = 0; i < numberOfRows; i++) {
      	  	var property = {};
      	  	property.name = this._getPropertiesTable().cell(i, 0).rawData();
          	property.value = this._getPropertiesTable().cell(i, 1).rawData();

          	//if (this._getPropertiesTable().cell(i, 1).isEditing()) {
          	var rmName = this._getPropertiesTable().model.store.get(property.name).resourceManagerName;
          	var internalName = this._getPropertiesTable().model.store.get(property.name).internalName;

          	if (rmName === "none") {
          	  if ((internalName === "shortDesc") || (internalName === "longDesc")) {
          	    basicProperties.push({
          	      "name"  : internalName,
          	      "value" : property.value
          	    });
          	  }
          	  else if ((internalName === "soapNodesUseEmbeddedListener") ||
          	    (internalName === "httpNodesUseEmbeddedListener")) {
          	    advancedProperties.push({
          	      "name"  : internalName,
          	      "value" : property.value
          	    });
          	  }
          	} else {
          	  basicProperties.push({
          	    "name"  : internalName,
          	    "value" : property.value
          	  });
          	}

          	//this._getPropertiesTable().cell(i, 1).cancelEdit();
          	//}
      	  }
      	  propertiesObject.basicProperties = basicProperties;
      	  propertiesObject.advancedProperties = advancedProperties;
        }

        // Add loading icon to tree:
        var tree = registry.byId('_explorerTree_ID');
        var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
        var oldIcon = attr.get(treeImgs[0],"class");
        attr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");

        window.smallMessage.displayPlainMessage("information", "PropertiesUpdate_SavingProperties");

        // Change the modified flag to false (as we are going to save the changes and we do not want isDirty() to return true):
        this._hasUserMadeAChange = false;

        // Disable the save and cancel buttons (to prevent the user from pressing them again while saving):
        this.toolbar.getButton("save").set("disabled", true);
        this.toolbar.getButton("cancel").set("disabled", true);

        // Call PUT to update the properties using the uri and object from above:
        xhr.put(
          uri,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json",
              "Content-type" : "application/json"
            },
            data : JSON.stringify(propertiesObject)
          }
        ).then(
          lang.hitch(this, function() {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Call to set properties was successful.");

            // Reset old icon (to remove loading icon):
            attr.set(treeImgs[0],"class",oldIcon);

            // Display a message that the creation was successful:
          	window.smallMessage.displayPlainMessage("success", "PropertiesUpdate_SaveSuccess");

            // Publish that the EG has been updated:
            topic.publish(Resources.pubSubTopic.egPropertiesUpdated, {uri: uri});

          }),
          lang.hitch(this, function(error) {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Text: " + error.response.text);

            // Reset old icon (to remove loading icon):
            attr.set(treeImgs[0],"class",oldIcon);

            // Display a message that the creation was unsuccessful:
            window.smallMessage.displayPlainMessage("error", "_errorGettingProperties");

            // Re-enable the modify flag, and re-enable the save and cancel buttons (as the user may want to continue working in the editor):
            this.toolbar.getButton("save").set("disabled", false);
            this.toolbar.getButton("cancel").set("disabled", false);
          })
        );
        // end put

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_saveProperties");
      },


      // Called when the user clicks the Cancel button:
      _onCancelClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onCancelClick");

        // Publish that the editor has been cancelled:
        topic.publish(Resources.pubSubTopic.egPropertiesEditCancelled, {editor: this});

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onCancelClick");
      },

      // Populates the provided widget with the properties of the EG:
      _populateTableWithProperties: function() {
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_populateTableWithProperties");

        // Set the text that will be read out by a screen reader for the '...' column header of the properties
      	// table. This has to be done or a screen reader will just read out that the column is read-only (or
      	// nothing will be said at all). The reason that this is being done here is so we can be sure that the
      	// egPropertiesTable-valueDialog DOM element is available:
      	var elementThatIsTheAriaLabelForTheValueDialogColumn = dom.byId("egPropertiesTable-valueDialog");
        if (elementThatIsTheAriaLabelForTheValueDialogColumn !== undefined) {
          attr.set(elementThatIsTheAriaLabelForTheValueDialogColumn, "aria-label", NLS.editValueDialogColumnHeaderText);
        }

      	// Get EG level properties
      	// Example URI: /apiv1/executiongroups/default/properties
        var uri = Resources.REST.root + "/" + this._type + "/" + this._name + "/properties";
        xhr.get(
          uri,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json"
            }
          }
        ).then( lang.hitch(this, function(response) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Call to get the properties for execution group: " + this._name + " was successful.");

          // Populate table with properties:
          var name;
          var i;
          var value;
          var displayName;
          if ( response !== undefined  ) {
            if (response.basicProperties !== undefined){
                for (i = 0; i < response.basicProperties.length; i++) {
                    name = response.basicProperties[i].name;
                    if ( (name === "shortDesc") || (name === "longDesc") ) {
                      value = response.basicProperties[i].value;
                      displayName = this._propertyDisplayName(name);
                   		this.propertyData.push(
                        {
                         id: displayName,
                         internalName: name,
                         displayName: displayName,
                         type : 'text',
                         value: value,
                         resourceManagerName: "none"
                        });
                    }
                }
            }

            if (response.advancedProperties !== undefined){
                for (i = 0; i < response.advancedProperties.length; i++) {
                    name = response.advancedProperties[i].name;
                    if ( (name === "soapNodesUseEmbeddedListener") || (name === "httpNodesUseEmbeddedListener") ) {
                      value = response.advancedProperties[i].value;
                      displayName = this._propertyDisplayName(name);
                   		this.propertyData.push(
                        {
                         id: displayName,
                         internalName: name,
                         displayName: displayName,
                         type : 'boolean',
                         value: value,
                         resourceManagerName: "none"
                        });
                    }
                }
            }

            if (response.resourceManagerProperties !== undefined){
              for (i = 0; i < response.resourceManagerProperties.length; i++) {
                name = response.resourceManagerProperties[i].name;
                value = response.resourceManagerProperties[i].value;
                var rmName = response.resourceManagerProperties[i].owner;
                var type = response.resourceManagerProperties[i].type;
                displayName = this._propertyDisplayName(name);
                   	this.propertyData.push(
                    {
                         id: displayName,
                         internalName: name,
                         displayName: displayName,
                         type : type,
                         value: value,
                         resourceManagerName: rmName
                    });
                  }
              }

              this._getPropertiesTable().select.row.clear(); // clear any selections first
              this._getPropertiesTable().model.clearLazyData(); // clear off any edits that may exist
              this._getPropertiesTable().model.clearCache();
              this._getPropertiesTable().model.store.setData(this.propertyData);
              this._getPropertiesTable().body.refresh();
            }

        }),
        lang.hitch(this, function(error) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Text: " + error.response.text);

          // Display a message that the properties could not be obtained:
          window.smallMessage.displayPlainMessage("error", "_errorGettingProperties");
        })
        );

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_populateTableWithProperties");
      },
      
            
      // Called when the user changes the value of a property in the property table:
      _handlePropertyValueChanged: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handlePropertyValueChanged");
      
        // Set the change flag:
        if (!this._hasUserMadeAChange) {
      	  this._hasUserMadeAChange = true;
      	}
      	
      	// Validate:
      	this._validate();
      	
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handlePropertyValueChanged");
      },
      
      // Validates the widget. Called when the user makes a change to a property value in the UI.
      _validate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_validate");
        
        // Ensure that the property values do not contain invalid characters:
        var numberOfRows = this._getPropertiesTable().rowCount();
        if (numberOfRows > 0) {
          for (var i = 0; i < numberOfRows; i++) {
            var propertyName = this._getPropertiesTable().cell(i, 0).rawData();
            var internalName = this._getPropertiesTable().model.store.get(propertyName).internalName;
            var propertyValue = this._getPropertiesTable().cell(i, 1).rawData();
            // Check if the property value is empty:
            if (propertyValue === null || propertyValue === undefined || propertyValue.trim() === '') {
              // nothing to do
            } else if (this._shouldPropertyValueBeCheckedForInvalidCharacters(internalName)) {
              // Dot ('.') character is allowed for the 'FTE Agent - Coordination Queue Manger' property value:
              var treatDotCharAsValid = (internalName === "coordinationQMgr"); 
            
              // Check whether the property value contains any invalid characters:
              var invalidCharInPropertyValue = UIUtils.findFirstInvalidCharInProperty(propertyValue, treatDotCharAsValid);
              if (invalidCharInPropertyValue !== null) {
                this.toolbar.getButton("save").set("disabled", true);
                window.smallMessage.displayPlainMessage("error", "propertyValueContainsInvalidCharacter", [propertyValue, invalidCharInPropertyValue]);
                return;
              }
            }
          }
        }
        
        // If we have gotten this far everything is good, so hide current message and enable the save button:
        window.smallMessage.hideMessage();
        this.toolbar.getButton("save").set("disabled", false);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_validate");
      },
      
      // Returns true if the provided internal property name should be checked for invalid characters, false
      // otherwise. Called during validation.
      _shouldPropertyValueBeCheckedForInvalidCharacters: function(internalPropertyName) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_shouldPropertyValueBeCheckedForInvalidCharacters");
        
        var shouldBeChecked = false;
        if (internalPropertyName !== null && internalPropertyName !== undefined) {
          switch(internalPropertyName) {
            case "soapNodesUseEmbeddedListener":
            case "httpNodesUseEmbeddedListener":
            case "jvmDebugPort":
            case "jvmMinHeapSize":
            case "jvmMaxHeapSize":
            case "jvmNativeStackSize":
            case "jvmVerboseOption":
            case "cbfEnabled":
            case "validationThreads":
            case "evaluationThreads":
            case "coordinationQMgr":
            case "enabled":
            case "enableCatalogService":
            case "enableContainerService":
            case "enableJMX":
            case "listenerPort":
            case "haManagerPort":
            case "jmxServicePort":
            case "clientsDefaultToSSL":
              shouldBeChecked = true;
              break;
          }
        }

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_shouldPropertyValueBeCheckedForInvalidCharacters");
        return shouldBeChecked;
      },
      
      // Returns true if the editor is dirty, false otherwise.
      isDirty: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "isDirty");
        // Check if the editor is dirty by checking the state of the save button or the change flag:
        var result = false;
        if (this.toolbar !== undefined && this.toolbar.getButton("save") !== undefined && !this.toolbar.getButton("save").get("disabled")) {
        	result = true;
        }
        else if (this._hasUserMadeAChange) {
        	result = true;
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "isDirty");
        return result;
      },

      // Called by dojo when this widget is being destroyed:
      uninitialize: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "uninitialize");
        // Destroy the property value edit dialog if it exists:
      	var editPropertyValueDialog = registry.byId("editPropertyValueDialog");
      	if (editPropertyValueDialog !== null && editPropertyValueDialog !== undefined) {
      		editPropertyValueDialog.destroy();
      	}
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "uninitialize");
      }

    });
    return egPropertyEditor;
  }
);

},
'webui/widgets/sharedlibraries/shlib_overview':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="2907093092" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/sharedlibraries/templates/shlib_overview.html",
  "dojo/i18n!webui/nls/web",
	"dojo/_base/declare", 
	"dojo/_base/lang",
	"dojo/dom-attr",
	"dojo/dom-construct",
	"dojo/query",
	"dojo/request/xhr",
  "dojo/string",
	"dijit/_TemplatedMixin",
	"dijit/_WidgetBase", 
  "dijit/_WidgetsInTemplateMixin",
  "dijit/registry",
  "webui/widgets/common/AttributesStore",
  "webui/widgets/common/HasContextMenu",
  "webui/widgets/common/QuickAndAdvancedProperties",
	"webui/widgets/common/Toolbar",
	"webui/widgets/common/Trace",
	"webui/widgets/common/UIUtils"
], function(
  template,
  NLS,
  declare,
  lang,
  domAttr,
  domConstruct,
  query,
  xhr,
  string,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  registry,
  AttributesStore,
  HasContextMenu,
  QuickAndAdvancedProperties,
  Toolbar,
  Trace,
  UIUtils
) {
  var libOverview = declare("webui.widgets.sharedlibraries.shlib_overview", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
    templateString: template,
    declaredClass: "webui.widgets.sharedlibraries.shlib_overview",
    toolbar: null,
    _attributesStore : new AttributesStore(),

    postCreate: function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			this.inherited(arguments);	
			
			// Create toolbar
			this.toolbar = new Toolbar();
			domConstruct.place(this.toolbar.domNode, this._toolbar);
			this.toolbar.addLeftAlignButtons("title");
			
			this.properties = new QuickAndAdvancedProperties("sharedLibrary");
			this.properties.createPropertiesContainer(this._propertyTitlePane);
		
	 		Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},
		
		resize: function() {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize"); 
		  this._egOverview_borderContainer.resize();
		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize"); 
    },
	    
    // This function is called manually when we need to remove this tab.
    tabRemove: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
      
      this.properties.unsubscribeAll();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove"); 
    },
        
        contextButtonsClicks : function(event) {
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks", [event]);
		
		    // Get the URI and action from the event:
		    var uriAndAction = UIUtils.getURIAndAction(event, true);
		    var itemURI = uriAndAction.uri;
		    var buttonType = uriAndAction.action;
		    
            this.actionLib(itemURI, buttonType);


            Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
          },
          
          actionLib : function(uri, action){
          	
              Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionLib", [uri,action]);

              var uriArray = uri.split("_");
              var buttonType = uriArray[uriArray.length - 1];
              uri = uri.substr(0,uri.length - buttonType.length - 1);

              if (null!=action && action === "delete" ) {

                var tree = registry.byId('_explorerTree_ID');
                var libName = tree.selectedNode.item.name;//label can be truncated, so use name instead
                  
                var confirmationMessage = string.substitute(NLS.messages.DeleteSharedLibraryAction_confirmation, [libName] );
                  
      	        var confirmCallback = lang.hitch(this, function() {

      	          //	Add loading icon to tree
      	          var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
      	          var oldIcon = domAttr.get(treeImgs[0],"class");
      	          domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");        	

      	          // REST Call to delete the library
      	          xhr.del(
      	              uri,
      	              {
      	                handleAs : "json",
      	                headers : {
      	                   "Accept" : "application/json"
      	                }
      	              }
      	            ).then( lang.hitch(this, function() {
      	              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Shared library delete success");
      	
      	              //reset old icon
      	              domAttr.set(treeImgs[0],"class",oldIcon);

      	              // Display success message for deleting a library
      	              window.smallMessage.displayPlainMessage("success", "DeleteSharedLibraryAction_successSharedLibraryDeleted", [libName]);
      	            }),
      	            lang.hitch(this, function(error) {
      	            	
      	              Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrDel to " + uri + " failed.", [error]);

      	              //reset old icon
      	              domAttr.set(treeImgs[0],"class",oldIcon);

                      //show error message
                      var response = JSON.parse(error.response.text);
                      window.smallMessage.displayMessage("error", "shlibdelete_5XX",response.bipNumber, response.description);
      	            })
      	          );
      	        });
                  
      	        window.wmbConsole.showConfirmationDialog("btConfirmDelete", "question", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, confirmationMessage, confirmCallback, null);
      			        
              	
              	
              }//if

              Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionLib");
            },
            
        
    tabFocus: function () {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus"); 
      // Get lib name and add to the toolbar title
      this.toolbar.setAttribute("title", "innerHTML", "");
      var populate = this._attributesStore.populateAttributesStore();
      populate.then(lang.hitch(this, function() {
        domAttr.set("_infoPaneTitleID", "innerHTML", this._attributesStore.getAttribute("name") + " - " + NLS.shlibTitle);
      }));

      // Populate quick view and advanced properties
      this.properties.populateProperties();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
    },
        
    tabBlur: function () {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur"); 
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
    }

	});
	return libOverview;
});

},
'webui/utils/RestUri':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="392431026" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */

/**
 * A RestUri object is a thin wrapper for a string representing a REST URI,
 * such as "/apiv1/executiongroups/default2/applications/app1/libraries/lib1/messageflows/flow1".
 * 
 * REST URIs may point towards numerous different artifacts, including deployed
 * artifacts, policies, and intangible things like configurable services.
 */
define(
  [
    "dojo/_base/declare",
    "dojo/_base/lang",
    "webui/config/Resources"
  ],
  function(
    declare,
    lang,
    Resources
  ) {
    var RestUri = declare("webui.utils.RestUri", [], {
      
      /** The original REST URI, in string form */
      "_string" : null,
      
      /** e.g. ["executiongroups", "default", "messageflows", "flow1"] */
      "_components" : null,

      /**
       * e.g. new RestUri("/apiv1/executiongroups/default/messageflows/flow1")
       * new RestUri({"string" : "/apiv1/executiongroups/default/messageflows/flow1"})
       * new RestUri({"components" : ["executiongroups", "default", "messageflows", "flow1"]})
       */
      "constructor" : function(args) {
        if(typeof args === "string") {
          args = {
            "string" : args
          };
        }

        // Constructor 1: from string
        if(args.string) {
          if(args.components) {
            throw new Error("Can't pass both `string` and `components` into this constructor");
          }

          this._string = args.string;
          
          var components = this._string.split("/").map(decodeURIComponent);
          // e.g. ["", "apiv1", "executiongroups", "default", "messageflows", "flow1"]
          
          var expectedComponents = Resources.REST.root.split("/");
          while(expectedComponents.length > 0) {
            if(components.shift() !== expectedComponents.shift()) {
              throw new Error("'" + args.string + "' is not a REST API URI. Try e.g. '" + Resources.REST.root + "/executiongroups/default/messageflows/flow1'");
            }
          }
          // Leaving e.g. ["executiongroups", "default", "messageflows", "flow1"]
          
          this._components = components;
          return;
        }
        
        // Constructor 2: from path components
        if(args.components) {
          this._components = args.components.slice();

          this._string = Resources.REST.root;
          this._components.forEach(lang.hitch(this, function(component) {
            this._string += "/" + encodeURIComponent(component);
          }));
          return;
        }
        
        throw new Error("Must pass at least one of `string` and `components` into this constructor");
      },
      
      "toString" : function() {
        return this._string;
      },
      
      "getComponents" : function() {
        // Do not return the original array, in case the caller modifies it
        return this._components.slice();
      },
      
      /**
       * If we are e.g. "/apiv1/policy/configurableservices", return
       * ["/apiv1", "/apiv1/policy", "/apiv1/policy/configurableservices"]
       */
      "getTreePath" : function() {
        
        // Gradually build up the parsed form of the REST URI,
        // starting from the root, adding a new component each time
        var string = Resources.REST.root;
        var treePath = [string];

        // And build up the REST URIs themselves here
        this._components.forEach(function(component) {
          string += "/" + encodeURIComponent(component);
          treePath.push(string);
        });
        
        return treePath;
      },
      
      "isIntegrationNode" : function() {
        return this._components.length === 0;
      },
      
      "isIntegrationServer" : function() {
        return this._components[0] === "executiongroups" && this._components[1] && this._components.length === 2;
      },
      
      "isMessageFlow" : function() {
        return (this.getArtifactType() === "messageflows");
      },      
      
      "isPolicies" : function() {
        return this._components[0] === "policy" && this._components.length === 1;
      },
      
      /** Some REST URIs point to configurable services, some do not. */ 
      "isConfigurableService" : function() {
        return this._components[0] === "policy" && this._components[1] === "configurableservices";
      },
      
      /**
       * Some REST URIs either point directly to policy instances
       * ("/apiv1/policy/WorkloadManagement/MyPolicy1") whereas some point
       * only to the type ("/apiv1/policy/WorkloadManagement"). This returns true in
       * both cases.
       */
      "isPolicyType" : function() {
        return this._components[0] === "policy" && this._components[1] !== "configurableservices";
      },

      /**
       * Some REST URIs point to policies. This returns true only if there is
       * also a policy name
       */
      "isPolicy" : function() {
        return this._components[0] === "policy" && this._components[1] !== "configurableservices" && this._components[2];
      },

      "isAdminLog" : function() {
        return this._components[0] === "monitoring" && this._components[1] === "adminlog";
      },
      
      "isBusinessTransactions" : function() {
        return this._components[0] === "business" && this._components[1] === "businesstransactions";
      },
      
      "isUser" : function() {
        return this._components[0] === "security" && this._components[1] === "users" && this._components[2] && this._components.length === 3;
      },

      "getUsername" : function() {
        return this.isUser() ? this._components[2] : null;
      },

      "getIntegrationServerName" : function() {
        return this.isArtifact() ? this._components[1] : null;
      },
      
      "getConfigurableServiceType" : function() {
        return this.isConfigurableService() ? this._components[2] : null; // e.g. "ActivityLog"
      },
      
      "getConfigurableServiceName" : function() {
        return this.isConfigurableService() ? this._components[3] : null; // e.g. "ActivityLogTemplate" or "MyCs1"
      },

      "isBusinessTransactionRecorder" : function() {
        return this.getPolicyType() === "businesstransactionrecorders";
      },
      
      // TODO: what are the proper indices here?
      "getBusinessTransactionRecorderName" : function() {
        return this.isBusinessTransactionRecorder() ? this._components[this._components.length - 1] : null;
      },
      
      "getBusinessTransactionName" : function() {
          return this.isBusinessTransactions() ? this._components[this._components.length - 1] : null;
       },
       
      "getMessageFlowName" : function() {
         return this.isMessageFlow() ? this._components[this._components.length - 1] : null;
      },
       
      

      "getPolicyType" : function() {
        return this.isPolicyType() ? this._components[1] : null; // e.g. "WorkloadManagement"
      },
      
      "getPolicyName" : function() {
        return this.isPolicy() ? this._components[2] : null; // e.g. "MyPolicy1"
      },
      
      /**
       * E.g. if input URI is
       * "/apiv1/executiongroups/default/services/integrationService2/resources/IBMdefined/org/w3/www/xml/_1998/namespace/xml.xsd"
       * with components ["executiongroups", "default", "services", "integrationService2", "resources", ...]
       * then return 5, otherwise `null`
       */
      "getResourceIndex" : function() {
        var i;
        for(i = 0; i < this._components.length; i += 2) {
          var type = this._components[i];
          var name = this._components[i + 1];

          // Should be a container type
          if(
            type !== "executiongroups" &&
            type !== "applications" &&
            type !== "services" &&
            type !== "restapis" &&
            type !== "libraries" &&
            type !== "sharedlibraries"
          ) {
            break;
          }
          
          // Name must exist, otherwise this is no resource
          if(!name) {
            return null;
          }
        }
        
        // If we get here then we've run out of container types.
        // We may even be at the end of the URI, e.g. URI was
        // "/apiv1/executiongroups/default/services/integrationService2"
        if(this._components[i] !== "resources") {
          return null;
        }
        
        i += 1;

        return i;
      },

      "isResource" : function() {
        return this.getResourceIndex() !== null;
      },
      
      /**
       * Resources have strange URIs such as 
       * "/apiv1/executiongroups/default/services/integrationService2/resources/IBMdefined/org/w3/www/xml/_1998/namespace/xml.xsd"
       * In this case, we would return "IBMdefined/org/w3/www/xml/_1998/namespace/xml.xsd"
       */
      "getResourcePath" : function() {
        if(!this.isResource()) {
          return null;
        }
        return this._components.slice(this.getResourceIndex()).map(encodeURIComponent).join("/");
      },

      /**
       * Does this represent an integration server or a deployed artifact (app, shlib, flow, ...)?
       * Note that an integration node is NOT considered to be a deployed artifact.
       */
      "isArtifact" : function() {
        
        if(this.isIntegrationNode()) {
          return false;
        }

        if(this._components.length % 2 !== 0) {
          return false;
        }

        for(var i = 0; i < this._components.length; i += 2) {

          var type = this._components[i]; // e.g. "executiongroups"
          var name = this._components[i + 1]; // e.g. "default"

          // Make sure all of the even-numbered components are proper container types.
          if(
            type !== "executiongroups" &&
            type !== "applications" &&
            type !== "services" &&
            type !== "restapis" &&
            type !== "libraries" &&
            type !== "sharedlibraries" &&
            type !== "messageflows" &&
            type !== "subflows" &&
            type !== "resources"
          ) {
            return false;
          }
          
          // Also the name has to be there!
          if(!name) {
            return false;
          }
        }

        return true;
      },
      
      "getArtifactType" : function() {
        return this.isArtifact() ? this.getArtifact().type : null;
      },
      
      "getArtifactName" : function() {
        return this.isArtifact() ? this.getArtifact().name : null;
      },

      "getArtifact" : function() {
        if(!this.isArtifact()) {
          return null;
        }
        var artifacts = this.getArtifacts();
        return artifacts[artifacts.length - 1];
      },
      
      "getArtifacts" : function() {
        if(!this.isArtifact()) {
          return null;
        }
        
        var artifacts = [];
        for(var i = 0; i < this._components.length; i += 2) {

          var type = this._components[i]; // e.g. "executiongroups"
          var name = this._components[i + 1]; // e.g. "default"
          artifacts.push({"type" : type, "name" : name});
        }
        
        return artifacts;
      },
      
      /**
       * Return the stats topic for this REST URI.
       * E.g. REST URI "/apiv1"
       * returns "IBM/IntegrationBus/IB10NODE/Statistics/JSON/SnapShot"
       * E.g. REST URI "/apiv1/executiongroups/default/applications/WSRRIntegrationDemos/messageflows/MathService"
       * returns "IBM/IntegrationBus/IB10NODE/Statistics/JSON/SnapShot/default/applications/WSRRIntegrationDemos/messageflows/MathService"
       * Notice that "executiongroups" is missing!
       */
      "getStatsTopic" : function(appendWildcard) {
        var topicString = Resources.websocket.topicRoot + window.brokerName + Resources.websocket.statsTopic;

        if(this.isIntegrationNode()) {
          // Do nothing, already complete
        }
        
        else if(this.isArtifact()) {
  
          this.getArtifacts().forEach(function(artifact) {
            // This clause is omitted, for some reason
            if(artifact.type !== "executiongroups") {
              topicString += "/" + artifact.type;
            }
            topicString += "/" + artifact.name;
          });
        }
        
        else {
          throw new Error("Don't know how to build a statistics topic string for REST URI '" + this.toString() + "'");
        }

        if(appendWildcard) {
          topicString += "/#";
        }
        
        return topicString;
      },
      
      /** Return the resource stats topic for this REST URI */
      "getResourceStatsTopic" : function() {
        var topicString = Resources.websocket.topicRoot + window.brokerName + Resources.websocket.resourceStatsTopic;

        if(this.isIntegrationNode()) {
          // Do nothing, already complete
        }
        
        else if(this.isArtifact()) {

          this.getArtifacts().forEach(function(artifact) {
            // This clause is omitted, for some reason
            if(artifact.type !== "executiongroups") {
              topicString += "/" + artifact.type;
            }
            topicString += "/" + artifact.name;
          });
        }
        
        else {
          throw new Error("Don't know how to build a statistics topic string for REST URI '" + this.toString() + "'");
        }
        
        // This is necessary otherwise it doesn't work
        topicString += "/";
        
        return topicString;
      },
      
      /**
       * Input a REST URI, e.g.
       * "/apiv1/executiongroups/default2/applications/app1/libraries/lib1/messageflows/flow1"
       * Output the admin notification topic string for changes to this deployed artifact.
       * E.g. "IBM/IntegrationBus/IB10NODE/AdminNotifications/Broker/IB10NODE/ExecutionGroup/default2/Application/app1/Library/lib1/MessageFlow/flow1"
       * Note that special characters (e.g. spaces) in artifact names are NOT escaped here.
       * Not yet confirmed: can an artifact be called "#"? Or "/"?
       */
      "getNotificationTopic" : function(appendWildcard) {
        var topicString = Resources.websocket.topicRoot + window.brokerName + Resources.websocket.adminNotificationsTopic;
  
        topicString += "/Broker";
        topicString += "/" + window.brokerName;
        
        if(this.isIntegrationNode()) {
          // We're done, do nothing else
        }
        
        // e.g. "/apiv1/monitoring/adminlog" returns
        // "IBM/IntegrationBus/IB10NODE/AdminNotifications/Broker/IB10NODE/Log/Log"
        else if(this.isAdminLog()) {
          topicString += "/Log";
          topicString += "/Log"; // deliberate duplication
        }
        
        // e.g. "/apiv1/policy" returns
        // "IBM/IntegrationBus/IB10NODE/AdminNotifications/Broker/IB10NODE/Policy"
        // There are, as far as I know, no finer-grained topics below this.
        else if(this.isPolicies()) {
          topicString += "/Policy";
        }
        
        // e.g. "/apiv1/security/users/Sam" returns
        // "IBM/IntegrationBus/IB10NODE/AdminNotifications/Broker/IB10NODE/WebAdmin/WebAdmin/WebUser/Sam"
        else if(this.isUser()) {
          topicString += "/WebAdmin";
          topicString += "/WebAdmin"; // deliberate duplication
          topicString += "/WebUser";
          topicString += "/" + this.getUsername();
        }
        
        else if(this.isResource()) {
          // Resources are artifacts, but have no admin notifications.
          return null;
        }
        
        else if(this.isArtifact()) {

          this.getArtifacts().forEach(function(artifact) {
           
            var artifactType = artifact.type;
    
            // These come from ImbDMConstants.cpp (mostly)
            var lookup = {
              "executiongroups" : "ExecutionGroup", // ImbDMConstants::CMC_TYPE_EXECUTIONGROUP
              "applications" : "Application", // ImbDMConstants::CMC_TYPE_APPLICATION
              "services" : "Service", // hard-coded in ImbDeployManagerCacheObject.cpp
              "restapis" : "restapiApplication", // Built on the fly
              "libraries" : "Library", // ImbDMConstants::CMC_TYPE_LIBRARY
              "sharedlibraries" : "SharedLibrary", // ImbDMConstants::CMC_TYPE_SHARED_LIBRARY
              "messageflows" : "MessageFlow", // ImbDMConstants::CMC_TYPE_MESSAGEFLOW_EXTERNAL
              "subflows" : "Subflow" // ImbDMConstants::CMC_TYPE_SUBFLOW
            };
            
            if(!(artifactType in lookup)) {
              throw new Error("adminType for artifactType '" + artifactType + "' not found.");
            }
    
            var adminType = lookup[artifactType];
    
            topicString += "/" + adminType;
            topicString += "/" + artifact.name;
          });
        }
        
        else {
          return null;
        }

        if(appendWildcard) {
          topicString += "/#";
        }

        return topicString;
      },
      
      /*
       * Decides whether the adminNotification is for this object.
       * It could be a notification for itself or one of its parents
       */
      "isAdminNotificationForThisObject": function (message) {
        
        var destinationName = message.destinationName;
        // if the notification is about this object
        if (destinationName === this.getNotificationTopic(false)) {
          return true;
        }
        // if admin notification of a direct or indirect parent
        var parent = this.getParentArtifactRestUri();
        while (parent != null) { // get parent will return null  at EG level e.g "/apiv1/executiongroups/default"
          if (destinationName === parent.getNotificationTopic(false)) {
            return true;
          }
          parent = parent.getParentArtifactRestUri();
        }
        return false;
      },

      /*
       * Decides whether the adminNotification is precisely this object only.
       */
      "isAdminNotificationForThisObjectOnly": function (message) {
        
        var destinationName = message.destinationName;
        // if the notification is about this object
        if (destinationName === this.getNotificationTopic(false)) {
          return true;
        }
        return false;
      },

      /**
       * Return the REST URI for the parent artifact. Note that integration
       * servers have no parent.
       * 
       * "/apiv1/executiongroups/default2/applications/app1/libraries/lib1/messageflows/flow1"
       * becomes "/apiv1/executiongroups/default2/applications/app1/libraries/lib1"
       * 
       * "/apiv1/executiongroups/default/services/integrationService2/resources/IBMdefined/org/w3/www/xml/_1998/namespace/xml.xsd"
       * becomes "/apiv1/executiongroups/default/services/integrationService2"
       * 
       * "/apiv1/executiongroups/default"
       * becomes `null`
       */
      "getParentArtifactRestUri" : function() {
        if(this.isResource()) {
          return new RestUri({"components" : this._components.slice(0, this.getResourceIndex() - 1)});
        }
        if(this.isArtifact() && !this.isIntegrationServer()) {
          return new RestUri({"components" : this._components.slice(0, -2)});
        }
        return null;
      },

      /**
       * Return the REST URI of an artifact's integration server, or null  if this artifact does not belong to an integration server   
       * 
       */
      "getIntegrationServerUri": function() {
    	  
    	   var integrationServerName = this.getIntegrationServerName();
    	   
    	   if(integrationServerName === null) {
    	      return null;
    	   }
    	   
    	   return RestUri.forIntegrationServer(integrationServerName);
       },
    	 
      /**
       * E.g. if `this` represents "/apiv1/policy/configurableservices/ActivityLog/a1"
       * return a RestUri representing "/apiv1/policy/configurableservices/ActivityLog"
       */
      "getConfigurableServiceTypeRestUri" : function() {
        if(!this.isConfigurableService()) {
          return null;
        }
        return new RestUri({"components" : this._components.slice(0, -1)});
      },
      
      "getPropertiesUri" : function() {
        if(this.isIntegrationNode() || this.isArtifact()) {
          var components = this._components.slice();
          components.push("properties");
          return new RestUri({"components" : components});
        }
        return null;
      },
      
      "getActivityLogUri" : function() {
        if(this.isMessageFlow()) {
          var components = this._components.slice();
          components.push("activitylog");
          return new RestUri({"components" : components});
        }
        return null;
      }

    });
    
    // Static methods

    /**
     * Input a policy type and name, return the REST URI for it
     */
    RestUri.forPolicy = function(policyType, policyName) {
      return new RestUri({"components" : ["policy", policyType, policyName]});
    };
    
    RestUri.forIntegrationServers = function() {
      return new RestUri({"components" : ["executiongroups"]});
    };
    
    /** Input an integration server name, return REST URI for it */
    RestUri.forIntegrationServer = function(integrationServerName) {
      return new RestUri({"components" : ["executiongroups", integrationServerName]});
    };

    /** Return the REST URI for the admin log */
    RestUri.forAdminLog = function() {
      return new RestUri({"components" : ["monitoring", "adminlog"]});
    };

    RestUri.forPolicies = function() {
      return new RestUri({"components" : ["policy"]});
    };
    
    RestUri.forConfigurableServices = function() {
      return new RestUri({"components" : ["policy", "configurableservices"]});
    };
    
    RestUri.forConfigurableServiceType = function(csType) {
      return new RestUri({"components" : ["policy", "configurableservices", csType]});
    };
    
    RestUri.forConfigurableService = function(csType, csName){
      return new RestUri({"components" : ["policy", "configurableservices", csType, csName]});
    };
    
    RestUri.forUser = function(username) {
      return new RestUri({"components" : ["security", "users", username]});
    };

    RestUri.forCurrentUser = function() {
      return new RestUri({"components" : ["security", "currentuser"]});
    };
    
    return RestUri;
  }
);

},
'webui/widgets/operation/operation_overview':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="2581534342" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/operation/templates/operation_overview.html",
	"dojo/i18n!webui/nls/web",
	"dojo/_base/declare", 
	"dojo/_base/lang",
	"dojo/dom-attr",
	"dojo/dom-construct",
	"dijit/_TemplatedMixin",
	"dijit/_WidgetBase", 
  "dijit/_WidgetsInTemplateMixin",
  "webui/widgets/common/AttributesStore",
  "webui/widgets/common/HasContextMenu",
	"webui/widgets/common/QuickAndAdvancedProperties",
	"webui/widgets/common/Toolbar",
	"webui/widgets/common/Trace"
], function(
  template,
  NLS,
  declare,
  lang,
  domAttr,
  domConstruct,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  AttributesStore,
  HasContextMenu,
  QuickAndAdvancedProperties,
  Toolbar,
  Trace
) {
  var operationOverview = declare("webui.widgets.operation.operation_overview", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
    templateString: template,
    toolbar: null,
    _attributesStore : new AttributesStore(),

    postCreate: function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			this.inherited(arguments);	
			
			// Create toolbar
			this.toolbar = new Toolbar();
			domConstruct.place(this.toolbar.domNode, this._toolbar);
			this.toolbar.addLeftAlignButtons("title");
			
			this.properties = new QuickAndAdvancedProperties("operation");
			this.properties.createPropertiesContainer(this._propertyTitlePane);
			
	 		Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},
		
		resize: function() {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize"); 
		  this._operationOverview_borderContainer.resize();
		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize"); 
		},
		
		// This function is called manually when we need to remove this tab.
		tabRemove: function() {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
		  this.properties.unsubscribeAll();
		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove"); 
		},
        
    tabFocus: function () {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus"); 
      // Get operation name and add to the toolbar title
      this.toolbar.setAttribute("title", "innerHTML", "");
      var populate = this._attributesStore.populateAttributesStore();
      populate.then(lang.hitch(this, function() {
          domAttr.set("_infoPaneTitleID", "innerHTML", this._attributesStore.getAttribute("name") + " - " + NLS.operationTitle);
      }));

      // Populate quick view and advanced properties
      this.properties.populateProperties();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
    },
        
    tabBlur: function () {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur"); 
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
    }
	});
	return operationOverview;
});

},
'webui/widgets/policy_editor/nls/web':function(){
// NLS_CHARSET=UTF-8

/*   
<copyright 
notice="lm-source" 
pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63" 
years="2013, 2014" 
crc="3118272360" > 
Licensed Materials - Property of IBM  
 
5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63 
 
(C) Copyright IBM Corp. 2013, 2014 All Rights Reserved.  
</copyright> 
*/
define({
  // begin v1.x content
  root: ({   
    // WLM Policy - Titles
    wlm_tAndL_title: "Targets and Limits",
    wlm_addInst_title: "Additional Instances",
    wlm_trans_title: "Transactionality",
    wlm_unresponsive_flows_title: "Unresponsive Message Flows",
    wlm_startMode_title: "Start Mode",
    
    //WLM Policy - Options
    maintained: "Maintained",
    manual: "Manual",
    automatic: "Automatic",
    none: "None", 
    restartExecutionGroup: "Restart execution group",
    yes: "Yes",
    no: "No",
    unspecified: "",
    
    //WLM Policy - Names
    policyName: "Policy name*",
    notificationThresholdMsgsPerSec: "Notification threshold",
    maximumRateMsgsPerSec: "Maximum rate",
    additionalInstances: "Additional instances",
    startInstancesWhenFlowStarts: "Start additional instances when flow starts",
    startMode: "Start mode",
    commitCount: "Commit count",
    commitInterval: "Commit interval",
    processingTimeoutAction: "Processing timeout action",
    processingTimeoutSec: "Processing timeout",
    	
    // MQTT Policy Properties
    group_description_title: "Description",
    shortDesc: "Short description",
    longDesc: "Long description",
    group_basic_title: "Basic",
    clientId: "Client ID",
    topicName: "Topic name",
    hostName: "Host name",
    port: "Port",
    qos: "Quality of service",
    qosempty: "Use the value that is set on the message flow node",
    qos0: "0 - At most once",
    qos1: "1 - At least once",
    qos2: "2 - Exactly once",
    policyUrl: "Policy URL",
    messageNode: "Message node name",
    	
    // MQEndpoint Policy Properties
    connection: "Connection",
    destinationQueueManagerName: "Queue manager name",
    queueManagerHostname: "Queue manager host name",
    listenerPortNumber: "Listener port number",
    channelName: "Channel name",
    ccdtURI: "CCDT file URL",
    DEFAULT: "Queue manager specified on the integration node",
    CLIENT: "MQ client connection properties",
    CCDT: "Client channel definition table (CCDT) file",
    SERVER: "Local queue manager",
    securityIdentity: "Security identity",
    useSSL: "Use SSL",
    SSLPeerName: "SSL peer name",
    SSLCipherSpec: "SSL cipher specification", 
    	
    // Error
    error_policyName_invalidCharacter: "The name contains invalid characters. Valid characters are alphanumeric and underscore.",
    error_integerOnly: "The value entered is not valid, it must be an integer."
  })
});

},
'webui/widgets/restapi/BulkRESTApiPushDialog':function(){
/*
 * <copyright
 * notice="lm-source"
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2"
 * years="2015,2016"
 * crc="763384209" >
 * Licensed Materials - Property of IBM
 *
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2
 *
 * (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.
 * </copyright>
 */
define([
  "dojo/text!webui/widgets/restapi/templates/BulkRESTApiPushDialog.html",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/array",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom-class",
  "dojo/dom-construct",
  "dojo/on",
  "dojo/request/xhr",
  "dojo/string",
  "dijit/Dialog",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetsInTemplateMixin",
  "webui/config/Resources",
  "webui/widgets/restapi/BulkRESTApiPushFeedbackDialog",
  "webui/widgets/common/Trace",

  //Grid X
  "gridx/Grid",
  "gridx/core/model/cache/Sync",
  "gridx/modules/ColumnResizer",
  "gridx/modules/ColumnWidth",
  "gridx/modules/extendedSelect/Row",
  "gridx/modules/IndirectSelect",
  "gridx/modules/RowHeader",
  "gridx/modules/SingleSort",
  "gridx/modules/VirtualVScroller",
  "dojo/store/Memory"
], function(
  template,
  NLS,
  array,
  declare,
  lang,
  domClass,
  domConstruct,
  on,
  xhr,
  string,
  Dialog,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  Resources,
  FeedbackDialog,
  Trace,
  // GridX classes
  Grid,
  CacheSync,
  ColumnResizer,
  ColumnWidth,
  RowSelect,
  IndirectSelect,
  RowHeader,
  SingleSort,
  VirtualVScroller,
  Store
) {
        var bulkRESTApiPushNewDialog = declare("webui.widgets.restapi.BulkRESTApiPushDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
    templateString: template,
    _actionUri: null,
    // PushDetails
    _apiCHost: null,
    _apiCPort: "443",
    _apiCUser: null,
    _apiCPassword: null,
    _apiCCatalogId: null,
    _apiCCatalogName: null,
    _egRESTApis: null,
    _selectedRESTApis: [],
    _availableRESTApis: [],
    _existingProducts: [],

    _onInputHandlers: [],

    _connectionSuccess: false,
    _productValid: false,
    _overridesValid: true,
    _apisSelected: false,
    _restApiGridInitialised: false,

    _pageIndex: 0,

    _restApiStore: null,
    _restApiGrid: null,

    _bulkRESTApiPushFeedbackDialog: null,

    // NLS
    _pushApisTitle: NLS.pushApisTitle,
    _pushApisConnDesc: NLS.pushApisConnectionDesc,
    _pushApisServerDesc: NLS.pushApisServerDesc,
    _pushApisHost: NLS.pushApisHost,
    _pushApisPort: NLS.pushApisPort,
    _pushApisAuthDesc: NLS.pushApisAuthenticationDesc,
    _pushApisUser: NLS.pushApisUser,
    _pushApisPassword: NLS.pushApisPassword,
    _pushApisTargetDesc: NLS.pushApisTargetDesc,
    _pushApisCatalog: NLS.pushApisCatalog,
    _pushApisCatalogDesc: NLS.pushApisCatalogDesc,
    _pushApisOrganization: NLS.pushApisOrganization,
    _pushApisOrganizationDesc: NLS.pushApisOrganizationDesc,
    _pushApisProductTitle: NLS.pushApisProductTitle,
    _pushApisProductName: NLS.pushApisProductName,
    _pushApisProductDesc: NLS.pushApisProductDesc,
    _pushApisProductVersion: NLS.pushApisProductVersion,
    _pushApisSelectDesc: NLS.pushApisSelectDesc,
    _pushApisStageProduct: NLS.pushApisStageProduct,
    _pushApisStageProductDesc: NLS.pushApisStageProductDesc,
    _pushApisTableName: NLS.pushApisTableName,
    _pushApisTableTitle: NLS.pushApisTableTitle,
    _pushApisTableVersion: NLS.pushApisTableVersion,
    _pushApisTableContainer: NLS.pushApisTableContainer,
    _pushApisPreviousLabel: NLS.previousButtonLabel,
    _pushApisNextLabel: NLS.nextButtonLabel,
    _pushApisPushLabel: NLS.pushApisPush,
    _pushApisCancelLabel: NLS.cancelButtonLabel,
    _pushApisTestLabel: NLS.pushApisTestConnection,
    _pushApisOverrideHTTPDesc: NLS.pushApisOverrideHTTPDesc,
    _pushApisOverrideHTTPSDesc: NLS.pushApisOverrideHTTPSDesc,
    _pushApisNoStageInCatalog: "-- " + NLS.pushApisNoStageInCatalog + " --",
    _pushApisHTTP: "http://",
    _pushApisHTTPS: "https://",
    _pushApisPortSeparator: ":",
    _pushApisAPIHostTitle: NLS.pushApisAPIHostTitle,
    _pushApisAPIPortTitle: NLS.pushApisAPIPortTitle,
    _pushApisOverrideHTTPTitle: NLS.pushApisOverrideHTTPTitle,
    _pushApisOverrideHTTPDesc: NLS.pushApisOverrideHTTPDesc,

    _loading : "Loading",
    _success : "Success",
    _failed : "Failed",

    constructor: function(args){
      if(!args) {
        throw new Error("No arguments passed");
      }
      this._actionUri = args.actionUri; // EG uri
    },

    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      // Setup pages
      this._setupConnectionPage();
      this._setupSelectPage();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },

    show : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "show");

      this.inherited(arguments);

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "show");
    },

    getActionUri : function() {
      return this._actionUri;
    },

    _setupConnectionPage : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setupConnectionPage");

      array.forEach(this._onInputHandlers, lang.hitch(this, function(nextHandler) {
        nextHandler.remove();
      }));

      this._onInputHandlers = [];

      // Set up default input values
      this._APICPortText.set("value", this._apiCPort);
      this._APICProductVersion.set("value", "1.0.0");

      this._setPageButtonBehaviour();

      this._onInputHandlers.push(on(this._connectButton, "click", lang.hitch(this, function() {
        this._testAPIConnectConnection();
      })));

      this._onInputHandlers.push(on(this._previousButton, "click", lang.hitch(this, function() {
        if (this._pageIndex > 0) this._switchPageNumber(this._pageIndex-1);
      })));

      this._onInputHandlers.push(on(this._nextButton, "click", lang.hitch(this, function() {
        if (this._pageIndex < 3) this._switchPageNumber(this._pageIndex+1);
      })));

      this._onInputHandlers.push(on(this._pushButton, "click", lang.hitch(this, function() {
        this._performBulkPush();
      })));

      this._onInputHandlers.push(on(this._cancelButton, "click", lang.hitch(this, function() {
        this.hide();
      })));

      this._APICHostText.attr('regExp', Resources.regexp.restApiPushHost); // Strict hostname structure
      this._APICHostText.attr('invalidMessage', NLS.pushApisInvalidHostErrorMsg);

      this._APICPortText.attr('regExp', Resources.regexp.restApiPushPort); // Strict port number
      this._APICPortText.attr('invalidMessage', NLS.pushApisInvalidPortErrorMsg);

      this._APICProductVersion.attr('regExp', Resources.regexp.restApiPushVersion);
      this._APICProductVersion.attr('invalidMessage', NLS.pushApisInvalidVersionErrorMsg);


      this._APICProductNameText.attr('regExp', Resources.regexp.restApiProductName);
      this._APICProductNameText.attr('invalidMessage', NLS.pushApisInvalidProductNameErrorMsg);

      this._APICHTTPHostText.attr('regExp', Resources.regexp.restApiPushHost); // Strict hostname structure
      this._APICHTTPHostText.attr('invalidMessage', NLS.pushApisInvalidHostErrorMsg);

      this._APICHTTPPortText.attr('regExp', Resources.regexp.restApiPushPort); // Strict port number
      this._APICHTTPPortText.attr('invalidMessage', NLS.pushApisInvalidPortErrorMsg);

      this._APICHTTPSHostText.attr('regExp', Resources.regexp.restApiPushHost); // Strict hostname structure
      this._APICHTTPSHostText.attr('invalidMessage', NLS.pushApisInvalidHostErrorMsg);

      this._APICHTTPSPortText.attr('regExp', Resources.regexp.restApiPushPort); // Strict port number
      this._APICHTTPSPortText.attr('invalidMessage', NLS.pushApisInvalidPortErrorMsg);

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setupConnectionPage");
    },

    _setupSelectPage : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setupSelectPage");

      this._getDeployedRESTApis();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setupSelectPage");
    },

    // Make API call to get deployed REST APIs
    _getDeployedRESTApis : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_getDeployedRESTApis");

      var restApisUrl = this._actionUri + "/" + Resources.REST.egRESTApis

      xhr(restApisUrl, {
        handleAs : "json",
        headers : {
          "Accept" : "application/json"
        }
      }).then(
        lang.hitch(this, function(response) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Get Rest APIs success");

          // Get list of RESTApis
          if(response && response.restApi) {
            // Need to get properties about each REST API, involves separate calls
            this._getDeployedRESTApisDetails(response.restApi);
          }
        }),
        lang.hitch(this, function(error) {
          // No REST Apis, so none will be able to be selected - thus no push can occur
          this._availableRESTApis = [];
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Get Rest APIs Error: " + error.response.status + " Response: " + error.response.response);
        })
      );

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_getDeployedRESTApis");
    },

    _getDeployedRESTApisDetails : function(restApis) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_getDeployedRESTApisDetails", [restApis]);

      // Reset available REST Apis
      this._availableRESTApis = [];

      // Iterate around each array
      array.forEach(restApis, lang.hitch(this, function(nextRestApi) {
        this._availableRESTApis.push({
          name: nextRestApi.name,
          title: nextRestApi.title,
          version: nextRestApi.version
        });
      }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_getDeployedRESTApisDetails");
    },

    _createRESTApisTable : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createRESTApisTable");

      // Have empty store on first visit to page
      this._restApiStore = new Store({
        data: this._availableRESTApis,
        idProperty: "name"
      });

      var restApiTableStructure = [
                            { id: "name", field: "name", name: NLS.pushApisTableName, width: '40%', type: 'string' },
                            { id: "title", field: "title", name: NLS.pushApisTableTitle, width: '40%', type: 'string' },
                            { id: "version", field: "version", name: NLS.pushApisTableVersion, width: '20%', type: 'string' }
                          ];

      // GridX Table
      this._restApiGrid = new Grid({
        store: this._restApiStore,
        cacheClass: CacheSync,
        structure: restApiTableStructure,
        autoHeight: false,
        autoWidth: false,
        autoResize: true,
        // Select a row when any cell in that row is clicked.
        selectRowTriggerOnCell: true,
        modules: [
          ColumnResizer,
          ColumnWidth,
          RowSelect,
          IndirectSelect,
          RowHeader,
          SingleSort,
          VirtualVScroller
        ]
      });

      this._restApiGrid.body.emptyInfo = NLS.pushApiGridNoRestApis;

      var newDiv = domConstruct.create("div", { id: "restApisGrid", className: "restApisGridContainer"});

      this._setContainerContent(newDiv, this._pushSelectContentSection);

      this._restApiGrid.placeAt("restApisGrid");
      this._restApiGrid.startup();

      this._restApiGrid.connect(this._restApiGrid.select.row, 'onSelectionChange',
          lang.hitch(this, function() {
            this._onRestAPIGridSelectionHandler();
          }
        )
      );

      this._restApiGridInitialised = true;

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createRESTApisTable");
    },

    _onRestAPIGridSelectionHandler : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onRestAPIGridSelectionHandler");

      if(this._restApiGrid) {
        var selectedRows = this._restApiGrid.select.row.getSelected();
        if(selectedRows && (selectedRows.length > 0)) {
          this._apisSelected = true;
        } else {
          this._apisSelected = false;
        }
        this._selectedRESTApis = selectedRows;
        this._setPageButtonBehaviour();
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onRestAPIGridSelectionHandler");
    },

    _testAPIConnectConnection : function(){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_testAPIConnectConnection");

      var host = this._APICHostText.get("value");
      var port = null;
      var username = null;
      var password = null;
      var hasError = false;

      // Check for null / empty input values
      if((host == null) || (host === "")) {
        hasError = true;
        message = string.substitute(NLS.pushApiTestConnectionRequiredField, [NLS.pushApisHost]);
      } else {
        if(!this._APICHostText.isValid()) {
          hasError = true;
          message = string.substitute(NLS.pushApiTestConnectionInvalidField, [NLS.pushApisHost]);
        } else {
          port = this._APICPortText.get("value");
          if((port == null) || (port === "")) {
            hasError = true;
            message = string.substitute(NLS.pushApiTestConnectionRequiredField, [NLS.pushApisPort]);
          } else {
            if(!this._APICPortText.isValid()) {
              hasError = true;
              message = string.substitute(NLS.pushApiTestConnectionInvalidField, [NLS.pushApisPort]);
            } else {
              username = this._APICUserText.get("value");
              if((username == null) || (username === "")) {
                hasError = true;
                message = string.substitute(NLS.pushApiTestConnectionRequiredField, [NLS.pushApisUser]);
              } else {
                password = this._APICPasswordText.get("value");
                if((password == null) || (password === "")) {
                  hasError = true;
                  message = string.substitute(NLS.pushApiTestConnectionRequiredField, [NLS.pushApisPassword]);
                }
              }
            }
          }
        }
      }

      // Only perform test connection if no errors yet
      if(hasError) {
        this._setTestConnectionFeedback(this._failed, message);
      } else {
        // XHR call - if success then update test connection success message and update orgs dropdown
        // if Failure then update test connection failure message only
        var connectionParameters = {
            host : host,
            port : port,
            username : username,
            password: password,
            minimumVersion: "5"
        };

        var testConnectionUri = this._actionUri + "/" + Resources.REST.pushApisAuthenticate

        this._setTestConnectionFeedback(this._loading, NLS.pushApiTestConnectionLoading);

        xhr.post(testConnectionUri, {
          handleAs : "json",
          headers : {
            "Accept" : "application/json",
            "Content-type" : "application/json"
          },
          data : JSON.stringify(connectionParameters)
        }).then(
          lang.hitch(this, function(response) {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "API Connect retrieve organizations success");

            this._setInputHandlers();
            this._setConnectionParameters(); // Save our successful connection parameters
            this._setTestConnectionFeedback(this._success, NLS.pushApiTestConnectionSuccess);

            // Process returned organization results
            var orgData = [];

            // This should be a list of the existing Orgs that can be used
            if(response && response.organizations) {
              /* Structure example:
                 orgData = [
                         {id : "org123", name : "myorg", title: "My Org"},
                         {id : "org456", name : "ibmorg", title: "IBM Org"}
                     ];*/
              // Add each returned org to the array
              array.forEach(response.organizations, lang.hitch(this, function(nextOrg) {
                orgData.push({id: nextOrg.id, title: nextOrg.title});
              }));
            }

            if(orgData.length > 0) {
              orgData.sort(function(a,b) {return (a.name > b.name) ? 1 : ((b.name > a.name) ? -1 : 0);} ); // Alphabetical

              this._updateOrganizationsSelect(orgData);

              // Enable the Next button and give it focus
              this._nextButton.set("disabled", false);
              this._nextButton.focus();
            } else {
              this._setOrganizationValuesFeedback(this._failed, NLS.pushApiTargetValuesNoOrgs);

              // Disable the Next button
              this._nextButton.set("disabled", true);
            }

          }),
          lang.hitch(this, function(error) {
            // Check to see if this was a partiuclar error, the RESTAPI
            // returns 400 with a message number which can be interrogated
            // to give specific errors.
            if ( (error.response.status == 400) &&
                 (typeof error.response.data !== 'undefined') &&
                 (typeof error.response.data.bipNumber !== 'undefined')) {
              var bipNumber = error.response.data.bipNumber;
              var message;
              if (bipNumber === "9363") {
                // Incompatible APIConnect version
                message = string.substitute(NLS.pushApiAPIConnectVersionError, error.response.data.bipInserts);
                this._setTestConnectionFeedback(this._failed, message);
              }
              else if (bipNumber === "9365") {
                // Connection error
                message = string.substitute(NLS.pushApiConnectionRefused, error.response.data.bipInserts);
                this._setTestConnectionFeedback(this._failed, message);
              }
              else if (bipNumber === "9364") {
                // Generic API Connect error
                message = string.substitute(NLS.pushApiTestConnectionFailureReason, error.response.data.bipInserts);
                this._setTestConnectionFeedback(this._failed, message);
              }
              else {
                // Generic API Connect error
                this._setTestConnectionFeedback(this._failed, NLS.pushApiTestConnectionFailure);
              }
            }
            else {
              // Some other error
             
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "API Connect retrieve organizations Error: " + error.response.status + " Response: " + error.response.response);
              // TODO - Better error that we can't connect to APIConnect - Probably same error from API Connect itself...
              this._setTestConnectionFeedback(this._failed, NLS.pushApiTestConnectionFailure);
            }

            this._setPageButtonBehaviour();
          })
        );
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_testAPIConnectConnection");
    },

    // Main upload function (every step) once required inputs are satisfied
    _performBulkPush : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_performBulkPush");

      // Re-validate options are all set
      var inputs = this._validateAllPushInputs();

      if(inputs.error) {
        this._setPerformPushFeedback(inputs.message);
        return;
      }

      this._hidePerformPushFeedback();

      if (this._bulkRESTApiPushFeedbackDialog) {
        this._bulkRESTApiPushFeedbackDialog.destroy();
        this._bulkRESTApiPushFeedbackDialog = null;
      }

      this._bulkRESTApiPushFeedbackDialog = new FeedbackDialog({
        pushParameters : inputs,
        cback : lang.hitch(this, this._performBulkPushComplete),
        egUri : this._actionUri
      });

      this._bulkRESTApiPushFeedbackDialog.startup();
      this._bulkRESTApiPushFeedbackDialog.show();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_performBulkPush");
    },

    _performBulkPushComplete : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_performBulkPushComplete");

      // Always hide/close the dialog for now
      this.hide();

      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_performBulkPushComplete");
    },

    // Get, check and return all inputs in a managable JSON object
    _validateAllPushInputs : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_validateAllPushInputs");

      var error = false;
      var errorMessage = null;
      // First validate all required inputs exist
      // Connection details
      if((this._apiCHost == null) || (this._apiCHost === "")) {
        error = true;
        errorMessage = string.substitute(NLS.pushApiTestConnectionRequiredField, [NLS.pushApisHost]);
      } else {
        if((this._apiCPort == null) || (this._apiCPort === "")) {
          error = true;
          errorMessage = string.substitute(NLS.pushApiTestConnectionRequiredField, [NLS.pushApisPort]);
        } else {
          if((this._apiCUser == null) || (this._apiCUser === "")) {
            error = true;
            errorMessage = string.substitute(NLS.pushApiTestConnectionRequiredField, [NLS.pushApisUser]);
          } else {
            if((this._apiCPassword == null) || (this._apiCPassword === "")) {
              error = true;
              errorMessage = string.substitute(NLS.pushApiTestConnectionRequiredField, [NLS.pushApisPassword]);
            }
          }
        }
      }

      // If no error yet - check Target Details
      var organization = this._APICOrganizationSelect.get("value");
      var title = this._APICProductTitleText.get("value");
      var product = this._APICProductNameText.get("value");
      var version = this._APICProductVersion.get("value");
      if(!error) {
        if((organization == null) || (organization === "")) {
          error = true;
          errorMessage = string.substitute(NLS.pushApiTestConnectionRequiredField, [NLS.pushApisHost]);
        } else if((product == null) || (product === "")) {
          error = true;
          errorMessage = string.substitute(NLS.pushApiTestConnectionRequiredField, [NLS.pushApisProductName]);
        } else if((title == null) || (title === "")) {
          error = true;
          errorMessage = string.substitute(NLS.pushApiTestConnectionRequiredField, [NLS.pushApisProductTitle]);
        } else if((version == null) || (version === "")) {
          error = true;
          errorMessage = string.substitute(NLS.pushApiTestConnectionRequiredField, [NLS.pushApisPort]);
        }
      }

      // If no error yet - check REST Apis to Push selections
      if(!error) {
        if(this._selectedRESTApis && (this._selectedRESTApis.length < 1)) {
            error = true;
            message = NLS.pushApiGridNoRestApisSelected;
          }
      }

      var pushParameters = null;

      // If Error
      if(error) {
        pushParameters = {
            error : true,
            message : message
        };
      } else {
        pushParameters = {
            "host" : this._apiCHost,
            "port" : this._apiCPort,
            "user" : this._apiCUser,
            "password" : this._apiCPassword,
            "organizationId" : organization,
            "catalogId" : this._apiCCatalogId,
            "catalogName" : this._apiCCatalogName,
            "productTitle" : title,
            "productName" : product,
            "productVersion" : version,
            "restApis" : this._selectedRESTApis
        }

        // Extract the override values if supplied
        if (this._APICHTTPHostText.get("value").length > 0) {
          pushParameters.httpHost = this._APICHTTPHostText.get("value");
        }
        if (this._APICHTTPPortText.get("value").length > 0) {
          pushParameters.httpPort = this._APICHTTPPortText.get("value");
        }
        if (this._APICHTTPSHostText.get("value").length > 0) {
          pushParameters.httpsHost = this._APICHTTPSHostText.get("value");
        }
        if (this._APICHTTPSPortText.get("value").length > 0) {
          pushParameters.httpsPort = this._APICHTTPSPortText.get("value");
        }
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_validateAllPushInputs");

      return pushParameters;
    },

    _targetOrganizationChange : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_targetOrganizationChange");

      // Get the current input values for the target information and derive if the next page can be got to - valid catalog and product (if yet set) values
      var organizationId = this._APICOrganizationSelect.get("value");
      if((organizationId == null) || (organizationId === "")) {
        error = true;
      } else {
        var connectionParameters = {
            host : this._apiCHost,
            port : this._apiCPort,
            username : this._apiCUser,
            password: this._apiCPassword,
            organizationId : organizationId
        };

        this._setOrganizationValuesFeedback(this._loading, NLS.pushApiTargetValuesLoading);

        var getCatalogsUri = this._actionUri + "/" + Resources.REST.pushApisCatalogs;
        xhr.post(getCatalogsUri, {
          handleAs : "json",
          headers : {
            "Accept" : "application/json",
            "Content-type" : "application/json"
          },
          data : JSON.stringify(connectionParameters)
        }).then(
          lang.hitch(this, function(response) {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "API Connect retrieve catalogs success");

            // This should be a list of the existing catalogs
            if(response && response.catalogs) {
              this._updateCatalogsSelect(response.catalogs);
            }
            else {
              this._updateCatalogsSelect([]);
            }

            this._setPageButtonBehaviour();
          }),
          lang.hitch(this, function(error) {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "API Connect retrieve catalogs Error: " + error.response.status + " Response: " + error.response.response);
            // TODO - Error that we can't connect to APIConnect / get Catalogs - Probably same error
            this._setPageButtonBehaviour();
          })
        );
 
        this._targetCatalogChange();
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_targetOrganizationChange");
    },


    _targetCatalogChange : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_targetCatalogChange");
      this._hideCatalogValuesFeedback();

      this._apiCCatalogId = this._APICCatalogSelect.get("value");
      this._apiCCatalogName = this._APICCatalogSelect.get("displayedValue");

      var getProductsUri = this._actionUri + "/" + Resources.REST.pushApisProducts

      var connectionParameters = {
          host : this._apiCHost,
          port : this._apiCPort,
          username : this._apiCUser,
          password: this._apiCPassword,
          organizationId : this._APICOrganizationSelect.get("value")
      };
   
      if ((this._apiCCatalogId !== null) && (this._apiCCatalogId !== Resources.REST.pushApisNoStageId)) {
        connectionParameters.catalogId=this._apiCCatalogId;
      }

      xhr.post(getProductsUri, {
        handleAs : "json",
        headers : {
          "Accept" : "application/json",
          "Content-type" : "application/json"
        },
        data : JSON.stringify(connectionParameters)
      }).then(
        lang.hitch(this, function(response) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "API Connect retrieve products success");

          this._existingProducts = [];

          // This should be a list of the existing products which we used to give feedback if
          // draft product with the same name and version already exists
          if(response && response.products) {
            this._existingProducts = response.products;
          }

          // Need to test the existing value of the product to see if it is still valid, as might now clash with one of the existing ones
          this._updateTargetProductValidity(false);
        }),
        lang.hitch(this, function(error) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "API Connect retrieve products Error: " + error.response.status + " Response: " + error.response.response);
          // TODO - Error that we can't connect to APIConnect / get Products - Probably same error
          this._setPageButtonBehaviour();
        })
      );

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_targetCatalogChange");
    },
    

    _targetProductTitleChange : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_targetProductTitleChange");

      // Convert the current value into a product name.
      // Rules are that the name can only contain numbers (0-9), letters (a-zA-Z),
      // dashes (-), or underscores (_). Spaces should be converted into dashes.
      // Everything else must be dropped.
      var title = this._APICProductTitleText.get("value");
      var name = title.replace(/[^0-9a-zA-Z-_ ]/g, "");
      name = name.replace(/ /g, "-")
      this._APICProductNameText.set("value", name);

      // Call down to the function below.
      this._targetProductChange();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_targetProductChange");
    },

    _targetProductChange : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_targetProductChange");

      this._updateTargetProductValidity(true);

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_targetProductChange");
    },

    _targetAdvancedOptionsChange : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_targetAdvancedOptionsChange");

      if ((this._APICHTTPHostText.isValid() === true) && (this._APICHTTPPortText.isValid() === true) && (this._APICHTTPSHostText.isValid() === true) && (this._APICHTTPSPortText.isValid() === true)) {
        this._overridesValid=true;
      }
      else {
        this._overridesValid=false;
      }

      this._setPageButtonBehaviour();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_targetAdvancedOptionsChange");
    },

    _updateTargetProductValidity : function(productChange) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_updateTargetProductValidity", [productChange]);

      // Assume Product value is valid and test
      var error = this._success;
      var title = this._APICProductTitleText.get("value");
      var product = this._APICProductNameText.get("value");
      var version = this._APICProductVersion.get("value");
      var productMessage = null;
      var catalogMessage = null;

      if (title == "") {
        error = this._failed;
        if(productChange) {
          productMessage = NLS.pushApiTargetValuesProductTitleNonEmpty;
        }
      } else if (product == "") {
        error = this._failed;
        if(productChange) {
          productMessage = NLS.pushApiTargetValuesProductNameNonEmpty;
        }
      } else {
        if (this._APICProductVersion.isValid() === false) {
          error = this._failed;
          productMessage = NLS.pushApiTargetValuesProductVersionNonEmpty;
        }
        else if (version == "") {
          error = this._failed;
          if(productChange) {
            productMessage = NLS.pushApiTargetValuesProductVersionNonEmpty;
          }
        } else {
          var mismatch = false;
          var inDraft = false;
          var inCatalog = false;
          var mismatchTitle="";
          array.forEach(this._existingProducts, function(item) {
            if ((product === item.name) && (version === item.version)) {
              if (title === item.title) {
                inDraft = true;
                if (item.staged) {
                  inCatalog = true;
                }
              }
              else {
                mismatch = true;
                mismatchTitle = item.title;
              }
            }
          });
          if (mismatch) {
            error = this._failed;
            productMessage = string.substitute(NLS.pushApiTargetValuesProductTitleMismatch, [product, version, mismatchTitle]);
          }
          else 
          {
            if (inDraft) {
              productMessage = string.substitute(NLS.pushApiTargetValuesProductWillBeUpdated, [title, version]);
            }
            else {
              productMessage = string.substitute(NLS.pushApiTargetValuesProductWillBeCreated, [title, version]);
            }

            if ((this._apiCCatalogId !== null) && (this._apiCCatalogId !== Resources.REST.pushApisNoStageId)) {
              if (inCatalog) {
                catalogMessage = string.substitute(NLS.pushApiTargetValuesCatalogProductWillBeReplaced, [title, version, this._apiCCatalogName]);
              }
              else {
                catalogMessage = string.substitute(NLS.pushApiTargetValuesCatalogProductWillBeCreated, [title, version, this._apiCCatalogName]);
              }
            }
            else {
              catalogMessage = string.substitute(NLS.pushApiTargetValuesCatalogProductNotStage, [title, version]);
            }
          }
        }
      }

      if (productMessage) {
        this._setProductValuesFeedback(error, productMessage);
      }
      else {
        this._hideProductValuesFeedback();
      }

      if (catalogMessage) {
        this._setCatalogValuesFeedback(error, catalogMessage);
      }
      else {
        this._hideCatalogValuesFeedback();
      }

      if (error === this._success) {
        this._productValid=true;
      }
      else {
        this._productValid=false;
      }
      this._setPageButtonBehaviour();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_updateTargetProductValidity");
    },

    _switchPageNumber : function(pageNumber) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_switchPageNumber", [pageNumber]);

      this._pageIndex = pageNumber;


      switch(pageNumber) {
        case 0:
          // Remove any earlier feedback
          this._hideTestConnectionFeedback();

          domClass.add(this._pushProductSection, "restApis_pushDialog_step_hidden");
          domClass.remove(this._pushConnectionDetailsSection, "restApis_pushDialog_step_hidden");
          this._pushApisPageDescription.innerHTML = NLS.pushApisConnectionDesc;

          // Reload the catalogs
          this._targetOrganizationChange();

          // Enable/Disable buttons
          this._setPageButtonBehaviour();

          // And set the focus to the first blank/invalid field
          if ((this._APICHostText.get("value") == "") || (this._APICHostText.isValid() === false)) {
            this._APICHostText.focus();
          }
          else if ((this._APICPortText.get("value") == "") || (this._APICPortText.isValid() === false)) {
            this._APICPortText.focus();
          }
          else if (this._APICUserText.get("value") == "") {
            this._APICHostText.focus();
          }
          else if (this._APICPasswordText.get("value") == "") {
            this._APICHostText.focus();
          }
          else if (this._connectionSuccess === false) {
            this._connectButton.focus();
          }
          else {
            this._nextButton.focus();
          }
          break;

        case 1:
          // Remove any earlier feedback
          this._hideOrganizationValuesFeedback();
          this._hideProductValuesFeedback();
          this._hideCatalogValuesFeedback();

          domClass.add(this._pushConnectionDetailsSection, "restApis_pushDialog_step_hidden");
          domClass.add(this._pushSelectSection, "restApis_pushDialog_step_hidden");
          domClass.remove(this._pushProductSection, "restApis_pushDialog_step_hidden");
          this._pushApisPageDescription.innerHTML = NLS.pushApisProductDesc;
          
          // Enable/Disable buttons
          this._setPageButtonBehaviour();

          // And set the focus to the first blank/invalid field
          if (this._APICProductTitleText.get("value") == "") {
            this._APICOrganizationSelect.focus();
          }
          else if (this._APICProductTitleText.isValid() === false) {
            this._APICProductTitleText.focus();
          }
          else if ((this._APICProductNameText.get("value") == "") || (this._APICProductNameText.isValid() === false)) {
            this._APICProductNameText.focus();
          }
          else if ((this._APICProductVersion.get("value") == "") || (this._APICProductVersion.isValid() === false)) {
            this._APICProductVersion.focus();
          }
          else {
            this._nextButton.focus();
          }
          break;

        case 2:
          domClass.add(this._pushProductSection, "restApis_pushDialog_step_hidden");
          domClass.add(this._pushAdvancedSection, "restApis_pushDialog_step_hidden");
          domClass.remove(this._pushSelectSection, "restApis_pushDialog_step_hidden");
          this._pushApisPageDescription.innerHTML = NLS.pushApisSelectDesc;
          // If store hasn't been created yet, then create it
          if(!this._restApiGridInitialised) {
            this._createRESTApisTable();
          }

          // Enable/Disable buttons
          this._setPageButtonBehaviour();

          // Set focus to either the prev or push button
          if (this._apisSelected === true) {
            this._pushButton.focus();
          }
          else {
            this._previousButton.focus();
          }

          break;

        case 3:
          domClass.add(this._pushSelectSection, "restApis_pushDialog_step_hidden");
          domClass.remove(this._pushAdvancedSection, "restApis_pushDialog_step_hidden");
          this._pushApisPageDescription.innerHTML = NLS.pushApisAdvancedDesc;

          // Enable/Disable buttons
          this._setPageButtonBehaviour();

          // And set the focus to the first invalid field (ignore blank fields)
          if (this._APICHTTPHostText.isValid() === false) {
            this._APICHTTPHostText.focus();
          }
          else if (this._APICHTTPPortText.isValid() === false) {
            this._APICHTTPPortText.focus();
          }
          else if (this._APICHTTPSHostText.isValid() === false) {
            this._APICHTTPSHostText.focus();
          }
          else if (this._APICHTTPSPortText.isValid() === false) {
            this._APICHTTPSPortText.focus();
          }
          else {
            this._pushButton.focus();
          }
          break;
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_switchPageNumber");
    },

    _updateOrganizationsSelect : function(organizations) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_updateOrganizationsSelect", [organizations]);

      // Remove all existing options
      if(this._APICOrganizationSelect.getOptions().length > 0) {
        this._APICOrganizationSelect.removeOption(this._APICOrganizationSelect.getOptions());
      }

      array.forEach(organizations, lang.hitch(this, function(nextOrganization) {
        this._APICOrganizationSelect.addOption({
          disabled: false, label: nextOrganization.title, selected: true, value: nextOrganization.id
        });
      }));

      var currentOrg = this._APICOrganizationSelect.get("value");
      if(currentOrg && currentOrg === organizations[0].id) {
        // Force update
        this._targetOrganizationChange();
      } else {
        this._APICOrganizationSelect.set("value", organizations[0].id);
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_updateOrganizationsSelect");
    },

    _updateCatalogsSelect : function(catalogs) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_updateCatalogsSelect", [catalogs]);
      
      this._hideOrganizationValuesFeedback();

      // Remove all existing options
      if(this._APICCatalogSelect.getOptions().length > 0) {
        this._APICCatalogSelect.removeOption(this._APICCatalogSelect.getOptions());
      }
      catalogFound = false;

      this._APICCatalogSelect.addOption({
        disabled: false, label: this._pushApisNoStageInCatalog, selected: true, value: Resources.REST.pushApisNoStageId });

      if (catalogs.length > 0) {
        // Sort the list alphabetically
        catalogs.sort(function(a,b) {return (a.name > b.name) ? 1 : ((b.name > a.name) ? -1 : 0);} ); // Alphabetical
        
        array.forEach(catalogs, lang.hitch(this, function(nextCatalog) {
          if (nextCatalog.name && nextCatalog.sandbox) {
            this._APICCatalogSelect.addOption({
              disabled: false, label: nextCatalog.name, selected: true, value: nextCatalog.id
            });
            if ((this._apiCCatalogId != null)  && (nextCatalog.id === this._apiCCatalogId)) {
              // If the selected catalog still exists, then we leave it selected

              catalogFound = true;
            }
          }
        }));
      }

      // If no catalog yet selected then select the no-stage option
      if ((this._apiCCatalogId === null) || (catalogFound === false)) {
        this._apiCCatalogId = Resources.REST.pushApisNoStageId;
        this._apiCCatalogName = this._pushApisNoStageInCatalog;
      }

      // Ensure the selected catalog is marked
      this._APICCatalogSelect.set("value", this._apiCCatalogId);
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_updateCatalogsSelect");
    },
    
    _setPageButtonBehaviour : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setPageButtonBehaviour", [this._pageIndex]);

      switch(this._pageIndex) {
        case 0:
          this._previousButton.set("disabled", true);
          if (this._connectionSuccess === true) {
            this._nextButton.set("disabled", false);
          } else {
            this._nextButton.set("disabled", true);
          }
          this._pushButton.set("disabled", true);
          break;
        case 1:
          this._previousButton.set("disabled", false);
          if (this._productValid === true) {
            this._nextButton.set("disabled", false);
          } else {
            this._nextButton.set("disabled", true);
          }
          this._pushButton.set("disabled", true);
          break;
        case 2:
          this._previousButton.set("disabled", false);

          if ((this._connectionSuccess === true) && (this._productValid === true) && (this._apisSelected === true)) {
            this._nextButton.set("disabled", false);
            if (this._overridesValid === true) {
              this._pushButton.set("disabled", false);
            } 
            else {
              this._pushButton.set("disabled", true);
            } 
          } else {
            this._nextButton.set("disabled", true);
            this._pushButton.set("disabled", true);
          }
          break;
        case 3:
          this._previousButton.set("disabled", false);
          this._nextButton.set("disabled", true);

          if ((this._connectionSuccess === true) && (this._productValid === true) && (this._apisSelected === true) && (this._overridesValid === true)) {
            this._pushButton.set("disabled", false);
          } else {
            this._pushButton.set("disabled", true);
          }
          break;
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setPageButtonBehaviour");
    },

    _setTestConnectionFeedback : function(error, message) {

      this._setFeedbackContent(this._pushApisConnectFeedback, this._pushApisConnectFeedbackIcon, this._pushApisConnectFeedbackInfo, error, message);

    },

    _setOrganizationValuesFeedback : function(error, message) {

      this._setFeedbackContent(this._pushApisOrganizationFeedback, this._pushApisOrganizationFeedbackIcon, this._pushApisOrganizationFeedbackInfo, error, message);

    },

    _setProductValuesFeedback : function(error, message) {

      this._setFeedbackContent(this._pushApisProductFeedback, this._pushApisProductFeedbackIcon, this._pushApisProductFeedbackInfo, error, message);

    },

    _setCatalogValuesFeedback : function(error, message) {
      this._setFeedbackContent(this._pushApisCatalogFeedback, this._pushApisCatalogFeedbackIcon, this._pushApisCatalogFeedbackInfo, error, message);
    },

    _setFeedbackContent : function(summaryDiv, iconDiv, feedbackDiv, error, message) {
      switch(error) {
        case this._loading:
          domClass.remove(iconDiv, "validationIcon_error");
          domClass.remove(iconDiv, "validationIcon_valid");
          domClass.add(iconDiv, "validationIcon_loading");
          break;
        case this._success:
          domClass.remove(iconDiv, "validationIcon_error");
          domClass.remove(iconDiv, "validationIcon_loading");
          domClass.add(iconDiv, "validationIcon_valid");
          break;
        case this._failed:
          domClass.remove(iconDiv, "validationIcon_valid");
          domClass.remove(iconDiv, "validationIcon_loading");
          domClass.add(iconDiv, "validationIcon_error");
          break;
      }

      domClass.remove(summaryDiv, "restApis_pushDialog_step_hidden");
      feedbackDiv.innerHTML = message;
    },

    _hideTestConnectionFeedback : function() {
      domClass.add(this._pushApisConnectFeedback, "restApis_pushDialog_step_hidden");
    },

    _hideOrganizationValuesFeedback : function() {
      domClass.add(this._pushApisOrganizationFeedback, "restApis_pushDialog_step_hidden");
    },

    _hideProductValuesFeedback : function() {
      domClass.add(this._pushApisProductFeedback, "restApis_pushDialog_step_hidden");
    },

    _hideCatalogValuesFeedback : function() {
      domClass.add(this._pushApisCatalogFeedback, "restApis_pushDialog_step_hidden");
    },

    _setPerformPushFeedback : function(message) {
      this._setFeedbackContent(this._pushApisSelectFeedback, this._pushApisSelectFeedbackIcon, this._pushApisSelectFeedbackInfo, true, message);
    },

    _hidePerformPushFeedback : function() {
      domClass.add(this._pushApisSelectFeedback, "restApis_pushDialog_step_hidden");
    },

    _setConnectionParameters : function() {
      this._connectionSuccess = true;
      this._apiCHost = this._APICHostText.get("value");
      this._apiCPort = this._APICPortText.get("value");
      this._apiCUser = this._APICUserText.get("value");
      this._apiCPassword = this._APICPasswordText.get("value");
    },

    _setInputHandlers : function() {
      if(this._onInputHandlers.length < 13) {
        // Connection
        this._onInputHandlers.push(on(this._APICHostText, "change", lang.hitch(this, this._connectionDetailsChange)));
        this._onInputHandlers.push(on(this._APICPortText, "change", lang.hitch(this, this._connectionDetailsChange)));
        this._onInputHandlers.push(on(this._APICUserText, "change", lang.hitch(this, this._connectionDetailsChange)));
        this._onInputHandlers.push(on(this._APICPasswordText, "change", lang.hitch(this, this._connectionDetailsChange)));

        // Target Details
        this._onInputHandlers.push(on(this._APICOrganizationSelect, "change", lang.hitch(this, this._targetOrganizationChange)));
        this._onInputHandlers.push(on(this._APICCatalogSelect, "change", lang.hitch(this, this._targetCatalogChange)));
        this._onInputHandlers.push(on(this._APICProductTitleText, "change", lang.hitch(this, this._targetProductTitleChange)));
        this._onInputHandlers.push(on(this._APICProductNameText, "change", lang.hitch(this, this._targetProductChange)));
        this._onInputHandlers.push(on(this._APICProductVersion, "change", lang.hitch(this, this._targetProductChange)));
        
        // Advanced panel
        this._onInputHandlers.push(on(this._APICHTTPHostText, "change", lang.hitch(this, this._targetAdvancedOptionsChange)));
        this._onInputHandlers.push(on(this._APICHTTPPortText, "change", lang.hitch(this, this._targetAdvancedOptionsChange)));
        this._onInputHandlers.push(on(this._APICHTTPSHostText, "change", lang.hitch(this, this._targetAdvancedOptionsChange)));
        this._onInputHandlers.push(on(this._APICHTTPSPortText, "change", lang.hitch(this, this._targetAdvancedOptionsChange)));
      }
    },

    _connectionDetailsChange : function() {
      // If there has been a previously successful connection
      if(this._connectionSuccess) {
        // Need to update UI to reflect change in connection details
        this._connectionSuccess = false;
        this._setTestConnectionFeedback(this._failed, NLS.pushApiTestConnectionFieldsChanged);
      } else {
        // Check if current values are the same as when last test connection was issued
        if((this._apiCHost === this._APICHostText.get("value")) &&
          (this._apiCPort === this._APICPortText.get("value")) &&
            (this._apiCUser === this._APICUserText.get("value")) &&
              (this._apiCPassword === this._APICPasswordText.get("value"))) {
          // Connection params are valid, set to be valid again and target inputs selectable if applicable
          this._connectionSuccess = true;
          this._setTestConnectionFeedback(this._success, NLS.pushApiTestConnectionSuccess);
        }
      }
      this._setPageButtonBehaviour();
    },

    _removeContainerContent : function(container) {
      this._setContainerContent("", container);
    },

    // Set only child
    _setContainerContent : function(content, container) {
      domConstruct.place(content,container,"only");
    }
  });

  return bulkRESTApiPushNewDialog;
});

},
'webui/widgets/resources/resource_overview':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="3356849190" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define(
  "webui/widgets/resources/resource_overview",
  [
    "dojo/text!webui/widgets/resources/templates/resource_overview.html",
    "dojo/i18n!webui/nls/web",

    "dojo/dom-attr",
    "dojo/dom-construct",
    "dojo/query",
    "dojo/_base/declare",
    "dojo/_base/lang",
    "dojo/request/xhr",
    "dojo/string",

    "dijit/_WidgetBase",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/registry",

    "webui/widgets/common/AttributesStore",
    "webui/widgets/common/HasContextMenu",
    "webui/widgets/common/QuickAndAdvancedProperties",
    "webui/widgets/common/Toolbar",
    "webui/widgets/common/Trace",
    "webui/widgets/common/UIUtils"
  ],
  function(
    template,
    NLS,
    attr,
    construct,
    query,
    declare,
    lang,
    xhr,
    string,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    registry,
    AttributesStore,
    HasContextMenu,
    QuickAndAdvancedProperties,
    Toolbar,
    Trace,
    UIUtils
  ) {

	  
    var resourceOverview = declare("webui.widgets.resources.resource_overview", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
      templateString: template,
      toolbar: null,
      _attributesStore : new AttributesStore(),

      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
        this.inherited(arguments);

        // Create toolbar
        this.toolbar = new Toolbar();
        construct.place(this.toolbar.domNode, this._toolbar);
        this.toolbar.addLeftAlignButtons("title");

        this.properties = new QuickAndAdvancedProperties("resource");
        this.properties.createPropertiesContainer(this._propertyTitlePane);

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
      },

      startup: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "startup");
        this.inherited(arguments);

        // Get resource name and add to the toolbar title
        this.toolbar.setAttribute("title", "innerHTML", "");

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "startup");
      },

      tabSelected: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabSelected");

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabSelected");
      },

      contextButtonsClicks : function(event) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks");

		  // Get the URI and action from the event:
		  var uriAndAction = UIUtils.getURIAndAction(event, true);
		  var itemURI = uriAndAction.uri;
		  var buttonType = uriAndAction.action;

          if( buttonType === "delete" ){
            this.actionResource(itemURI, buttonType);
          }

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
        },

        actionResource : function(uri, action){
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionResource");


          var uriArray = uri.split("_");
          var buttonType = uriArray[uriArray.length - 1];
          uri = uri.substr(0,uri.length - buttonType.length - 1);

          if (null!=action && action === "delete" ) {

            var tree = registry.byId('_explorerTree_ID');
            var resourceName = tree.selectedNode.item.name;//label can be truncated, so use name instead
              
            var confirmationMessage = string.substitute(NLS.messages.DeleteResourceAction_confirmation, [resourceName] );
              
  	        var confirmCallback = lang.hitch(this, function() {

  	          //	Add loading icon to tree
  	          var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
  	          var oldIcon = attr.get(treeImgs[0],"class");
  	          attr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");        	

  	          // REST Call to delete the resource
  	          xhr.del(
  	              uri,
  	              {
  	                handleAs : "json",
  	                headers : {
  	                   "Accept" : "application/json"
  	                }
  	              }
  	            ).then( lang.hitch(this, function() {
  	              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Resource delete success");
  	
  	              //reset old icon
  	              attr.set(treeImgs[0],"class",oldIcon);

  	              // Display success message for deleting a resource
  	              window.smallMessage.displayPlainMessage("success", "DeleteResourceAction_successResourceDeleted", [resourceName]);
  	            }),
  	            lang.hitch(this, function(error) {
  	            	
  	              Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrDel to " + uri + " failed.", [error]);

  	              //reset old icon
  	              attr.set(treeImgs[0],"class",oldIcon);

  	              //show error message
  	              var response = JSON.parse(error.response.text);
  	              window.smallMessage.displayMessage("error", "resourcedelete_5XX",response.bipNumber, response.description);
  	              
  	            })
  	          );
  	        });
              
  	        window.wmbConsole.showConfirmationDialog("btConfirmDelete", "question", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, confirmationMessage, confirmCallback, null);
			        
          	
          	
          }//if
          


          Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionResource");
        },

      tabFocus : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");

        
        // If we switch back to the overview tab, attempt to reload the properties
        var populate = this._attributesStore.populateAttributesStore();
        populate.then(lang.hitch(this, function() {
          attr.set("_infoPaneTitleID", "innerHTML", this._attributesStore.getAttribute("name") + " - " + NLS.resourceTitle);
        }));

        // Populate quick view and advanced properties
        this.properties.populateProperties();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
       },
       
    		   
      resize: function() {
        this._msgflowOverview_borderContainer.resize();
      },

      // This function is called manually when we need to remove this tab.
      tabRemove: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");

        this.properties.unsubscribeAll();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
      },

      tabBlur: function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
      }

    });
    return resourceOverview;
  }
);

},
'webui/widgets/business/BTEditor':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2013,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.  
 * </copyright> 
 * The Business Transaction graphical editor widget.
 * Within the Event Configuration tab of the Business Transaction page, the top section contains a graphical editor implemented by this widget
 * The widget handles the addition and visualization of flows and external systems to the business transaction
 * and the visual representation of business events on the flows
 *
 */
define("webui/widgets/business/BTEditor", [
  "dojo/i18n!webui/nls/web",
  "dojo/_base/declare",
  "dijit/_WidgetBase",
  "dijit/registry",
  "webui/widgets/common/Trace",
  "webui/widgets/business/BTDialog",
  "webui/widgets/business/BTModel",
  "webui/widgets/business/BTTooltip",
  "webui/config/Resources",
  "dojo/dom",
  "dojo/dom-construct",
  "dojo/hash",
  "dojo/keys",
  "dojo/_base/lang",
  "dojo/string",
  "dojo/topic",
  "dojo/dnd/Source",
  "idx/widget/ConfirmationDialog",
  "dojo/dom-geometry",
  "dojo/dom-class",
  "dojo/on",
  "dojo/dom-style",
  "dojo/_base/array"
], function(
  NLS,
  declare,
  _WidgetBase,
  registry,
  Trace,
  BTDialog,
  BTModel,
  BTTooltip,
  Resources,
  dom,
  domConstruct,
  hash,
  keys,
  lang,
  string,
  Topic,
  Source,
  ConfirmationDialog,
  domGeom,
  domClass,
  on,
  domStyle,
  array
) {

  var BTEditor = declare("webui.widgets.business.BTEditor", [_WidgetBase], {

    widgetContainer: null,
    btName: null,
    roundedCorner : 2,
    elementWidth : 32,
    elementHeight : 32,
    borderWidth : 42,
    borderHeight : 40,
    
    // cell size
    cellWidth: 115,
    cellHeight: 85,  
    
    // adjustments on the row and column
    xDelta: 60,
    yDelta: 10,
    
      
    step: 2, // pixels when moving flows with keyboard

    width : 800, // starting width by default
    minimumWidth: 800, // forced minimum
    height : 185,
    minimumHeight: 185, // forced minimum
    iconHeight: 12,
    iconWidth: 12,

    svg: null,


    // number of pixels below which the move does not count as a change to BTD
    threshold: 3,

    dropHandle: null,
    firstTime : true,
    btModel : null,
    eventTooltipId: "btEventTooltip",

    constructor: function(/*Object*/ args){
      
      this.btName = args.name;
      args.canvasWidth = this.width;
      args.canvasHeight =  this.height;
      args.cellWidth = this.cellWidth;
      args.cellHeight = this.cellHeight;
      args.xDelta = this.xDelta;
      args.yDelta = this.yDelta;
      this.btModel = new BTModel(args);
      
      this.containerId = args.containerId;
      this._attributesStore = args.attributesStore;
      
    },

    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.widgetContainer = dom.byId("btCanvas");

      domClass.add(this.widgetContainer, "btCanvasContainer");

      var obj = domGeom.position(dom.byId("btCanvas"));
      this.width = obj.w * 0.96;
      // only reset width
      this.btModel.setCanvasDimensions(this.width, -1);
      
      this.svg= d3.select("#"+this.containerId).append("svg")
         .attr("id", "btCanvasSVG")
         .attr("class", "btCanvas")
         .attr("width", this.width)
         .attr("height", this.height)
         .on("click", lang.hitch(this, function() {
           // when user clicks away on the canvas the other components on the page need to clear their selection
           Topic.publish(Resources.pubSubTopic.businessTransaction, {"none":true, "callingHash": hash()});
           this.deselectHandler();
         }));
      
      // Add defs for image rendering.
      // So that we can use a single image from a sprite rather than a file for each individual image
      var defs = this.svg.append("defs");
      
      // Main BT Icon - heavy weight seeing as we only show it once!
      // Clip path for sizing 32 pixels
      defs.append("clipPath")
        .attr("id", "btEdit_clipPath_32")
        .append("rect")
          .attr("x", 0)
          .attr("y", 0)
          .attr("width", 32)
          .attr("height", 32);
      
      // IF THE MAIN PNG IMAGE IS CHANGED IN SIZE, THESE SIZINGS MUST BE CHANGED ACCORDINGLY      
      defs.append("image")
        .attr("id", "btEdit_image_32")
        .attr("height","32")
        .attr("width", Resources.icons.icons32pxWidth)
        .attr("xlink:href", Resources.icons.iconsLocation + Resources.icons.icons32px);
      
      // Clip path for sizing 16 pixels
      defs.append("clipPath")
        .attr("id", "btEdit_clipPath_16")
        .append("rect")
          .attr("x", 0)
          .attr("y", 0)
          .attr("width", 16)
          .attr("height", 16);
      
      // IF THE MAIN PNG IMAGE IS CHANGED IN SIZE, THESE SIZINGS MUST BE CHANGED ACCORDINGLY
      defs.append("image")
        .attr("id", "btEdit_image_16")
        .attr("height", "16")
        .attr("width", Resources.icons.icons16pxWidth)
        .attr("xlink:href", Resources.icons.iconsLocation + Resources.icons.icons16px);
        
      // The Images
      // BT Main Icon  
      defs.append("g")
        .attr("id", "btEdit_main")
        .attr("clip-path", "url(#btEdit_clipPath_32)")
        .append("use")
          .attr("xlink:href","#btEdit_image_32")
          .attr("transform","translate(-512,0)");

      // Ok Validation Icon
      defs.append("g")
        .attr("id", "btEdit_ok")
        .attr("clip-path", "url(#btEdit_clipPath_16)")
        .append("use")
          .attr("xlink:href","#btEdit_image_16")
          .attr("transform","translate(-672,0)");
      
      // Warning Validation Icon
      defs.append("g")
        .attr("id", "btEdit_warning")
        .attr("clip-path", "url(#btEdit_clipPath_16)")
        .append("use")
          .attr("xlink:href","#btEdit_image_16")
          .attr("transform","translate(-688,0)");
      
      // Business Event Icon
      defs.append("g")
        .attr("id", "btEdit_busEvent")
        .attr("clip-path", "url(#btEdit_clipPath_16)")
        .append("use")
          .attr("xlink:href","#btEdit_image_16")
          .attr("transform","translate(-704,0)");
      
      // Msg Flow Icon
      defs.append("g")
        .attr("id", "btEdit_msgFlow")
        .attr("clip-path", "url(#btEdit_clipPath_32)")
        .append("use")
          .attr("xlink:href","#btEdit_image_32")
          .attr("transform","translate(-544,0)");
      
      // Selected Flow Icon
      defs.append("g")
        .attr("id", "btEdit_selMsgFlow")
        .attr("clip-path", "url(#btEdit_clipPath_32)")
        .append("use")
          .attr("xlink:href","#btEdit_image_32")
          .attr("transform","translate(-576,0)");
      
      this.addHintToCanvas();

      // for viewing existing BTD, create the element to represet it
      if (this.btName != NLS.businessTransactionNewName) {
        this.createBTDElement();
      }

      var btCanvasDiv = dom.byId(this.containerId);

      // Select on bt canvas body
      on(btCanvasDiv,"keydown", lang.hitch(this, function(event) {
        var key = event.keyCode;
        event.stopPropagation();
        // is there any flow selected
        var selectedFlow = d3.selectAll(".bt_element").filter(function(d) { return d.selected;});
        if (selectedFlow[0].length == 0) {
          // no flow selected
          return;
        }

        if ((key == keys.LEFT_ARROW)|| (key == keys.RIGHT_ARROW) ||
          (key == keys.UP_ARROW)|| (key == keys.DOWN_ARROW)) {
          var step = this.step;
          var width = this.width;
          var height = this.height;
          
          selectedFlow.each(function (d){
            var x1 = d.pos.x;
            var y1 = d.pos.y;

            if (key == keys.LEFT_ARROW) {
              x1 = Math.max(0, d.pos.x - step);
            }
            if (key == keys.RIGHT_ARROW) {
              x1 = Math.min(width, d.pos.x + step);
            }
            if (key == keys.UP_ARROW) {
              y1 = Math.max(0, d.pos.y - step);
            }
            if (key == keys.DOWN_ARROW) {
              y1 = Math.min(height, d.pos.y + step);
            }
            var position = {x: x1, y: y1, group:1};
            d.pos = position;
            d3.select(this).attr("transform", "translate(" + x1 + "," + y1 + ")");
            this.btModel.updateState(false);
          });
        }

        if ((key == keys.DELETE)|| (key == keys.BACKSPACE)) {
          this.flowDeleteHandler(selectedFlow);
        }
      }));

      // Add focus highlighting for canvas so we know when focus is on canvas
      on(btCanvasDiv, "focus", lang.hitch(this, function() {
        domClass.add(this.containerId, "btCanvasDivHideFocus");
        d3.select("#btCanvasSVG")
          .attr("class", "btCanvas btCanvasSelected");
      }));

			// Remove highlighting when focus on canvas is lost
      on(btCanvasDiv, "blur", lang.hitch(this, function() {
        domClass.remove(this.containerId,"btCanvasDivHideFocus");
        d3.select("#btCanvasSVG")
          .attr("class", "btCanvas");
      }));

      new Source("btCanvas", { accept: ["text", "treeNode"],
        onDropExternal : function(/* source, nodes, copy */){
          //overwrite this method that does the drop to do nothing;
          // we handle the drop by subscribing to dnd/drop where we also get the event, in particular the
          // x and y coordinates where the user has clicked that we use to calculate where to draw the D3JS element
        }
      });

      this.dropHandle = Topic.subscribe(Resources.pubSubTopic.businessTransactionObjectDNDDrop, lang.hitch(this, function(source, nodes, copy, target, event) { // jshint ignore:line
        // user has dropped a flow on the canvas
        if (this.firstTime) {
          // Increase the size of the svg canvas so that it is maximum to the div size without scrolling
          this.removeHint("#btHint");
          this.firstTime = false;
          Topic.publish(Resources.pubSubTopic.businessTransaction, {"dirty": true, "callingHash": hash()});
        }

        if (source && (source.getSelectedTreeNodes()) && Array.isArray(source.getSelectedTreeNodes()) &&
          (source.getSelectedTreeNodes().length>0)) {
          var flowUri = source.getSelectedTreeNodes()[0].item.uri,
          descr = source.getSelectedTreeNodes()[0].item.description,
          flowName = flowUri;
          var i = flowUri.lastIndexOf("/");
          if (i>0) {
            flowName = flowName.substring(i+1);
          }
          if (this.btModel.containsElement(flowUri)) {
            window.smallMessage.displayMessage("warning", "BTDrop_AlreadyPresent", "", NLS.messages.BTDropAlreadyPresentDescription, [flowName]);
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Element "+flowUri+" already in the business transaction.");
            return;
          }

          var x1;
          var y1;
          if (event.target.id.indexOf("btHint")>=0) {
            // droped on the hint, add the flow to the coordinates of the hint
            x1 = 0.5*this.width;
            y1 = this.elementHeight * 2;
          }
          else {
            x1 = event.layerX;
            y1 = event.layerY;
          }
          var position = {x: x1, y: y1, group:1};
          var element =  { "uri":flowUri,
            "name": flowName,
            "type": Resources.businessTransaction.btElementTypeNamespace + Resources.businessTransaction.btElementTypeFlow,
            "description":descr,
            "events": [],
            "idValue": flowUri.replace(/\/|\./g,"_")
          };
          element.pos = position;
          this.btModel.addElement(element);
          this.drawElements();
          var editorWidget = this;

          //now select the newly added widget
          this.svg.selectAll(".bt_element")
          .filter(function(d) {
            return (flowUri === d.uri) ? this : null;
          })
          .each(function (d) {
            var btElement = d3.select(this);
            // Publish out to notify the event table that a new flow has been added
            Topic.publish(Resources.pubSubTopic.businessTransaction, {"flowAdded": true, "messageFlow": d, "selected": true, "callingHash": hash()});
            editorWidget.flowSelectedHandler(d, btElement, true);
          });

          this.validateBT();
        }
      }));

      this.addFlowHandle = Topic.subscribe(Resources.pubSubTopic.businessTransactionFlowAdd, lang.hitch(this, function(event) {
        
        // Only run if the hash is still the same
        if(hash() === event.callingHash) {
          // user has added a flow on the canvas
          if (this.firstTime) {
            // Increase the size of the svg canvas so that it is maximum to the div size without scrolling
            this.removeHint("#btHint");
            this.firstTime = false;
            Topic.publish(Resources.pubSubTopic.businessTransaction, {"dirty": true, "callingHash": hash()});
          }

          var flowUri = event.id,
          flowName = flowUri;
          var i = flowUri.lastIndexOf("/");
          if (i>0) {
            flowName = flowName.substring(i+1);
          }
          // shouldn't happen once the list is filtered
          if (this.btModel.containsElement(flowUri)) {
            window.smallMessage.displayMessage("warning", "BTDrop_AlreadyPresent", "", NLS.messages.BTDropAlreadyPresentDescription, [flowName]);
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Element "+flowUri+" already in the business transaction.");
            return;
          }

          // compute a reasonable position for the new flow
          if (this.btModel.maxNumberOfFlowsReached()) {
            this.increaseCanvas();
          }
          else {
            this.removeHint("#btFlowHint");
          }
          var result = this.btModel.getNextPosition();
          var  x1 = result.x,
            y1 = result.y;
          
          //TODO compute a suitable position for the new flow on canvas
          var position = {x: x1, y: y1, group:1};
          var element =  { "uri":flowUri,
             "name": flowName,
             "type": Resources.businessTransaction.btElementTypeNamespace + Resources.businessTransaction.btElementTypeFlow,
             "events": [],
             "idValue": flowUri.replace(/\/|\./g,"_")
          };
          element.pos = position;
          this.btModel.addElement(element);
          this.drawElements();
          var editorWidget = this;
          var selectFlow = event.selected;

          //now select the newly added widget
          this.svg.selectAll(".bt_element")
           .filter(function(d) {
              return  (flowUri === d.uri)? this: null;  })
           .each(function (d) {
              var btElement = d3.select(this);
              // Publish out to notify the event table that a new flow has been added
              Topic.publish(Resources.pubSubTopic.businessTransaction, {"flowAdded": true, "messageFlow": d, "selected": selectFlow, "callingHash": hash()});
              if (selectFlow) {
                editorWidget.flowSelectedHandler(d, btElement, true);
              }
           });

          this.validateBT();
        }
      }));

      if (this.btName) {
        this.updateBTDHandle = Topic.subscribe(Resources.pubSubTopic.businessTransaction, lang.hitch(this, function(event) {
          if (event.update){
            this.createBTDElementWithAnimation(event.shadow);
          }
        }));
      }

      this.newBTDHandle = Topic.subscribe(Resources.pubSubTopic.businessTransactionNew, lang.hitch(this, function(event) {
        if (event.newBTD){
          this.btName = event.newBTD;
          this.btModel = new BTModel({"name":event.newBTD, 
            "description": event.description,
            "canvasWidth" : this.width,
            "canvasHeight" :  this.height,
            "cellWidth" : this.cellWidth,
            "cellHeight": this.cellHeight,
            "xDelta" : this.xDelta,
            "yDelta" : this.yDelta

          });
          this.createBTDElementWithAnimation(event.shadow, true);
        }
      }));
      // create a business Event decoration to
      // hold the expanded version of business event information
      this.eventTooltip = new BTTooltip(true, this.eventTooltipId, "", "btCanvas");
      // Add the tooltip to the main flow profile container.
      var toolTipContainer = d3.select("#btCanvas");
      toolTipContainer.append("div")
        .attr("id", this.eventTooltipId);
      domClass.add(this.eventTooltipId, "event_tooltip event_tooltip_hidden");

      // Add the hidden tooltip to the diagram, now prepared for rendering
      domConstruct.place(this.eventTooltip.domNode, this.eventTooltipId);

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },
    

    removeHint: function(id){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "removeHint");
      this.svg.select(id).remove();
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "removeHint");

    },

    deleteFlowByUri: function(uri){
      // called from the editor "Delete flow" button to delete the selected
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "deleteFlowByUri");
      var selectedFlow =d3.selectAll(".bt_element").filter(function(d) { return d.uri === uri;});
      if (selectedFlow[0].length == 0) {
        // no flow selected
        return;
      }

      this.flowDeleteHandler(selectedFlow);
      window.smallMessage.hideMessage();
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "deleteFlowByUri");
    },

    flowDeleteHandler: function(selectedFlow) {
      // deletes the selected flow, whether from pressing the delete key while on the editor or from the editor button
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "flowDeleteHandler");
      if (d3.event) {
        d3.event.stopPropagation();
      }

      selectedFlow.each(lang.hitch(this, function (d){
        var btConfirmDeleteFlowDialog = registry.byId("btConfirmDeleteFlowDialog");
        var bodyText = string.substitute(NLS.btConfirmDeleteFlow, [d.name]);
        if (!btConfirmDeleteFlowDialog) {
          domConstruct.place(domConstruct.create("div", { id: "btConfirmDeleteFlowDialog" }),"btConfirmDeleteFlow");
          btConfirmDeleteFlowDialog = new ConfirmationDialog( {
            type : "question",
            buttonLabel : NLS.btRemove,
            cancelButtonLabel : NLS.btCancel,
            text : bodyText
          }, "btConfirmDeleteFlowDialog");
          // Set keypress/click on ok up, only once
          btConfirmDeleteFlowDialog.confirm(lang.hitch(this, function() {
            this.removeSelectedFlowFromBTD();
          }));

          on(btConfirmDeleteFlowDialog, "keydown", lang.hitch(this, function (event){
            // Move the focus accordingly if the arrow keys are pressed
            var key = event.keyCode;
            if ((key == keys.LEFT_ARROW) && btConfirmDeleteFlowDialog.closeAction.focused) {
              btConfirmDeleteFlowDialog.confirmAction.focus();
            }
            else if ((key == keys.RIGHT_ARROW) && btConfirmDeleteFlowDialog.confirmAction.focused){
              btConfirmDeleteFlowDialog.closeAction.focusNode.focus();
            }
            // Extend confirm/close function to close on Enter key press
            if (key == keys.ENTER) {
              if(btConfirmDeleteFlowDialog.confirmAction.focused) {
                this.removeSelectedFlowFromBTD();
                btConfirmDeleteFlowDialog.hide();
              } else {
                if(btConfirmDeleteFlowDialog.closeAction.focused) {
                  btConfirmDeleteFlowDialog.hide();
                }
              }
            }
            // Stop the keyboard event propagating i.e. moving a flow on the canvas
            event.stopPropagation();
          }));
        } else {
          btConfirmDeleteFlowDialog._setTextAttr(bodyText); // TODO: don't invoke private method!
        }
        btConfirmDeleteFlowDialog.show();
      }));
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "flowDeleteHandler");
    },

    addHintToCanvas: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "addHintToCanvas");
      var hint = this.svg.append("text")
        .attr("id", "btHint")
        .attr("class", "btHint")
        .attr("x", 0.5*this.width)
        .attr("y", this.elementHeight * 2);
      hint.append("tspan")
        //.attr("x", 20)
       // .attr("y", 20)
        .attr("id", "btHintSpan")
        .attr("class", "node-text")
        .text(function() { return NLS.btStartHint;});
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "addHintToCanvas");
    },


    /*
     * Method used to show an existing Business Transaction Definition
     * The BTD, read from the RDF store via a REST call is available in the PropertiesStore
     * It is used to populate the BT model and then drawn in the top section
     * REST calls to get the monitoring events are initiated and the event definition table is populated
     */
    showBTD :function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "showBTD");
      // construct the model to match what is being built in the editor
      var descr = this._attributesStore.getAttribute("description");
      if (descr) {
        this.btModel.description = descr;
      }
      var flows = this._attributesStore.getAttribute("elements");
      // This only needs to be run / subscribed to when an existing BTD has flows already added.
      if (flows.length > 0) {
        var eventsForFlowsReceived =  flows.slice(0);// copy
        this.eventBTDHandle = Topic.subscribe(Resources.pubSubTopic.businessTransaction, lang.hitch(this, function(event) {
          if (event.gotEvents){
            var uri = event.messageFlow;
            for(var i= eventsForFlowsReceived.length-1; i >=0; i--) {
              if(eventsForFlowsReceived[i].elementUri === uri) {
                break;
              }
            }
            if (i>=0) {
              eventsForFlowsReceived.splice(i,1);
            }
            if (eventsForFlowsReceived.length==0) {// got the events for all flows from the BTS
              this.btModel.unsavedChanges = false;
              // all events now received
              Topic.publish(Resources.pubSubTopic.businessTransaction, {"gotAllEvents":true, "callingHash": hash()});
              // Need to kill the handler now as this no longer applies otherwise will be called on further flow adds and affect the unsaved changes state.
              this.eventBTDHandle.remove();
            }
        }
        }));

        this.removeHint("#btHint");

        var bEvents = this._attributesStore.getAttribute("businessEvents");
        if (bEvents) {
          Object.keys(bEvents).forEach(lang.hitch(this, function(eventType) {
            var events = bEvents[eventType]; // start, end or failure
            array.forEach(events, lang.hitch(this, function(event){
              var eventRole = Resources.businessTransaction.btEventDoNotFlag;
              if (eventType === Resources.REST.businessEvents.progress) {
                eventRole = Resources.businessTransaction.btEventProgress;
              }
              else if (eventType === Resources.REST.businessEvents.start) {
                eventRole = Resources.businessTransaction.btEventStart;
              }
              else if (eventType === Resources.REST.businessEvents.end) {
                eventRole = Resources.businessTransaction.btEventEnd;
              }
              else if (eventType === Resources.REST.businessEvents.fail) {
                eventRole = Resources.businessTransaction.btEventFailure;
              }
              // For now add only the information we have got for the event as for now this is all that is needed to render and form the definition
              var monitorEvent = {nodeId: event.nodeName, flowUri: event.flowUri, role: eventRole, eventSourceAddress: event.eventSourceAddress, uri: event.eventUri};

              this.btModel.changeEvent(eventRole, monitorEvent, event.flowUri, true);
            }));
          }));

          array.forEach(flows, lang.hitch(this, function(element){
            // If the flow has not being added yet to the model, then add it
            if(!this.btModel._doesFlowElementExist(element.elementUri)) {
              var modelElement =  { "uri":element.elementUri,
                  "name": element.name,
                  "type": element.type,
                  "description": element.description,
                  "idValue": element.elementUri.replace(/\/|\./g,"_")
                };
      
                // Associate the monitoring event that is the business event on this flow (for individual flow decoration)
                modelElement.businessEvents = [];
                for (var i=0; i<this.btModel.businessEvents.length; i++) {
                  if (this.btModel.businessEvents[i].parentFlow === element.elementUri) {
                    modelElement.businessEvents.push(this.btModel.businessEvents[i].monitorEvent);
                  }
                }
      
                modelElement.pos = {"x":element.xCoord, "y":element.yCoord};
                this.btModel.addElement(modelElement, true);
            }
          }));
        }
      for (var i=0; i<this.btModel.elementsArray.length; i++) {
        Topic.publish(Resources.pubSubTopic.businessTransaction, {"flowAdded": true, "messageFlow": this.btModel.elementsArray[i], "selected": false, "callingHash": hash()});
      }

        // Update the canvas sizing according to the positioning of the nodes so that all are visible
        if((this.btModel != null) && (this.btModel.elementsArray.length > 0)) {
          var nodeMaximumXPos = this.minimumWidth;
          // Get the greatest X value across all nodes in the model
          array.forEach(this.btModel.elementsArray, lang.hitch(this, function(element) {
            if(element.pos.x > nodeMaximumXPos) {
              nodeMaximumXPos = element.pos.x;
            }
          }));
          // If canvas needs widening then widen
          if(nodeMaximumXPos > this.svg.attr("width")) {
            this.width = nodeMaximumXPos + this.elementWidth;
            this.btModel.setCanvasDimensions(this.width, -1);            
            this.svg.attr("width",this.width);
          }
        }

        // now that we have all the data in the model, flows and events, we can draw
        this.drawElements();
        // add the business event decorations for flows, if any
        if (this.btModel.businessEvents.length > 0) {
          array.forEach(this.btModel.businessEvents, lang.hitch(this, function (event) {
            this.addFlowDecoration(event.role, event.monitorEvent, event.parentFlow, true);
          }));
        }
        // validate the business transaction definition
        this.validateBT();
      }
      if (this.btModel.maxNumberOfFlowsReached()) {
        this.increaseCanvas();
      }
      else {
        this.removeHint("#btFlowHint");
      }
     Trace.trace(this.declaredClass, Trace.levels.EXIT, "showBTD");
    },

    createBTDElementWithAnimation: function(shadow) {
      if (shadow) {
        var shadowElement = this.svg.append("rect");
        shadowElement
          .style("fill", "none")
          .style("stroke", "white")
          .style("stroke-width", "1")
          .attr("x",shadow.x)
          .attr("y",shadow.y)
          .attr("width",shadow.w)
          .attr("height",shadow.h)
          .attr("rx", 3)
          .attr("ry", 3)
          .transition()
          .duration(750)
          .style("fill","none")
          .style("stroke", "grey")
          .style("stroke-width", "3")
          .attr("x",0)
          .attr("y",0)
          .attr("width",this.elementWidth)
          .attr("height",this.elementHeight)
          .each("end", lang.hitch(this, function() {
            shadowElement.remove();
          }));
       }
       else {
         this.createBTDElement();
       }
    },

    /*
    * This is used for removing invalid flows from the BTD, 
    * The flow is not selected
    */
    
    removeFlowFromBTD :function(flowUri){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "removeFlowFromBTD");
      // find the graphical element corresponding to the flow with this uri
      
      var btEl =d3.selectAll(".bt_element") 
      .filter(function(d) {
        if (d.uri === flowUri) {  return true;}
        else { return false;}
      });

      btEl.remove();
      this.btModel.removeElement(flowUri);
      if (this.btModel.elementsArray.length ==0) {
        // no flows left
        // add back the hint
        this.addHintToCanvas();
        this.firstTime = true;

      // Notify the summary widget and event table that the flowUri has been removed
      Topic.publish(Resources.pubSubTopic.businessTransaction, {"businessEvent":flowUri, "deleted": true, "flowUri": flowUri, "callingHash": hash()});
      }
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "removeFlowFromBTD");
    },


    removeSelectedFlowFromBTD:function(){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "removeSelectedFlowFromBTD");
      var flowUri ="";
      var declaredClass = this.declaredClass;
      var btEl =d3.selectAll(".bt_element").filter(function(d) {
        if (d.selected) {
          flowUri = d.uri;
          Trace.trace(declaredClass, Trace.levels.DEBUG, "Deleting flow "+ d.uri);
        }
        return d.selected? this: null;
      });
      btEl.attr("selected", true);
      // Always should return a match, otherwise it is unknown what should be deleted.
      if(flowUri != "") {
        if (this.eventTooltip.hasFlowTooltip(this.eventTooltipId, flowUri)) {
          this.eventTooltip.hideTooltip();
        }
        btEl.remove();
        this.btModel.removeElement(flowUri);
        if (this.btModel.elementsArray.length ==0) {
          // no flows left
          // add back the hint
          this.addHintToCanvas();
          this.firstTime = true;
        }
        if (!this.btModel.maxNumberOfFlowsReached()) {
          this.removeHint("#btFlowHint");
        } 

        // Notify the summary widget and event table that the flowUri has been removed
        Topic.publish(Resources.pubSubTopic.businessTransaction, {"businessEvent":flowUri, "deleted": true, "flowUri": flowUri, "callingHash": hash()});
      }
      // else nothing to delete
      // Stop the event bubbling - across browsers
      if (event && event.stopPropagation) {
        event.stopPropagation();
      }
      if (event && event.cancelBubble != null) {
        event.cancelBubble = true;
      }
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "removeSelectedFlowFromBTD");
    },

    destroy: function(){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "destroy");
      this.inherited(arguments);
      if (this.dropHandle) {
        this.dropHandle.remove();
      }
      if (this.eventTooltip != null) {
          this.eventTooltip.destroy();
      }
      if (this.eventBTDHandle) {
        this.eventBTDHandle.remove();
      }
      if (this.addFlowHandle) {
        this.addFlowHandle.remove();
      }
      // Remove delete dialog for this editor instance
      var btConfirmDeleteFlowDialog = registry.byId("btConfirmDeleteFlowDialog");
      if (btConfirmDeleteFlowDialog != null) {
        btConfirmDeleteFlowDialog.destroy();
      }

      this.eventTooltipId = undefined;

      domConstruct.empty(this.widgetContainer);

      // Remove the child g which holds the diagram from the business transaction profile
      d3.select("#btCanvas").select("g").remove();
      this.btModel.clear();

      if (this.newBTDHandle){
        this.newBTDHandle.remove();
      }
      if (this.updateBTDHandle){
        this.updateBTDHandle.remove();
      }
      window.smallMessage.hideMessage();
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "destroy");
    },


    createBTDElement:function(){
      var btSummaryGroup = this.svg.selectAll(".btInfo")
      .data([this.btModel])
      .enter()
      .append("g")
      .attr("class","btInfo")
      .attr("id","btSummaryGroup");
      
      btSummaryGroup.append("use")
        .attr("id","btSummaryIcon")
        .attr("xlink:href","#btEdit_main");
      
      // Insert additional rect element to cover image mouseover/clicks - as this breaks in IE
      btSummaryGroup.append("rect")
      .attr("width", 34)
      .attr("height", 34)
      .attr("y", -1)
      .attr("x", -1)
      .attr("class", "svg-use-coverage")
      .on("click", lang.hitch(this, function(){
        var canvasGeom = domGeom.position(dom.byId("btCanvas"));
        var btDialog = registry.byId("createBTDDialog");
        if (!btDialog) {
          btDialog = new BTDialog( {
            id : "createBTDDialog"
          });
          btDialog.startup();
        }
        var val ={"btName": this.btModel.btName, "btDescription": this.btModel.description, "btNew": false, "btModel": this.btModel};
        btDialog.setInitialValues(val);

        btDialog.refresh();
        var svg = this.svg;
        var elementWidth = this.elementWidth;
        var elementHeight = this.elementHeight;
        domStyle.set(btDialog.domNode, 'visibility', 'hidden');

        btDialog.show().then(function () {
          var dialogGeom = domGeom.position(dom.byId("createBTDDialog"));
          var x1 = Math.max(0, Math.min(canvasGeom.w, dialogGeom.x - canvasGeom.x ));
          var y1 = Math.max(0, Math.min(canvasGeom.h, dialogGeom.y - canvasGeom.y));

          var visual = svg.append("rect");
          visual.style("fill", "none")
            .style("stroke", "white")
            .style("stroke-width", "1")
            .attr("x",0)
            .attr("y",0)
            .attr("id", "btDialogShadow")
            .attr("width",function() {
              return elementWidth;
            })
            .attr("height", function () {
              return elementHeight;
             })
            .attr("rx", 3)
            .attr("ry", 3)
            .transition()
            .duration(600)
            .style("fill","none")
            .style("stroke", "grey")
            .style("stroke-width", "3")
            .attr("x",x1)
            .attr("y",y1)
            .attr("width",function (){
              return dialogGeom.w;
            })
            .attr("height",function() {
              return dialogGeom.h;
            })
            .each("end", function() {
              svg.select("#btDialogShadow").remove();
              domStyle.set(btDialog.domNode, 'visibility', 'visible');
              btDialog.setGeomAttributes(canvasGeom, dialogGeom);
            });
        });
      }));
    },

    /*
     * callback for a user interaction with the monitoring events definition table
     * invoked when a monitoring event has been promoted or demoted
     */
    changeEvent: function(newValue, event, flowUri) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "changeEvent");
        // store the change in the model
      this.btModel.changeEvent(newValue, event, flowUri);

      // decorate the flow (or remove decoration)
      this.addFlowDecoration(newValue, event, flowUri);
      // refresh the BT validation
      this.showBTValidationExtended(false, this.btModel);
      this.validateBT();
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "changeEvent");
    },

    /*
     * A flow can have a number of monitoring events
     * One or more of these have been promoted as business events (start, fail, end)
     * Based on which business event definitions the flow has, decorate with the right icon
     * and compute a toolkit that describes the business events for the flow
     */
    addFlowDecoration: function(eventRole, event, flowUri, skipAnimation) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "addFlowDecoration");

      var eventTooltipId = this.eventTooltipId;
      var eventTooltip = this.eventTooltip;
      var eWidth = this.elementWidth;
      var eHeight = this.elementHeight;
      var beType = Resources.btValidation.businessEventsType;
      var flowIdValue = "";

      // select the SVG element corresponding to the flow that is being modified and
      // compute a list of business events for the flow
      var flow = this.svg.selectAll(".bt_element")
      .filter(function(d) {
        // find the graphical element corresponding to the flow whose monitoring events have been promoted or demoted
        if (d.uri === flowUri) { // that's the flow
					flowIdValue = d.idValue;
          return true;
        }
        else { return false;}
      })
      .each(function(d) {
        var tempSquare;
        if (!skipAnimation) {
          // temporary highlight
          tempSquare=d3.select(this).append("rect")
          .style("fill", "none")
          .style("stroke", "white")
          .style("stroke-width", "1")
          .attr("x",-2)
          .attr("y",0)
          .attr("width",eWidth+4)
          .attr("height",eHeight)
          .attr("rx", 3)
          .attr("ry", 3)
          .transition()
          .duration(2000)
          .style("fill","none")
          .style("stroke", "grey")
          .style("stroke-width", "3")
          .attr("x",-4)
          .attr("y",-2)
          .attr("width",eWidth+8)
          .attr("height",eHeight+4);
        }

        if (!d.businessEvents){
          // store in the data associated with the svg element the list of business events
          d.businessEvents = [];
        }
        var modifiedElement =array.filter(d.businessEvents, function(item) {
          if (item && (item.uri === event.uri)) { return true;}
          else { return false;}
        });
        if (modifiedElement.length == 0) {
          // This is a new event that is being promoted add to the tooltip
          if (eventRole !== Resources.businessTransaction.btEventDoNotFlag) {
            // If the event is being promoted add it to the array of business events
            d.businessEvents.push(event);
          }
        } else { // the business event that is being modified has been previously promoted
          array.forEach(modifiedElement, function(element){
            var i = d.businessEvents.indexOf(element);
            if (eventRole === Resources.businessTransaction.btEventDoNotFlag) { //remove
              d.businessEvents.splice(i, 1);
            }
            else { // the role has changed e.g. from end to failure
              element.role = eventRole;
            }
          });
        }
        if (d.businessEvents.length == 0) {
          // no business events left for this flow
          // remove decoration
          d3.select(this)
          .select("#business_events" + d.idValue)
          .remove();
          // if the expanded decoration for this flow is shown, hide it
          // now that there are no business events for the flow
          if (eventTooltip.hasFlowTooltip(eventTooltipId, d.uri) && eventTooltip.type === beType){
            eventTooltip.hideTooltip();
          }
        }
        if (tempSquare) {
          tempSquare.remove();
        }
        
      });
      // if there are no business events left, no decoration to add
      var result = array.filter(this.btModel.elementsArray,function(item){
        return (item.uri=== flowUri);
      });
      if (result.length >0 ){
         if (result[0].businessEvents.length ===0) {
           return;
         }
      }
      // construct or update the decoration
      var iW = this.iconWidth;
      var iH = this.iconHeight;
      eventTooltip = this.eventTooltip;

      // find out if the SVG for this flow has a business event decoration
      // if it has, update it with the new icon and tooltip
      // if not, create the decorations
      var beGroup = flow.select("#business_events" + flowIdValue);
      if (beGroup.empty()) { // none found, create the decoration
        var businessEvents = flow.append("g")
          .attr("id",lang.hitch(this, function(d) {
          	return "business_events" + d.idValue;
        	}))
          .on("click", lang.hitch(this, function(d){
            this.showBusinessEventsExtended(true, d);
            if (d3.event) {
              d3.event.stopPropagation();
            }
          }));
        
        businessEvents.append("use")
          .attr("id",lang.hitch(this, function(d) {
          	return "be_eventsIcon" + d.idValue;
        	}))
          .attr("y", function() {return 2 - iH;})
          .attr("x", function() {return 4 - iW;})
          // Assume all are the same for now - should return the same image
          .attr("xlink:href", "#btEdit_busEvent")
          .attr("class", "node-event-icon");
        
        // Insert additional rect element to cover image mouseover/clicks - as this breaks in IE  
        businessEvents.append("rect")
          .attr("width", 18)
          .attr("height", 18)
          .attr("y", function() {return 2 - iH - 1;})
          .attr("x", function() {return 4 - iW - 1;})
          .attr("class", "svg-use-coverage")
          .append("title")
            .attr("id",lang.hitch(this, function(d) {
            	return "be_tooltip" + d.idValue;
          	}))
            .text(lang.hitch(this, function(d) { return this.btModel.computeEventsTooltipInformation(d); }));
      } else {
        // found, update icon and tooltip
        flow.select("#be_eventsIcon" + flowIdValue)
        .attr("xlink:href", "#btEdit_busEvent");
        flow.select("#be_tooltip" + flowIdValue)
        .text(lang.hitch(this, function(d) {
          if (this.eventTooltip.type === Resources.btValidation.businessEventsType) {
            this.showBusinessEventsExtended(false, d);
          }
          return this.btModel.computeEventsTooltipInformation(d);
        }));

      }
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "addFlowDecoration");
    },

    /**
     * creates or updates the content of the extended tooltip for business events
     */
    showBusinessEventsExtended: function(create, d) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "showBusinessEventsExtended");
      if (create || this.eventTooltip.hasFlowTooltip(this.eventTooltipId, d.uri)) {
        var eventPolicy = {};
        eventPolicy.predicates = [];
        array.forEach(d.businessEvents, function(event) {
          var predicate = {};
          predicate.name="";
          predicate.address = event.source;
          eventPolicy.predicates.push(predicate);
        });
        this.eventTooltip.setBusinessEventsAttributes(Resources.btValidation.businessEventsType, this, d.businessEvents, d.uri);
        this.eventTooltip.showTooltip(d, eventPolicy,  d.pos.x+this.elementWidth, d.pos.y+this.iconHeight/5, true);
        this.eventTooltip.set("data-node-id", d.uri);
        if (d3.event) {
          d3.event.stopPropagation();
        }
      }
      //else nothing to show
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "showBusinessEventsExtended");
    },

		/**
     * Creates or updates the content of the extended tooltip for Flow summary
     */
    showFlowValidationExtended: function(flowUri, flowEventData, d) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "showFlowValidationExtended");
      if(typeof this.eventTooltip !== "undefined") {
      	this.eventTooltip.setBusinessEventsAttributes(Resources.btValidation.flowValidationType, this, flowEventData, flowUri);
        this.eventTooltip.showTooltip(d, null, d.pos.x+5/4*this.elementWidth, d.pos.y+this.iconHeight/5, true);
        if (d3.event) {
        	d3.event.stopPropagation();
        }
      }
      //else nothing to show
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "showFlowValidationExtended");
    },

    /**
     * Creates or updates the content of the extended tooltip for BTSummary
     */
    showBTValidationExtended: function(create, d) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "showBTValidationExtended");
      if (create || this.eventTooltip.hasFlowTooltip(this.eventTooltipId, d.uri)) {
        var eventPolicy = {};
        eventPolicy.predicates = [];
        if (d && d.businessEvents) {
          array.forEach(d.businessEvents, function(event) {
            var predicate = {};
            predicate.name="";
            predicate.address = event.source;
            eventPolicy.predicates.push(predicate);
          });
        }
        var validateData = this.btModel.validateModel();
        this.eventTooltip.setBusinessEventsAttributes(Resources.btValidation.btValidationType, this, validateData, d.uri);
        this.eventTooltip.showTooltip(d, eventPolicy, 5/4*this.elementWidth, this.iconHeight/5, true);
        if (d3.event) {
          d3.event.stopPropagation();
        }
      }
      //else nothing to show
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "showBTValidationExtended");
    },

    addFlowEventsToModel: function(flowUri, events) {
      this.btModel.addFlowElementMonitoringEvents(flowUri, events);
      // Now update the validation model for that flow
      this.updateFlowElementValidation(flowUri);
    },

    removeFlowFromModel: function(flowUri) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "removeFlowFromModel");

      this.btModel.removeFlowElementMonitoringEvents(flowUri);
      this.btModel.removeFlowBTMEvents(flowUri);
      // Now update the validation model for the BT
      this.validateBT();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "removeFlowFromModel");
    },

    getFlowEventsFromModel: function(flowUri) {
      return this.btModel.getFlowElementMonitoringEvents(flowUri);
    },

    drawElements: function () {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "drawElements");
        //draw elements
      var elementHeight = this.elementHeight;
      var height = this.height;
      var elementWidth = this.elementWidth;
      var iconWidth = this.iconWidth;
      var iconHeight = this.iconHeight;
      var eventTooltip = this.eventTooltip;
      var eventTooltipId = this.eventTooltipId;
      var svg = this.svg;
      var updateFunction = lang.hitch(this, function() {
        this.btModel.updateState(false);
      });
      var threshold = this.threshold;

      var g = this.svg.selectAll(".bt_element")
      .data(this.btModel.getElementsArray())
      .enter()
      .append("g")
      .attr("class", "bt_element")
      .attr("transform", function(d) {
        return "translate(" + d.pos.x + "," + d.pos.y + ")";
      })
      .call(d3.behavior.drag()
        .origin(function(d) { return d; })
        // Dragmove function determines the drag behaviour of a selected and dragged node, moving the flow.
        .on("drag", function(d) {
          // Reposition based on dx and dy movement and update accordingly to re-draw.
          var x1 = d.pos.x + d3.event.dx;
          // Use the current width of canvas as this might have changed with window resizing
          x1 = Math.max(0 + (elementWidth/2), Math.min(svg.attr("width" ) - elementWidth, x1));

          var y1 = d.pos.y + d3.event.dy;
          y1 = Math.max(0 + (elementHeight/2), Math.min(height - elementHeight, y1));

          var position = {x: x1, y: y1, group:1};
          d.pos = position;
          if (eventTooltip.hasFlowTooltip(eventTooltipId, d.uri)){
            eventTooltip.updatePosition(d.pos.x+elementWidth, d.pos.y+iconHeight/5);
          }
          d3.select(this).attr("transform", "translate(" + x1 + "," + y1 + ")");
          if ((Math.abs(d3.event.dx)<threshold) && (Math.abs(d3.event.dy)<threshold)) {
            // this is a selection not a drag, do nothing
            return;
          }
          else {
            updateFunction();
          }
        })
      );

      g.append("use")
        .attr("id",lang.hitch(this, function(d) {
         	return "flowIcon" + d.idValue;
        }))
        .attr("xlink:href", "#btEdit_msgFlow");
      
      // Insert additional rect element to cover image mouseover/clicks - as this breaks in IE
      g.append("rect")
        .attr("width", 34)
        .attr("height", 34)
        .attr("x", -1)
        .attr("y", -1)
        .attr("class", "svg-use-coverage");
      

      var flowValidationElement = g.append("g")
        .attr("id",lang.hitch(this, function(d) {
         	return "flowValidation" + d.idValue;
        }));
        
      flowValidationElement.append("use")
        .attr("id",lang.hitch(this, function(d) {
          return "flowValidationIcon" + d.idValue;
        }))
        .attr("y",  function() {return 2 - iconHeight;})
        .attr("x",  function() {return (2 * iconWidth) - 2;})
        .attr("class", "node-event-icon");

      // Insert additional rect element to cover image mouseover/clicks - as this breaks in IE
      flowValidationElement.append("rect")
        .attr("width", 18)
        .attr("height", 18)
        .attr("y",  function() {return 2 - iconHeight - 1;})
        .attr("x",  function() {return (2 * iconWidth) - 3;})
        .attr("class", "svg-use-coverage");
        
      g.append("title")
      .attr("id", lang.hitch(this, function(d) {
        return "flowElementTooltip" + d.idValue;
      }))
      .text( lang.hitch(this, function(d) { return this.btModel.computeTooltipInformation(d); }));

      var flowHeight = this.elementHeight;
      var flowWidth = this.elementWidth;
      
      g.append("svg")
      .each( function(d) {
        var svg = d3.select(this)
        .attr("overflow", "visible")
        .attr("y", function() { return flowWidth - 7; })
        .attr("width", flowWidth)
        .attr("height", flowHeight - 10);
        // Add the text element to enclose the text lines
        var text = svg.append("text")
        .attr("id", "flowLabel" + d.idValue)
        .attr("y", 5)
        .attr("class", "node-text");

        // Get an array of lines split by newline delimeter.
        var lines = d.flowLabel.split("\n");
        var ySpacing = (flowHeight / 2) - 1;

        lines.forEach( function(line,j) {
          // Sets the text displayed on the node
          text.append("tspan")
            .attr("x", flowWidth / 2)
            .attr("y", ySpacing * (j + 1))
                .text(line);
        });
      });
      var editorWidget = this;
      g.on("click", function(d) {
        var btElement = d3.select(this);
        if(!d.selected) {
          editorWidget.flowSelectedHandler(d, btElement, false);
        }
        d3.event.stopPropagation();
      });
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "drawElements");
    },

    updateFlowTooltipInformation: function(flow) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "updateFlowTooltipInformation");

			var flowIdValue = "";

      // Get the flow which needs tooltip information updating
      this.svg.selectAll(".bt_element")
        .filter( function(d) {
          if(flow.uri === d.uri) {
	          flowIdValue = d.idValue;
            return this;
          } else {
            return null;
          }
        })
        .select("#flowElementTooltip" + flowIdValue)
        .text(this.btModel.computeTooltipInformation(flow));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "updateFlowTooltipInformation");
    },

    flowSelectedHandler: function(d, btElement, onDrop) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "flowSelectedHandler");

      this.deselectHandler();

      // make the selection more visible
      var txt = btElement.select("#flowLabel" + d.idValue);
      txt.attr("class", "flowElementHighlighted");
      var img = btElement.select("#flowIcon" + d.idValue);
      img.attr("xlink:href", "#btEdit_selMsgFlow");

      btElement.selected = true;
      btElement.attr("selected", true);

      // If drop, then don't publish on topic, as updates will be handled by initial drop call
      if(!onDrop) {
        // Publish the new selection for the editor to update the other sections
        Topic.publish(Resources.pubSubTopic.businessTransaction, {"flow":d, "callingHash": hash()});
      }

      d.selected = true;

      // Set the div canvas to be focused, such that keyboard events (i.e. delete) will work.
      dom.byId("btCanvas").focus();

      // do not propagate for the canvas to get the event;
      if (d3.event) {
        d3.event.stopPropagation();
      }
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "flowSelectedHandler");
    },

   /*
    * deselect called when the user has clicked on the canvas and not on any flow (or another flow other than the currently selected one)
    * previously highlighted flows are cleared
    */
    deselectHandler: function(force) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "deselectHandler");
      this.svg.selectAll(".bt_element")
        .filter(function(d) {
          if (force) {
            return true;
          }
          else {
            return (d.selected)? this: null;
          }
        })
        .each (function (d){
          var btElement = d3.select(this);
          btElement.selectAll("#flowLabel" + d.idValue)
            .attr("class", "node-text");
          btElement.select("#flowIcon" + d.idValue)
             .attr("xlink:href", "#btEdit_msgFlow");
          d.selected = false;
        });
      domClass.add(this.eventTooltipId, "event_tooltip_hidden");
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "deselectHandler");
    },

    // Use known event definitions on flow to determine validation decoration on flow element
    updateFlowElementValidation: function(flowUri) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "updateFlowElementValidation");

      var flowEvents = this.btModel.getFlowElementMonitoringEvents(flowUri);
      var correlationExists = false;
      var i = 0, j;
      var correlationObject = null;
      var defaultCorrelation = "automatic";
      var warningIcon = "#btEdit_warning";
      var okIcon = "#btEdit_ok";

			// Retrieve the correlation information into more manageable form
			if(typeof flowEvents !== "undefined") {
      	while((!correlationExists) && (i < flowEvents.length)) {
        	j = 0;
        	while((!correlationExists) && (j < flowEvents[i].nodeMonitoringEvents.length)) {
          	correlationObject = flowEvents[i].nodeMonitoringEvents[j].transactionCorrelation;
          	// Determine if global or parent correltor values have been specified
          	if((correlationObject.global != defaultCorrelation) || (correlationObject.parent != defaultCorrelation)) {
            	correlationExists = true;
          	}
          	j++;
        	}
        	i++;
      	}
      }

			// Callback function for clicking flow validation information
      var validationFunction = lang.hitch(this, function(d) {
	      this.showFlowValidationExtended(flowUri, {flowEvents: flowEvents, hasCorrelation: correlationExists}, d);
      });

      // Filter on flowUri, and add the correct validation to the flow element
      this.svg.selectAll(".bt_element")
      .filter( function(d) { return d.uri === flowUri; })
      .each( function (d) {
        var btElement = d3.select(this);
        // Grab the main click validation element to attach the show validation callback
        var validation = btElement.select("#flowValidation" + d.idValue);
        var validationCB = validation.select("rect");
        if(validationCB) {
          validationCB.on("click", lang.hitch(this, function(d){
            validationFunction(d);
            if (d3.event) {
              d3.event.stopPropagation();
            }
          }));
        }

        var validationIcon = validation.select("#flowValidationIcon" + d.idValue);
        if(validationIcon) {
          validationIcon.attr("xlink:href", function() {
            // If no monitoring events, or correlation specified on at least one of them then denote that flow is not "valid"
            if(correlationExists) {
              return okIcon;
            } else {
              return warningIcon;
            }}
          );
        }
      });

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "updateFlowElementValidation");
    },

    // Resize the canvas container
    resizeCanvas: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");

      // First check that it can be resized, either it is above the hard minimum (currently 800px)
      // And resizing won't crop out any existing nodes on the canvas
      var btCanvasContainer = domGeom.position(dom.byId("btCanvas"));
      var updatedWidth = btCanvasContainer.w * 0.96;

      // Set to the minimum x value of the canvas
      var nodeMaximumXPos = this.minimumWidth;

      // Get the greatest X value across all nodes in the model
      array.forEach(this.btModel.elementsArray, lang.hitch(this, function(element) {
        if(element.pos.x > nodeMaximumXPos) {
          nodeMaximumXPos = element.pos.x;
        }
      }));

      if(updatedWidth > nodeMaximumXPos) {
        this.svg.attr("width", updatedWidth);
        this.width = updatedWidth;
        this.btModel.setCanvasDimensions(this.width, -1);

        // If the hint is showing, then reposition
        if(this.btModel.elementsArray.length == 0) {
          var hint = this.svg.select("#btHint");
          hint.attr("x", updatedWidth * 0.5);
        }
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
    },
    
    // Increase the canvas container
    increaseCanvas: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "increaseCanvas");

      // First check that it can be resized, either it is above the hard minimum (currently 800px)
      // And resizing won't crop out any existing nodes on the canvas
      var btCanvasContainer = domGeom.position(dom.byId("btCanvas"));
      // 
      var updatedHeight = btCanvasContainer.h * 1.20;

      // Set to the minimum x value of the canvas
      var nodeMaximumYPos = this.minimumHeight;

      // Get the greatest X value across all nodes in the model
      array.forEach(this.btModel.elementsArray, lang.hitch(this, function(element) {
        if(element.pos.y > nodeMaximumYPos) {
          nodeMaximumYPos = element.pos.y;
        }
      }));

      if(updatedHeight > nodeMaximumYPos) {
        this.svg.attr("height", updatedHeight);
        this.height = updatedHeight;
        this.btModel.setCanvasDimensions(-1, this.height);
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "increaseCanvas");
    },


    // Generate the latest model representation of the BTX that is rendered in the Editor
    generateModel: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "generateModel");

      //TODO: Get the broker URL path

      // Generate the json representation of the flows that are participating in the business transaction and their business transaction monitoring events
      // For now just a single broker in the model
      var bTXModel =
        { name: this.btModel.btName, description: this.btModel.description,
              elements: [], links: [], businessEvents: { progressBusinessEvents: [], startBusinessEvents: [], endBusinessEvents: [], failBusinessEvents: []}
            };
      
      array.forEach(this.btModel.elementsArray, lang.hitch(this, function(element) {
        var newElement = { elementUri: element.uri, name: element.name, type: element.type, description: element.description,
                            xCoord: element.pos.x, yCoord: element.pos.y};
        bTXModel.elements.push(newElement);
      }));

      array.forEach(this.btModel.businessEvents, lang.hitch(this, function(event) {
        var newEvent = {
          flowUri: event.parentFlow,
          nodeName: event.monitorEvent.nodeId,
          eventSourceAddress: event.monitorEvent.eventSourceAddress,
          eventUri: event.monitorEvent.uri
        };

        switch (event.role) {
        case Resources.businessTransaction.btEventProgress:
          bTXModel.businessEvents.progressBusinessEvents.push(newEvent);
          break;
        case Resources.businessTransaction.btEventStart:
          bTXModel.businessEvents.startBusinessEvents.push(newEvent);
          break;
        case Resources.businessTransaction.btEventEnd:
          bTXModel.businessEvents.endBusinessEvents.push(newEvent);
          break;
        case Resources.businessTransaction.btEventFailure:
          bTXModel.businessEvents.failBusinessEvents.push(newEvent);
          break;
        }
      }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "generateModel");
      return bTXModel;
    },

    validateBT: function() {
      var warnIcon = "#btEdit_warning";
      var okIcon = "#btEdit_ok";
      var width = this.elementWidth+2;
      var editorWidget = this;
      var result = this.btModel.validateModel();
      var showBTValidationFunction = lang.hitch(this, function(show) {
        editorWidget.showBTValidationExtended(show, this.btModel);
      });

      this.svg.selectAll(".btInfo").each(function() {
        var txn = d3.select(this);
        txn.select("g").remove();
        var newTxn = txn.append("g")
         .attr("id","btValidation")
         .on("click", lang.hitch(this, function(d) {
           showBTValidationFunction(true, d);
           if (d3.event) {
             d3.event.stopPropagation();
           }
         }));
        newTxn.append("use")
           .attr("id","btValidationIcon")
           .attr("y",  1)
           .attr("x",  function(){return width + 1;})
           .attr("xlink:href", function(){
             if (result.status) {
               return okIcon;
             } else {
               return warnIcon;
             }
           });
        
        // Insert additional rect element to cover image mouseover/clicks - as this breaks in IE
        newTxn.append("rect")
          .attr("width", 18)
          .attr("height", 18)
          .attr("y", 0)
          .attr("x", width)
          .attr("class", "svg-use-coverage")
           .append("title")
             .attr("id", "btValidation_tooltip")
             .text(function(){
                return NLS.btMoreInfo;})
             .attr("class", "node-event-icon");
       });

    }
  });
  return BTEditor;
});

},
'webui/widgets/common/CustomTreeNode':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="940908975" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define(
  [
    "dojo/i18n!webui/nls/web",
    "dijit/form/DropDownButton",
    "dijit/DropDownMenu",
    "dijit/MenuItem",
    "dijit/MenuSeparator",
    "dijit/Tree",
    "dijit/registry",
    "dojo/_base/array",
    "dojo/_base/declare",
    "dojo/_base/lang",
    "dojo/dom-style",
    "dojo/when",
    "webui/utils/RestUri",
    "webui/widgets/common/Trace",
    "dojox/html/entities"
  ],
  function(
    NLS,
    DropDownButton,
    DropDownMenu,
    MenuItem,
    MenuSeparator,
    Tree,
    registry,
    array,
    declare,
    lang,
    domStyle,
    when,
    RestUri,
    Trace,
    entities
  ) {

    return declare(
      "webui.widgets.common.CustomTreeNode",
      [Tree._TreeNode],
      {
        _dropDownButton: null,
        
        constructor: function(/*Object*/ kwArgs){
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor", [kwArgs.label, kwArgs]);
          lang.mixin(this, kwArgs);
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
        },

        _userHasThisPermissionOnContainingEG : function( item, permission ) {
            var ret = false; //TODO: default to false?
            if(item) {
               var myArtifactUri = new RestUri(item.uri);
               var serverName    = myArtifactUri.getIntegrationServerName();
  	           if (serverName){
                  ret = window.currentuser.userPermission("eg." + serverName, permission);
               }//if - server name is not null
             }//if - item is not null
            return ret;
        	
        },
        
        _userHasExecOnContainingEG : function( item ) {
            return this._userHasThisPermissionOnContainingEG(item,"execute");
        },
        
        _userHasWriteOnContainingEG : function( item ) {
            return this._userHasThisPermissionOnContainingEG(item,"write");
        },

        _userHasReadOnContainingEG : function( item ) {
          return this._userHasThisPermissionOnContainingEG(item,"read");          
        },

        _userHasWriteOnBroker : function() {
          return window.currentuser.userPermission("broker", "write");
        },

        _userHasExecOnBroker : function() {
          return window.currentuser.userPermission("broker", "execute");
        },

        postCreate : function() {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
          this.inherited(arguments);
          
          this.createContextMenu();
        },

        /**
         * Creates/recreates the context menu for this CustomTreeNode. The context menu
         * consists of the DropDownButton (a small downward-pointing triangle which is part
         * of the CustomTreeNode itself) along with a DropDownMenu which is a separate widget
         * which is not directly attached to the CustomTreeNode and is usually not visible.
         * HOWEVER, if this CustomTreeNode has no buttons (or the user has no permission to
         * use any of the buttons), no DropDownButton is rendered and no DropDownMenu is
         * created.
         * Note that this can change over time. As the user's permissions change, they may gain
         * permission to use context menus, or lose it. So, this method will sometimes replace
         * one DropDownMenu with another, sometimes destroy the DropDownMenu and DropDownButton,
         * and sometimes create them anew. We must do this without ending up with duplicate
         * menus!
         */
        createContextMenu : function() {
          
          // Determine what the user has permission to do
          var userHasWriteOnBroker   = this._userHasWriteOnBroker()   === true;
          
          var userHasReadOnContainingEG  = this._userHasReadOnContainingEG(this.item)  === true;
          var userHasWriteOnContainingEG = this._userHasWriteOnContainingEG(this.item) === true;
          var userHasExecOnContainingEG  = this._userHasExecOnContainingEG(this.item)  === true;

          var restUri = new RestUri(this.item.uri);
          var parentArtifactRestUri = restUri.getParentArtifactRestUri(); // `null` in many cases
          
          var buttons = null;
          var statsOn = null;
          var attachedPolicy = null;
          var flowMonitoringActive = null;
          
          // Work out the full collection of buttons for the context menu
          switch (this.item.type) {

            case "application":
              buttons = this._getApplicationContextMenu(userHasReadOnContainingEG,userHasWriteOnContainingEG,userHasExecOnContainingEG);
              break;
            
            case "restApi":
              if(
                //Only show stop/start if we have exec permission on EG
                userHasExecOnContainingEG &&

                //We don't want to show duplicate menus for referent entries
                ( !this._descendantOfReferencesOrReferents(this.item) )
              ) {
                buttons = ["start", "stop", "-", "delete", "-", "statsOn", "statsOff", "-", "startFlowMonitoring", "stopFlowMonitoring"];
              }
              break;
            
            case "broker":
              buttons = ["exportPortConfigurationAsWASPlugin", "exportPortConfigurationAsModProxyModule"];
              break;
            
            case "executionGroups":
              if(userHasWriteOnBroker) {
                buttons = ["create"];
              }
              break;
            
            case "executionGroup":
              buttons = this._getEGContextMenu(userHasWriteOnBroker,userHasReadOnContainingEG,userHasWriteOnContainingEG,userHasExecOnContainingEG);
              statsOn = false;              
              flowMonitoringActive = false;              
              break;

            case "flow":
              break;
            
            case "businessTransactions":
              //Only show create if we have exec permission on EG
              if(userHasWriteOnBroker) {
                buttons = ["create"];
              }
              break;
            
            case "businessTransactionRecorders":
              //Only show create if we have exec permission on EG
              if(userHasWriteOnBroker) {
                buttons = ["create"];
              }
              break;
            
            case "businessTransactionRecorder":
              //Only delete if we have exec permission on EG
              if(userHasWriteOnBroker) {
                buttons = ["delete"];
              }
              break;
              
            case "businessTransaction":
              //Only delete if we have exec permission on EG
              if(userHasWriteOnBroker) {
                buttons = ["delete"];
              }
              break;
              
            case "library":
              buttons = this._getStaticAndSharedLibraryContextMenu(parentArtifactRestUri.isIntegrationServer(),userHasReadOnContainingEG,userHasWriteOnContainingEG);
              break;
            
            case "sharedLibrary":
              buttons = this._getStaticAndSharedLibraryContextMenu(parentArtifactRestUri.isIntegrationServer(),userHasReadOnContainingEG,userHasWriteOnContainingEG);
              break;
              
            case "messageFlow":

              // Do not allow for delete action if flow is part of lib or app or service.
              // E.g. no delete: "/apiv1/executiongroups/default2/applications/myApp1/messageflows/flow1"
              // OK to delete: "/apiv1/executiongroups/default/messageflows/intFlow1"
              var messageFlowIsDirectChildOfServer = parentArtifactRestUri.isIntegrationServer();

              buttons = this._getMessageFlowContextMenu(messageFlowIsDirectChildOfServer,userHasReadOnContainingEG,userHasWriteOnContainingEG,userHasExecOnContainingEG);
              
              if(userHasWriteOnContainingEG) {//stats can only be turned on and off if user has write permission on the server (execution group)
                var statsActive = this.item.snapshotStatistics.enabled;
                var outputFormat = this.item.snapshotStatistics.outputFormat;
                var monitoringActive = this.item.flowMonitoringActive;
                
                statsOn = statsActive && outputFormat.json;
                attachedPolicy = false;
                if(this.item.policies && this.item.policies[0] && this.item.policies[0].name !== '') {
                  attachedPolicy = true;
                }//if
                flowMonitoringActive = monitoringActive;
                
              }//if - userHasWriteOnContainingEG
              
              break;
            
            case "subFlow":
                //can only delete subflow files which are direct children of a server
                buttons = this._getSubflowAndResourcesContextMenu(parentArtifactRestUri.isIntegrationServer(),userHasReadOnContainingEG,userHasWriteOnContainingEG);
                break;
           
            case "resource":
                //can only delete resource files which are direct children of a server
                buttons = this._getSubflowAndResourcesContextMenu(parentArtifactRestUri.isIntegrationServer(),userHasReadOnContainingEG,userHasWriteOnContainingEG);
                break; 

            case "service":
                buttons = this._getServiceContextMenu(userHasReadOnContainingEG,userHasWriteOnContainingEG,userHasExecOnContainingEG);
                break;
                
            case "policyType":
              if(userHasWriteOnBroker) {
                buttons = ["create"];
              }
              break;
              
            case "policy":
              if(
                userHasWriteOnBroker &&
                this.item.policyType !== undefined
              ) {
                buttons = ["delete"];
              }
              break;
              
            case "configurableService":
              if(userHasWriteOnBroker) {
                // only allow deletion of user defined configurable services:
                if(this.item.ibmDefined === true) {
                  buttons = ["exportConfigurableService"];
                }
                else {
                  buttons = ["delete", "-", "exportConfigurableService"];
                }
              }
              break;
              
            case "configurableServices":
              if(userHasWriteOnBroker) {
                buttons = ["create", "importConfigurableService"];
              }
              break;
              
            default:
              break;
          }

          // Don't create menus for descendants of references or referents
          // elements - we'll get exceptions about duplicate menu IDs.
          if (this._descendantOfReferencesOrReferents(this.item)) {
            buttons = null;
          }

          // Find this CustomTreeNode's DropDownButton (if it exists) and
          // delete both it and its attached DropDownMenu.
          if(this._dropDownButton) {
            this._dropDownButton.destroyRecursive();
            this._dropDownButton = null;
          }

          if(buttons) {
            this._createMenuItems(buttons, statsOn, attachedPolicy, flowMonitoringActive);
          }
          
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
        },

        _descendantOfReferencesOrReferents: function(item) {
            var ancestor = item.__parent;
            while (!!ancestor) {
              if (ancestor.type === "references" || ancestor.type === "referents") {
                return true;
              }
              ancestor = ancestor.__parent;
            }
            return false;
          },

        _getSubflowAndResourcesContextMenu: function(parentIsIntegrationServer, egRead, egWrite) {

            /*
             * 
                 var all = [
                             "delete"    //needs write on eg
                             ]; 
             * 
             * 
             * There are 2 cases to consider:
             * 
             *                egWrite(false)
             *                egWrite(true)
             * 
             * 
             */            
                var menuButtons = null;

                // 1a)
                // Do not allow for delete action if subflow is part of lib or shared lib or app or service.
                // E.g. no delete: "/apiv1/executiongroups/default2/applications/myApp1/subflows/subflow1"
                // OK to delete: "/apiv1/executiongroups/default/subflows/subFlow1"

                // 1b)
                // Do not allow for delete action if resource is part of lib or shared lib or app or service
                // E.g. no delete: "/apiv1/executiongroups/default2/applications/myApp1/resources/ds1.rules"
                // OK to delete: "/apiv1/executiongroups/default/resources/ds1.rules"
                
                //2.
                // Also, there is no context menu if user doesn't have read access to execution group
                //
                if(
                    parentIsIntegrationServer &&
                    egRead
                  ) {
    
                    //
                    // does not matter if egExec is true or false
                    // only matters what the egWrite value is
                    //
                    if ( (egWrite===false) ){
                        menuButtons = null;
                    }
                    else if ( (egWrite===true) ){
                        menuButtons = ["delete"];
                    }
                    
                  }// - (egRead) && (this resource or subflow is directly under server)
    
          return menuButtons;
        },
        
        _getStaticAndSharedLibraryContextMenu: function(parentIsIntegrationServer,egRead,egWrite) {
            /*
             * 
                 var all = [
                             "delete"    //needs write on eg
                             ]; 
             * 
             * 
             * There are 2 cases to consider:
             * 
             *                egWrite(false)
             *                egWrite(true)
             * 
             * 
             */            
                var menuButtons = null;
    
                //We don't want to show duplicate menus for referent entries
                //treeLabel_references: "References",
                //treeLabel_referents: "Referenced By",
                //
                // Do not allow "Delete" action for libraries that are internal to an application
                // or service, only those at the integration server level.
                //                
                // Also, there is no context menu if user doesn't have read access to execution group
                //
                if ( ( !this._descendantOfReferencesOrReferents(this.item) ) &&    
                    parentIsIntegrationServer &&
                    egRead
                  ) {
    
                    //
                    // does not matter if egExec is true or false
                    // only matters what the egWrite value is
                    //
                    if ( (egWrite===false) ){
                        menuButtons = null;
                    }
                    else if ( (egWrite===true) ){
                        menuButtons = ["delete"];
                    }
                    
                  }//if
    
                return menuButtons;
                
            },
        
        _getServiceContextMenu: function(egRead,egWrite,egExec) {
            
            /*
             * 
                 var all = [ 
                  "start",   //needs exec on eg
                  "stop",    //needs exec on eg
                  "-",
                  "delete",  //needs write on eg
                  "-",
                  "statsOn",  //needs write on eg
                  "statsOff", //needs write on eg
                  "-",
                  "saveInterfaceFiles", //needs read on eg 
                  "-",
                  "startFlowMonitoring",  //needs write on eg
                  "stopFlowMonitoring", //needs write on eg
                  ];
                  
             * 
             * 
             * There are 4 cases to consider:
             * 
             *                egWrite(false) egExec (false)
             *                egWrite(false) egExec (true)
             *              egWrite(true)  egExec (true)
             *              egWrite(true)  egExec (false)
             * 
             * 
             * 
             */            
                var menuButtons = null;
    
                //We don't want to show duplicate menus for referent entries
                // Also, there is no context menu if user doesn't have read access to execution group                
                if ( ( !this._descendantOfReferencesOrReferents(this.item) ) &&  
                     egRead
                ) {

                  //
                  //"saveInterfaceFiles" is always available since we are guaranteed read access to eg in this block of code
                  //
                  if ( (egWrite===false) && (egExec===false) ){
                    menuButtons = ["saveInterfaceFiles"]; 
                  }
                  else if ( (egWrite===true) && (egExec===false) ){
                    menuButtons = ["delete", "-", "statsOn", "statsOff","-","startFlowMonitoring","stopFlowMonitoring","-","saveInterfaceFiles"];
                  }
                  else if ( (egWrite===true) && (egExec===true) ){
                    menuButtons = ["start", "stop", "-", "delete", "-", "statsOn", "statsOff","-","startFlowMonitoring","stopFlowMonitoring","-","saveInterfaceFiles"];
                  }
                  else if ( (egWrite===false) && (egExec===true) ){
                    menuButtons = ["start", "stop","-","saveInterfaceFiles"];
                  }
                    
                }//if
    
                return menuButtons;
            },
        
        _getApplicationContextMenu: function(egRead,egWrite,egExec) {
            /*
             * 
                 var all = ["start",      //needs exec on eg
                            "stop",       //needs exec on eg
                             "-",
                             "delete",    //needs write on eg
                             "-",
                             "statsOn",   //needs write on eg
                             "statsOff",  //needs write on eg
                             "-",
                             "startFlowMonitoring",   //needs write on eg
                             "stopFlowMonitoring"  //needs write on eg
                             ]; 
             * 
             * 
             * There are 4 cases to consider:
             * 
             *                egWrite(false) egExec (false)
             *                egWrite(false) egExec (true)
             *              egWrite(true)  egExec (true)
             *              egWrite(true)  egExec (false)
             * 
             * 
             * 
             */            
                var menuButtons = null;
    
                //We don't want to show duplicate menus for referent entries
                // Also, there is no context menu if user doesn't have read access to execution group
                if ( ( !this._descendantOfReferencesOrReferents(this.item) ) &&                    
                    egRead
                  ) {
                    
                    if ( (egWrite===false) && (egExec===false) ){
                        menuButtons = null;
                    }
                    else if ( (egWrite===true) && (egExec===false) ){
                        menuButtons = ["delete", "-", "statsOn", "statsOff", "-", "startFlowMonitoring", "stopFlowMonitoring"];
                    }
                    else if ( (egWrite===true) && (egExec===true) ){
                        menuButtons = ["start", "stop", "-", "delete", "-", "statsOn", "statsOff", "-", "startFlowMonitoring", "stopFlowMonitoring"];
                    }
                    else if ( (egWrite===false) && (egExec===true) ){
                        menuButtons = ["start", "stop"];
                    }
                    
                  }// - isn't listed under "References" or "Referenced By"
    
                return menuButtons;
                
            },

            _getMessageFlowContextMenu: function(messageFlowIsDirectChildOfServer,egRead,egWrite,egExec) {
                /*
                 * 
                     var all = [
                     
                        "start",  //needs exec on eg
                        "stop",   //needs exec on eg
                        "stopWithRestartExecutionGroup", //needs exec on eg
                        "-",
                        "delete",//needs write on eg ( AND only if messageFlow is direct child of server)
                        "-",
                        "disableTestRecordMode",//need write on eg
                        "-",
                        "statsOn", //needs write on eg
                        "statsOff",//needs write on eg
                        "-",
                        "attachPolicy", //needs write on eg
                        "detachPolicy", //needs write on eg
                        "-",
                        "startFlowMonitoring", //needs write on eg
                        "stopFlowMonitoring" //needs write on eg
                     
                                 ]; 
                 * 
                 * 
                 * There are 8 cases to consider:
                 * 
                        messageFlowIsDirectChildOfServer(true)  egWrite(false) egExec (false)
                        messageFlowIsDirectChildOfServer(true)  egWrite(true)  egExec (false)
                        messageFlowIsDirectChildOfServer(true)  egWrite(false)  egExec (true)                        
                        messageFlowIsDirectChildOfServer(true)  egWrite(true)  egExec (true)
                        
                        messageFlowIsDirectChildOfServer(false) egWrite(false) egExec (false)
                        messageFlowIsDirectChildOfServer(false) egWrite(true)  egExec (false)
                        messageFlowIsDirectChildOfServer(false) egWrite(false)  egExec (true)                       
                        messageFlowIsDirectChildOfServer(false) egWrite(true)  egExec (true)
                 * 
                 * 
                 * 
                 */            

                var menuButtons = null;
                
                
                if ( egRead ) {//execution group is locked and without context menu; if user doesn't have read access

                    
                    if ( (messageFlowIsDirectChildOfServer===true) && (egWrite===false) && (egExec===false) ){
                        menuButtons = null;
                    }
                    else if ( (messageFlowIsDirectChildOfServer===true) && (egWrite===true) && (egExec===false) ) {
                        menuButtons = [
                                        "delete",
                                        "-",
                                        "disableTestRecordMode",
                                        "-",
                                        "statsOn",
                                        "statsOff",
                                        "-",
                                        "attachPolicy",
                                        "detachPolicy",
                                        "-",
                                        "startFlowMonitoring",
                                        "stopFlowMonitoring"
                                     ];

                    }
                    else if ( (messageFlowIsDirectChildOfServer===true) && (egWrite===false) && (egExec===true) ) {
                        menuButtons = [
                                       "start",  //needs exec on eg
                                       "stop",   //needs exec on eg
                                       "stopWithRestartExecutionGroup" //needs exec on eg
                                     ];

                    }
                    else if ( (messageFlowIsDirectChildOfServer===true) && (egWrite===true) && (egExec===true) ) {
                        //essential all menu items
                        menuButtons = [
                                        "start",
                                        "stop", 
                                        "stopWithRestartExecutionGroup",
                                        "-",
                                        "delete",
                                        "-",
                                        "disableTestRecordMode",
                                        "-",
                                        "statsOn", 
                                        "statsOff",
                                        "-",
                                        "attachPolicy", 
                                        "detachPolicy",
                                        "-",
                                        "startFlowMonitoring",
                                        "stopFlowMonitoring"
                                     ];

                    }
                    else if ( (messageFlowIsDirectChildOfServer===false) && (egWrite===false) && (egExec===false) ) {
                        menuButtons = null;
                    }
                    else if ( (messageFlowIsDirectChildOfServer===false) && (egWrite===true) && (egExec===false) ) {
                        menuButtons = [
										"disableTestRecordMode",
										"-",
                                        "statsOn",
                                        "statsOff",
                                        "-",
                                        "attachPolicy",
                                        "detachPolicy",
                                        "-",
                                        "startFlowMonitoring",
                                        "stopFlowMonitoring"
                                     ];
                    }
                    else if ( (messageFlowIsDirectChildOfServer===false) && (egWrite===false) && (egExec===true) ) {
                        menuButtons = [
                                       "start",  //needs exec on eg
                                       "stop",   //needs exec on eg
                                       "stopWithRestartExecutionGroup" //needs exec on eg
                                     ];
                    }
                    else if ( (messageFlowIsDirectChildOfServer===false) && (egWrite===true) && (egExec===true) ) {
                        menuButtons = [
                                        "start",
                                        "stop", 
                                        "stopWithRestartExecutionGroup",
                                        "-",
                                        "disableTestRecordMode",
                                        "-",
                                        "statsOn", 
                                        "statsOff",
                                        "-",
                                        "attachPolicy", 
                                        "detachPolicy",
                                        "-",
                                        "startFlowMonitoring",
                                        "stopFlowMonitoring"
                                     ];
                    }
                    
                    
                }//has read access - at least
                
                
                
                return menuButtons;
                
                },
                        
            
        _getEGContextMenu: function(brokerWrite,egRead,egWrite,egExec) {

          /*
            The following menu items and the permissions needed for each : 
   
            var allButtons = [
                                  "start",//need exec on eg
                                  "startAllApplicationTypes",//need exec on eg
                                  "startAllMessageFlows",//need exec on eg
                                  "-",
                                  "stop",//need exec on eg
                                  "stopAllApplicationTypes",//need exec on eg
                                  "stopAllMessageFlows",//need exec on eg
                                  "-",
                                  "deleteAll",//need write on eg
                                  "delete",//need write access on broker
                                  "-",
                                  "deploy",//need write on eg
                                  "-",
                                  "statsOn",//need write on eg
                                  "statsOff",//need write on eg
                                  "-",
                                  "resourceStatsOn", //need write on eg
                                  "resourceStatsOff", //need write on eg
                                  "-",
                                  "startFlowMonitoring",
                                  "stopFlowMonitoring"
            ];
     
            There are 8 cases to account for:
            
            brokerWrite (true)  egWrite(false) egExec (false)
            brokerWrite (true)  egWrite(true)  egExec (false)
            brokerWrite (true)  egWrite(false) egExec (true)            
            brokerWrite (true)  egWrite(true)  egExec (true)
            
            brokerWrite (false) egWrite(false) egExec (false)
            brokerWrite (false) egWrite(true)  egExec (false)
            brokerWrite (false) egWrite(false)  egExec (true)            
            brokerWrite (false) egWrite(true)  egExec (true)
          */            
          var menuButtons = null;
          
          if ( egRead ) {//execution group is locked and without context menu; if user doesn't have read access
            if ( (brokerWrite===true) && (egWrite===false) && (egExec===false) ){
              menuButtons = [
                             "delete",
                             "-",
                             "pushRESTApis"
                             ];
            }
            else if ( (brokerWrite===true) && (egWrite===true) && (egExec===false) ) {
              menuButtons = [
                             "deleteAll",
                             "delete",
                             "-",
                             "deploy",
                             "pushRESTApis",
                             "-",
                             "statsOn",
                             "statsOff",
                             "-",
                             "resourceStatsOn",
                             "resourceStatsOff",
                             "-",
                             "startFlowMonitoring",
                             "stopFlowMonitoring",
                             ];
            }
            else if ( (brokerWrite===true) && (egWrite===false) && (egExec===true) ) {
                menuButtons = [
                               "start",//need exec on eg
                               "startAllApplicationTypes",//need exec on eg
                               "startAllMessageFlows",//need exec on eg
                               "-",
                               "stop",//need exec on eg
                               "stopAllApplicationTypes",//need exec on eg
                               "stopAllMessageFlows",//need exec on eg
                               "-",
                               "delete",//need write access on broker
                               "-",
                               "pushRESTApis"
                               ];
              }
            else if ( (brokerWrite===true) && (egWrite===true) && (egExec===true) ) {
              //essential all menu items
              menuButtons = [
                             "start",
                             "startAllApplicationTypes",
                             "startAllMessageFlows",
                             "-",
                             "stop",
                             "stopAllApplicationTypes",
                             "stopAllMessageFlows",
                             "-",
                             "deleteAll",
                             "delete",
                             "-",
                             "deploy",
                             "pushRESTApis",
                             "-",
                             "statsOn",
                             "statsOff",
                             "-",
                             "resourceStatsOn",
                             "resourceStatsOff",
                             "-",
                             "startFlowMonitoring",
                             "stopFlowMonitoring"
                             ];
            }
            else if ( (brokerWrite===false) && (egWrite===false) && (egExec===false) ) {
              menuButtons = null;
            }
            else if ( (brokerWrite===false) && (egWrite===true) && (egExec===false) ) {
              menuButtons = [
                             "deleteAll",
                             "-",
                             "deploy",
                             "pushRESTApis",
                             "-",
                             "statsOn",
                             "statsOff",
                             "-",
                             "resourceStatsOn",
                             "resourceStatsOff",
                             "-",
                             "startFlowMonitoring",
                             "stopFlowMonitoring"
                             ];
            }
            else if ( (brokerWrite===false) && (egWrite===false) && (egExec===true) ) {
                menuButtons = [
                               
                               "start",//need exec on eg
                               "startAllApplicationTypes",//need exec on eg
                               "startAllMessageFlows",//need exec on eg
                               "-",
                               "stop",//need exec on eg
                               "stopAllApplicationTypes",//need exec on eg
                               "stopAllMessageFlows",//need exec on eg
                               "-",
                               "pushRESTApis"
                               ];
              }
            else if ( (brokerWrite===false) && (egWrite===true) && (egExec===true) ) {
              menuButtons = [
                             "start",
                             "startAllApplicationTypes",
                             "startAllMessageFlows",
                             "-",
                             "stop",
                             "stopAllApplicationTypes",
                             "stopAllMessageFlows",
                             "-",
                             "deleteAll",
                             "-",
                             "deploy",
                             "pushRESTApis",
                             "-",
                             "statsOn",
                             "statsOff",
                             "-",
                             "resourceStatsOn",
                             "resourceStatsOff",
                             "-",
                             "startFlowMonitoring",
                             "stopFlowMonitoring"
                             ];
            }
          }//has read access - at least
          return menuButtons;
        },
        
        /**
         * 
         * Given a server uri, this method will return a boolean indicating if it is currently running.
         * This information is sometimes important when enabling or disabling context menu items of artifacts which are 
         * descendant tree nodes of a server. ( e.g. If a server is stopped, it should not be possible to start an application.)
         * 
         */
        _isServerRunning : function(serverUri) {

          //
          // e.g. '/apiv1/executiongroups/default'
          //
        
          var isRunning = false;
            
          var tempArray =window.wmbConsole._explorerTree._itemNodesMap[ serverUri ];
          if (tempArray && tempArray[0] && tempArray[0].item){
              var theItem = tempArray[0].item;
              isRunning = theItem.isRunning;
          }//if
          
          return isRunning;
        }, 

        /**
         * Create a new DropDownButton and DropDownMenu for this CustomTreeNode.
         */
        _createMenuItems : function(buttons, statsOn, attachedPolicy, flowMonitoringActive) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createMenuItems",[buttons, statsOn, attachedPolicy, flowMonitoringActive]);
          
          var item = this.item;
          var resourceStatsOn = item.resourceStatsEnabled; // usually `undefined`
          
          //prevent a 'menu already defined' exception in javascript console
          var dropDownMenuId = item.uri + "_dropDownMenu";
          var dropDownMenu = registry.byId(dropDownMenuId);
          if (dropDownMenu){
            dropDownMenu.destroyRecursive();
            dropDownMenu = null;
          }

          dropDownMenu = new DropDownMenu({
            "id" : dropDownMenuId // enables HasContextMenu to find us
          });

          //prevent a 'menu already defined' exception in javascript console
          var headerId = item.uri + "_contextMenu";
          var header = registry.byId(headerId);
          if (header){
            header.destroyRecursive();
            header = null;
          }
          
          var itemName = this._getItemName(item);
          var label = this._computeMenuItemLabel(itemName, item);
          
          header = new MenuItem({
            "label" : label,
            "title": itemName,
            "id": headerId,
            "class": "explorerTree_contextMenu_header"
          });
          dropDownMenu.addChild(header);

          var topSeparator = new MenuSeparator();
          dropDownMenu.addChild(topSeparator);

          array.forEach(buttons, lang.hitch(this, function(button) {

            if(button === "-") {
              var separator = new MenuSeparator();
              dropDownMenu.addChild(separator);
              return;
            }

            // `button` is e.g. "start", "stop", "statsOn", "statsOff",
            // "create", "delete", "attachPolicy", "upload", "detachPolicy",
            // "stopWithRestartExecutionGroup"

            var itemValue = item;
            var statsOnValue = statsOn;
            var flowMonitoringActiveValue = flowMonitoringActive;

            // Use the URI as a unique identifer for the menuItem name
            var label = NLS.action[button];
            var menuItemId = item.uri + "_" + button;
            var disabled = this._computeDisabledStatus(button, statsOnValue, attachedPolicy, itemValue, resourceStatsOn, flowMonitoringActiveValue);
            var description = NLS.actionDescription[button] || label;
            
            //prevent a 'menu already defined' exception in javascript console
            var menuItem = registry.byId(menuItemId);
            if (menuItem){
              menuItem.destroyRecursive();
              menuItem = null;
            }//if
            
            menuItem = new MenuItem({
              label : label,
              id : menuItemId,
              title: description,
              button: button,
              disabled: disabled
            });
            dropDownMenu.addChild(menuItem);
            
            // Connect the newly created context menu to the relevant widget
            this._connectToWidget(menuItem, item);
          }));

          var dropDownButton = new DropDownButton({
            label: itemName,
            title: itemName,
            showLabel: false,
            dropDown: dropDownMenu,
            isLoaded: lang.hitch(dropDownButton, function(){
              // update the menu items with their new enabled/disabled status
              dropDownButton.updateMenuStatus();
              var dropDown = dropDownButton.dropDown;
              return (!!dropDown && (!dropDown.href || dropDown.isLoaded));
            }),

            /**
             * Whenever isLoaded() is called, make an XHR to refresh the
             * menu items and their enabled/disabled state.
             */
            updateMenuStatus:lang.hitch(this, function(){
              // get the up to date element from the tree
              var promise = this.tree.model.get(this.item.uri);
              
              // get the item type from uri, this is required by a policy item
              var originalType = this.item.type;
              var originalUri = this.item.uri;
              var originalPolicyType = "";
              var originalPolicyName = "";
              if (originalType === "policy"){
                originalPolicyType = this.item.policyType;
                originalPolicyName = this.item.name;
              }
              
              when(promise, lang.hitch(this, function(fullObject) {
                var menu = dropDownMenu;
                // new statistics on status

                var statsActive = fullObject.snapshotStatistics && fullObject.snapshotStatistics.enabled;
                var outputFormat = statsActive && fullObject.snapshotStatistics.outputFormat;
                var statsOn1 = statsActive && outputFormat.json;
                var flowMonitoringActiveValue = fullObject.flowMonitoringActive;

                var policy1 = false;
                if(fullObject.policies && fullObject.policies[0] && fullObject.policies[0].name !== '') {
                  policy1 = true;
                }

                array.forEach(menu.getChildren(), lang.hitch(this, function(menuItem, i) {
                  var item = fullObject;
                  
                  // wrap around the object returned from REST call for policy item
                  if (originalType === "policy" && originalPolicyType === fullObject.type){ // not WLM policy
                    item = {
                      "type" : originalType,
                      "policyType" : originalPolicyType,
                      "uri" : originalUri,
                      "data" : fullObject,
                      "name" : originalPolicyName
                    };
                  }

                  if ((i>0) && menuItem.label) { // skip separators and first menu
                    var statsOnValue = statsOn1;
                    var policyValue = policy1;
                    var updatedStatus = this._computeDisabledStatus(menuItem.button, statsOnValue, policyValue, item, item.resourceStatsEnabled, flowMonitoringActiveValue);
                    if (updatedStatus !== menuItem.disabled) { // status has changed, update
                      menuItem.set('disabled', updatedStatus);
                    }

                  }
                  else if (i===0) { // refresh the top item in the menu

                    var itemName = this._getItemName(item) || menuItem.title || "";
                    
                    menuItem.set('label', this._computeMenuItemLabel(itemName, item));
                    menuItem.set('title', itemName);
                  }
                }));
                menu.focus();
              }));
            }),

            onClick: function() {
              return false;
            }
          });
          
          this.domNode.children[0].appendChild(dropDownButton.domNode);
          this._dropDownButton = dropDownButton;

          domStyle.set(this.domNode.children[0], "position", "relative");
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createMenuItems");
        },
        
        _getItemName : function(item) {
          if(item.name !== undefined) {
            return item.name;
          }
          if(item.type === "policyType" && item.policyType !== undefined) {
            return item.policyType;
          }
          if (
            (item.type === "executionGroups")||
            (item.type === "businessTransactions")||
            (item.type === "businessTransactionRecorders")||
            (item.type === "businessTransactionRecorder")||
            (item.type === "configurableServices")
          ){
            return NLS.treeLabel[item.type];
          }
          return "";
        },
        
        /**
         * This is the top (title) of the context menu of a CustomTreeNode.
         * TODO: use a Dojo template
         */
        _computeMenuItemLabel: function(
          name, // e.g. "Flow1"
          item
        ) {
          
          // Truncate context menu names at 30 characters if need be
          // Check that if we have a really long name, that we truncate in a human readable manner of characters.
          var charLimit = 30;
          name = name.length > charLimit ? name.substr(0, charLimit) + "..." : name;
          name = entities.encode(name);

          var iconClass = this.tree.getIconClass(item);
          iconClass = entities.encode(iconClass);

          return "<div class='explorerTree_contextMenu_headerIcon " + iconClass + "'></div>" +
          "<div class='explorerTree_contextMenu_headerTitle'>" + name + "</div>";
        },

        _computeDisabledStatus: function (button, statsOn, attachedPolicy, item, resourceStatsOn, flowMonitoringActive) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_computeDisabledStatus");
          var disabled = false;
          if(item.type === "service" && button === "saveInterfaceFiles") {
            if (!item.isRunning || !item.hasServiceURL) {
              disabled=true;
            }
          }
          else if(item.isRunning !== undefined){
            if(item.isRunning && (button === "start")){
              disabled = true;
            } else if(
              !item.isRunning &&
              (
                button === "stop" || 
                button === "stopWithRestartExecutionGroup" || 
                button === "deploy" ||
                button === "pushRESTApis" ||
                button === "statsOn" ||
                button === "statsOff" ||
                button === "startFlowMonitoring" ||
                button === "stopFlowMonitoring" ||
                button === "resourceStatsOn" ||
                button === "resourceStatsOff" ||
                button === "enableTestRecordMode" ||
                button === "disableTestRecordMode" ||
                button === "startAllMessageFlows" ||
                button === "stopAllMessageFlows" ||
                button === "startAllApplicationTypes" ||
                button === "stopAllApplicationTypes" ||                      
                button === "deleteAll"
              )
            ){
              disabled = true;
            }
          }

          if(statsOn !== undefined){
            if(statsOn && (button === "statsOn")){
              disabled = true;
            } else if(!statsOn && (button === "statsOff")){
              disabled = true;
            }
          }

          if(flowMonitoringActive !== undefined){
            if(flowMonitoringActive && (button === "startFlowMonitoring")){
              disabled = true;
            } else if(!flowMonitoringActive && (button === "stopFlowMonitoring")){
              disabled = true;
            }
          }
          
          if(resourceStatsOn !== undefined){
            if(resourceStatsOn && (button === "resourceStatsOn")){
              disabled = true;
            } else if(!resourceStatsOn && (button === "resourceStatsOff")){
              disabled = true;
            }
          }
          
          if(attachedPolicy !== undefined) {
            if(attachedPolicy && (button === "attachPolicy")) {
              disabled = true;
            } else if(!attachedPolicy && (button === "detachPolicy")) {
              disabled = true;
            }
          }
          
          if (item.type !== undefined && item.type === "messageFlow" && item.isInTestRecordMode !== undefined) {
            // Disable the 'disableTestRecordMode' context menu item if the message flow is not in test record mode:
            if (button === "disableTestRecordMode" && item.isInTestRecordMode === false) {
              disabled = true;
            }
          }
          
          // If EG is running, then check that at least one REST Api is deployed otherwise disable option
          if(item.isRunning && (item.type === "executionGroup") && (button === "pushRESTApis")) {
            if(item.restApis && (item.restApis.hasChildren === "true")) {
              disabled = false;
            } else {
              disabled = true;
            }
          }
          
          //
          // Extra code to make sure certain menu items are not enabled WHEN the execution group is NOT running
          //
          if (
            button === "start" ||
            button === "delete" ||
            button === "attachPolicy"
          ) {
            if (
              item.type === "application" ||
              item.type === "service" ||
              item.type === "messageFlow" ||
              item.type === "library" ||
              item.type === "sharedLibrary"
            ) {
                
              //
              // Use the item's uri, to obtain the uri of the server on which it resides
              //    
              var myArtifactUri = new RestUri(this.item.uri);
              var serverUri     = myArtifactUri.getIntegrationServerUri().toString();
              
              //
              // Check if this artifact's server is running.
              //
              if ( !this._isServerRunning(serverUri) ) {
                disabled = true;
              }
            }//application  
          }//if
          
          
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "_computeDisabledStatus "+ item.label+" "+disabled);
          return disabled;
        },

        /**
         * When a context menu button is clicked, somebody must handle that click. Although really
         * it should be CustomTreeNode itself which does this, at present it is a tab widget which
         * does. Here we determine which tab widget, and attach it to the click event.
         */
        _connectToWidget : function(menuItem, item) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_connectToWidget", arguments);

          var type = item.type;

          ////////////////////////////////////////////////////////
          // Only make changes here
          var widgetIds = {
            "application" : "webui.widgets.application.app_overview",
            "restApi" : "webui.widgets.restapi.Overview",
            "broker" : "webui.widgets.broker.broker_overview",
            "executionGroups" : "webui.widgets.executiongroup.eg_overview",
            "executionGroup" : "webui.widgets.executiongroup.eg_overview",
            "businessTransactions" : "webui.widgets.business.businesstransactions",
            "businessTransaction" : "webui.widgets.business.businesstransaction_overview",
            "library" : "webui.widgets.libraries.lib_overview",
            "sharedLibrary" : "webui.widgets.sharedlibraries.shlib_overview",
            "messageFlow" : "webui.widgets.msgflows.msgflow_overview",
            "messageFlowActivityLog" : "webui.widgets.msgflows.msgflow_activityLog",
            "subFlow" : "webui.widgets.subflows.subflow_overview",
            "resource" : "webui.widgets.resources.resource_overview",
            "service" : "webui.widgets.service.svc_overview",
            "policyType" : "webui.widgets.policy.policy_overview",
            "policy" : "webui.widgets.policy.policy_overview",
            "configurableService" : "webui.widgets.configurableservice.cs_overview",
            "configurableServices" : "webui.widgets.configurableservice.cs_category_overview"
          };

          var widgetId = widgetIds[type];
          if(!widgetId) {
            throw new Error("Unrecognised item type '" + type + "'");
          }

          var listener = registry.byId(widgetId);
          if(!listener) {
            throw new Error("No widget found with ID '" + widgetId + "'");
          }

          if(!listener.contextButtonsClicks) {
            throw new Error("'" + widgetId + "' must implement contextButtonsClicks()");
          }

          ////////////////////////////////////////////////////////
          menuItem.on("click", function(event) {
            listener.contextButtonsClicks(event);
          });
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "_connectToWidget");
        }
      }
    );
  }
);

},
'webui/widgets/business/BTPermissionsModel':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2015,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.  
 * </copyright> 
 *
 * Business Transaction Model
 * Used by the Business Transaction editor to store the data associated with a business transaction
 * the flows, the external system and the business events
 *
 */
define("webui/widgets/business/BTPermissionsModel", [], function() {

  return {
  
    _declaredClass: "webui.widgets.business.BTPermissionsModel",
    
    // To prevent content being loaded at root level (tree shouldn't be able to be queried past this).
    noReadWriteAccessForBTM: function() {
      if((!window.currentuser.userPermission("broker", "write")) &&
          (!window.currentuser.userPermission("broker", "read"))) {
        return true;
      }
      else {
        return false;
      }
    },
	
		readOnlyModeForBTD: function() {
		  if(!window.currentuser.userPermission("broker", "write")) {
		    return true;
		  }
		  else {
		    return false;
		  }
		},
		
    writeModeForBTD: function() {
      if(window.currentuser.userPermission("broker", "write")) {
        return true;
      }
      else {
        return false;
      }
    },
  };
});

},
'webui/widgets/executiongroup/DeployBARDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="4072148188" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/executiongroup/templates/DeployBARDialog.html", 
  "dojo/i18n!webui/nls/web",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/aspect",
  "dojo/data/ItemFileWriteStore",
  "dojo/dom-attr",
  "dojo/dom-class",
  "dojo/dom-style",
  "dojo/on",
  "dojo/string",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetsInTemplateMixin",
  "dijit/Dialog",
  "dijit/tree/ForestStoreModel",
  "webui/config/Resources",
  "webui/widgets/common/Trace",

  // For the template only
  "dijit/DropDownMenu",
  "dijit/MenuItem",
  "dijit/ProgressBar",
  "dijit/form/ComboButton",
  "dojox/form/Uploader",
  "dojox/grid/TreeGrid"
], function(
  template,
  NLS,
  declare,
  lang,
  aspect,
  ItemFileWriteStore,
  domAttr,
  domClass,
  domStyle,
  on,
  string,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  Dialog,
  ForestStoreModel,
  Resources,
  Trace
) {
  var deloyBARDialog = declare("webui.widgets.executiongroup.DeployBARDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
    templateString : template,
		
    _actionURI : null,
    _callback : null,
		
    _barData : null,

    /**
     * Constructor.
     */
    constructor: function(args) {
      this.NLS = NLS;
      
      if (args != null) {
        this._actionURI   = args.actionURI;
        this._callback    = args.cback;
      }
      
      /*
       * Define the initial empty data for the tree grid.  This is a string 
       * because it is referenced in the widget template when declaratively
       * defining the tree grid. 
       */
      this.data = "{identifier: 'id', label: 'id', items: []}";
    },

    /**
     * postCreate.
     */
    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      /*
       * Configure the BAR file form uploader widget.  This involves adding a
       * number of handlers to handle different stages of the loading process.  
       * Importantly, we need to add an onChange handler to store the encoded
       * file name in the hidden form field before manually submitting the form.
       */
			this._barLoader.url = Resources.REST.root + "/bar/readBar";
      this.own(aspect.after(this._barLoader, "onChange", lang.hitch(this, function() {
        this.clearMessage();
        var value = this._barLoader.getFileList()[0].name;
        if (value) {
          // Store the encoded name of the file in the hidden form field
          this._escapedBarFileName.value = encodeURI(value);
          this._barLoader.submit(this._form);
        }
      })));
			this._barLoader.onBegin = lang.hitch(this, function() {
			  domStyle.set(this._uploadProgressBar.domNode, "visibility", "visible");
			});
			this._barLoader.onProgress = lang.hitch(this, function(progressEvent) {
			  this._uploadProgressBar.set("value", progressEvent.percent);
			});
			this._barLoader.onComplete = lang.hitch(this, function(response) {
				this.clearMessage();
        domStyle.set(this._uploadProgressBar.domNode, "visibility", "hidden");
        this._uploadProgressBar.set("value", 0); // Set progress bar back to zero
				this.readBarCompleted(response);
			});
			
      /*
       * Configure the overrides file form uploader widget.  This involves 
       * adding a number of handlers to handle different stages of the loading
       * process. Importantly, we need to add an onChange handler to store the 
       * encoded file name in the hidden form field before manually submitting
       * the form.
       */
      this._overridesLoader.url = Resources.REST.root + "/bar/readOverrides";
      this.own(aspect.after(this._overridesLoader, "onChange", lang.hitch(this, function() {
        var value = this._overridesLoader.getFileList()[0].name;
        if (value) {
          // Store the encoded name of the file in the hidden form field
          this._escapedOverridesFileName.value = encodeURI(value);
          this._overridesLoader.submit(this._form);
        }
      })));
      this._overridesLoader.onComplete = lang.hitch(this, function(response) {
        this.readDeploymentDescriptorCompleted(response);
      });

      // Define the behaviour for the deploy and cancel buttons
      this.own(on(this, "execute", lang.hitch(this, function() {
        this._form.action = this._actionURI + "/deploy";
        this._callback(this._form.action, this._escapedBarFileName.value, this._escapedOverridesFileName.value);
        this.hide();
      })));
      this.own(on(this._cancelButton, "click", lang.hitch(this, function() {
        this.destroy();
      })));

      /*
       * Finish initializing the tree grid.  This involves defining the sort,
       * edit and select behaviour and ensuring that it responds to window
       * resize events.
       */
      this._propTreeGrid.canSort = function() {
        return false;
      };
      this._propTreeGrid.canEdit = function() {
        return false;
      };
      this._propTreeGrid.onCanSelect = function() {
        return false;
      };
      this.own(on(window, "resize", lang.hitch(this, function() {
        this._propTreeGrid.resize();
      })));
      
      /*
       * Finally, define the behaviour of the overrides menu items by simply
       * adding onClick handles to each menu item.
       */
      this._menuItemSelectOverrides.onClick = lang.hitch(this, function() {
        // Link the selection of this menu item to the hidden overrides uploader button
        this._overridesLoader.domNode.childNodes[0].click();
      });
      this._menuItemClearOverrides.onClick = lang.hitch(this, function() {
        // First, retrieve the name of the overrides file for the message
        var overridesFile = this._overridesLoader.getFileList()[0].name;
        
        // Now reset the various controls related to the overrides file
        this._overridesLoader.reset();
        this._escapedOverridesFileName.value = "";
        this._menuItemClearOverrides.set("disabled", true);

        /*
         * Revert any existing changes to the store.  We need to do this to
         * avoid possible errors in the ItemFileWriteStore caused by modifying
         * the items in the store and not saving the changes.
         */ 
        this._propTreeGrid.treeModel.store.revert();
        this._displayMessage("success", string.substitute(NLS.clearOverridesSuccess, [overridesFile]));
      });
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },
		
    /**
     * The readBarCompleted function handles the response from the readBar REST
     * API call.
     * 
     * @param responseObject
     *          The response for the REST API call.
     */
    readBarCompleted : function(responseObject) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "readBarCompleted");

      /*
       * Regardless of whether the BAR file was successfully loaded, always
       * reset the overrides file... we assume that any existing overrides file
       * was for a previously specified BAR file.
       */
      this._escapedOverridesFileName.value = "";
      this._overridesLoader.reset();
      this._menuItemClearOverrides.set("disabled", true);

      // Check to see if the server returned an error
      if (responseObject.error) {
        this._barFileName.set("value", "");
        this._okButton.set("disabled", true);
        this._overridesDropDownButton.set("disabled", true);
        this.handleReadError(responseObject);
      } else if (responseObject.properties) {
        this._barFileName.set("value", this._barLoader.getFileList()[0].name);
        this._okButton.set("disabled", false);
				
        /*
         * If the response contained some properties then update the tree grid
         * and enable the overrides drop down.
         */
        if (responseObject.properties.length > 0) {
          this.updateTree(responseObject.properties);
          this._overridesDropDownButton.set("disabled", false);
        } else {
          this._displayMessage("info", string.substitute(NLS.readBARInfo_noConfigPropertiesInBAR, [this._barFileName.value]));
        }
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "readBarCompleted");
    },

    /**
     * The readDeploymentDescriptorCompleted function handles the response from
     * the readOverrides REST API call.
     * 
     * @param responseObject
     *          The response for the REST API call.
     */
    readDeploymentDescriptorCompleted : function(responseObject) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "readDeploymentDescriptorCompleted");
			
      /*
       *  Revert any existing changes to the store that may have been made by
       *  loaded a previous overrides file.
       */
      this._propTreeGrid.treeModel.store.revert();
      
      // Check to see if the server returned an error
      if (responseObject.error) {
        // Reset the overrides file related controls
        this._escapedOverridesFileName.value = "";
        this._overridesLoader.reset();
        this._menuItemClearOverrides.set("disabled", true);

        // Display a suitable message
        this.handleReadError(responseObject);
      } else if (responseObject.properties) {
        /*
         * Enable the clear overrides menu item, update the tree grid and
         * display a success message.
         */ 
        this._menuItemClearOverrides.set("disabled", false);
        this.updateTreeWithOverrides(responseObject.properties);
        this._displayMessage("success", string.substitute(NLS.appliedOverridesSuccess, [this._overridesLoader.getFileList()[0].name, this._barFileName.value]));
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "readDeploymentDescriptorCompleted");
    },
		
    /**
     * The updateTree function updates the contents of the tree grid with the
     * content of the REST response from the server.
     *  
     * @param responseObject
     *          The response for the REST API call.
     */
    updateTree : function(responseObject) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "updateTree");
      
      // Save properties from BAR
      this._barData = JSON.parse(JSON.stringify(responseObject));

      /*
       * Update the model for the tree grid based on the contents of the 
       * response object.
       */
      var _propStore = new ItemFileWriteStore({
        data: {
          identifier: "id",
          label: "id",
          items: responseObject
        }
      });
      var _propModel = new ForestStoreModel({
        store: _propStore,
        childrenAttrs: ["children"]
      });
      this._propTreeGrid.setModel(_propModel);

			Trace.trace(this.declaredClass, Trace.levels.EXIT, "updateTree");
		},

    /**
     * The updateTreeWithOverrides function updates the contents of the tree 
     * grid with the content of the REST response from the server.
     *  
     * @param responseObject
     *          The response for the REST API call.
     */
    updateTreeWithOverrides : function(responseObject) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "updateTreeWithOverrides");
      
      /*
       * Iterate over the elements of the response object and attempt to find
       * a corresponding item in the data store for the tree grid.  If a match
       * is found, update the value 
       */
      var dataStore = this._propTreeGrid.treeModel.store;
      responseObject.forEach(lang.hitch(this, function(responseElem) {
        dataStore.fetch({query: { id: "*" + responseElem.id },
          queryOptions: { deep: true },
          onComplete: lang.hitch(this, function(items){
            for (var j = 0; j < items.length; j++) {
              dataStore.setValue(items[j], "value", responseElem.value);
            } // FOR
          })
        });
      }));
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "updateTreeWithOverrides");
    },

    /**
     * The handleReadError function displays a suitable message in the dialog
     * depending on the type of error specified in the response object.
     *  
     * @param res
     *          The response object for the REST API call.
     */
    handleReadError : function(res) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "handleReadBARError");
      
      var msg = NLS.UploadError_UploadFailed;
      if (res.error == "readBARError_invalidBAR") {
        msg += NLS.readBARError_invalidBAR;
      } else if (res.error == "readBARError_errorReadingBAR") {
        msg += NLS.readBARError_errorReadingBAR;
      } else if (res.error == "readOverridesError_errorReadingOverrides") {
        msg += NLS.readOverridesError_errorReadingOverrides;
      }
      
      this._displayMessage("error", msg);
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "handleReadBARError");
    },
    
    /**
     * The clearMessage function clears any existing messages from the dialog.
     */
    clearMessage : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "clearMessage");
      
      domClass.remove(this.messageIcon);
      domAttr.set(this.messageArea, "innerHTML", "");
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "clearMessage");
    },

    /**
     * The _displayMessage displays the specified message within the dialog.
     * 
     * @param type
     *          The type of the message.  Valid types are error, warning, info
     *          and success
     * @param message
     *          The message to display.
     */
    _displayMessage : function(type, message) { // valid types are error, warning, info, success
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_displayMessage");
      
      this.clearMessage();
      
      domClass.add(this.messageIcon, type);
      domAttr.set(this.messageArea, "innerHTML", message);
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_displayMessage");
    }
  });
  return deloyBARDialog;
});

},
'webui/widgets/business/FlowFilter':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2013,2016" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.  
 * </copyright> 
 * Widget for filtering flows to add to the business transaction  
 */
define("webui/widgets/business/FlowFilter", [
  "dojo/i18n!webui/nls/web",
  "dojo/_base/declare", 
  "dijit/_WidgetBase", 
  "webui/widgets/common/Trace",
  "webui/config/Resources",
  "dojo/dom",
  "dojo/dom-construct",
  "dojo/_base/array",
  "dojo/_base/lang",
  "dojo/string",
  "dojo/on",
  "dijit/form/ComboBox",
  "dijit/registry",
  "dojo/store/Memory",
  "dojo/request/xhr",
  "webui/widgets/common/UIUtils"
],
function(
  NLS,
  declare,
  _WidgetBase,
  Trace,
  Resources,
  dom,
  construct,
  array,
  lang,
  string,
  on,
  FilteringSelect,
  registry,
  Memory,
  xhr,
  UIUtils
) {
  var FlowFilter = declare("webui.widgets.business.FlowFilter", [_WidgetBase], {

    widgetContainer: null,

    // filtering widget, constructed programatically rather than in the template to 
    // allow more custom behaviour on hovering
    filteringSelect: null, 

    // list of flows or apps deployed on this broker that have not yet been added to the BTD
    // the dialog widget AddFlowDialog computes and maintains these lists and passes them the this widget
    _resources: [],
    
    // store containing the resources 
    _resourcesStore: null, 
    
    // Default to message flows
    filterSelection: Resources.businessTransaction.btAddFlow,

    // ID of the owning dialog
    parentId: null,
    
    // the owning dialog
    parent: null,
    
    // the model, contaning the flows in this BTD
    btModel: null,
    
    // Added flow details
    addedFlowsPlaceholder: null,
    
    constructor: function(/*Object*/ args){
      this.parentId = args.parentId;
      this.parent = args.parent;
      if(args.selectType) {
        this.filterSelection = args.selectType;  
      }
      if (args.btModel) {
        this.btModel = args.btModel;
      }
      if (args.resources) {
        this._resources = args.resources;
      }
    },
    
    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.widgetContainer = dom.byId(this.parentId);
      
      this._resourcesStore = new Memory({data: [], idProperty: "id"});
      // create the widget with this ID only once
      var selectId = "filterSelect_" + this.filterSelection;
      this.filteringSelect = registry.byId(selectId);
      if (!this.filteringSelect) {             
        this.filteringSelect = new FilteringSelect({
          "id": "filterSelect_" + this.filterSelection,
          "label": "Flow",
          "name": "btFlows",
          "store": this._resourcesStore,
          "searchAttr": "qualifiedName"
        }, "btFlowSelect");
      }
      
      // Disable user input into the combo box - but retin keyboard navigation
      this.filteringSelect.textbox.readOnly = true;
      
      var buttonContainer = construct.create("div", { 
        id: "filterContainer_" + this.filterSelection,
        className: "btAddFlowFilter"
      });

      var labelText = "";
      switch(this.selectType) {
        case Resources.businessTransaction.btAddFlow:
          labelText = NLS.btFlowName;
          break;
          
        case Resources.businessTransaction.btAddApp:
          labelText = NLS.application.label;
          break;
          
        case Resources.businessTransaction.btAddService:
          labelText = NLS.service.label;
          break;
          
        case Resources.businessTransaction.btAddRestApi:
          labelText = NLS.restApi.label;
          break;
      }
      
      var label1 = construct.create("label",{
        innerHTML: labelText,
        className: "btFlow_Label",         
       });
      
      label1.setAttribute("for", "filterSelect_" + this.filterSelection);

      construct.place(label1, buttonContainer);
      construct.place(this.filteringSelect.domNode, buttonContainer);

      this.addedFlowsPlaceholder = dom.byId("btFlowsFromArtifact");
      this.addedFlowsPlaceholder.innerHTML = "";

      construct.place(buttonContainer, this.widgetContainer);
      
      on(this.filteringSelect, 'change', lang.hitch(this, function () {
        dijit.hideTooltip("btFlowFilter");
        // If the value in the drop-down is empty then if applicable disable the add button
        if(this.filteringSelect.item == null) {
          this.removeFlowsAddedContent();
          this.parent.resetOKButton(); 
        }
        else {
          switch(this.selectType) {
            case Resources.businessTransaction.btAddFlow:
              this.showFlowForMessageFlow(this.filteringSelect.item);
              break;
            case Resources.businessTransaction.btAddApp:
              this.showFlowsForApp();
              break;
            case Resources.businessTransaction.btAddService:
              this.showFlowForService();
              break;
            case Resources.businessTransaction.btAddRestApi:
              this.showFlowForRestApi();
              break;
          }
        }
      }));

      this.filteringSelect.focus();
    },
    
    refreshStore : function(contentId) {
      // First assocaite qualified name value to be shown
      array.forEach(this._resources, lang.hitch(this, function(item, i) {
        var deployed = UIUtils.deriveLabelValue(item.uri);
        this._resources[i].qualifiedName = deployed[0];
        this._resources[i].deployedEG = deployed[1];
      }));
      
      // Sorting function
      var compare = function (a,b) {
        if (a.qualifiedName < b.qualifiedName) {
           return -1;
        }
        if (a.qualifiedName > b.qualifiedName) {
          return 1;
        }
        return 0;
      };
      this._resources.sort(compare);
      
      var data = [];
      for (var i = 0; i<this._resources.length;i++) {
        var resource = this._resources[i];
        var item = null;
        // Type determines the added value
        switch(this.selectType) {
          case Resources.businessTransaction.btAddFlow:
            if (this.isValidFlow(resource) && // add the resource if it's in an app, but not a service or restapi
                (resource && (resource.available))) { // if it's a flow, check if it hasn't been added yet
                item = {
                  "name":resource.name, 
                  "id": resource.uri, 
                  "parentName": resource.parentName, 
                  "parentType":resource.parentType,
                  "qualifiedName": resource.qualifiedName,
                  "deployedEG": resource.deployedEG
                };
                data.push(item);
              }
            
            break;
          
          // Else just add the first class artifact
          default:
          	item = {
                  "name": resource.name, 
                  "id": resource.uri, 
                  "parentName": resource.parentName, 
                  "parentType": resource.parentType,
                  "qualifiedName": resource.qualifiedName,
                  "deployedEG": resource.deployedEG
                };
            data.push(item);
            break;
        }
      }
      
      this._resourcesStore = new Memory({
        data: data,
        idProperty: "id"
      });

      this.filteringSelect.store = this._resourcesStore;
      
      // Remove the no items message (if there is one)
      construct.destroy(contentId + "_NoAdd");
      
      // If no items in the dropdown, set appropriate message
      if(data.length == 0) {
        var explanation = "";
        switch(this.selectType) {
          case Resources.businessTransaction.btAddFlow:
            explanation = NLS.btNoFlowsToAdd;
            break;
            
          case Resources.businessTransaction.btAddApp:
            explanation = NLS.btNoAppsToAdd;
            break;
          
          case Resources.businessTransaction.btAddService:
            explanation = NLS.btNoServicesToAdd;
            break;
            
          case Resources.businessTransaction.btAddRestApi:
            explanation = NLS.btNoRestApisToAdd;
            break;
        }        
        construct.place(construct.create("span",{
          innerHTML: explanation,
          id: contentId + "_NoAdd"
        }), contentId);
      }
    },
    
    updateAndRefresh: function(resources, messageId) {
      this._resources = resources;
      this.refreshStore(messageId);
      // Also check if the current selection is now no longer in the store, if it isn't deselect it...
      var selectedItem = this.getSelectedItem();
      if(selectedItem) {
        var result = this.queryStore({ id: selectedItem.id });
        if(result && result.length == 0) {
          this.filteringSelect.reset();
        }
      }
    },
    
    showFlowForMessageFlow: function(flow) {
      this.newFlows = [];
      this.newFlows.push({"name": flow.name, "uri": flow.id});
      this.existingFlows = [];
      this.parent.resetRadioButtons(this.selectType);
    },
    
    // Retrieve the flows contained within an App, when it is selected
    showFlowsForApp: function(){
      var item = this.filteringSelect.item;
      //http://localhost:4415/apiv1/executiongroups/default/applications/TestApplication/messageflows
      var uri =item.id+"/messageflows";
      this.executeFlowsRequest(uri);
    },
    
    // Retrieve the flow (should only be one contained within an Integration Service) when it is selected
    showFlowForService: function(){
      var item = this.filteringSelect.item;
      // http://localhost.hursley.ibm.com:4414/apiv1/executiongroups/default/services/TestService/messageflows
      var uri = item.id + "/messageflows";
      this.executeFlowsRequest(uri);
    },
    
    // Retrieve the flow (should only be one contained within an REST API) when it is selected
    showFlowForRestApi: function(){
      var item = this.filteringSelect.item;
      // http://localhost.hursley.ibm.com:4414/apiv1/executiongroups/default/restapis/TestRESTAPI/messageflows
      var uri = item.id + "/messageflows";
      this.executeFlowsRequest(uri);
    },
    
    // Request to establish the flows that will be added upon selecting a first class artifact.
    executeFlowsRequest: function(uri) {
      xhr(
          uri,
          {
            handleAs : "json",
            headers : {
               "Accept" : "application/json"
            }
          }
        ).then( lang.hitch(this, function(response) {
          var flows = response.messageFlow;
          // Reset tracking objects
          this.newFlows = [];
          this.existingFlows = [];
          var flow;
          for (var i=0;i < flows.length;i++) {
            flow = flows[i];
            if (this.btModel.containsElement(flow.uri)) {
              this.existingFlows.push(flow.name);
            }
            else {
              this.newFlows.push({"name": flow.name, "uri": flow.uri});
            }
          }
          this.parent.resetRadioButtons(this.selectType);
        }),
        lang.hitch(this, function(error) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Get flows Error: " + error.response.xhr.status + " Response: " + error.response.xhr.response);
        }));
    },
    
    // Set the flows that will be added information depending on the selection
    constructFlowsToAdd: function() {
      if((typeof this.newFlows === "undefined") || (this.newFlows.length == 0)) {
        
        var noFlowsMessage = "";
        var artifactName = this.filteringSelect.item.name;
        
        switch(this.selectType) {
          case Resources.businessTransaction.btAddFlow:
            if((typeof this.existingFlows === "undefined") || (this.existingFlows.length == 0)) {
              noFlowsMessage = string.substitute(NLS.btNoFlowsToAdd, [artifactName]);
            } else {
              noFlowsMessage = string.substitute(NLS.btNoAvailableFlowsToAdd, [artifactName]);
            }
            
            break;
            
          case Resources.businessTransaction.btAddApp:
            noFlowsMessage = string.substitute(NLS.btNoAppFlowsToAdd, [artifactName]);
            break;
          
          case Resources.businessTransaction.btAddService:
            noFlowsMessage = string.substitute(NLS.btNoServiceFlowsToAdd, [artifactName]);
            break;
            
          case Resources.businessTransaction.btAddRestApi:
            noFlowsMessage = string.substitute(NLS.btNoRestApiFlowsToAdd, [artifactName]);
            break;
        }
        content = "<div>" + noFlowsMessage + "</div>";     
        this.addedFlowsPlaceholder.innerHTML = content;
        this.parent._okButton.setDisabled(true);
        return;  
      }
      // at least one flow to add
      var content = "<div class='btMessageFlowsTableDesc'>" + NLS.btAddingFlows + "</div>";

      content += this.createFlowTable(this.newFlows);
      
      // Only add already added flows if there are any
      if((typeof this.existingFlows !== "undefined") && (this.existingFlows.length > 0)) {
        content += "<div class='btMessageFlowsTableDesc'>" + NLS.btFlowsAlreadyAdded + "</div>";
        content += this.createFlowTable(this.existingFlows);
      }
      
      this.addedFlowsPlaceholder.innerHTML = content;
      this.parent._okButton.setDisabled(false);
    },
    
    createFlowTable: function(flows) {
      var table = "<table class='btMessageFlows_table'";
      
      // Sort out flows into two columns to be added to table
      var col1 = flows.slice(0,(flows.length + 1) / 2);
      var col2 = [];
      if(flows.length > 1) {
        col2 = flows.slice(col1.length,flows.length);
      }
      
      for(var i=0; i < col1.length; i++) {
        table += "<tr><td>" + (col1[i].name || col1[i])  + "</td><td>";
        if(i < col2.length) {
          table += (col2[i].name || col2[i]);
        } 
        table += "</td></tr>";
      }
      
      table += "</table>";
      
      return table;
    },
    
    // Validate if flow can be added to list, so not in a Service or REST API
    isValidFlow: function(flow) {
      if((flow.parentType === Resources.REST.servicesType) || (flow.parentType === Resources.REST.restApisTypeUri)) {
        return false;
      }
      
      return true;
    },
    
    removeFlowsAddedContent: function() {
      this.addedFlowsPlaceholder.innerHTML = "";
    },
    
    removeFlow: function(item) {
       this._resourcesStore.remove(item);    
       this.filteringSelect.store = this._resourcesStore;           
    },
    
    getResources: function(){
      return this._resources;
    },
    
    getSelectedItem: function () {
      return this.filteringSelect.item;
    },
    
    queryStore: function(queryCondition) {
      return this._resourcesStore.query(queryCondition);
    },
    
    destroy: function(){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "destroy");
      this.inherited(arguments);
      if (this.filteringSelect) {
        this.filteringSelect.destroyRecursive();
      }      
      construct.empty(this.widgetContainer);
      this._resourcesStore = null;
    }
  });
  return FlowFilter;
});

},
'webui/widgets/service/svc_overview':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="2128363747" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/service/templates/svc_overview.html",
	"dojo/i18n!webui/nls/web",
	"dojo/_base/array",
	"dojo/_base/declare", 
	"dojo/_base/lang",
	"dojo/dom-attr",
	"dojo/dom-construct",
	"dojo/query",
  "dojo/ready",
	"dojo/request/xhr",
  "dojo/string",
	"dijit/_TemplatedMixin",
	"dijit/_WidgetBase", 
  "dijit/_WidgetsInTemplateMixin",
  "dijit/registry",
  "webui/widgets/common/AttributesStore",
  "webui/widgets/common/HasContextMenu",
	"webui/widgets/common/PropertiesStore",
	"webui/widgets/common/QuickAndAdvancedProperties",
	"webui/widgets/common/Toolbar",
	"webui/widgets/common/Trace",
	"webui/widgets/common/UIUtils"
], function(
  template,
  NLS,
  array,
  declare,
  lang,
  domAttr,
  domConstruct,
  query,
  ready,
  xhr,
  string,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  registry,
  AttributesStore,
  HasContextMenu,
  PropertiesStore,
  QuickAndAdvancedProperties,
  Toolbar,
  Trace,
  UIUtils
) {
  var svcOverview = declare("webui.widgets.service.svc_overview", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
    templateString: template,
    toolbar: null,
    _propertiesStore: new PropertiesStore(),
    _attributesStore : new AttributesStore(),

    postCreate: function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			this.inherited(arguments);	
			
			
			// Create toolbar
			this.toolbar = new Toolbar();
			domConstruct.place(this.toolbar.domNode, this._toolbar);
			this.toolbar.addLeftAlignButtons("title");

			this.properties = new QuickAndAdvancedProperties("service");
			this.properties.createPropertiesContainer(this._propertyTitlePane);
			
    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},
		
		resize: function() {
			this._svcOverview_borderContainer.resize();
		},
	    
		// This function is called manually when we need to remove this tab.
		tabRemove: function() {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
            
		  this.properties.unsubscribeAll();

		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove"); 
		},
		
		contextButtonsClicks : function(event) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks", [event]);
			
			// Get the URI and action from the event:
			var uriAndAction = UIUtils.getURIAndAction(event, true);
			var itemURI = uriAndAction.uri;
			var buttonType = uriAndAction.action;
		    
			if(buttonType == "statsOn" || buttonType == "statsOff"){
			  this.actionButtonSetStatsContainer(itemURI, buttonType);
			} else if (buttonType == "saveInterfaceFiles") {
			  this.actionButtonSaveInterfaceFiles(itemURI, buttonType);
			} else {
			  this.actionSvc(itemURI, buttonType);
			}
		
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
		},
		
		actionButtonSaveInterfaceFiles : function(itemURI,buttonType) {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionButtonSaveInterfaceFiles",[itemURI,buttonType]);
		  var targetUri = itemURI.substring(0, (itemURI.length - (buttonType.length+1))) +  "/interfaceFilesAsZip";

		  ready(function(){  
		    var ifrm = document.createElement("IFRAME");
		    ifrm.setAttribute("src", targetUri);
		    document.body.appendChild(ifrm);  
		  });

		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionButtonSaveInterfaceFiles");
		},

		actionButtonSetStatsContainer : function(itemURI,buttonType){
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionButtonSetStatsContainer",[itemURI,buttonType]);
		  var targetUri = itemURI.substring(0, (itemURI.length - (buttonType.length+1)));
		  var uriStatsparam;
		  if(buttonType == "statsOn"){
		    uriStatsparam="on";
		  }else if(buttonType == "statsOff"){
		    uriStatsparam="off";
		  }
		  
		  // Add loading icon to tree
		  var tree = registry.byId('_explorerTree_ID');      
		  var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
		  var oldIcon = domAttr.get(treeImgs[0],"class");
		  domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");
		  
		  xhr.put(
		    targetUri + "?action=setStatistics&setStatistics=" + uriStatsparam,
		    {
		      handleAs:"json",
		      headers : {
		        "Accept" : "application/json"
		      }
		    }
		  ).response.then(lang.hitch(this, function(response){
		    Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionButtonSetStatsContainer.xhrLoad",[response]);
		    
		    //reset old icon
		    domAttr.set(treeImgs[0],"class",oldIcon);
		    
		    if(buttonType == "statsOn"){
		      window.smallMessage.displayMessage("success", "FlowStatsAction_successstatsOn");
		    } else {
		      window.smallMessage.displayMessage("success", "FlowStatsAction_successstatsOff");
		    }
		    
		    Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionButtonSetStatsContainer.xhrLoad");
		  }), lang.hitch(this,function(error){     
		    Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionButtonSetStatsContainer.xhrError",[error]);
		    
		    //reset old icon
		    domAttr.set(treeImgs[0],"class",oldIcon);
		    //show error message
		    var response = JSON.parse(error.response.text);
		    if(buttonType == "statsOn") {
		      window.smallMessage.displayMessage("error", "msgflowstatsOn_5XX", response.bipNumber, response.description);
		    } else {
		      window.smallMessage.displayMessage("error", "msgflowstatsOff_5XX", response.bipNumber, response.description);
		    }
		    
		    Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionButtonSetStatsContainer.xhrError");
		  }));
		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionButtonSetStatsContainer");
		},
		
		actionSvc : function(uri, action){
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionSvc",[uri, action]);

			var uriArray = uri.split("_");
			var buttonType = uriArray[uriArray.length - 1];
			uri = uri.substr(0,uri.length - buttonType.length - 1);	

			
			var tree;
			if (null!=action && action === "delete" ) {
			  tree = registry.byId('_explorerTree_ID');
			  var svcName = tree.selectedNode.item.name;//label can be truncated, so use name instead
	              
			  var confirmationMessage = string.substitute(NLS.messages.DeleteServiceAction_confirmation, [svcName] );
	              
			  var confirmCallback = lang.hitch(this, function() {

			    //	Add loading icon to tree
			    var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
			    var oldIcon = domAttr.get(treeImgs[0],"class");
			    domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");        	

			    // REST Call to delete the service
			    xhr.del(
			      uri,
			      {
			        handleAs : "json",
			        headers : {
			          "Accept" : "application/json"
			        }
			      }
			    ).then( lang.hitch(this, function() {
			      Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Service delete success");
			      
			      //reset old icon
			      domAttr.set(treeImgs[0],"class",oldIcon);
			      
			      // Display success message for deleting an service
			      window.smallMessage.displayPlainMessage("success", "DeleteServiceAction_successServiceDeleted", [svcName]);
			    }), lang.hitch(this, function(error) {
			      
			      Trace.trace(this.declaredClass, Trace.levels.ERROR, "actionSvc.xhrDel to " + uri + " failed.", [error]);
			      //reset old icon
			      domAttr.set(treeImgs[0],"class",oldIcon);

			      //show error message
			      var response = JSON.parse(error.response.text);
			      window.smallMessage.displayMessage("error", "svcdelete_5XX",response.bipNumber, response.description);
			    }));
			  });
			  
			  window.wmbConsole.showConfirmationDialog("btConfirmDelete", "question", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, confirmationMessage, confirmCallback, null);
			  
			}//if - (delete action)
			else {
	        	
				//	Add loading icon to tree
				tree = registry.byId('_explorerTree_ID');	
	            var treeNodeID = tree.selectedNode.id;//store this for the call to this.buttonState()
				var treeImgs = query('#' + treeNodeID + ' .dijitTreeIcon');
	      var oldIcon = domAttr.get(treeImgs[0],"class");
				domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");
							
				xhr.put(
				  uri + "?action=" + action,
				  {
				    handleAs:"json",
				    headers : {
				      "Accept" : "application/json"
				    }
				  }
				).response.then( lang.hitch(this, function(response){
				  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionSvc.xhrLoad()",[response]);
				  
				  this.buttonState(action, uri, treeNodeID);

                  var svcName = tree.selectedNode.item.name;//label can be truncated, so use name instead
                  if (action === "startFlowMonitoring") {
      	            window.smallMessage.displayPlainMessage("success", "FlowMonitoringStartedSuccessfully_Service", [svcName]);
                  } else if (action === "stopFlowMonitoring") {
                	window.smallMessage.displayPlainMessage("success", "FlowMonitoringStoppedSuccessfully_Service", [svcName]);
                  }
	                   
				  Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionSvc.xhrLoad()");
			  }), lang.hitch(this,function(error){	
			    Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionSvc.xhrError()",[error]);

			    Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrPut to " + uri + " failed.", [error]);
			    //reset old icon
			    domAttr.set(treeImgs[0],"class",oldIcon);
			    //show error message
			    var response = JSON.parse(error.response.text);
			    if(action == "start"){
			      window.smallMessage.displayMessage("error", "svcstart_5XX",response.bipNumber, response.description);
			    } else if (action === "stop") {
                  window.smallMessage.displayMessage("error", "svcstop_5XX",response.bipNumber, response.description);
                } else if (action === "startFlowMonitoring") {
                  window.smallMessage.displayMessage("error", "FlowMonitoringFailedToStart");
                } else if (action === "stopFlowMonitoring") {
                  window.smallMessage.displayMessage("error", "FlowMonitoringFailedToStop");
                }
			    Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionSvc.xhrError()");
			  }));
	        	
			}//endif - (not delete action)
			
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionSvc");
		},
        
		buttonState:function(action, uri, treeNodeID){
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "buttonState", [action, uri]);

		  // Disable and enable the relevant buttons
		  var treeImgs = query('#' + treeNodeID + ' .dijitTreeIcon');
		  var populateAttributesStore = this._attributesStore.populateAttributesStore(uri);  
		  var populatePropertiesStore = this._propertiesStore.populatePropertiesStore(uri);
            
		  populatePropertiesStore.then(lang.hitch(this, function() {
		    populateAttributesStore.then(lang.hitch(this, function() {
		      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "buttonState.then", [action, uri]);
		      // Get the flow's running status
		      var running = this._propertiesStore.getProperty("basic", "isRunning") == "true";
		      var hasServiceURL = this._propertiesStore.getProperty("basic", "soapHTTPURL") !== "";
		      var name = this._attributesStore.getAttribute("name");
                    
		      // Set the TreeNode icon as appropriate
		      if (running) {
		        domAttr.set(treeImgs[0], "class", "dijitInline dijitIcon dijitTreeIcon explorer_service_running");
		      } else {
		        domAttr.set(treeImgs[0], "class", "dijitInline dijitIcon dijitTreeIcon explorer_service_stopped");
		      }
                    
		      // Same for context menu
		      this._updateContextMenuTitle(uri, name, "service", running);

		      //Now show/hide the appropriate start/stop stats on/off buttons, but greying out as appropriate
		      //Again iterating over all viewable buttons to find the ones which we have just changed
		      array.forEach(this._getContextButtons(uri), function(button) {
		        var tmp = button.id.split("_");
		        var buttonType = tmp[tmp.length - 1];
		        var thisButtonUri = button.id.substring(0,button.id.length - (buttonType.length+1));
                
		        if( thisButtonUri == uri){
		          switch(buttonType){
		          case "start":
		            button.set("disabled", running);
		            break;
		          case "stop":
		            button.set("disabled", !running);
		            break;  
		          case "saveInterfaceFiles":
		            button.set("disabled", !running || !hasServiceURL);
		            break;
		          }
		        }
		      }, this);
		      Trace.trace(this.declaredClass, Trace.levels.EXIT, "buttonState.then");
		    }));
		  }));
		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "buttonState");
		},

		tabFocus: function () {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus"); 
		  // Get service name and add to the toolbar title
		  this.toolbar.setAttribute("title", "innerHTML", "");
		  var populate = this._attributesStore.populateAttributesStore();
		  populate.then(lang.hitch(this, function() {
		    domAttr.set("_infoPaneTitleID", "innerHTML", this._attributesStore.getAttribute("name") + " - " + NLS.serviceTitle);
		  }));
    
		  // Populate quick view and advanced properties
		  this.properties.populateProperties();
    
		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
		},
        
		tabBlur: function () {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur"); 
		  
		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
		}
  });
	return svcOverview;
});

},
'webui/widgets/policy/MessageDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63" 
 * years="2014, 2015" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63 
 *  
 * (C) Copyright IBM Corp. 2014, 2015 All Rights Reserved.  
 * </copyright> 
 *
 * 
 * MessageDialog widget - widget with a description attributes
 * 
 */
define(
  "webui/widgets/policy/MessageDialog",
  [
    "dojo/text!webui/widgets/policy/templates/MessageDialog.html", 
    "dojo/i18n!webui/nls/web", 
    "dojo/_base/declare",
    "dijit/Dialog",
    "dijit/_TemplatedMixin", 
    "dijit/_WidgetsInTemplateMixin",
    "webui/widgets/common/Trace", 
    "dojo/keys",
    "dojo/_base/event"
  ], 
  function( 
    template, 
    NLS, 
    declare,
    Dialog,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    Trace,
    keys,
    event
  ) {

	  var messageDialog = declare("webui.widgets.policy.MessageDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
	    templateString : template,
	    _firstTimeValidation : false,
	    _messageOKLabel: NLS.okButtonLabel,
	    _buttonCancel: NLS.cancelButtonLabel,
	    
	    _onKey : function(evt) {
	      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onKey");
	      this.inherited(arguments);
	      if (evt.charOrCode) {
	        if (evt.charOrCode === keys.ENTER) {
	          if ( !this._okButton.get("disabled" ) ) {
	            event.stop(evt);
	            this.hide();
	          }
	        }
	      }
	      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onKey");
	    },

	    postCreate : function() {
	      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
	      this.inherited(arguments);

	      this.titleNode.setAttribute("tabIndex", -1);
	      this.instructionNode.setAttribute("tabIndex", -1);
	               		        
	      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
	    },
	        
	    refresh : function() {
	      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "refresh");

	      if (this._value != null) {
	       //Set the flag value to detect if the dialog has been just opened.
	        this._firstTimeValidation = true; 
	      }
	      this._okButton.set("disabled", false);
	      this._firstTimeValidation = true;
	      Trace.trace(this.declaredClass, Trace.levels.EXIT, "refresh");
	    }
	    
	  });
		return messageDialog;
	}
);

},
'webui/widgets/business/businesstransaction_results':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2013,2016" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.  
 * </copyright> 
 * 
 * This widget shows the grid of business transaction results, as well as (optionally)
 * the individual monitoring events involved in a selected business transaction.
 */
define(
  "webui/widgets/business/businesstransaction_results",
  [
    "dojo/text!webui/widgets/business/templates/businesstransaction_results.html",
    "dojo/i18n!webui/nls/web",
    "dojo/_base/declare",
    "dijit/_WidgetBase",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/registry",
    "webui/widgets/common/AttributesStore",
    "webui/widgets/common/Trace",
    "dojo/_base/lang",
    "webui/widgets/common/Toolbar",
    "dojo/hash",
    "dojo/on",
    "dojo/string",
    "dojo/dom-class",
    "dojo/dom-construct",
    "dijit/TitlePane",
    "webui/config/Resources",
    "webui/widgets/common/UIUtils",
    "dojo/_base/array",
    
    // Grid X
    "gridx/Grid",
    "gridx/core/model/cache/Sync",
    'gridx/core/model/cache/Async',
    "gridx/modules/VirtualVScroller",
    "gridx/modules/ColumnResizer",
    "gridx/modules/ColumnWidth",
    "gridx/modules/select/Row",
    "gridx/modules/Filter",
    "gridx/modules/Focus",
    /*"gridx/modules/filter/FilterBar",*/
    /*"gridx/modules/Pagination",*/
    /*"gridx/modules/pagination/PaginationBar",*/
    "dojo/store/Memory",
    "dojo/store/JsonRest",
    "dojo/request/xhr",
    "webui/widgets/business/EventDetailsDialog",
    "dojo/query",
    "dojo/dom-style",  
    "webui/widgets/business/BTDFilteringOptionsDialog"
  ],
  function(
    template,
    NLS,
    declare,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    registry,
    AttributesStore,
    Trace,
    lang,
    Toolbar,
    hash,
    on,
    string,
    domClass,
    domConstruct,
    TitlePane,
    Resources,
    UIUtils,
    array,
    
    // GridX
    Grid,
    CacheSync,
    CacheAsync,
    VirtualVScroller,
    ColumnResizer,
    ColumnWidth,
    SelectRow,
    Filter,
    Focus,
    /*FilterBar,*/
    /*Pagination,*/
    /*PaginationBar,*/
    // Dojo Store
    Store,
    JsonRest,
    xhr,
    EventDetailsDialog,
    dojoQuery,
    domStyle,
    BTDFilteringOptionsDialog
  ) {

  var resultsWidget = declare("webui.widgets.business.businesstransaction_results", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
    templateString : template,

    toolbar : null,
    _refreshResultsView : false,
    _attributesStore: new AttributesStore(),
    _filterParamsString : null,
    _filterConditions : null,
    _filteringOptionsDialog : null,
    _eventDetailsDialog : null,
    _selectedBTDInstance : null,
    _totalBTDsLabel : null,
    _totalBTDeventsLabel : null,
    _viewResultsHandlers: [],
    
    // no results loading on tabFocus
    // on first click of the Refresh or Filter, initialise the store
    storeInitialised: false,
    
    constructor : function(args) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");
      
      this.inherited(arguments);
      this.btName = args.event.name;
      if (!this.btName) {
    	  this.btName = args.event.type;
      }
      this._filterParamsString = "";
      this._filterConditions = null;
      this._refreshResultsView = true;
      
      if (!this._filterConditions){
    	  this._filterConditions = this._getDefaultFilterOptions();
      }//if

      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
    },
    
    _getDefaultFilterOptions : function() {

    	var defaultFilterOptions =
    		
        {
          	    "conditions" : 
          	    	[
          	    	 
    	         		{ 
    	          	        "colId" : Resources.REST.businessTransactionResultParameter.id,//fixed
    	          	    	"checked" : false,
    	          	        "value": null,
    	          	        "verb": null,
    	          	        "type": "string"//fixed
    	          	    },
    	          	    {
    	         	        "colId" : Resources.REST.businessTransactionResultParameter.status,//fixed      	    	
    	          	    	"checked" : false,
    	          	        "value": null,
    	          	        "verb": "equals",//fixed
    	          	        "type": "string"//fixed
    	                }
          	    	 
          	        ]
         };
    	
    	return defaultFilterOptions;
    		
    },
    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      this._attributesStore.populateAttributesStore();

      // Create toolbar
      this.toolbar = new Toolbar();
      domConstruct.place(this.toolbar.domNode, this._toolbar2); // `_toolbar2` from HTML template

      //////////////////////////////////////////////////////////////////////
      
      // "Transaction results"
      this._resultsTp = new TitlePane({
        title : NLS.btResults
      });
      this._businessResultsBody.appendChild(this._resultsTp.domNode);
      this._resultsTp.startup();

      // "Detailed events"
      
      this._eventsTp = new TitlePane({
        title : NLS.btResultsEvent
      });
      this._businessResultsBody.appendChild(this._eventsTp.domNode);
      this._eventsTp.startup();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },

    startup : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "startup");
      
      this.inherited(arguments);

      this._createResultsTables();
      
      this._show_ClearFilter_Button(false);
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "startup");
    },
                  
      _destroyEventDetailsDialogIfItExists : function() {
        if (this._eventDetailsDialog) {
          this._eventDetailsDialog.destroy();
          this._eventDetailsDialog=null;
        }
      },
    
    _createResultsTables: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createEventTables");

      domClass.add(this._resultsTp.focusNode, "btSectionTitlePane");
      domClass.add(this._resultsTp.titleBarNode, "btSectionTitlePane_titleBarNode");
      domClass.add(this._resultsTp.containerNode, "btSectionTitlePane_containerNode");

      this.createButtonsForResultsTable(this._resultsTp.titleBarNode);
      this._btResultsGrid = this._getTransactionResultsGrid();
      
      domClass.add(this._eventsTp.focusNode, "btSectionTitlePane");
      domClass.add(this._eventsTp.titleBarNode, "btSectionTitlePane_titleBarNode");
      domClass.add(this._eventsTp.containerNode, "btSectionTitlePane_containerNode");
   
      this.createButtonsForEventsTable(this._eventsTp.titleBarNode);
      this._eventsGrid = this._getEventsResultsGrid();
   
      // Override default toggling behaviour.
      // Want to check whether we need to toggle, or if click event has propagated from filter option, if so then no toggle needed.
      lang.mixin(this._resultsTp,
        {
          toggle:function(){ 
        	  this.resize();//so table is always proper size (calls ContentPane.resize())
          }
        }
      );
      
      // Responsible for performing the toggle of the title pane, if event (click or key press) hasn't come from one of the filter buttons, then toggle.
      // This prevents us using event.stopPropagation which is highly un-recommended.
      // Click listened for on title pane title bar.
      on(this._resultsTp.focusNode,  "click", lang.hitch(this, function(event) {
        if((typeof event === "undefined") || (event.target.className !== "bt_BusinessTransactionSectionButtonActive")) {
          this._resultsTp.set('open', !this._resultsTp.open);
        }
        // Else do nothing, event has already been handled.
      }));

      
      // Override default toggling behaviour.
      // Want to check whether we need to toggle, or if click event has propagated from refresh option, if so then no toggle needed.
      lang.mixin(this._eventsTp,
        {
          toggle:function(){ 
        	  this.resize();//so table is always proper size (calls ContentPane.resize())
          }
        }
      );

      // Responsible for performing the toggle of the title pane, if event (click or key press) hasn't come from the refresh button, then toggle.
      // This prevents us using event.stopPropagation which is highly un-recommended.
      // Click listened for on title pane title bar.
      on(this._eventsTp.focusNode,  "click", lang.hitch(this, function(event) {
        if((typeof event === "undefined") || (event.target.className !== "bt_BusinessTransactionSectionButtonActive")) {
          this._eventsTp.set('open', !this._eventsTp.open);
        }
        // Else do nothing, event has already been handled.
      }));
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createEventTables");
    },

    // Returns: the default GridX object that displays results data
    _getTransactionResultsGrid : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_getTransactionResultsGrid");

      this._resultsTp.set('title', string.substitute(NLS.btResultsInstanceAll, [this.btName]));

      var eventResultsData = [];    

      /* - Remove when no pagination
      // Default query values
      this._queryParams = {
          "pageNumber" : 1,
          "numberOfEntriesPerPage" : Resources.REST.businessTransactionResultsPageSize
      };*/
      
      // Have empty store on first visit to page
      this._btResultsStore = new Store({
        data: eventResultsData,
        idProperty: "id"
      });

      // Create the grid with an empty store - so as not to make an initial call upon grid creation
      var resultsGrid = new Grid({
        store: this._btResultsStore,
        cacheClass: CacheAsync,
        // For now set to limit of 1000 - may need to re-address when showing more than 1000 results.
        cacheSize: Resources.REST.businessTransactionResultsPageSize,
        bodyEmptyInfo: NLS.btResultsTableOnEntry,        
        clearCache: false,
        hasFilter: false,
        structure: [
                    { id: Resources.REST.businessTransactionResultParameter.id, field: Resources.REST.businessTransactionResultParameter.id,
                        dataType: "string", name: NLS.btResultsTableBtxId, width: '17.5%' },
                    { id: Resources.REST.businessTransactionResultParameter.startTimestamp, field: Resources.REST.businessTransactionResultParameter.startTimestamp,
                        dataType: "Date", name: NLS.btResultsTableStartTime, width: '21%' },
                    { id: Resources.REST.businessTransactionResultParameter.lastUpdateTimestamp, field: Resources.REST.businessTransactionResultParameter.lastUpdateTimestamp,
                        dataType: "Time", name: NLS.btResultsTableLastUpdate, width: '21%' },
//                    { id: Resources.REST.businessTransactionResultParameter.elapsedTimestamp, field: Resources.REST.businessTransactionResultParameter.elapsedTimestamp,
//                        dataType: "Time", name: NLS.btResultsTableElapsedTime, width: '21%' },
                    { id: Resources.REST.businessTransactionResultParameter.status, field: Resources.REST.businessTransactionResultParameter.status,
                        dataType: "string", name: NLS.btResultsTableStatus, width: 'auto',formatter : lang.hitch(this, this._translateStatus ) }
                  ],
        autoHeight: false,
        autoWidth: false,
        autoResize: true,
        // Select a row when any cell in that row is clicked.
        selectRowTriggerOnCell: true,
        selectRowMultiple: false,
        // Filter Bar Characteristics
        /*filterBarCloseButton: false,
        filterBarMaxRuleCount: 5,
        filterBarRuleCountToConfirmClearFilter: 1,*/
        // These two properties means no changing of page size (so only default is available in table view), or a go to button
        /*paginationBarGotoButton: false,
        paginationBarSizes : [],
        paginationBarMessage: NLS.btResultsTableResultsMessageTotal + ": ${0} " + NLS.btResultsTableResultsMessageRange + ": ${2} - ${3}",
        paginationInitialPageSize: Resources.REST.businessTransactionResultsPageSize,*/
				// Set a reasonable buffer size to balance memory use and smoothness when scrolling
        modules: [
          {
            moduleClass : VirtualVScroller,
            buffSize: 25,
            lazy: false
          },
          ColumnResizer,
          ColumnWidth,
          SelectRow,
          /*{
            moduleClass : Pagination,
            serverMode : true,
            // For now as Pagination bar has been removed these two functions shouldn't get called as no mechanism to change page size of page number
            onSwitchPage: lang.hitch(this, function(newPage){  

              // Set the page value for REST call parameters
              this._queryParams.pageNumber = newPage + 1;    
              this._btResultsStore.headers.QueryParams = this._generateRESTQueryString(this._queryParams, this._filterParamsString);

              /* 
               * Clear cache when switching to first page, and notification that a clearCache is needed (when changing result set that is being viewed).
               * Otherwise we sometimes suffer:
               *  console.error("Error of _Cache._addRow: different row id " + id + " and " + ids[index + 1] + " for same row index " + index);
               */
              /*
              if(resultsGrid.clearCache && (newPage === 0)) {
                resultsGrid.model.clearCache();
                resultsGrid.clearCache = false;
              }

              return newPage;
            }),
            onChangePageSize: lang.hitch(this, function(newPageSize){

              // Clear the cache to ensure no duplicate entries on increasing size of viewing page
              if((newPageSize > this._queryParams.numberOfEntriesPerPage) && (this._queryParams.pageNumber === 1)) {
                resultsGrid.model.clearCache();
              }
              
              this._queryParams.numberOfEntriesPerPage = newPageSize;
              this._btResultsStore.headers.QueryParams = this._generateRESTQueryString(this._queryParams, this._filterParamsString);

              return newPageSize;
            })
          },*/
          /*PaginationBar,*/
          Focus,
          {
            moduleClass : Filter,
            serverMode: true,
            /*
             * GridX has very infrequent, odd behaviour when it comes to combining REST Store data, applying filtering on that data, and Pagination navigation.
             * In a specific scenario of moving around the pages and visiting the 1st page of results (or only if not many results),
             * the cache can duplicate id of row items. It seems its not getting cleaned out of what is being viewed from one page to the next.
             * As we are assuming we want a fresh view of the world every time we change a page number, size, filter param etc. then a new call is always made.
             * Thus the cache size is set explicitly to 0, but despite this the problem still seems to be hit.
             * Some extra checked code has been added in this function to set variables (hasFilter & clearCache) which track filter state of the grid.
             * If these are true when pagination occurs, then the cache is manually cleared (see onSwitchPage and onChangePageSize functions in Pagination module)
             * so that the grid and store doesn't become corrupt.
             */  
            setupFilterQuery: lang.hitch( this, function(expr){
              // If empty filter i.e. no filter applied
              if((typeof expr === "undefined") || (expr === null))  {
                // If going from filtered results, to unfiltered then clear the cache to reset the view 
                if(resultsGrid.hasFilter) {
                  resultsGrid.hasFilter = false;
                  resultsGrid.clearCache = true;
                }
                // Set no filter string
                this._filterParamsString = "";
              } else {
                // If going from non-filtered results, to filtered then set to clear the cache to reset the view 
                if(!resultsGrid.hasFilter) {
                  resultsGrid.hasFilter = true;
                  resultsGrid.clearCache = true;
                }
                // Change this to use the new filter expr value
                this._filterParamsString = this._updateFilterQueryParams(expr);
              }
              
              // Only set this if btResultsStore has been initiallised
              if (this.storeInitialised) {
                // Update the headers in the store query
                this._btResultsStore.headers.QueryParams = this._generateRESTQueryString(/*this._queryParams,*/ this._filterParamsString);
              }

              return null;
            })
          }
          /*FilterBar,*/
          /*Removed quick filter for now to set out how to handle such queries
          QuickFilter,*/
        ]
      });
      
      this._totalBTDsLabel = domConstruct.create("label");
      this._totalBTDsLabel.setAttribute("id", "totalBTDs");
      this._totalBTDsLabel.setAttribute("style", "display: block;padding-bottom: 5px;");
      this._updateBTDsTotalLabel(0);
      


      var newOuterDiv = domConstruct.create("div", { id: "btTransactionResultsGridOuterContainer"});
      
      var newDiv = domConstruct.create("div", { id: "btTransactionResultsGrid", className: "btResultsGridContainer"}); 
      newOuterDiv.appendChild(this._totalBTDsLabel);
      newOuterDiv.appendChild(newDiv);
      
      this._resultsTp.set("content", newOuterDiv);
      
      resultsGrid.placeAt("btTransactionResultsGrid");

      resultsGrid.startup();

      // Connect error handling to show error messages to messages bar
      resultsGrid.connect(resultsGrid.body, 'onLoadFail',
          lang.hitch(this, function(error) {
            var response = JSON.parse(error.response.text);
            window.smallMessage.displayMessage("error", "BusinessTransactionViewer_5XX", response.bipNumber, response.description);
            
          }
        )
      );
      
      resultsGrid.connect(resultsGrid.body, 'onRender',
          lang.hitch(this, function() {
        	  var theBTDCount = resultsGrid.rowCount();
        	  //step 1. update the label
        	  this._updateBTDsTotalLabel(theBTDCount);
        	  //step 2. issue a warning if maximum was reached.
        	  if (theBTDCount >= Resources.REST.businessTransactionResultsPageSize){//1000 right now
                  window.smallMessage.displayPlainMessage("warning", "BusinessTransaction_MaxRowsReached", [ this.btName ] );        
        	  }//if
          }
        )
      );

      // Track the current grid height...      
      this.gridHeight = 300;
      
      // Callback to get initial height and then check if grid needs resizing.
      var onViewOnUpdateCallback = lang.hitch(this, function() {
        if(typeof this._btResultsGrid != "undefined") {
          if(this.gridHeight === null) {
            this.gridHeight = this._btResultsGrid.domNode.clientHeight;
          }
          resizeGridCallback();
        }
      });

      // Callback to resize the grid.
      // If the scroller bar is not showing (so grid might need making smaller),
      // then use gridX autoheight to resize in bounds of container.
      // If showing grid scroller might need making bigger (showing 2 rows, to now showing 20),
      // so ensure we maximise grid size within container bounds.
      // Force resize with height by setting initial height (so default)
      // resizeGridCallback() called again incase reverting back to default has now made it to big, so make smaller as per normal.
      var resizeGridCallback = lang.hitch(this, function() {
        if(typeof this._btResultsGrid != "undefined") {
          // Only resize if the grid has been instantiated (shown before)
          if((this._btResultsGrid.vScrollerNode.style.display === "none") && (this._btResultsGrid.domNode.clientHeight > 0) && (this._btResultsGrid.domNode.clientWidth > 0)) {
            this._btResultsGrid.autoHeight = true;
            this._btResultsGrid.resize();
            this._btResultsGrid.autoHeight = false;
            return;
          } else {
            // Only resize if the grid has been instantiated (shown before)
            if((this.gridHeight > this._btResultsGrid.domNode.clientHeight) && (this._btResultsGrid.domNode.clientWidth > 0)) {
              this._btResultsGrid.resize({w: this._btResultsGrid.domNode.clientWidth, h: this.gridHeight});
              resizeGridCallback();
            }
          }
        }
      });

      resultsGrid.connect(resultsGrid.view, 'onUpdate', onViewOnUpdateCallback);

      // RE-ADD When we have singular event data to show from Store
      // Add event handlers for the results grid
      // Event fired on module select, so module event not grid event
      resultsGrid.connect(resultsGrid.select.row, 'onSelected',
          lang.hitch(this, function(data, rowId) {

        	  var selectedItem = resultsGrid.select.row.model.byId( rowId );
        	  
            this._clearEventsGrid();
              
        	  this._selectedBTDInstance = selectedItem.item;//also used by Events table
        	  
        	  this._queryEventsForBTD(this._selectedBTDInstance);        	  
          }
        )
      );

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_getTransactionResultsGrid");
      
      return resultsGrid;
    },

    _updateBTDsTotalLabel : function(rowCount) {
    
  	  var totalLabel = string.substitute(NLS.btRowsTotalCount, [rowCount] );
	  
	  this._totalBTDsLabel.innerHTML = totalLabel;
    	
    	
    },
    
    _updateBTDeventsTotalLabel : function(rowCount) {
        
      var totalLabel = string.substitute(NLS.btRowsTotalCount, [rowCount] );
  	  
  	  this._totalBTDeventsLabel.innerHTML = totalLabel;
      	
      	
      },
    
    _showEventDetailsDialog : function(monitoringEvent) {
    	

        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showEventDetailsDialog");
        
        this._destroyEventDetailsDialogIfItExists();//ensures we don't create multiple dialogs in memory
        
        this._eventDetailsDialog = new EventDetailsDialog(
	        { 
	        	btdName     : this.btName,
	        	btdInstance : this._selectedBTDInstance.id,
	        	mEvent      : monitoringEvent
	        }
        );
        
        this._eventDetailsDialog.startup();
        this._eventDetailsDialog.show();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showEventDetailsDialog");
      },
    
    _setJsonRESTStore : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setJsonRESTStore");
      
      // First clear any pagination and filtering that may currently be applied to the grid
      // Check that we want to do this...
      // Force pagination to go back to first page...
      
      // Determine the business data-capture store to point to from the BT Recorder policy
      var targetStore = Resources.REST.businessTransactions + this.btName + Resources.REST.businessResults;

      // Parameters that are used to track and update the query parameters for the REST API call
      // This will always reset them to the default value - pagination should be derived from current size on the grid
      /* Remove pagination function when not exposed in WebUI
      this._queryParams.pageNumber = 1;
      this._queryParams.numberOfEntriesPerPage = this._btResultsGrid.pagination.pageSize();*/

      
      var queryString = this._generateRESTQueryString(/*this._queryParams,*/ this._filterParamsString);

      // Create Rest Store
      /*
       * A specific approach has been taken to handle again intrinsic behaviour of GridX when using a JSON REST Store.
       * Rather than setting an explicit REST String that has the query parameters in the setupFilterQuery function,
       * the content of that query string is tracked as a header in the REST GET call.
       * This is because that once a filter expression has been set, it seems that is cannot be changed in situ with pagination.
       * As we set out pagination requirements in the url parameter string (pageNumber and numberOfEntriesPerPage), and don't use range-headers on the GET,
       * then not having a method to update the request string will always result in the same set of data being returned as was in the last filter request.
       * This is especially a problem once a filter has been cleared, where the filter string is reset to a default, and it seems can then never be modified.
       * To get around this, such that the query parameters are dynamic and relate to the view (and any possible filtering) that a user would want,
       * then any pagination, filtering changes are explicitly propagated to the QueryParams header, and then this string is handled at the REST layer.
       * This is then processed in the standard way in which a typical REST query would be made.
       * Note that the response is also composed differently.
       * As opposed to returning a full ImbBusinessDataCaptureResponseObject, we just return the array of results (if any) that are returned by the request.
       * This is because the gridX expects just an array of results.
       * Furthermore if the original call is made by the WebUI (so has the QueryParams header present), then the response also returns a Content-Range header,
       * as the Grid also requires information about the range of results, and the number of available results to update the pagination and summary information.
       */
      this._btResultsStore = new JsonRest({
        target: targetStore,
        handleAs : "json",
        headers : {
          "Accept" : "application/json",
          "Content-type" : "application/json",
          "QueryParams" : queryString
        },
        idProperty: "id"
      });
      
      // Purpose of this callback is to ensure we don't change the "loading..." message mid-results retrieval.
      // So don't update the empty message until we try and update the view.
      // This will only get run once, for every REST Store change made.
      // After that we disconnect the callback as we have our empty message that we want for the duration of this BTD.
      var fireOnceHandle = null;
      var callback = lang.hitch(this, function() {
        this._btResultsGrid.body.emptyInfo = string.substitute(NLS.btResultsTableResultsNoResults, [( this.btName ? this.btName : "")]);
        this._btResultsGrid.disconnect(fireOnceHandle);
      });
      
      fireOnceHandle = this._btResultsGrid.connect(this._btResultsGrid.view, 'onUpdate', callback);
      
      
      // Set the related grid messages based on name
      this._btResultsGrid.body.loadingInfo = NLS.btResultsTableResultsLoading; // This one doesn't appear to work...
      this._btResultsGrid.body.loadFailInfo = string.substitute(NLS.btResultsTableResultsFail, [this.btName]);

      this._btResultsGrid.setStore(this._btResultsStore);
      
      // Not needed, setting store forces initial call
      //this._btResultsGrid.body.refresh();

      this._clearResultsTableSelections();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setJsonRESTStore");
    },

    _processEventsForBTD : function(events) {

    	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_processEventsForBTD");

        var eventResultsData = [];
        
        array.forEach(events, lang.hitch(this, function(nextEvent) {
          var nextItem = {
              businessTransactionEventId: nextEvent.msgKey,
              businessTransactionEventName: nextEvent.eventName,            
              businessTransactionEventLocal: nextEvent.localTransactionId,
              businessTransactionEventFlow: nextEvent.messageFlowName,
              businessTransactionEventTimestamp: nextEvent.eventTimestamp,
              businessTransactionEventBitStream: nextEvent.hasBitstream,
              businessTransactionEventException: nextEvent.hasException,
          
              businessTransactionEventHasUserData: nextEvent.hasUserData,
              businessTransactionEventKeyField1: nextEvent.keyField1,
              businessTransactionEventKeyField2: nextEvent.keyField2,
              businessTransactionEventKeyField3: nextEvent.keyField3,
              businessTransactionEventKeyField4: nextEvent.keyField4,
              businessTransactionEventKeyField5: nextEvent.keyField5,
              businessTransactionEventParent: nextEvent.parentTransactionId,
              businessTransactionEventGlobal: nextEvent.globalTransactionId,
              businessTransactionEventNodeName: nextEvent.nodeName,
              businessTransactionEventNodeType: nextEvent.nodeType,
              businessTransactionEventNodeTerminalName: nextEvent.terminalName,            
              businessTransactionEventSourceAddress: nextEvent.eventSourceAddress,
              businessTransactionEventBrokerName: nextEvent.brokerName,
              businessTransactionEventExecutionGroupName: nextEvent.executionGroupName,
              businessTransactionEventApplicationName: nextEvent.applicationName,
              businessTransactionEventLibraryName: nextEvent.libraryName,
              businessTransactionEventType: nextEvent.eventType
            };
          // Add next event record
          eventResultsData.push(nextItem);
        }));

        // Got the events, now add them to the store
        this._eventsGrid.model.clearCache();
        this._eventsGrid.model.store.setData(eventResultsData);
        
        if ( eventResultsData && (eventResultsData.length>0) ){
  	        this._eventsGrid.body.emptyInfo = "";
	  	}//if
	  	else {
	  	    this._eventsGrid.body.emptyInfo = NLS.btEventResultsTableResultsNoEvents;
	  	}//endif
        
      this._eventsGrid.body.refresh();
  
    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "_processEventsForBTD");        
        
    },
    
    _queryEventsForBTD : function(selectedInstance) {

      this._eventsTp.set('title', string.substitute(NLS.btResultsEventInstance, [this.btName, selectedInstance.id]));
      this._eventsGrid.body.emptyInfo = NLS.btEventResultsTableResultsLoading;
      this._eventsGrid.body.refresh();

      var uri = Resources.REST.businessTransactions + this.btName + Resources.REST.businessResults+ selectedInstance.id+Resources.REST.businessResultsEvents;
      
      // To prevent manual populate of table if we are no longer on that hash
      var callingHash = hash();
      
      xhr(
        uri,
        {
          handleAs : "json",
          headers : {
  					"Accept" : "application/json",
          	"Content-type" : "application/json",
				}
        }
      ).then(
        lang.hitch(this, function(response) {
        	
            //  
            //only update events table if selected transaction id is equal to the given transaction id
            //
            // If user clicks 77,88,99 in quick succession, their async responses may arrive in a different order,
            // so only fill the events table if the transaction ids line up.
            //
            if(UIUtils.isSameObjectHash(callingHash, 2, 3)  && ( selectedInstance.id === this._selectedBTDInstance.id)) {
            	this._processEventsForBTD(response);
            }//if
            
        }),
        lang.hitch(this, function(error) {
        	
            //  
            //only show error if selected transaction id is equal to the given transaction id
            //
            // If user clicks 77,88,99 in quick succession, their async responses may arrive in a different order,
            // so report error message if the transaction ids line up; otherwise may be confusing to user.
            //
            if(UIUtils.isSameObjectHash(callingHash, 2, 3) && (selectedInstance.id === this._selectedBTDInstance.id)) {
                var response = JSON.parse(error.response.text);
                window.smallMessage.displayMessage("error", "retrieveBTDInstanceEvents_5XX",response.bipNumber, response.description, [this.btName, selectedInstance.id] );
            }//if
        	
        })
      );
    },

    
      _insertBitstreamLink : function(eventRowData) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_insertBitstreamLink");

          var MsgKey = eventRowData.businessTransactionEventId;
          var result = "";
          
          if (eventRowData.businessTransactionEventBitStream === true){
             result = "<center><a target='_blank' href='" + Resources.REST.businessTransactions + this.btName + Resources.REST.businessResults + this._selectedBTDInstance.id + Resources.REST.businessResultsEvents + MsgKey + "/?payload=bitstream" + "'><div title='" + NLS.bitStreamDownloadBTM + "' class='replayDownload'></div></a></center>";
          }//if
          else {
        	  result = "<center> </center>";
          }//endif

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "_insertBitstreamLink");
          return result;
        },

        _applyFilteringOptions : function(newfilteringConditions) {
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_applyFilteringOptions");
            
            //update the filtering conditions
            this._filterConditions = newfilteringConditions;
            
      	    this._show_ClearFilter_Button(true);
      	    this._clearEventsGrid();    	
            this._applyResultsFilter(this._filterConditions);

            Trace.trace(this.declaredClass, Trace.levels.EXIT, "_applyFilteringOptions");
          },
        
        _showFilteringOptionsDialog : function() {

            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_showFilteringOptionsDialog");

            this._destroyFilteringOptionsDialogIfItExists();
            //ensures we don't create multiple dialogs in memory

            this._filteringOptionsDialog = new BTDFilteringOptionsDialog ({
              cback        : lang.hitch(this, this._applyFilteringOptions),
              filterParms : this._filterConditions,
            });

            this._filteringOptionsDialog.startup();
            this._filteringOptionsDialog.show();

            Trace.trace(this.declaredClass, Trace.levels.EXIT, "_showFilteringOptionsDialog");
          },

          _destroyFilteringOptionsDialogIfItExists : function() {
            if (this._filteringOptionsDialog) {
              this._filteringOptionsDialog.destroy();
              this._filteringOptionsDialog = null;
            }
          },
        
        _insertExceptionLink : function(eventRowData) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_insertExceptionLink");

          var MsgKey = eventRowData.businessTransactionEventId;
          var result = "";
          
          if (eventRowData.businessTransactionEventException === true){
        	   result = "<center><a target='_blank' href='" + Resources.REST.businessTransactions + this.btName + Resources.REST.businessResults + this._selectedBTDInstance.id + Resources.REST.businessResultsEvents + MsgKey + "/?payload=exceptionList" + "'><div title='" + NLS.exceptionListDownloadBTM + "' class='ExceptionDownload'></div></a></center>";
           }//if
           else {
         	  result = "<center> </center>";
           }//endif


          Trace.trace(this.declaredClass, Trace.levels.EXIT, "_insertExceptionLink");
          return result;
        },

        _translateStatus : function(eventRowData) {
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_translateStatus");

            var result = "";
            
            if (eventRowData.status === "inProgress"){
            	result = NLS.btResultsTableRunningFilter;
            }
            else if (eventRowData.status === "ended") {
            	result = NLS.btResultsTableSucceededFilter;
            }
            else if (eventRowData.status === "failed") {
            	result = NLS.btResultsTableFailedFilter;
            }
            else if (eventRowData.status === "inconsistent") {
            	result = NLS.btResultsTableInconsistentFilter;
            }            
            else if (eventRowData.status != undefined) {
            	result = eventRowData.status;
            }
            
            Trace.trace(this.declaredClass, Trace.levels.EXIT, "_translateStatus");
            return result;
          },
        
        _moreDetailsValue : function(eventRowData) {
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_moreDetailsValue");

            var result = "<center><a>" + NLS.btEventTableEventDetailsCell + "</a></center>";
           
            Trace.trace(this.declaredClass, Trace.levels.EXIT, "_moreDetailsValue");
            return result;
          },
    
    _getEventsResultsGrid : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_getEventsResultsGrid");
      
      var eventResultsData = [];    

      // Have empty store on first visit to page
      this._eventsResultsStore = new Store({
        data: eventResultsData,
        idProperty: "businessTransactionEventId"
      });

      // Calculate the structure based on the number of business data that is available
      var eventStructure = [
                            { id: "businessTransactionEventName", field: "businessTransactionEventName", name: NLS.btEventResultsTableEventName, width: '17.5%', type: 'string' },
                            { id: "businessTransactionEventLocal", field: "businessTransactionEventLocal", name: NLS.btEventResultsTableLocalId, width: '17.5%', type: 'string' },
                            { id: "businessTransactionEventFlow", field: "businessTransactionEventFlow", name: NLS.btEventResultsTableFlowName, width: '17.5%', type: 'string' },
                            { id: "businessTransactionEventTimestamp", field: "businessTransactionEventTimestamp", name: NLS.btEventResultsTableTimestamp, width: '17.5%', type: 'string' },
                            { id: "businessTransactionEventBitStream", field: "businessTransactionEventBitStream", name: NLS.btEventResultsTableBitStream, width: '7.5%', type: 'string',formatter : lang.hitch(this, this._insertBitstreamLink )  },
                            { id: "businessTransactionEventException", field: "businessTransactionEventException", name: NLS.btEventResultsTableException, width: '7.5%', type: 'string',formatter : lang.hitch(this, this._insertExceptionLink )  },                            
                            { id: "businessTransactionEventMoreDetails", field: "businessTransactionEventMoreDetails", name: NLS.btEventResultsTableDetails, width: 'auto', type: 'string',formatter : lang.hitch(this, this._moreDetailsValue )  }                            
                          ];
      
      // GridX Table
      var eventsGrid = new Grid({
        store: this._eventsResultsStore,
        cacheClass: CacheSync,
        structure: eventStructure,
        autoHeight: false,
        autoWidth: false,
        autoResize: true,
        // Select a row when any cell in that row is clicked.
        selectRowTriggerOnCell: true,
        selectRowMultiple: false,
        modules: [
          ColumnResizer,
          ColumnWidth
        ]
      });
      
      eventsGrid.body.emptyInfo = NLS.btEventResultsTableResultsNoEvents;
      eventsGrid.body.refresh();

      this._totalBTDeventsLabel = domConstruct.create("label");
      this._totalBTDeventsLabel.setAttribute("id", "totalBTDevents");
      this._totalBTDeventsLabel.setAttribute("style", "display: block;padding-bottom: 5px;");
      this._updateBTDeventsTotalLabel(0);

      var newOuterDiv = domConstruct.create("div", { id: "btEventResultsGridOuterContainer"});
      
      var newDiv = domConstruct.create("div", { id: "btEventResultsGrid", className: "btResultsGridContainer"});

      newOuterDiv.appendChild(this._totalBTDeventsLabel);
      newOuterDiv.appendChild(newDiv);

      this._eventsTp.set("content", newOuterDiv);
      
      eventsGrid.placeAt("btEventResultsGrid");
      eventsGrid.startup();

      eventsGrid.connect(eventsGrid, "onCellClick", lang.hitch(this, function(event){
          if ((event.columnId === "businessTransactionEventMoreDetails") && (event.rowId !== "") ) { // Details column
            var monitoringEvent = eventsGrid.model.byId(event.rowId);
            this._showEventDetailsDialog(monitoringEvent.item);
        }

      }));

      
      eventsGrid.connect(eventsGrid.body, 'onRender',
              lang.hitch(this, function() {
            	  
            	  var theEventCount = eventsGrid.rowCount();
            	  
            	  //update the label
            	  this._updateBTDeventsTotalLabel(theEventCount);
            	  
              }
            )
          );
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_getEventsResultsGrid");
      
      return eventsGrid;
    },
    
    resize : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");
        
        this.inherited(arguments);
        this._businessTransactionResultsView_borderContainer.resize();
        this._resultsTp.resize();
        this._eventsTp.resize();
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
    },

    createButtonsForResultsTable: function(target) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createButtonsForResultsTable");     

      var buttonContainer = domConstruct.create("div", {className: "bt_BusinessTransactionSectionButtonsContainer", id: "btResults_buttonsContainer"});
     
      var clearFilterContainer = domConstruct.create("span",{
        className: "bt_BusinessTransactionSectionSingleButtonContainer"
      });
      
      this._ClearFilterButton = domConstruct.create("div",{
        className: "bt_BusinessTransactionSectionButtonActive",
        tabindex: "0",
        innerHTML: NLS.btResultsTableClearFilter,
        id : "bt_BusinessTransaction_ClearFilter_Button"          
      });

      var filterContainer = domConstruct.create("span",{
        className: "bt_BusinessTransactionSectionSingleButtonContainer"
      });

      this._FilterButton = domConstruct.create("div",{
          className: "bt_BusinessTransactionSectionButtonInactive",
          tabindex: "0",
          innerHTML: NLS.btResultsTableFilterDotDotDot          
        });             

      var refreshContainer = domConstruct.create("span",{
        className: "bt_BusinessTransactionSectionSingleButtonContainer"
      });

      this._ResultsTableRefreshButton = domConstruct.create("div",{
          className: "bt_BusinessTransactionSectionButtonInactive",
          tabindex: "0",
          innerHTML: NLS.btResultsTableRefresh
        });             

      domConstruct.place(this._ClearFilterButton, clearFilterContainer);
      domConstruct.place(clearFilterContainer, buttonContainer);
      domConstruct.place("<span id='bt_BusinessTransaction_ClearFilter_Separator' class='bt_BusinessTransactionSectionButtonsDivider' aria-hidden='true'>|</span>", buttonContainer);
      domConstruct.place(this._FilterButton, filterContainer);
      domConstruct.place(filterContainer, buttonContainer);
      domConstruct.place("<span class='bt_BusinessTransactionSectionButtonsDivider' aria-hidden='true'>|</span>", buttonContainer);
      domConstruct.place(this._ResultsTableRefreshButton, refreshContainer);
      domConstruct.place(refreshContainer, buttonContainer);

      on(this._ClearFilterButton,  "click", lang.hitch(this, function(){
    	  this._updateBTDsTotalLabel(0);
  	      this._show_ClearFilter_Button(false);
    	  this._filterConditions.conditions[0].checked = false;
    	  this._filterConditions.conditions[1].checked = false;
    	  this._clearEventsGrid();
    	  // This should clear our filter and retain gridx tracking of filtering (so kick of new REST call without a filter)
    	  this._btResultsGrid.filter.setFilter({});
    	  this._clearResultsTableSelections();
    	  this._update_ResultsTp_Title();
      }));
      
      // Add class to retain button positioning
      domClass.add(target, "btSectionTitlePane_titleBarNodeButtonContainer");

      domConstruct.place(buttonContainer, target);
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "createButtonsForResultsTable");
    },
    
    createButtonsForEventsTable: function(target) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createButtonsForEventsTable");     

        var buttonContainer = domConstruct.create("div", {className: "bt_BusinessTransactionSectionButtonsContainer", id: "btEventResults_buttonsContainer"});

        this._EventsTableRefreshButton = domConstruct.create("span",{
            className: "bt_BusinessTransactionSectionButtonActive",
            tabindex: "0",
            innerHTML: NLS.btResultsTableRefresh
          });
        
        domConstruct.place(this._EventsTableRefreshButton, buttonContainer);

        on(this._EventsTableRefreshButton,  "click", lang.hitch(this, function(){
      	  this._refreshEventsTable();
          }));

        // Add class to retain button positioning
        domClass.add(target, "btSectionTitlePane_titleBarNodeButtonContainer");

        domConstruct.place(buttonContainer, target);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "createButtonsForEventsTable");
      },
    
    _applyResultsFilter : function(filterConditions) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_applyResultsFilter");

      this._updateBTDsTotalLabel(0);
      var filterExpr = this._generateFilterExpressionFromConditions(filterConditions);
      // Tell the grid a change to the filter has happened
      this._btResultsGrid.filter.setFilter(filterExpr);
      
      // If no store has been setup yet, do this in combination with the filter query so only one REST call is made
      if (!this.storeInitialised) {
        // create and set the store on the first Filter run for this BTD
        this._setJsonRESTStore();
        this.storeInitialised = true;
      }        

      this._update_ResultsTp_Title();//updates title based on whether we are filtering or not.
      
      this._clearResultsTableSelections();
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_applyResultsFilter");
    },
    
    _generateFilterExpressionFromConditions : function(filterConditions) {
      
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_generateFilterExpressionFromConditions");
      
      var filterExpr = null;
      
      if (filterConditions.conditions[0].checked && filterConditions.conditions[1].checked){
        filterExpr = Filter.and(
            this._createFilterConditionObject( filterConditions.conditions[0] ),
            this._createFilterConditionObject( filterConditions.conditions[1] ));
      }//if
      else if (filterConditions.conditions[0].checked) {
        filterExpr = Filter.and(
            this._createFilterConditionObject( filterConditions.conditions[0] ));
      }//if
      else if (filterConditions.conditions[1].checked) {
        filterExpr = Filter.and(
            this._createFilterConditionObject( filterConditions.conditions[1] ));
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_generateFilterExpressionFromConditions");

      return filterExpr;
    },
    
    _createFilterConditionObject : function(filterCriteria) {
   	  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createFilterConditionObject");
/*
 	         		{ 
	          	        "colId" : Resources.REST.businessTransactionResultParameter.id,//fixed
	          	    	"checked" : false,
	          	        "value": null,
	          	        "verb": null,
	          	        "type": "string"//fixed
	          	    }
 
 */   	    
    	var filterConditionObj = null;
    	
    	if (filterCriteria.verb === 'equals'){
    		
    		filterConditionObj =
    			
    	        Filter.equal(
    	                Filter.column(filterCriteria.colId, filterCriteria.type),
    	                Filter.value(filterCriteria.value, filterCriteria.type)
    	        );
    			
    	}
    	else if (filterCriteria.verb === 'contains') {

    		filterConditionObj =

	            Filter.contain(
    	                Filter.column(filterCriteria.colId, filterCriteria.type),
    	                Filter.value(filterCriteria.value, filterCriteria.type)
	            );
    		
    	}
    	else if (filterCriteria.verb === 'startsWith') {

    		filterConditionObj =

	            Filter.startWith(
    	                Filter.column(filterCriteria.colId, filterCriteria.type),
    	                Filter.value(filterCriteria.value, filterCriteria.type)
	            );
    		
    	}
    	else if (filterCriteria.verb === 'endsWith') {

    		filterConditionObj =

	            Filter.endWith(
    	                Filter.column(filterCriteria.colId, filterCriteria.type),
    	                Filter.value(filterCriteria.value, filterCriteria.type)
	            );
    		
    	}
    	
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createFilterConditionObject");
        
        return filterConditionObj;
    },
    
    _clearEventsGrid: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_clearEventsGrid");
      
      var eventResultsData = [];
      
      // Got the events, now add them to the store
      this._eventsGrid.model.clearCache();
      this._eventsGrid.model.store.setData(eventResultsData);
      this._eventsGrid.body.emptyInfo = NLS.btEventResultsTableResultsNoEvents;
      this._eventsGrid.body.refresh();
      
      this._eventsTp.set('title', NLS.btResultsEvent);
      this._updateBTDeventsTotalLabel(0);
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_clearEventsGrid");
    },
    
    /**
     * Function to take as input json structured filter expression from the GridX Filter module
     * (Usually input based on a change to the base filter expression driven through the UI).
     * Then process filter expressions and values to generate a filter query string with parameters in a structure that the REST API is accustomed with.
     */
    _updateFilterQueryParams: function(filterExpr) {
      
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_updateFilterQueryParams");
      
      var filterQueryParamsString = "";
      
      // Check that there are filter expressions to extract
      if((typeof filterExpr !== "undefined") && (filterExpr != null)) {
        // If there is at least one filter rule to process
        if(filterExpr.data && filterExpr.op && (filterExpr.data.length > 0) && (filterExpr.op === "and")) {
          // Iterate around each rule and add it to the query string
          array.forEach(filterExpr.data, function(nextFilterRule) {
            // Check that the filter rule has data and values
            if(nextFilterRule.data && (nextFilterRule.data.length === 2) && (nextFilterRule.data[0].data !== "")) {
              filterQueryParamsString += "&&" + nextFilterRule.data[0].data + "=";
              // Determine the matching condition
              switch(nextFilterRule.op) {
                case "contain":
                  filterQueryParamsString += nextFilterRule.data[1].data;
                  break;
                case "equal":
                  // If the filter parameter is status of the business transaction, then don't wrap with quotations ' as this will break the REST API.
                  // Status can only be "succeeded,failed,unknown,running", so no need to add match exact.
                  // For example the search phrase "faile" would return 0 matches (in fact would throw an error).
                  // We might want to change the REST response so that it can handle partial search terms... 
                  if(nextFilterRule.data[0].data === Resources.REST.businessTransactionResultParameter.status) {
                    filterQueryParamsString += nextFilterRule.data[1].data;
                  } else {
                    filterQueryParamsString += "'" + nextFilterRule.data[1].data + "'";
                  }
                  break;
                case "startWith":
                	filterQueryParamsString += "'" + nextFilterRule.data[1].data + "*'";
                    break;
                case "endWith":
                	filterQueryParamsString += "'*" + nextFilterRule.data[1].data + "'";                	
                    break;
              }
            }
          });
        }
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_updateFilterQueryParams");
      
      return filterQueryParamsString;
    },
    
    /**
     * From json structure of base (always needed) parameters of pageNumber, numberOfRecordToShow
     * and any addiotional filter parameters.
     * Generate the REST query string that will then be decomposed by the REST client to generate the set of requested results.
     */
    _generateRESTQueryString: function(/*queryParams,*/ queryFilterParams) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_generateRESTQueryString");
      
      var queryString = "";
      /* Remove Pagination capability when not exposed in the UI
      
      if(queryParams.pageNumber != null){
        queryString += Resources.REST.businessTransactionMonitoringResults.pageNumber + "=" + queryParams.pageNumber;
      }
      
      if(queryParams.numberOfEntriesPerPage != null){
        queryString += "&&" + Resources.REST.businessTransactionMonitoringResults.entriesPerPage + "=" + queryParams.numberOfEntriesPerPage;
      }*/
      
      // Append any additional filter query to the query string
      queryString += queryFilterParams;

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_generateRESTQueryString");
      
      return queryString;
    },
    
    // Called to ensure that pagination change will allow for valid view
    _validateGridView: function(totalAvailableResults) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_validateGridView");
      
      // If the paginate change (page size change), check that the current page can be rendered.
      // Datacapture cannot render page numbers that are out of range (server will return error), so prevent this call being made
      // Check that the new page size with the current page number will show results, based on the total available from last retrieval
      var startCount = (this._queryParams.pageNumber + 1) * this._queryParams.numberOfEntriesPerPage;

      // If view window is invalid (no results to view) then reset the page number to
      if(startCount >= totalAvailableResults) {
        return false;
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_validateGridView");
      
      return true;
    },
    
    
    // Refresh the recorder dropdown and (if current recorder still available) the results page also
    _refreshResultsTable : function() {
    	
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_refreshResultsTable");
        
        this._updateBTDsTotalLabel(0);
        this._btResultsGrid.model.clearCache();
        this._btResultsGrid.body.refresh();
        this._clearResultsTableSelections();
  	    this._clearEventsGrid();
  	    
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_refreshResultsTable");
        
    },
    
    _refreshEventsTable : function() {
    
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_refreshEventsTable");
        
      if (this._selectedBTDInstance){
    	  
          this._clearEventsGrid();

    	  this._queryEventsForBTD(this._selectedBTDInstance);  
      }
      else {
    	  
          window.wmbConsole.showInfoDialog( NLS.btEventResultTablePleaseSelectBTDInstance);
      }
	          	  
    	
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_refreshEventsTable");
      
    },
    
    _show_ClearFilter_Button: function(show) {
  	  
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_show_ClearFilter_Button");


        //
        // show or hide the "Clear Filter" button 
        //
        var querylist = dojoQuery("#bt_BusinessTransaction_ClearFilter_Button");
        if (querylist && querylist.length===1){
        	
    		  if (show === true) {
       		     domStyle.set( querylist[0] ,"display","" );//show span
    		  } else {
       		     domStyle.set( querylist[0] ,"display","none" );//hide span
    		  }
        	
        }//if

        //
        // show or hide the "Clear Filter" button's separator "|" 
        //
        querylist = dojoQuery("#bt_BusinessTransaction_ClearFilter_Separator");
        if (querylist && querylist.length===1){
        	
    		  if (show === true) {
       		     domStyle.set( querylist[0] ,"display","" );//show span
    		  } else {
       		     domStyle.set( querylist[0] ,"display","none" );//hide span
    		  }
        	
        }//if
        
    
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_show_ClearFilter_Button");
    },
    
    // Set the business transactions results grid to be reset to a default (non server) store
    _clearTransactionsResultsStore : function() {
    	
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_clearTransactionsResultsStore");
        
      // Empty the results so that it is not hanging around on next viewing
      // Default the store back to an empty results store
      // Have empty store on first visit to page
      this._btResultsStore = new Store({
        data: [],
        idProperty: "id"
      });
      // Clear out the current view
      this._btResultsGrid.model.clearCache();
      this._btResultsGrid.model.setStore(this._btResultsStore);
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_clearTransactionsResultsStore");
      
    },

    _update_ResultsTp_Title : function() {
  	  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_update_ResultsTp_Title");
  	  
          
  	  if ( this._filterConditions.conditions[0].checked || this._filterConditions.conditions[1].checked ){
  		  this._resultsTp.set('title', string.substitute(NLS.btResultsInstanceFiltered, [this.btName]));
  	  }//if
  	  else {
  		  this._resultsTp.set('title', string.substitute(NLS.btResultsInstanceAll, [this.btName]));  		  
  	  }
  	  
  	  Trace.trace(this.declaredClass, Trace.levels.EXIT, "_update_ResultsTp_Title");	
    },
    
    // This function is called manually when we need to remove this tab.
    tabRemove : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
      
      if (typeof this._btResultsGrid !== "undefined") {    	  
        // we are moving away from this business transaction to something else in the tree, so clear filter value
        this._filterParamsString = "";
        this._show_ClearFilter_Button(false);
        this._filterConditions = this._getDefaultFilterOptions();
        
        /*
        this._queryParams.numberOfEntriesPerPage = Resources.REST.businessTransactionResultsPageSize;
        this._queryParams.pageNumber = 1;*/
        /* - Removed whilst no pagination.
        this._btResultsGrid.pagination.setPageSize(this._queryParams.numberOfEntriesPerPage);
        // 0 index
        this._btResultsGrid.pagination.gotoPage(this._queryParams.pageNumber - 1);*/       

        this._clearTransactionsResultsStore();
        
        this._clearResultsTableSelections();
        this._updateBTDsTotalLabel(0);
        
        // Set the info message with no results to be normal no results info
        this._btResultsGrid.body.emptyInfo = "";
        this._btResultsGrid.body.refresh();
        
        // Remove associated recorder polciies from the dropdown
        this._refreshResultsView = true;
        this.btName = null;
        
        //clear the Events table
        this._clearEventsGrid();
        
        // Remove event handlers for viewing results
        array.forEach(this._viewResultsHandlers, lang.hitch(this, function(handler){
          handler.remove();
        }));

        // Reset the eventTopicHandles array
        this._viewResultsHandlers = [];
        
        domClass.remove(this._FilterButton, "bt_BusinessTransactionSectionButtonActive");
        domClass.add(this._FilterButton, "bt_BusinessTransactionSectionButtonInactive");
        
        domClass.remove(this._ResultsTableRefreshButton, "bt_BusinessTransactionSectionButtonActive");
        domClass.add(this._ResultsTableRefreshButton, "bt_BusinessTransactionSectionButtonInactive");
        
        // prepare it for the next BTD toshow the instruction message in the table
        this.storeInitialised = false;
        this._btResultsGrid.body.emptyInfo =NLS.btResultsTableOnEntry; 
        // Set grid view back to default height - to handle BTD View to BTD View navigation
        // Only resize if the grid has been instantiated (shown before)
        if(this.gridHeight > this._btResultsGrid.domNode.clientHeight && (this._btResultsGrid.domNode.clientWidth > 0) && (this._btResultsGrid.domNode.clientHeight > 0)) {
          this._btResultsGrid.resize({w: this._btResultsGrid.domNode.clientWidth, h: this.gridHeight});
        }

     }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
    },

    _clearResultsTableSelections : function() {
    	this._btResultsGrid.select.row.clear();
        this._selectedBTDInstance=null;
    },
    
    _attachedToPolicy : function() {
    	
    	/**  This method needs to change once the proper policy API is in placed **/
    	var policyAttached = true;
    	
    	return policyAttached;
    },
    
    _setupTableButtonActions : function(){
      
      if(this._viewResultsHandlers.length == 0) {
        this._viewResultsHandlers.push(on(this._FilterButton,  "click", lang.hitch(this, function(){
          this._showFilteringOptionsDialog();
        })));
      
        this._viewResultsHandlers.push(on(this._ResultsTableRefreshButton,  "click", lang.hitch(this, function(){
          if (!this.storeInitialised) {
            // show the loading message straight away
            this._btResultsGrid.body.emptyInfo = NLS.btEventResultsTableResultsLoading;
            this._btResultsGrid.body.refresh();
            // create and set the store on the first Refresh click for this BTD
            this._setJsonRESTStore();
            this.storeInitialised = true;
          } else {
            this._refreshResultsTable();
          }
        })));
        
        domClass.remove(this._FilterButton, "bt_BusinessTransactionSectionButtonInactive");
        domClass.add(this._FilterButton, "bt_BusinessTransactionSectionButtonActive");
        
        domClass.remove(this._ResultsTableRefreshButton, "bt_BusinessTransactionSectionButtonInactive");
        domClass.add(this._ResultsTableRefreshButton, "bt_BusinessTransactionSectionButtonActive");
      }
    },
    
    _displayMessageIfInvalid : function(newlyDefinedBTDAndNotSaved) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "displayMessageIfInvalid");
        
        //check if not saved yet
        if (newlyDefinedBTDAndNotSaved === true){
          	window.smallMessage.displayPlainMessage("warning", "btBTDNotYetSavedSoNoResults", [this.btName] );
          	return;
        }//if
        
        if ( !this. _attachedToPolicy() ) {
          	window.smallMessage.displayPlainMessage("warning", "btBTDNotAttachedToPolicy", [this.btName] );
          	return;
        	
        }//if
        
        
    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "displayMessageIfInvalid");
    },
    
    tabFocus : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");

        var populate = this._attributesStore.populateAttributesStore();
        populate.then(lang.hitch(this, function() {
          this.btName = this._attributesStore.getAttribute("name");
          
          var newlyDefinedBTDAndNotSaved = false;
          
          if (!this.btName){//user is defining a new Business transaction, but hasn't saved it yet, and clicked on View tab
        	 
        	  newlyDefinedBTDAndNotSaved = true;
        	  
        	//get the btName value from the "Define tab"  
        	var defineTab = registry.byId("webui.widgets.business.businesstransaction_overview");
        	if (defineTab){
        		this.btName = defineTab.btName;
        	}//if 
        	else {
        		this.btName="";
        	}//endif
        	
          }//if
          this._setupTableButtonActions();
          
          if (this._refreshResultsView === true){
        	  
        		this._update_ResultsTp_Title(); //necessary if we switch between different business transactions
            this._btResultsGrid.body.refresh();

            // No getting of results until explicitly asked to via Refresh or Filter
            this._refreshResultsView = false;
            
            this._clearResultsTableSelections();
            
          }//if

          //shows appropriate message(s), if something wrong with BTD
          this._displayMessageIfInvalid( newlyDefinedBTDAndNotSaved );
          
        }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
    },

    tabBlur : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
    }
  });

  return resultsWidget;
});

},
'webui/widgets/msgflows/msgflow_activityLog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="3356849190" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/msgflows/templates/msgflow_activityLog.html",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/array",
  "dojo/_base/declare",
  "dojo/_base/fx",
  "dojo/_base/lang",
  "dojo/data/ObjectStore",
  "dojo/date/locale",
  "dojo/dom-attr",
  "dojo/dom-class",
  "dojo/dom-construct",
  "dojo/on",
  "dojo/query",
  "dojo/request/xhr",
  "dojo/store/Memory",
  "dojo/hash",
  "dijit/_WidgetBase",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetsInTemplateMixin",
  "dojox/grid/DataGrid",
  "webui/widgets/common/Toolbar",
  "webui/widgets/common/Trace",
  "webui/utils/WebUiHash",
  "webui/widgets/common/PropertiesStore",
  "idx/widget/HoverHelpTooltip",
  "dojo/mouse"
], function(
  template,
  NLS,
  array,
  declare,
  fx,
  lang,
  ObjectStore,
  locale,
  domAttr,
  domClass,
  domConstruct,
  on,
  query,
  xhr,
  Memory,
  hash,
  _WidgetBase,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  DataGrid,
  Toolbar,
  Trace,
  WebUiHash,
  PropertiesStore,
  HoverHelpTooltip,
  mouse
) {
    var msgflowsActivityLog = declare("webui.widgets.msgflows.msgflow_activityLog", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
      templateString: template,
      _flowUri: "",
      _activityLogUri: "",
      _isRunning : "",
      _propertiesStore : new PropertiesStore(),
      _populatePropertiesStore: "",
      _threadID: "",
      _threadsFound: [],
      
      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
        this.inherited(arguments);
        
        this._flowUri = new WebUiHash(hash()).getRestUri();
        this._activityLogUri = new WebUiHash(hash()).getRestUri().getActivityLogUri();
        this._threadID = "";
        
        var _populatePropertiesStore = this._propertiesStore.populatePropertiesStore(this._flowUri.toString());        
        _populatePropertiesStore.then(lang.hitch(this, function() {
        this._isRunning = this._propertiesStore.getProperty("basic", "isRunning");
        }));
        
        // Create toolbar
        this.toolbar = new Toolbar();
        domConstruct.place(this.toolbar.domNode, this._toolbar);
        this.toolbar.addLeftAlignButtons("title");

        var buttons = [ "destroyActivityLogFilter", "refresh" ];
        this.toolbar.addRightAlignButtons(buttons);
        this.toolbar.connectButtons("refresh", "click", this, "_refreshGrid");
        this.toolbar.connectButtons("destroyActivityLogFilter", "click", this, "_resetGrid");
        
        // Disable the filter button as filter not applied
        this.toolbar.setButtonState("disable", "destroyActivityLogFilter");
        
        // DATA GRID
        this._layout = [ [ {
          field : 'timestamp',
          name : NLS.timestamp,
          width : '15%',
          formatter : lang.hitch(this, this._insertTime)
        },{
          field : 'bipNumber',
          name : NLS.message,
          width : '10%',
          formatter : lang.hitch(this, this._insertBIP)
        }, 
        {
          field : 'threadId',
          name : NLS.threadID,
          width : '10%',
          formatter : lang.hitch(this, this._insertThread)
        }, {
          field : 'rm',
          name : NLS.resourceManager,
          width : "10%",
          formatter : lang.hitch(this, this._insertRM)
        },{
          field : 'message',
          name : NLS.messageDetail,
          width : "auto",
          formatter : lang.hitch(this, this._insertMessageDetail)
        },{
          field : 'detailedMessage',
          name : "detailedMessage",
          hidden: "true",
          formatter : lang.hitch(this, this._insertDetailedMessage)
        } ] ];

        this._grid = new DataGrid({
          store : new ObjectStore({
            objectStore : new Memory({
              data : []
            })
          }),
          structure : this._layout,
          escapeHTMLInData : false,
          selectable : true,
          rowsPerPage : 100,
          sortInfo : "-1"
        }, document.createElement('div'));

        // Append the new grid to the div
        this._activitylog_grid.appendChild(this._grid.domNode);
        
        // Call startup() to render the grid
        this._grid.startup();
        
        on(this._grid, "RowClick", lang.hitch(this, function(event) {
          this._onRowClickHandler(event);
        }));
        
        on(this._grid, mouse.enter, lang.hitch(this, function(event) {
          this._onMouseEnterHandler(event);
        }));
        
        // NLS Strings
        domAttr.set(this.activitylogLoading, "innerHTML", NLS.dataLoading);
        domAttr.set(this.activitylogNoData, "innerHTML", NLS.adminlogNoMessages);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
      },

      startup: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "startup");
        this.inherited(arguments);
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "startup");
      },
      
      
      _resetGrid : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_resetGrid");
        this._emptyGrid();
        this._threadID = "";
        this._threadsFound = [];
        // Disable the filter button as filter no longer applied
        this.toolbar.setButtonState("disable", "destroyActivityLogFilter");
        this._updateGrid();
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_resetGrid");
      },
      
      _refreshGrid : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_refreshGrid");
        this._emptyGrid();
        this._updateGrid();
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_refreshGrid");
      },
      
      _emptyGrid : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_emptyGrid");
        // Clear the table so it's obvious that a refresh has occurred
        var _gridStore = new ObjectStore({
          objectStore : new Memory({
            data : null
          })
        });
        this._grid.setStore(_gridStore);
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_emptyGrid");
      },
      
      
      _updateGrid : function() {
        Trace.trace(this.widgetName, Trace.levels.ENTRY, "_updateGrid");
        this._isRunning = this._propertiesStore.getProperty("basic", "isRunning");
        domAttr.set(this.activitylogLoading, "innerHTML", NLS.dataLoading);
        this._threadsFound = [];
        if (this._isRunning=="false") {
          // Flow is not running
          window.smallMessage.displayMessage("warning", "FlowNotRunning_XX", "", NLS.messages.FlowNotRunningDescription);
        }
        else {
          // Disable the refresh button
          this.toolbar.setButtonState("disable", "refresh");
          // Now actually update the grid
          this._updateGridWithoutRefresh();
        }

        Trace.trace(this.widgetName, Trace.levels.EXIT, "_updateGrid");
      },
      
      _onRowClickHandler : function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onRowClickHandler");
        if(event.target.className.match("threadIDCell") ) {
          // We clicked on the thread id, lets update the view to show just that thread id (if we're not already)
          if (this._threadID === "" || this._threadID === null)
          {
            this._threadID = event.target.text;
            this._emptyGrid();
            this._updateGrid();
          }
        }
        // Need to cover ourselves here because the icon is part of the parent
        else if (event.target.className.match("threadIDIcon")) {
          this._threadID = event.target.parentNode.text;
          this._emptyGrid();
          this._updateGrid();
        }
        else
        {
          // Clicking on the row that isn't thread ID turns wrapping on
          // First turn wrapping off for all items
          query('._activityLog_wrap').replaceClass("_activityLog_nowrap", "_activityLog_wrap");
          // Turn wrapping on for all nodes in the same row as selected one
          array.forEach(event.target.parentNode.parentNode.children,
            function(item) {
            domClass.replace(item.children[0], "_activityLog_wrap",
            "_activityLog_nowrap");
          });
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "onRowClickHandler");
      },
      
      _onMouseEnterHandler : function(event) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onMouseEnterHandler");  
        
        if(event.cell.name.match(NLS.messageDetail)) {
          // Check the message is still valid, we may of moved to another cell and kicked off a new event since
          if (event.target.parentNode.children[5] !== undefined)
          {
            var message = event.target.parentNode.children[5].innerHTML;
            // Check this isn't the column header (surely there is a better way?)
            if (message.match("dojoxGridSortNode") === null)
              {
              var hh = new HoverHelpTooltip( {
                connectId : event.target.children,
                forceFocus: true,
                label : message,
                showDelay : 0
              });
              hh.startup();
              }
          }
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onMouseEnterHandler");
      },
      
      _updateGridWithoutRefresh : function() {
        Trace.trace(this.widgetName, Trace.levels.ENTRY,
            "_updateGridWithoutRefresh");
        var threadIDForURI = "";
        if (this._threadID === "" || this._threadID === null) {
        }
        else {
          // Enable the clear filter button as filter applied
          this.toolbar.setButtonState("enable", "destroyActivityLogFilter");
          threadIDForURI = "?threadId=" + this._threadID;
        }
        domClass.add(this.activitylogLoading, "logLoading");
        xhr(this._activityLogUri + threadIDForURI, {
          handleAs : "json",
          headers : {
            "Accept" : "application/json"
          }
        }).then(
          
          lang.hitch(this, function(data) {
            // Enable the refresh button
            this.toolbar.setButtonState("enable", "refresh");

            this._timeFormat = data.timestampFormat;
            if (this._threadID === ""){
            domAttr.set(this.activitylogLoading, "innerHTML", NLS.rrrPaginationTotal + ": " +
                data.numberOfLogEvents);
            }
            else {
              domAttr.set(this.activitylogLoading, "innerHTML", NLS.rrrPaginationTotal + ": " +
                data.numberOfLogEvents + " (" + NLS.filteringOnThreadID + " " + this._threadID + ")");
              }
            
            var _gridData = null;
            
            if (data.numberOfLogEvents > 0) {
              // Hide the "No Messages" message
              if (!domClass.contains(this.activitylogNoData, "_common_hideDiv")) {
                fadeArgs = {
                  node : "activitylogNoData_ID",
                  duration : 300,
                  onEnd : function() {
                    domClass.add("activitylogNoData_ID", "_common_hideDiv");
                  }
                };
                fx.fadeOut(fadeArgs).play();
              }
              _gridData = {
                items : data.activityLogEntry
              };

            } else {
              // Show the "No Messages" message
              if (domClass.contains(this.activitylogNoData, "_common_hideDiv")) {
                fadeArgs = {
                  node : "activitylogNoData_ID",
                  duration : 300,
                  onBegin : function() {
                    domClass.remove("activitylogNoData_ID", "_common_hideDiv");
                  }
                };
                fx.fadeIn(fadeArgs).play();
              }
              _gridData = {
                items : null
              };
            }
            
            // Time to hack around with what is returned and sort out the message/tags so it can then be sorted    
            _gridData.items.forEach(function(item){
              //Firstly, sort out the message detail, since it contains BIP number at the start, so split on space
              // E.g "BIP12345: Something went wrong" becomes "Something went wrong"        
              var delimiterPos = item.message.indexOf(": ") + ": ".length;
              item.message = item.message.substring(delimiterPos);
              // Now the RM tags. We create a new string and store it there, either empty if not there, or the value 
              item.rm = "";
              item.tags.forEach(function(tag){
                if (tag.name === "RM") {
                  item.rm = tag.value;
                }
              });
            });

            domClass.remove(this.activitylogLoading, "logLoading");

            var _gridStore = new ObjectStore({
              objectStore : new Memory({
                data : _gridData
              })
            });
            this._grid.setStore(_gridStore);
          }),
          lang.hitch(this, function() {
            // Enable the refresh button
            this.toolbar.setButtonState("enable", "refresh");

            // Display an error
            window.smallMessage.displayMessage("error", "Activitylog_XXX");

            // Show the "No Messages" message
            if (domClass.contains(this.activitylogNoData, "_common_hideDiv")) {
              fadeArgs = {
                node : "activitylogNoData_ID",
                duration : 300,
                onBegin : function() {
                  domClass.remove("activitylogNoData_ID", "_common_hideDiv");
                }
              };
              fx.fadeIn(fadeArgs).play();
            }
          })
        );

        Trace.trace(this.widgetName, Trace.levels.EXIT,
            "_updateGridWithoutRefresh");
      },
      
      _insertBIP : function(name, rowIndex) { // jshint ignore:line
        Trace.trace(this.widgetName, Trace.levels.ENTRY, "_insertBIP");

        var bipNumber = this._grid.getItem(rowIndex).bipNumber;
        var messageType = bipNumber.charAt(bipNumber.length - 1);

        var result;
        if (messageType == "I") {
          result = "<div class='bipMessageCell activityLogInfo'>" + bipNumber + "</div>";
        } else if (messageType == "W") {
          result = "<div class='bipMessageCell activityLogWarning'>" + bipNumber + "</div>";
        } else if (messageType == "E") {
          result = "<div class='bipMessageCell activityLogException'>" + bipNumber + "</div>";
        } else {
          result = bipNumber;
        }

        Trace.trace(this.widgetName, Trace.levels.EXIT, "_insertBIP");
        return result;
      },

      _insertTime : function(name) {
        Trace.trace(this.widgetName, Trace.levels.ENTRY, "_insertTime");

        var x = new Date(name);
        x = locale.format(x, {
          datePattern : this._timeFormat,
          selector : "date"
        });

        var time = "<a class='_activityLog_nowrap'>" + x + "</a>";

        Trace.trace(this.widgetName, Trace.levels.EXIT, "_insertTime");
        return time;
      },

      _insertMessageDetail : function(name) {
        Trace.trace(this.widgetName, Trace.levels.ENTRY, "_insertMessageDetail");
        var messageDetail = "<a class='_activityLog_nowrap messageDetailCell'>" +  name + "</a>";
        Trace.trace(this.widgetName, Trace.levels.EXIT, "_insertMessageDetail");
        return messageDetail;
      },
      
      // We wrap the detailed message column so that the hover help is wrapped!
      // This column is not actually shown
      _insertDetailedMessage : function(name) {
        
        Trace.trace(this.widgetName, Trace.levels.ENTRY, "_insertDetailedMessage");
        var detailedMessage = "<a class='_activityLog_wrap detailedMessage'>" +
            name + "</a>";

        Trace.trace(this.widgetName, Trace.levels.EXIT, "_insertDetailedMessage");
        return detailedMessage;
      },
      
      // We need to find the RM tag if there is one
      _insertRM : function(name) {
        Trace.trace(this.widgetName, Trace.levels.ENTRY, "_insertRM");
        var rm = "<a class='_activityLog_nowrap messageRMCell'>" + name + "</a>";
        Trace.trace(this.widgetName, Trace.levels.EXIT, "_insertRM");
        return rm;
      },
      
      _insertThread : function(name) {
        Trace.trace(this.widgetName, Trace.levels.ENTRY, "_insertThread");
        // Here, we get a list of all possible threads, then on the first ones we meet, 
        // we add the magnifying glass icon
        var threadInArray = (this._threadsFound.indexOf(name) > -1);
        var thread = "<a class='_activityLog_nowrap threadIDCell'>" + name + "</a>";
        // Only show the magnifying glass if it's the first occurence of this thread ID and we're not filtering on one already
        if (threadInArray == false && (this._threadID==="" || this._threadID===null))
        {
          thread = "<a class='_activityLog_nowrap threadIDCell'>" + name + "<img src=\'/webui/widgets/common/images/drillDown4.png\' class='_activityLog_nowrap threadIDIcon'></a>";
          this._threadsFound.push(name);
        }

        Trace.trace(this.widgetName, Trace.levels.EXIT, "_insertThread");
        return thread;
      },
      
      
      
      tabFocus : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");
        
        // Clear the table so it's obvious that a refresh has occurred
        this._emptyGrid();
        
        // We may of changed to a different flow since last being on the activity log tab, so lets reload with the latest hash
        this._activityLogUri = new WebUiHash(hash()).getRestUri().getActivityLogUri();
        this._flowUri = new WebUiHash(hash()).getRestUri();
        var _populatePropertiesStore = this._propertiesStore.populatePropertiesStore(this._flowUri.toString()); 
        _populatePropertiesStore.then(lang.hitch(this, function() {
          this._isRunning = this._propertiesStore.getProperty("basic", "isRunning");
          this._updateGrid();
          }));
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
       },

      resize: function() {
        this._threadID = "";
        this._threadsFound = [];
        this._msgflowOverview_borderContainer.resize();
      },

      tabRemove: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
      },

      tabBlur: function(){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
      }

    });
   return msgflowsActivityLog;
  }
);

},
'webui/widgets/libraries/lib_overview':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="2907093092" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/libraries/templates/lib_overview.html",
	"dojo/i18n!webui/nls/web",
	"dojo/_base/declare", 
	"dojo/_base/lang",
	"dojo/dom-attr",
	"dojo/dom-construct",
	"dojo/query",
	"dojo/request/xhr",
  "dojo/string",
	"dijit/_TemplatedMixin",
	"dijit/_WidgetBase",
  "dijit/_WidgetsInTemplateMixin",
  "dijit/registry",
  "webui/widgets/common/AttributesStore",
  "webui/widgets/common/HasContextMenu",
	"webui/widgets/common/QuickAndAdvancedProperties",
	"webui/widgets/common/Toolbar",
	"webui/widgets/common/Trace",
	"webui/widgets/common/UIUtils"
], function(
  template,
  NLS,
  declare,
  lang,
  domAttr,
  domConstruct,
  query,
  xhr,
  string,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  registry,
  AttributesStore,
  HasContextMenu,
  QuickAndAdvancedProperties,
  Toolbar,
  Trace,
  UIUtils
) {
  var libOverview = declare("webui.widgets.libraries.lib_overview", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu], {
    templateString: template,
    toolbar: null,
    _attributesStore : new AttributesStore(),

    postCreate: function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			this.inherited(arguments);	
			
			// Create toolbar
			this.toolbar = new Toolbar();
			domConstruct.place(this.toolbar.domNode, this._toolbar);
			this.toolbar.addLeftAlignButtons("title");
			
			this.properties = new QuickAndAdvancedProperties("library");
			this.properties.createPropertiesContainer(this._propertyTitlePane);
		
	 		Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},
    
		resize: function() {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize"); 
		  this._egOverview_borderContainer.resize();
    	Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize"); 
    },
	    
    // This function is called manually when we need to remove this tab.
    tabRemove: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
        
      this.properties.unsubscribeAll();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove"); 
    },
      
        contextButtonsClicks : function(event) {
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "contextButtonsClicks", [event]);

            // Get the URI and action from the event:
		    var uriAndAction = UIUtils.getURIAndAction(event, true);
		    var itemURI = uriAndAction.uri;
		    var buttonType = uriAndAction.action;

            this.actionLib(itemURI, buttonType);


            Trace.trace(this.declaredClass, Trace.levels.EXIT, "contextButtonsClicks");
          },
          
          actionLib : function(uri, action){
          	
              Trace.trace(this.declaredClass, Trace.levels.ENTRY, "actionLib", [uri,action]);

              var uriArray = uri.split("_");
              var buttonType = uriArray[uriArray.length - 1];
              uri = uri.substr(0,uri.length - buttonType.length - 1);

              if (null!=action && action === "delete" ) {

                var tree = registry.byId('_explorerTree_ID');
                var libName = tree.selectedNode.item.name;//label can be truncated, so use name instead
                  
                var confirmationMessage = string.substitute(NLS.messages.DeleteLibraryAction_confirmation, [libName] );
                  
      	        var confirmCallback = lang.hitch(this, function() {

      	          //	Add loading icon to tree
      	          var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
      	          var oldIcon = domAttr.get(treeImgs[0],"class");
      	          domAttr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");        	

      	          // REST Call to delete the library
      	          xhr.del(
      	              uri,
      	              {
      	                handleAs : "json",
      	                headers : {
      	                   "Accept" : "application/json"
      	                }
      	              }
      	            ).then( lang.hitch(this, function() {
      	              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Library delete success");
      	
      	              //reset old icon
      	              domAttr.set(treeImgs[0],"class",oldIcon);

      	              // Display success message for deleting a library
      	              window.smallMessage.displayPlainMessage("success", "DeleteLibraryAction_successLibraryDeleted", [libName]);
      	              
      	            }),
      	            lang.hitch(this, function(error) {
      	            	
      	              Trace.trace(this.declaredClass, Trace.levels.ERROR, "xhrDel to " + uri + " failed.", [error]);

      	              //reset old icon
      	              domAttr.set(treeImgs[0],"class",oldIcon);

      	              //show error message
      	              var response = JSON.parse(error.response.text);
      	              window.smallMessage.displayMessage("error", "libdelete_5XX", response.bipNumber, response.description);
      	            })
      	          );
      	        });
                  
      	        window.wmbConsole.showConfirmationDialog("btConfirmDelete", "question", NLS.btConfirmDeleteYes, NLS.btConfirmDeleteNo, confirmationMessage, confirmCallback, null);
      			        
              	
              	
              }//if

              Trace.trace(this.declaredClass, Trace.levels.EXIT, "actionLib");
            },
            
        
     tabFocus: function () {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");
      // Get lib name and add to the toolbar title
      this.toolbar.setAttribute("title", "innerHTML", "");
      var populate = this._attributesStore.populateAttributesStore();
      populate.then(lang.hitch(this, function() {
        domAttr.set("_infoPaneTitleID", "innerHTML", this._attributesStore.getAttribute("name") + " - " + NLS.libTitle);
      }));

      // Populate quick view and advanced properties
      this.properties.populateProperties();
         
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
     },
        
        tabBlur: function () {
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur"); 

            Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
        }
        
	});
	return libOverview;
});

},
'webui/widgets/policy/PolicyEditorDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63" 
 * years="2014, 2015" 
 * crc="182285012" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63 
 *  
 * (C) Copyright IBM Corp. 2014, 2015 All Rights Reserved.  
 * </copyright> 
 *
 * 
 * BTNameDescriptionCreateDialog widget - widget with a name and description attributes
 * 
 */
define([
  "dojo/text!webui/widgets/policy/templates/PolicyEditorDialog.html", 
  "dojo/i18n!webui/nls/web",
  "dojo/_base/array",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/dom-class",
  "dojo/dom-construct",
  "dojo/on",
  "dojo/request/xhr",
  "dojo/string",
  "dojox/html/entities",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetsInTemplateMixin",
  "dijit/Dialog",
  "dijit/registry",
  "webui/config/Resources",
  "webui/utils/RestUri",
  "webui/widgets/common/HasContextMenu",
  "webui/widgets/common/Trace",
  "webui/widgets/policy/PolicySaveAsDialog",
  "webui/widgets/policy/PolicyUtils",
  "webui/widgets/policy_editor/policy_editor_dynamic"
], function(
  template,
  NLS,
  array,
  declare,
  lang,
  domAttr,
  domClass,
  domConstruct,
  on,
  xhr,
  string,
  entities,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  Dialog,
  registry,
  Resources,
  RestUri,
  HasContextMenu,
  Trace,
  PolicySaveAsDialog,
  PolicyUtils,
  policy_editor_dynamic
) {
  var POLICY_EDITOR_DYNAMIC_CALLER_ID = "policyEditorDialogDynamic"; // this is an unique id from the caller to policy_editor_dynamic widget, for all the fields created by the widget will be prefixed by the caller id

  var policyEditorDialog = declare("webui.widgets.policy.PolicyEditorDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin, HasContextMenu ], {    
    templateString : template,
//    _firstTimeValidation : false,
    _policySaveLabel: NLS.action.save,
    _policySaveAsLabel: NLS.action.saveAs,
    _policyCancelLabel: NLS.cancelButtonLabel,
    _buttonCancel: NLS.cancelButtonLabel,

    policyEditorDynamic: null,
    policyDocumentURI: null,
    displayPolicyName: null,
    informationalMessage: null,
    isNewCreate: false,
    policyURL: null,
    policyType: null,
    policyName: null,
    actionType: null,
    
     
    // MQTTPublish Layout
    mqttPublishPolicyLayout: {id: "root", contents: [
                                                     {id: "policyUrl", type: "String", "default": "", readOnly: true, style:"width: 400px"},
                                                     {id: "group_description_title", type: "Group", "default": "true", contents: 
                                                      [ 
                                                       {id: "shortDesc", type: "String", "default": "", style:"width: 400px"  },
                                                       {id: "longDesc", type: "String", "default": "", style:"width: 400px"}
                                                      ]
                                                     },
                                                     {id: "group_basic_title", type: "Group", "default": "true", contents: 
                                                      [ 
                                                       {id: "clientId", type: "String", "default": "", style:"width: 400px"},
                                                       {id: "topicName", type: "String", "default": "", style:"width: 400px"},
                                                       {id: "hostName", type: "String", "default": "", style:"width: 400px"},
                                                       {id: "port", type: "Number", "default": "", constraints: {min: 0, max: 100000, places: 0, pattern:'#'}, style:"width: 400px", invalidMessage: "error_integerOnly"},
                                                       {id: "qos", type: "Enum", contents: [ "empty", "0", "1", "2"], "default": "empty", style:"width: 402px"}
                                                      ]
                                                     }
                                                    ]},
    mqttPublishReadOnlyPolicyLayout: {id: "root", contents:[
                                                            {id: "policyUrl", type: "String", "default": "", readOnly: true, style:"width: 400px"},
                                                            {id: "group_description_title", type: "Group", "default": "true", contents: 
                                                             [ 
                                                              {id: "shortDesc", type: "String", "default": "", readOnly: true, style:"width: 400px;"  },
                                                              {id: "longDesc", type: "String", "default": "", readOnly: true, style:"width: 400px;" }
                                                             ]
                                                            },
                                                            {id: "group_basic_title", type: "Group", "default": "true", contents: 
                                                             [ 
                                                              {id: "clientId", type: "String", "default": "", readOnly: true, style:"width: 400px;"},
                                                              {id: "topicName", type: "String", "default": "", readOnly: true, style:"width: 400px;"},
                                                              {id: "hostName", type: "String", "default": "", readOnly: true, style:"width: 400px;"},
                                                              {id: "port", type: "Number", "default": "", readOnly: true, constraints: {min: 0, max: 100000, places: 0, pattern:'#'}, style:"width: 400px;"},
                                                              {id: "qos", type: "Enum", contents: [ "empty", "0", "1", "2"], "default": "empty", readOnly: true, style:"width: 402px;"}
                                                             ]
                                                            }
                                                           ]},
                                                           
     // MQTTSubscribe Layout
     mqttSubscribePolicyLayout: {id: "root", contents: [
                                                        {id: "policyUrl", type: "String", "default": "", readOnly: true, style:"width: 400px"},
                                                        {id: "group_description_title", type: "Group", "default": "true", contents: 
                                                         [ 
                                                          {id: "shortDesc", type: "String", "default": "", style:"width: 400px;" },
                                                          {id: "longDesc", type: "String", "default": "", style:"width: 400px;"}
                                                         ]
                                                        },
                                                        {id: "group_basic_title", type: "Group", "default": "true", contents: 
                                                         [ 
                                                          {id: "clientId", type: "String", "default": "", style:"width: 400px;"},
                                                          {id: "topicName", type: "String", "default": "", style:"width: 400px;"},
                                                          {id: "hostName", type: "String", "default": "", style:"width: 400px;"},
                                                          {id: "port", type: "Number", "default": "", constraints: {min: 0, max: 100000, places: 0, pattern:'#'}, style:"width: 400px;", invalidMessage: "error_integerOnly"},
                                                          {id: "qos", type: "Enum", contents: [ "empty", "0", "1", "2"], "default": "empty", style:"width: 402px;"}
                                                         ]
                                                        }
                                                       ]},
    mqttSubscribeReadOnlyPolicyLayout: {id: "root", contents:[
                                                              {id: "policyUrl", type: "String", "default": "", readOnly: true, style:"width: 400px"},
                                                              {id: "group_description_title", type: "Group", "default": "true", contents: 
                                                               [ 
                                                                {id: "shortDesc", type: "String", "default": "", readOnly: true, style:"width: 400px;" },
                                                                {id: "longDesc", type: "String", "default": "", readOnly: true, style:"width: 400px;"}
                                                               ]
                                                              },
                                                              {id: "group_basic_title", type: "Group", "default": "true", contents: 
                                                               [ 
                                                                {id: "clientId", type: "String", "default": "", readOnly: true, style:"width: 400px;"},
                                                                {id: "topicName", type: "String", "default": "", readOnly: true, style:"width: 400px;"},
                                                                {id: "hostName", type: "String", "default": "", readOnly: true, style:"width: 400px;"},
                                                                {id: "port", type: "Number", "default": "", readOnly: true, constraints: {min: 0, max: 100000, places: 0, pattern:'#'}, style:"width: 400px;"},
                                                                {id: "qos", type: "Enum", contents: [ "empty", "0", "1", "2"], "default": "empty", readOnly: true, style:"width: 402px;"}
                                                               ]
                                                              }
                                                             ]},
                
                                                                         
    // MQEndpoint Layout
    mqEndpointPolicyLayout: {id: "root", contents: [
                                                    {id: "policyUrl", type: "String", "default": "", readOnly: true, style:"width: 400px"},
                                                    {id: "connection", type: "Enum", contents: [ "CLIENT", "CCDT", "SERVER"], "default": "SERVER", style:"width: 402px;"},
                                                    {id: "destinationQueueManagerName", type: "String", "default": "", style:"width: 400px;"},
                                                    {id: "queueManagerHostname", type: "String", style:"width: 400px;"},
                                                    {id: "listenerPortNumber", type: "Number", constraints: {min: 0, max: 100000, places: 0, pattern:'#'}, style:"width: 400px;", invalidMessage: "error_integerOnly"},
                                                    {id: "channelName", type: "String", style:"width: 400px;"},
                                                    {id: "securityIdentity", type: "String", "default": "", style:"width: 400px;"},
                                                    {id: "useSSL", type: "Boolean"},
                                                    {id: "SSLPeerName", type: "String", "default": "", style:"width: 400px;"},
                                                    {id: "SSLCipherSpec", type: "String", "default": "", style:"width: 400px;"}
                                                   ]},
                                                   
     mqEndpointReadOnlyPolicyLayout: {id: "root", contents:[
                                                            {id: "policyUrl", type: "String", "default": "", readOnly: true, style:"width: 400px"},
                                                            {id: "connection", type: "Enum", contents: [ "CLIENT", "CCDT", "SERVER"], "default": "SERVER", readOnly: true, style:"width: 402px;"},
                                                            {id: "destinationQueueManagerName", type: "String", "default": "", readOnly: true, style:"width: 400px;"},
                                                            {id: "queueManagerHostname", type: "String", readOnly: true, style:"width: 400px;"},
                                                            {id: "listenerPortNumber", type: "Number", constraints: {min: 0, max: 100000, places: 0, pattern:'#'}, readOnly: true, style:"width: 400px;"},
                                                            {id: "channelName", type: "String", readOnly: true, style:"width: 400px;"},
                                                            {id: "securityIdentity", type: "String", "default": "", readOnly: true, style:"width: 400px;"},
                                                            {id: "useSSL", type: "Boolean", readOnly: true},
                                                            {id: "SSLPeerName", type: "String", "default": "", readOnly: true, style:"width: 400px;"},
                                                            {id: "SSLCipherSpec", type: "String", "default": "", readOnly: true, style:"width: 400px;"}
                                                           ]},


   

    postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
        this.inherited(arguments);    

        this.titleNode.setAttribute("tabIndex", -1);
          
        on(this._saveButton, "click", lang.hitch(this, function() {
               this.saveContent();
              this.hide();
        }));
          
        on(this._saveAsButton, "click", lang.hitch(this, function() {
            this.saveAsContent();
        }));
          
        on(this._cancelButton, "click", lang.hitch(this, function() {
            window.smallMessage.hideMessage();  
            this.hide();
        }));

          
        this.policyEditorDynamic = new policy_editor_dynamic({
            id: POLICY_EDITOR_DYNAMIC_CALLER_ID
        });
        domConstruct.place(this.policyEditorDynamic.domNode, this._policyEditorDialogDynamicContentPane);    
    
         Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },
    
    cleanup: function(){
   
        if (this.policyEditorDynamic){

               try{        
                this.policyEditorDynamic.destroy();
            }
            catch(e) {}
        
            this.policyEditorDynamic = null;
        }
        
        var saveAsDialog = registry.byId("policySaveAsDialog");
        if (saveAsDialog){
            try{
                saveAsDialog.destroy();
            }
            catch(e) {}
        
            saveAsDialog = null;
        }
    },
    
    showDialogContent: function (actiontype, policyURL, node) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "showDialogContent"); 
        
      this.policyURL = policyURL;
      this.actionType = actiontype;
      
      if(policyURL){
        var restUri = new RestUri(policyURL);
        this.policyType = restUri.getPolicyType();
        this.policyName = restUri.getPolicyName();
        this.displayPolicyName = restUri.getPolicyName();
      }         
        
      this._setTitle(this.displayPolicyName, node.name);
        
      // set page instruction
      if (actiontype === 'E'){
        domAttr.set(this.pageInstructionNode, "innerHTML", entities.encode(NLS._unspecifiedNodePolicyPropertiesTooltip));
      }
      else {
        domAttr.set(this.pageInstructionNode, "innerHTML", entities.encode(NLS.nodePolicyPropertiesTooltip));
      }
        
      if(this.policyType === "MQTTPublish") {
        if (actiontype === 'E'){
          this.policyEditorDynamic.displayPolicyLayout(this.mqttPublishPolicyLayout);
        }
        else {
          this.policyEditorDynamic.displayPolicyLayout(this.mqttPublishReadOnlyPolicyLayout);
        }
        this.isNewCreate = false;
      }
      else if(this.policyType === "MQTTSubscribe") {
        if (actiontype === 'E'){
          this.policyEditorDynamic.displayPolicyLayout(this.mqttSubscribePolicyLayout);
        }
        else {
          this.policyEditorDynamic.displayPolicyLayout(this.mqttSubscribeReadOnlyPolicyLayout);
        }
        this.isNewCreate = false;
      } 
      else if(this.policyType === "MQEndpoint") {
        if (actiontype === 'E'){
          this.policyEditorDynamic.displayPolicyLayout(this.mqEndpointPolicyLayout);
        }
        else {
          this.policyEditorDynamic.displayPolicyLayout(this.mqEndpointReadOnlyPolicyLayout);
        }
        this.isNewCreate = false;
      } 
        
      window.smallMessage.hideMessage();  
     
      var target; 
      if (this.actionType === "E"){
        target = policyURL;
      }
      else if (this.actionType === "S"){
        target = this._attributesStore.getAttribute("uri") + "/node/" + node.name + "/effectivePolicy";
      }
        
      xhr(
        target, 
        {
          handleAs : "json",
          headers : {
            "Accept" : "application/json"
          }
        }
      ).then(lang.hitch(this, function(response) {
        
        var policyType = null;
        if (typeof response.policyType != "undefined") {
          policyType = response.policyType;  
        }
        else if (typeof response.type != "undefined") {
          policyType = response.type;  
        }
        
        var policyData = { id: "root", contents: []};
        var policyContentsCounter = 0;
        if (typeof response.policyProperties != "undefined") {
          var policyProperties = response.policyProperties;
                      
          // loop thru the response to get the policy content
          policyData = PolicyUtils.loopThruPolicyDataStructureFromREST(policyProperties, policyData, policyContentsCounter, POLICY_EDITOR_DYNAMIC_CALLER_ID);
        }
        else if (typeof response.effectivePolicyProperties != "undefined") {
          var effectivePolicyProperties = response.effectivePolicyProperties;
          
          for (var propName in effectivePolicyProperties) 
          {
            if (propName === "policyProperties"){
              // loop thru the response to get the policy content
              policyData = PolicyUtils.loopThruPolicyDataStructureFromREST(effectivePolicyProperties[propName], policyData, policyContentsCounter, POLICY_EDITOR_DYNAMIC_CALLER_ID);
            }
            else if (propName === "type"){
              policyType = effectivePolicyProperties[propName];
            }
          }
        }
        
        //Determine readonly or readwrite layout
        var policyLayout;
        if (policyType === "MQTTPublish"){
          if (this.actionType === "E"){
            if(window.currentuser.userPermission("broker", "write")) {
              policyLayout = this.mqttPublishPolicyLayout;
            } else {
              policyLayout = this.mqttPublishReadOnlyPolicyLayout;
              this._saveButton.set("disabled", true);
              this._saveAsButton.set("disabled", true);
            }
          }
          else {
            policyLayout = this.mqttPublishReadOnlyPolicyLayout;
            this._saveButton.set("disabled", true);
            this._saveAsButton.set("disabled", true);
          }
        }
        else if (policyType === "MQTTSubscribe"){
          if (this.actionType === "E"){
            if(window.currentuser.userPermission("broker", "write")) {
              policyLayout = this.mqttSubscribePolicyLayout;
            } else {
              policyLayout = this.mqttSubscribeReadOnlyPolicyLayout;
              this._saveButton.set("disabled", true);
              this._saveAsButton.set("disabled", true);
            }
          }
          else {
            policyLayout = this.mqttSubscribeReadOnlyPolicyLayout;
            this._saveButton.set("disabled", true);
            this._saveAsButton.set("disabled", true);
          }
        }
        else if (policyType === "MQEndpoint"){
          if (this.actionType === "E"){
            if(window.currentuser.userPermission("broker", "write")) {
              policyLayout = this.mqEndpointPolicyLayout;
            } else {
              policyLayout = this.mqEndpointReadOnlyPolicyLayout;
              this._saveButton.set("disabled", true);
              this._saveAsButton.set("disabled", true);
            }
          }
          else {
            policyLayout = this.mqEndpointReadOnlyPolicyLayout;
            this._saveButton.set("disabled", true);
            this._saveAsButton.set("disabled", true);
          }
        }
        this.policyEditorDynamic.displayPolicy(policyData, policyLayout, policyURL);
        
        return true;
      }),
      
      lang.hitch(this, function(error) {
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.xhr.status + " Response: " + error.response.xhr.response);            
                
        try {
          // Policy not found, display error in dialog and web page
          domAttr.set(this.policyEditorDialogInstructionNode, "innerHTML", entities.encode(NLS.messages.nodepolicyget_failed));
          domClass.add(this.policyEditorDialogInstructionDiv, "policyDialogWarningText");  
          
          // Disable save and saveAs buttons
          this._saveButton.set("disabled", true);
          this._saveAsButton.set("disabled", true);
          
          this.policyEditorDynamic.displayPolicyURL(policyURL);
          
        } catch (e){
          window.smallMessage.displayMessage("error", "nodepolicyget_failed");
        }
        
        return false;
      })
      );
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "showDialogContent");
    },
      
    
    saveContent : function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "saveContent");
            
        if(!this.policyEditorDynamic.isValid()) {
            var output = "";
            var isFirst = true;
            array.forEach(this.policyEditorDynamic.listInvalid(), lang.hitch(this, function(entry) {
                if(!isFirst) {
                    output+=", ";
                } else {
                    isFirst = false;
                }
                output += entry.name +" : "+entry.value;
            }));

            window.smallMessage.displayMessage("error", "policyinvalidproperty_000",null, NLS.messages.policyinvalidproperty_000+": '"+output+"'");
        } else {
          var treeRoot = Resources.REST.root;
          var policyRoot = "policy";

          var tree = window.wmbConsole._explorerTree;
          var model = tree.model;
          var policyObject = {
            "uri" : this.policyURL,
            "name" : this.policyName,
            "type" : policyRoot,
            "policyType" : this.policyType,
            "documentURI" : this.policyURL
          };

          // get the policy content from policy dynamic editor to a structure used by REST API
          policyObject.data = PolicyUtils.getNodePolicyPropertiesForREST(this.policyType, POLICY_EDITOR_DYNAMIC_CALLER_ID, this.policyEditorDynamic);
                  
          // Check whether this policy already exists
          model.get(treeRoot+"/"+policyRoot+"/"+this.policyType+"/"+this.policyName)
          .then(lang.hitch(this, function() {
          
            // Policy exists, update the policy
            var options = {};
            options.id = policyObject.uri;
            model.put(policyObject.data, options)
            .then(lang.hitch(this, function() {
              
              // policy is updated successfully
              window.smallMessage.displayPlainMessage("success", "policyupdate_success", [this.displayPolicyName]);
            }),
            lang.hitch(this, function(error) {
              
              // Policy update failed
              Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.status + " Response: " + error.responseText);                        
              try {
                var response = JSON.parse(error.responseText);
                window.smallMessage.displayMessage("error", "policyupdate_5XX", response.bipNumber, response.description);
              } catch (e){
                window.smallMessage.displayMessage("error", "policyupdate_5XX");                                
              }
            })
            ); //then
            
          }), lang.hitch(this, function() {
            // The policy does not already exist
            window.smallMessage.displayPlainMessage("error", "policyupdate_notExists", [this.displayPolicyName]);
          }));
        }

        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "saveContent");
    },
    
    saveAsContent : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "saveAsContent");
        
      domAttr.set(this.policyEditorDialogInstructionNode, "innerHTML", "");//Clear message in dialog 
        
      var saveAsDialog = registry.byId("policySaveAsDialog");

      // callback function from saveAsDialog to create the policy
      var createCallback = lang.hitch(this, function(){
        var policyName = saveAsDialog._policyNameText.get("value");

        this.createSaveAsPolicy(policyName);
      }); //createCallback
          
      // create saveAsDialog       
      if (!saveAsDialog) {
        saveAsDialog = new PolicySaveAsDialog( {
          id : "policySaveAsDialog",
          createCallback : createCallback
        });                
        saveAsDialog.startup();
      }
      domAttr.set(saveAsDialog.titleNode, "innerHTML", entities.encode(NLS.policy_saveAsDialogTitle));
      domAttr.set(saveAsDialog.instructionNode, "innerHTML", entities.encode(NLS.policySaveAsDescription));
      saveAsDialog._policyNameText.set("value", "");

      saveAsDialog.refresh();
      saveAsDialog.show();
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "saveAsContent");
    },
    
    createSaveAsPolicy : function(policyName){
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createSaveAsPolicy");
            
        if(typeof policyName == "undefined" || policyName.length == 0) {
            window.smallMessage.displayMessage("error", "policyinvalidname_000");
            return;
        }
        
        domAttr.set(this.policyEditorDialogInstructionNode, "innerHTML", "");//Clear message in dialog 
        
        var uriTarget;
 
        var idx = this.policyURL.lastIndexOf('/');
        if (idx > 0){
            uriTarget = this.policyURL.substring(0, idx + 1) + encodeURIComponent(policyName);
            this.policyURL = uriTarget;
        }
        
        
        // create policy
        if(!this.policyEditorDynamic.isValid()) {
            var output = "";
            var isFirst = true;
            array.forEach(this.policyEditorDynamic.listInvalid(), lang.hitch(this, function(entry) {
                if(!isFirst) {
                    output+=", ";
                } else {
                    isFirst = false;
                }
                output += entry.name +" : "+entry.value;
            }));

            window.smallMessage.displayMessage("error", "policyinvalidproperty_000",null, NLS.messages.policyinvalidproperty_000+": '"+output+"'");
        } else {
            var treeRoot = Resources.REST.root;
            var policyRoot = "policy";

            var tree = window.wmbConsole._explorerTree;
            var model = tree.model;
            var policyObject = {};
            policyObject.uri = uriTarget;
            policyObject.name = policyName;
            policyObject.type = policyRoot;
            policyObject.policyType = this.policyType;
            this.policyName = policyName;
            policyObject.documentURI = this.policyDocumentURI;

            // get the policy content from policy dynamic editor to a structure used by REST API
            policyObject.data = PolicyUtils.getNodePolicyPropertiesForREST(this.policyType, POLICY_EDITOR_DYNAMIC_CALLER_ID, this.policyEditorDynamic);
        
            // Add loading icon to tree
            tree = registry.byId('_explorerTree_ID');        

            // Check whether this policy already exists
            model.get(treeRoot+"/"+policyRoot+"/"+this.policyType+"/"+encodeURIComponent(policyName)).then(lang.hitch(this, function() {
                
              // The policy already exists, report an error
              window.smallMessage.hideMessage();                                        
              domAttr.set(this.policyEditorDialogInstructionNode, "innerHTML", string.substitute(NLS.messages.policysave_alreadyExists, [policyName]));
              domClass.add(this.policyEditorDialogInstructionDiv, "policyDialogWarningText");  
                    
                    
            }), lang.hitch(this, function() {
                
                // The policy does not already exist, go ahead and create the policy
                domAttr.set(this.policyEditorDialogInstructionNode, "innerHTML", entities.encode(NLS.policy_creatingNewPolicy));
                domClass.remove(this.policyEditorDialogInstructionDiv, "policyDialogWarningText"); 
                
                // Firstly set the path to /apiv1/policy/{policyType}
                tree.set(
                        "path",
                        [
                             treeRoot,
                             treeRoot+"/"+policyRoot,
                             treeRoot+"/"+policyRoot+"/"+this.policyType
                         ]
                ).then(lang.hitch(this, function() {
                        
                    // Now that the path is /apiv1/policy/{policyType} create the actual policy
                    this.hide();
                    
                        // create non-WorkloadManagement policies                            
                        var options = {};
                        options.id = policyObject.uri;
                        options.incremental = false; //PUT request to {target}/{id}
                        model.put(policyObject.data, options)
                        .then(lang.hitch(this, function() {
                            
                            // policy is created successfully
                            window.smallMessage.displayPlainMessage("success", "policysave_successCreate", [policyName]);

                            // Policy creation succeeded, now refresh the model at /apiv1/policy/{policyType}
                            model.get(treeRoot+"/"+policyRoot+"/"+this.policyType).then(lang.hitch(this, function(updatedPolicies) {
                                // Model refresh succeeded, refresh the tree
                                model.onChildrenChange(updatedPolicies, updatedPolicies.policy);
                                model.onChange(updatedPolicies);
                            
                            }), lang.hitch(this, function(error) {
                                
                                // Model refresh failed
                                Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.status + " Response: " + error.responseText);                        
                                try {
                                    var response = JSON.parse(error.responseText);                
                                    window.smallMessage.displayMessage("error", "TreeError_5XX", response.bipNumber, response.description);
                                } catch (e){
                                    window.smallMessage.displayMessage("error", "TreeError_5XX");
                                }
                                
                            })); // end of model.get
                        }), lang.hitch(this, function(error) {
                            
                          // Policy creation failed
                          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.status + " Response: " + error.responseText);                        
                          try {
                            var response = JSON.parse(error.responseText);                
                            window.smallMessage.displayMessage("error", "policysave_5XX", response.bipNumber, response.description);
                          } catch (e){
                            window.smallMessage.displayMessage("error", "policysave_5XX");
                          }
                        })); //then

                }));
                
            }));
        
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "createSaveAsPolicy");
    },
    
    
    _setTitle: function(policyName, nodeName) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_setTitle");
        
      var title = NLS.policy_editorTitle;
      if(this.actionType){
        if (this.actionType === "E"){
          title = NLS.policy_EditPolicyTitle;
        }
        else if (this.actionType === "V"){
          title = NLS.policy_ViewPolicyTitle;
        }
        else if (this.actionType === "S"){
          title = NLS.policy_EffectivePropertiesTitle;
        }
      }
        
      if (this.actionType === "S"){
        if(typeof nodeName != 'undefined' && nodeName != null) {
          title = title + " : " + nodeName; 
        }
      }
      else {
        if (typeof this.policyType != 'undefined' && this.policyType != null){
          title = title + " - " + this.policyType; 
        }
        
        if(typeof policyName != 'undefined' && policyName != null && policyName !== this.policyType) {
          title = title + " : " + policyName; 
        }
      }

      domAttr.set(this.titleNode, "innerHTML", entities.encode(title));
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_setTitle");
    },
        
    
    refresh : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "refresh");

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "refresh");
    }
       
    
  });

  
    return policyEditorDialog;
});

},
'webui/widgets/common/QuickAndAdvancedProperties':function(){
/*
 * <copyright
 * notice="lm-source"
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2"
 * years="2011,2016"
 * crc="2502625866" >
 * Licensed Materials - Property of IBM
 *
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2
 *
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.
 * </copyright>
 */
define([
  "dojo/i18n!webui/nls/web",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/dom-class",
  "dojo/dom-construct",
  "dojo/hash",
  "dojo/request/xhr",
  "dojo/string",
  "dojo/topic",
  "dijit/_WidgetBase",
  "dijit/TitlePane",
  "webui/config/Resources",
  "webui/utils/RestUri",
  "webui/utils/WebUiHash",
  "webui/widgets/common/Trace",
  "dojox/html/entities"
], function(
  NLS,
  declare,
  lang,
  domAttr,
  domClass,
  domConstruct,
  hash,
  xhr,
  string,
  Topic,
  _WidgetBase,
  TitlePane,
  Resources,
  RestUri,
  WebUiHash,
  Trace,
  HTMLEntities
) {
  var QuickAndAdvancedProperties = declare("webui.widgets.common.QuickAndAdvancedProperties", [_WidgetBase], {

    _propertyTypes: [
      "properties",
      "basicProperties",
      "advancedProperties",
      "deployedProperties",
      "userDefinedProperties",
      "componentProperties",
      "resourceManagerProperties"
    ],

    propertiesByType: null, // public
    _titlePanesByType: null,
    _propertySpacersByType: null,
    _notificationHandle: null,
    _deleteNotificationHandle: null,
    _propertiesUri: null, // the REST URI to get properties from
    _parentUri: null, // the REST URI of the parent object
    _resourceType: null, // e.g. "broker", "executionGroup". This is the hash's first element
    _resourceNLS: null,
    _configurableServiceResourceType: null, // e.g. MonitoringProfiles. This is to determine encoding of properties.
    _configurableServiceXMLResourceTypes: [ // Configurable Service types that have XML doc properties.
      "MonitoringProfiles",
      "PolicySetBindings",
      "PolicySets"],
      
    // Default function for filtering properties. Can be overidden using setFilterProperty().
    _filterProperty: function (name, value) { return true; },
    
    // Default function for translating properties. Can be overidden using setFilterProperty().
    _translateProperty: function (name, value) { return { name: name, value: value }; },

		// Override the default function for filtering properties.
    setFilterProperty: function(func) {
      this._filterProperty = func;
    },
    
    // Override the default function for translating properties.
    setTranslateProperty: function(func) {
      this._translateProperty = func;
    },

    constructor: function(resourceType) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");
      this.inherited(arguments);

      this._resourceType = resourceType;
      this._resourceNLS = NLS[resourceType];
      if(!this._resourceNLS) {
        console.error("No NLS resources found for resource type", resourceType);
        this._resourceNLS = {};
      }

      this.propertiesByType = {
        "properties": "",
        "basicProperties": "",
        "advancedProperties": "",
        "deployedProperties": "",
        "userDefinedProperties": "",
        "componentProperties": "",
        "resourceManagerProperties": ""
      };

      this._titlePanesByType = {
        "properties" : null,
        "basicProperties": null,
        "advancedProperties": null,
        "deployedProperties": null,
        "userDefinedProperties": null,
        "componentProperties": null,
        "resourceManagerProperties": null
      };

      this._propertySpacersByType = {
        "properties" : null,
        "basicProperties": null,
        "advancedProperties": null,
        "deployedProperties": null,
        "userDefinedProperties": null,
        "componentProperties": null,
        "resourceManagerProperties": null
      };

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
    },

    createPropertiesContainer: function(/* attachPoint */ target) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "createPropertiesContainer");

      this._propertyTypes.forEach(lang.hitch(this, function(type) {

        // TitlePane for this type of property
        if(!this._titlePanesByType[type]) {
          this._titlePanesByType[type] = new TitlePane({
            title : NLS.viewTitle[type],
            className : "_common_propertyTitle"
          });
          target.appendChild(this._titlePanesByType[type].domNode);
          domAttr.set(this._titlePanesByType[type].domNode, "data-test-attrName", type);
          domClass.add(this._titlePanesByType[type].domNode, "_common_hideDiv");
        }

        // Space beneath
        if(!this._propertySpacersByType[type]) {
          this._propertySpacersByType[type] = domConstruct.create("div", {
            className : "_common_propertySpacer"
          }, target);
          domClass.add(this._propertySpacersByType[type], "_common_hideDiv");
        }

        // All hidden at first, since we don't know which ones will be shown
        // until we make an XHR call for the properties themselves.
      }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "createPropertiesContainer");
    },

    populateProperties: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "populateProperties");

      // Compute resource type, properties URI, parent object URI
      // TODO: make users of QAAP pass the properties URL in

      var webUiHash = new WebUiHash(hash());

      var restUri = webUiHash.getRestUri();

      this._propertiesUri = restUri.toString();
      if(this._resourceType !== "configurableService") {
        this._propertiesUri += "/properties";
      }
      if (this._resourceType === "broker" || this._resourceType === "executionGroup") {
        this._propertiesUri += "?allProperties=true";
      }

      var parentRestUri = restUri.getParentArtifactRestUri(); // Could be `null`
      if(parentRestUri) {
        this._parentUri = parentRestUri.toString();
      }

      if( typeof window.brokerName != 'undefined') {
        this.unsubscribeAll();

        // Do a dojo subscribe for any changes (AdminNotifications) to the current flow so we can recheck
        var notificationsTopicName = restUri.getNotificationTopic();
        if(notificationsTopicName) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "registering for notifications on topic "+notificationsTopicName);
          this._notificationHandle = Topic.subscribe(notificationsTopicName, lang.hitch(this, this._populatePropertiesInner));
        }

        // Do a dojo subscribe to check for any changes to the parent (i.e. possible deletion of selected object).
        // Note that we can't just subscribe to deletion notifications -_-
        if(parentRestUri) {
          var checkFlowComparisonParentTopicName = parentRestUri.getNotificationTopic();
          if(checkFlowComparisonParentTopicName != null) {
            this._deleteNotificationHandle = Topic.subscribe(checkFlowComparisonParentTopicName, lang.hitch(this, this._checkHashObjectDeleted));
          }
        }
      }

      var toReturn = this._populatePropertiesInner();
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "populateProperties");
      return toReturn;
    },

    _populatePropertiesInner: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_populatePropertiesInner");

      // Load the memory store with properties from the item selected in the tree.
      this._propertyTypes.forEach(lang.hitch(this, function(type) {
        domAttr.set(this._titlePanesByType[type], "content", domConstruct.create("div", {
          innerHTML : "<div class='_common_propertyLoading'></div>"
        }));
      }));

      var previousHash = hash();

      var results = xhr(
        this._propertiesUri,
        {
          timeout : 10000, // milliseconds
          headers : {
            "Accept" : "application/json"
          },
          handleAs : "json"
        }
      ).then(
        lang.hitch(this, function(response) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "populateProperties.xhr.load");

          // If there are no UDPs for a flow then stub out a replacement
          if(this._resourceType == "messageFlow") {
            // Apparently this section is completely optional
            if(!response.userDefinedProperties) {
              response.userDefinedProperties = [];
            }
            if(response.userDefinedProperties.length === 0) {
              response.userDefinedProperties.push({
                "name"  : "noUserDefinedPropertiesDefined",
                "value" : ""
              });
            }
          }

          // Add a computed property named "Type" for subflows and resources
          if (this._resourceType === "subFlow" || this._resourceType === "resource"){
            var TYPE_VALUE = this._computeTypeValue(response.uri);
            response.basicProperties.push({
              "name": "calculated_type",
              "value": TYPE_VALUE
            });
          }

          // Grab the configurable service type to determine display behaviour.
          if(this._resourceType === "configurableService" && response.configurableServiceType !== undefined) {
            this._configurableServiceResourceType = response.configurableServiceType;
          }

          // Show properties
          this._propertyTypes.forEach(lang.hitch(this, function(type) {

            if(response[type] === undefined || response[type].length === 0) {
              domClass.add(this._titlePanesByType[type].domNode, "_common_hideDiv");
              domClass.add(this._propertySpacersByType[type], "_common_hideDiv");
              return;
            }

            domClass.remove(this._titlePanesByType[type].domNode, "_common_hideDiv");
            domClass.remove(this._propertySpacersByType[type], "_common_hideDiv");
            this._generateProperties(type, response[type]);
          }));

          Trace.trace(this.declaredClass, Trace.levels.EXIT, "populateProperties.xhr.load");
        }),
        lang.hitch(this, function(error) {
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "populateProperties.xhr.error");

          // If the object has been deleted, then show the parent object instead (integration node)
          // TODO: what about message flows (parent is an application) etc.?
          if (error.response.status === 404) {
            this.unsubscribeAll();
            if(hash() === previousHash) {
              hash(Resources.REST.nodeHome);
            }
          }

          // Write to console (unless this is a not-found case, where the broker resource has been deleted
          else {
            console.error(error);
          }

          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "populateProperties.xhr.error", error.response.xhr.response);
          Trace.trace(this.declaredClass, Trace.levels.ENTRY, "populateProperties.xhr.error");
        })
      );

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_populatePropertiesInner");
      return results;
    },

    /**
     * Valid values of `type`:
     * "properties", "basicProperties", "advancedProperties", "deployedProperties",
     * "userDefinedProperties", "componentProperties", "resourceManagerProperties"
     * `properties` is an array containing key-value pairs.
     */
    _generateProperties : function(propertyType, properties) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_generateProperties");

      // Sort the properties. Some properties are preferentially listed above all
      // the others:
      var first = ["label", "name", "calculated_type", "version", "runState"];

      // For a REST API, certain properties get placed last:
      var last = ["baseURL", "definitionsURL", "localBaseURL", "localDefinitionsURL"];

      // And here are the property names in their original order:
      var original = properties.map(function(property) {
        return property.name;
      });

      // Example input: ["name", "calculated_type", "", "definitionsURL", "localBaseURL", "foo", "bar", "localDefinitionsURL", "baseURL", "label"]
      // Correct output: ["label", "name", "calculated_type", "", "foo", "bar", "baseURL", "definitionsURL", "localBaseURL", "localDefinitionsURL"]
      // (Except with [{"name": "label", "value": "blah"}, ...])

      properties.sort(function(a, b) {

        // Elements not found in the `top` listing are considered to
        // come last of all.
        var aTop = first.indexOf(a.name); if(aTop === -1) { aTop = first.length; }
        var bTop = first.indexOf(b.name); if(bTop === -1) { bTop = first.length; }

        // Returns >= 0 for all `a` and `b`
        var aMiddle = original.indexOf(a.name);
        var bMiddle = original.indexOf(b.name);

        // Elements not found in the `bottom` listing are considered to
        // come first, index -1
        var aBottom = last.indexOf(a.name);
        var bBottom = last.indexOf(b.name);

        return (aTop - bTop) || (aBottom - bBottom) || (aMiddle - bMiddle);
      });

      var rowId = 1; // sigh
      var rows = [];
      properties.forEach(lang.hitch(this, function(property) {

        var name = property.name || "";
        var value = property.value || "";

				// Give the user of this class a chance to filter out properties that they do not want.
        if (!this._filterProperty(name, value)) {
        	return;
        }

				// Give the user of this class a chance to translate the property name and value
				// to a completely different name and value (if they so desire).
        var translated = this._translateProperty(name, value);
        if (translated) {
        	name = translated.name || name;
        	value = translated.value || value;
        }

        // if a property looks like it might be a URL, display it as a hyperlink.
        if (value.indexOf('http://') === 0 || value.indexOf('https://') === 0) {
          value = '<a target="_blank" href="' + value + '">' + value + '</a>';
        }
        else {
          // Check whether the type is configurable service and a whether it is in the exempt encoding list (as this is encoded XML - so don't encode further)
          if((this._resourceType !== 'configurableService') || (this._configurableServiceXMLResourceTypes.indexOf(this._configurableServiceResourceType) === -1)) {
            // Encode value to prevent code injection:
            value = HTMLEntities.encode(value);
          }
        }

        // Admin Security gets special consideration and a big blue button (see broker_overview.js)
        if(name === "AdminSecurity") {
          if(value === "active") {
            value = "On";
          } else {
            value = "<span class='_common_propertyHoverHelpIcon'></span> <span class='_common_hoverHelp'>Off</span>";
          }
        }

        var nameClass = ["_common_propertySubTextEven", "_common_propertySubTextOdd"][rowId % 2];
        var valueClass = ["_common_propertySubValueEven", "_common_propertySubValueOdd"][rowId % 2];

        rows.push(
          "<tr>" +
            "<td data-test-attrName='" + name + "' class='" + nameClass + "'>" +
              this._propertyName(name) +
            "</td>" +
            "<td class='" + valueClass + "'>" +
              value +
            "</td>" +
          "</tr>"
        );

        rowId += 1;
      }));

      var innerHTML = "<table class='_common_propertyContainer'>" + rows.join("") + "</table>";

      domAttr.set(this._titlePanesByType[propertyType], "content", domConstruct.create("div", {
        "innerHTML" : innerHTML
      }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_generateProperties");
    },

    /**
     * Actually destroy this widget and everything in it.
     */
    destroy: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "destroy");
      this.inherited(arguments);

      this.unsubscribeAll();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "destroy");
    },

    /** Unsubscribe from admin notifications. */
    unsubscribeAll: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "unsubscribeAll");

      if (this._notificationHandle) {
        this._notificationHandle.remove();
      }

      if (this._deleteNotificationHandle) {
        this._deleteNotificationHandle.remove();
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "unsubscribeAll");
    },

    /**
     * Called to check whether the parent of the current hash() object has been deleted.
     * If so the hash() is updated to go to the parent of the original object.
     */
    _checkHashObjectDeleted: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_checkHashObjectDeleted");

      var previousHash = hash();

      xhr(
        encodeURI(this._parentUri),
        {
          handleAs : "json",
          headers : {
            "Accept" : "application/json"
          }
        }
      ).then( lang.hitch(this, function(response) {
        var targetObjects = null;

        /*
         * Check that we are interrogating at the messageflow, application, service or library level.
         * So notification is whether the object currently shown in the flow comparison has been deleted.
         * This is notified by the inital xhr request that was sent and the object type that it returned.
         * If it has been deleted then update the hash to the parent execution group.
         */
        switch(response.type) {
          case "messageFlows" : targetObjects = response.messageFlow; break;
          case "subFlows" : targetObjects = response.subFlow; break;
          case "applications": targetObjects = response.application; break;
          case "restApis": targetObjects = response.restApi; break;
          case "services": targetObjects = response.service; break;
          case "libraries": targetObjects = response.library; break;
          case "sharedLibraries": targetObjects = response.sharedLibrary; break;
          case "resources": targetObjects = response.resource; break;
        }

        if(!targetObjects) {
          return;
        }

        // If so check that any objects were returned
        var objectDeleted = true;
        if(targetObjects.length > 0) {
          // Get the name of the object that the hash currently points to
          if (hash()) {
            var objectName = new WebUiHash(hash()).getArtifactName();
          }

          objectDeleted = !targetObjects.some(function(curObject) {
            return curObject.name == objectName;
          });
        }

        // If the object has been deleted then update the hash back to the root execution group
        if(objectDeleted) {
          this.unsubscribeAll();

          if(hash() === previousHash) {
            var newHash = WebUiHash.fromRestUri(new RestUri(response.uri)).toString();
            hash(newHash);
          }
        }
      }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_checkHashObjectDeleted");
    },

    _propertyName: function(name){
      // We deliberately do not NLS configurable service property names.
      if(this._resourceType === "configurableService") {
        return name;
      }

      var nlsName = this._resourceNLS[name];
      if(!nlsName) {
        console.error("No NLSed version found for property", name, "for resource type", this._resourceType);
        nlsName = name;
      }

      return nlsName;
    },

    /**
     * example of uri :
     * "/apiv1/executiongroups/default/services/integrationService1/resources/integrationService1.wsdl/properties"
     */
    _computeTypeValue: function(uri){

      if ( this._resourceType === "subFlow" ){
        return NLS.resource_file_subflow_Type_Description;
      }

      if(uri === undefined) {
        return "";
      }

      var resourceFileExtension = "";
      var uriOfResourceTokenized = uri.split("/");
      if (uriOfResourceTokenized.length > 1) {
        uriOfResourceTokenized.pop();//remove the "properties" segment
      }//if
      if (uriOfResourceTokenized.length > 1) {
        var fileNameWithExtension = uriOfResourceTokenized.pop();//remove the "fileName.extension" segment

        //let's take a look to see if file has an extension.
        var index = fileNameWithExtension.lastIndexOf(".");
        if (index !== -1){
          resourceFileExtension = fileNameWithExtension.substring(index+1);
        }//if
      }//if

      var TYPE_VALUE = "";
      if (resourceFileExtension.length > 0){

        resourceFileExtension = resourceFileExtension.trim().toLowerCase();

        //generic default value of the form :  EXTENSION File  ,  e.g.  MAP File  or  ESQL File
        var upperCasedExtension = resourceFileExtension.toUpperCase();//only uppercase here
        TYPE_VALUE = string.substitute(NLS.resource_file_generic_Type_Description, [upperCasedExtension]);

        //for a more meaningful description... provide one here  e.g.
        // .rules:  instead of  RULES File, provide  'Decision Service'
        //
        // In v9 IBX, only these extensions had a more meaningful description
        //
        var lookup = {
          "subflow"      : NLS.resource_file_subflow_Type_Description,
          "xsd"          : NLS.resource_file_xsd_Type_Description,
          "xsdzip"       : NLS.resource_file_xsdzip_Type_Description,
          "appdomainzip" : NLS.resource_file_appdomainzip_Type_Description,
          "dictionary"   : NLS.resource_file_dictionary_Type_Description,
          "rules"        : NLS.resource_file_rules_Type_Description,
          "txt"          : NLS.resource_file_txt_Type_Description
        };
        TYPE_VALUE = lookup[resourceFileExtension] || TYPE_VALUE;

      }//if - there is a file extension

      return TYPE_VALUE;
    }
  });
  return QuickAndAdvancedProperties;
});

},
'webui/widgets/business/BTTooltip':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 */
/* global d3 */   
define(
  "webui/widgets/business/BTTooltip",
  [
    "dojo/i18n!webui/nls/web",
    "dojo/_base/declare",
    "webui/widgets/business/BTEventTooltip",
    "webui/widgets/common/Trace",
    "dojo/_base/lang",
    "dojo/keys",
    "dojo/on",
    "dojo/dom-class",
    "webui/config/Resources",
    "dojo/_base/array",
    "dojo/dom",
    "dojo/string",
    "dojo/topic"
  ],
  function(
    NLS,
    declare,
    BTEventTooltip,
    Trace,
    lang,
    keys,
    on,
    domClass,
    Resources,
    array,
    dom,
    string,
    topic
  ) {
   
   var BTTooltip = declare("webui.widgets.business.BTTooltip", [BTEventTooltip], {
     // Customization of the BtEventTooltip that shows monitoring events to show business events
    type: null,
    data: null,
    elementURI: null,

    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      
      var closeTooltipHandler = lang.hitch(this, function(event){
        // Only close the tooltip when is is showing, and clicking on the X or elsewhere on the diagram
        if((!this.isHidden) && ((event.currentTarget.id === this.flowProfileContainer) || (event.currentTarget === this._event_tooltip_close_text))) {
          this.hideTooltip();
        }
        // Stop the event bubbling - across browsers
        if (event.stopPropagation) {
          event.stopPropagation();
        }
        if (event.cancelBubble != null) {
          event.cancelBubble = true;
        }
      });

      // Set up the close handler on the tooltip
      this.closeTooltipHandlers.push( on(dom.byId(this._event_tooltip_close_text), 'click', closeTooltipHandler));
      this.closeTooltipHandlers.push( on(dom.byId(this._event_tooltip_close_text), 'keypress',
        lang.hitch(this, function(event){
          // Only close the tooltip if the key event was a space or return carriage
          var charCode = (typeof event.which == "number") ? event.which : event.keyCode;
          // Return               // Space
          if((charCode === keys.ENTER) || (charCode === keys.SPACE)) {
            closeTooltipHandler(event);
          }
        })
      ));
            
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },

    
    // type : "BusinessEvents",  "FlowValidation"
    setBusinessEventsAttributes : function(type, parent, data, uri){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "setBusinessEventsAttributes");
      this.type = type;
      this.data = data;
      this.parent = parent;
      this.elementURI = uri;      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "setBusinessEventsAttributes");           
    },
    
    addTitle: function(target) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "addTitle");
      if (this.type === Resources.btValidation.businessEventsType) {
        var i = target.uri.lastIndexOf("/");
        var flowName =""; // short Flow name, last part of the uri      
        if (i>=0) {
           flowName = target.uri.substring(i+1);
        }
        this._event_table_heading.innerHTML = string.substitute(NLS.btEventsForFlow, [flowName]);
      }
      else if (this.type ===Resources.btValidation.flowValidationType) {
        this._event_table_heading.innerHTML = NLS.btFlowValidation;
      } 
      else if (this.type ===Resources.btValidation.btValidationType) {
        this._event_table_heading.innerHTML = NLS.btValidationTitle;        
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "addTitle");
    },
            
    addTableContent: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "addTableContent");
      
      var warningIconClass = "validationIcon_warning";
      var infoIconClass = "validationIcon_info";

      var table = "<table class='event_tooltip_table'>";
      
      // Determine the table content based on the type of information being shown
      switch(this.type) {
        case Resources.btValidation.businessEventsType:

          // For now don't show any 'Progress' events
          // Add the basic event information
          this.data.forEach( lang.hitch(this, function(event) {
            table += "<tr><td>";
            // Establish the icon for the event type
            var eventIcon = this.parent.iconsLocation;
            if (event.role === NLS.btStartRole) {
              eventIcon += this.parent.stIcon;
            }
            else if (event.role === NLS.btEndRole) {
              eventIcon += this.parent.endIcon;
            }
            else{ // promoted events are only start, end or failure  
              //i.e. (event.role === NLS.btFailureRole) 
              eventIcon += this.parent.failIcon;
            }         
            
            table += "<div id='" + event.eventSourceAddress + "_Icon' alt='" + event.eventSourceAddress + "' class='flowIcon_businessEvent'></img></td>" + 
                    "<td id='" + event.eventSourceAddress + "'>" +event.role+":"+event.eventSourceAddress+ "</td><tr>"; 
          }));
        
          // Empty the handlers - for now no linkage to event table, so they'll never be any handlers
          this.eventHandlers = [];
            
          // Now add all the event Handlers on the images in the table
          this.eventPolicy.predicates.forEach( lang.hitch(this, function(predicate) {
            var element = dom.byId(predicate.address+"_Icon");
            if (element) {
              this.eventHandlers.push( on(element, 'click', lang.partial(this.tooltipEventSelectedHandler,predicate,this.eventPolicy,this.elementURI)));
            }
          }));
        break;
        
        case Resources.btValidation.flowValidationType:
       
          // Content determined by whether monitoring events are specified, and if those have any correlation specified
          this.warningIcon = this.parent.iconsLocation + this.parent.warningIcon;     

          if(this.data.flowEvents.length == 0) {
            table += "<tr><td>  <div alt='" +  NLS.btNoMonitoringEvent+ "' class='" + warningIconClass + "'></div></td>" + 
            "<td >" + NLS.btNoMonitoringEvent+ " <a href=\""+ Resources.help.monitoringEventsUrl +"\"  target=\"_blank\">"+NLS.btMoreInfo +"</a> </td></tr>";
          }
          if(!this.data.hasCorrelation) {
            table += "<tr><td>  <div alt='" +  NLS.btNoCorrelation+ "' class='" + warningIconClass + "'></div></td>" +
            "<td >" + NLS.btNoCorrelation+ " <a href=\""+ Resources.help.eventCorrelationUrl +"\"  target=\"_blank\">"+NLS.btMoreInfo +"</a> </td></tr>";
          } else {
            this._event_table_heading.innerHTML = NLS.btCorrelation;
            var defaultCorrelation = "automatic";
            var globalCorrelations = [];
            var parentCorrelations = [];
            // List the correlation for each flow event (if any - there'll be at least one)
            array.forEach(this.data.flowEvents, function( flowNodeEvents) {
              array.forEach(flowNodeEvents.nodeMonitoringEvents, function (nodeMonitoringEvent) {
                // At present assuming that no precedence, both are shown
                if(nodeMonitoringEvent.transactionCorrelation.global != defaultCorrelation) {
                	globalCorrelations.push({event: nodeMonitoringEvent.eventSourceAddress, correlation: nodeMonitoringEvent.transactionCorrelation.global});
                }
                if(nodeMonitoringEvent.transactionCorrelation.parent != defaultCorrelation) {
                  parentCorrelations.push({event: nodeMonitoringEvent.eventSourceAddress, correlation: nodeMonitoringEvent.transactionCorrelation.parent});
                }
              });
            });
            
            // Now populate the table with the correlation information
            if(globalCorrelations.length > 0) {
              table += "<tr><td >" + NLS.btCorrelationGlobal + "</td></tr>";
              array.forEach(globalCorrelations, function(nextCorrelation) {
                table += "<tr><td>" + nextCorrelation.event + "</td><td>" + nextCorrelation.correlation +"</td></tr>";
              });
            }
            if(parentCorrelations.length > 0) {
              if(globalCorrelations.length > 0) {
                table += "<tr/>";
            }
            table += "<tr><td >" + NLS.btCorrelationParent + "</td></tr>";
            array.forEach(parentCorrelations, function(nextCorrelation) {
                table += "<tr><td > " +  NLS.btEvent +nextCorrelation.event + ",</td> <td >" +NLS.btValue+ nextCorrelation.correlation +"</td></tr>";
              });
            }
          }
        break;
        
        case Resources.btValidation.btValidationType:
          
          // Validation ok, return with valid message
          if(this.data.details.length == 0) {
            this._event_table.innerHTML = string.substitute(NLS.btValidationGoodMsg, [this.data.btModelData.btName]);
            if(domClass.contains(this._event_table, "event_tooltip_body")) {
              domClass.replace(this._event_table, "event_tooltip_body_valid", "event_tooltip_body");
            }
            return;
          }
          
          this.data.details.forEach( lang.hitch(this, function(message) {
            table += "<tr><td>";
            // Establish the icon for the event type
            var iconClass = "";
           
            if (message.sev===Resources.btValidation.btWarning) {
              iconClass = warningIconClass;
            }
            else if (message.sev===Resources.btValidation.btInfo) {
              iconClass = infoIconClass;
            }
 
            table += "<div alt='" + message.sev + "' class='" + iconClass + "'></div> </td>" + 
                    "<td>" +message.text+ "</td><tr>"; 
          }));
          
          // Add an information link about creating a business transaction
          table += "<tr><td></td><td><a href=\""+ Resources.help.businessTransactionInWebUI +"\"  target=\"_blank\">"+NLS.btMoreInfo +"</a></td></tr>";
          
        break;
      }
      
      table += "</table>";
      
      // Check that non-valid styling is set
      if(domClass.contains(this._event_table, "event_tooltip_body_valid")) {
        domClass.replace(this._event_table, "event_tooltip_body", "event_tooltip_body_valid");
      }
      
      this._event_table.innerHTML = table;
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "addTableContent");
    },
          
    tooltipEventSelectedHandler: function(predicate, eventPolicy, elementURI, event) {
      if (this.type === Resources.btValidation.businessEventsType) {

        // Event handler for clicking on event on flow profile, or on event table     
        // Update the selection in the table
        // First remove any previous selections in the table so that they are n
        for(var i=0; i < eventPolicy.predicates.length; i++) {
          if(domClass.contains(eventPolicy.predicates[i].address, "event_tooltip_table_row_selected")) {
            domClass.remove(eventPolicy.predicates[i].address, "event_tooltip_table_row_selected");
            break;
          }
        }
        domClass.add(predicate.address, "event_tooltip_table_row_selected");
        // Only publish if click was on dialog itself
        if(typeof event !== "undefined") {
          //publishing to something like bt/apiv1/executiongroups/default/messageflows/TotalPurchaseOrderFlow/event
          var newUri = elementURI+"/event";
          topic.publish("bt"+newUri, predicate, elementURI);
          if (event) { event.stopPropagation();}
          if (d3.event) {d3.event.stopPropagation();}
        }
      }
    },
      
    /*
     * checks whether the expanded toolkit is visible and attached to the specified flow
     * 
     */
    hasFlowTooltip: function(eventTooltipId, uri) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "hasFlowTooltip");        
      if ((typeof eventTooltipId != "undefined") && 
          (!domClass.contains(eventTooltipId, "event_tooltip_hidden")) &&
             (this.elementURI === uri)){
          Trace.trace(this.declaredClass, Trace.levels.EXIT, "hasFlowTooltip");        
          return true;    
      }
      else {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "hasFlowTooltip");              
        return false;
      }     
   }
  });

  return BTTooltip;
});

},
'webui/widgets/common/AttributesStore':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="3085515704" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dijit/registry",
  "dojo/_base/declare",
  "dojo/_base/lang",
  "dojo/hash",
  "dojo/store/JsonRest",
  "webui/utils/RestUri",
  "webui/utils/WebUiHash",
  "webui/widgets/common/Trace"
], function(
  registry,
  declare,
  lang,
  hash,
  JsonRest,
  RestUri,
  WebUiHash,
  Trace
) {
  return declare("webui.widgets.common.AttributesStore", [], {

    _store: null,
    _attributesArray: null,

    /**
     * 
     * Called when "OverView" tab has focus or is clicked.
     * Make sure 'target' variable does NOT have trailing "/"
     * 
     */
    populateAttributesStore: function(/* optional uri */ uri) {  
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "populateAttributesStore", [uri]);
      
      // Load the memory store with properties from the item selected in the tree
      var target;
      if(uri){
        target = uri;
      } else if(hash()){
        target = new WebUiHash(hash()).getRestUri().toString();
      } else {
        target = registry.byId('_explorerTree_ID').selectedItem.uri;        
      }

      Trace.trace(this.declaredClass, Trace.levels.DEBUG, "populateAttributesStore", [target]);

      this._store = new JsonRest({"target": target});
      
      var attributesStored = this._store.get("").then(
        lang.hitch(this, function(object){
            
          // get the item type from uri, this is required by a policy item
          var restUri = new RestUri(target);
          var uriPolicyType = restUri.getPolicyType() || "";
          var uriPolicyName = restUri.getPolicyName() || "";

          if (uriPolicyType === object.type){ 
            var wrapperObject = {
              "data" : object,
              "uri" : target,
              "type" : "policy",
              "policyType" : uriPolicyType,
              "name" : uriPolicyName
            };
              
            this._attributesArray = wrapperObject;  
          }
          else {
            this._attributesArray = object;  
          }
        }),
        lang.hitch(this,function(error){
          
          var bipNumber;
          var description;

          if(error.responseText) {
            var errorResponse = JSON.parse(error.responseText);
            if(errorResponse.bipNumber) {
              bipNumber = errorResponse.bipNumber;
              description = errorResponse.description;
            }
          }

          // Specific message for deleted flows (BIP1019) and integration servers (BIP1038)
          
          if(error.status == 404) {
            if(bipNumber == "1019") {
              window.smallMessage.displayMessage("error", "DeployedObjectDoesNotExist_404", bipNumber, description);
            } else if(bipNumber == "1038") {
              window.smallMessage.displayMessage("error", "EGDoesNotExist_404", bipNumber, description);
            } else {
              window.smallMessage.displayMessage("error", "ItemDoesNotExist_404", bipNumber, description);
            }
          } else {
            if(bipNumber == "1019") {
              window.smallMessage.displayMessage("error", "DeployedObjectDoesNotExist_5XX", bipNumber, description);
            } else if(bipNumber == "1038") {
              window.smallMessage.displayMessage("error", "EGDoesNotExist_5XX", bipNumber, description);
            } else {
              window.smallMessage.displayMessage("error", "ItemDoesNotExist_5XX", bipNumber, description);
            }
          }
        })
      );  
        
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "populateAttributesStore");
      return attributesStored;
    },

    getAttribute: function(/* string */ name) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "getAttribute",[name]);
      
      var value = "";
      if (this._attributesArray) {
        value = this._attributesArray[name];
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "getAttribute", [value]);
      return value;
    },
    
    updateAttributeValue : function(/* string */ name, /* string */ value) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "updateAttributeValue",[name,value]);
      if (this._attributesArray) {
        this._attributesArray[name] = value;
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "updateAttributeValue");
    },
    
    saveAttributeUpdates : function (){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "saveAttributeUpdates");
      var response = this._store.put(this._attributesArray,{id: ""});
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "saveAttributeUpdates",[response]);
      return response;
    }
  });
});

},
'webui/widgets/executiongroup/ResourceStatisticsChart':function(){
/* 
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2013,2016" 
 * crc="1195428145" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/_base/array",
  "dojo/_base/lang",
  "dojo/_base/declare", 
  "dojo/dom-style", 
  "dojo/number",
  "dojo/on",
  "dojo/string",  
  "dijit/_TemplatedMixin",
  "dijit/_WidgetBase", 
  "dijit/_WidgetsInTemplateMixin",
  "dijit/Tooltip",
  "webui/widgets/common/Trace", 
  "dojo/text!webui/widgets/executiongroup/templates/ResourceStatisticsChart.html",
  "dojo/i18n!webui/nls/web",
  "dojo/text!webui/config/ResourceTypeGridLayouts.json",
  "d3js",        
  "dojo/domReady!"
], function(
  array,
  lang,
  declare,
  domStyle,
  number,
  on,
  string,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  Tooltip,
  Trace,
  template,
  NLS,
  gridLayoutsJson) {
    
  return declare("webui.widgets.executiongroup.ResourceStatisticsChart", [ _WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin  ], {
    templateString : template,
    _currentResourceType: "JVM",
    _currentResourceIds: ["summary"],
    _defaultMetricIndex: 0,
    _sessionData: null,
    _chartMargins: {top: 5, right: 5, bottom: 20, left: 65},
    _height: 150, 
    _width: 1000,
    _sessionStartTime: new Date().getTime(),
    _numberOfSeconds: 0,
    _lineColorMap: {},
    _usedColorMap: {},
    _dataPointTooltipTemplate: "<div class='dataPointTooltipContainer'><div class='dataPointTooltipName'>${dataSetName}:&nbsp;</div><div class='dataPointTooltipValue'>${dataSetValue}</div></div>",
    _nonNumericMetrics: [
      "name",
      "legend",
      "Protocol",
      "NameOfJDBCProvider",
      "PolicySetApplied",
      "Id",
      "ApplicationBase"
    ],
    
    /**
     * The constructor initializes various non-visual components of the
     * widget, most notably generating the options arrays that hold the 
     * translations for the various metrics that can be selected for each
     * resource type.
     */
    constructor: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");

      /*
       * Associated the NLS resources with this widget so that we can 
       * declaratively references resources in the template markup. 
       */
      this.NLS = NLS;
      
      /*
       * The JSON blob that defines the grid layouts for the 
       * ResourceStatisticGrid widget contains all of the information that we
       * need on the various metrics that are returned for each resource type.
       * Rather than introduce additional configuration, simply parse this
       * configuration to extract the information.
       */
      this._resourceTypeMetrics = {};
      var gridLayouts = JSON.parse(gridLayoutsJson);
      Object.keys(gridLayouts).forEach(lang.hitch(this, function(resourceTypeKey) {
        // Process the fields for the current resource type
        var gridLayout = gridLayouts[resourceTypeKey];
        var metrics = [];
        array.forEach(gridLayout[0], lang.hitch(this, function(fieldConfig) {
          
          // Ignore any non-numeric metrics
          if (this._nonNumericMetrics.indexOf(fieldConfig.field) == -1) {
            metrics.push({ label: this.NLS[fieldConfig.field], value: fieldConfig.field });
          }
        })); // FOREACH
        
        // Store the metrics for the current resource type
        this._resourceTypeMetrics[resourceTypeKey] = metrics;
      })); // FOREACH
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
    },
    
    /**
     * The postCreate function initializes the various visual components of the
     * widget, most notably the SVG canvas for the chart widget. 
     */
    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      // Add the options to the select widget for the current resource type
      var options = this._resourceTypeMetrics[this._currentResourceType];      
      this._resourceMetricSelect.addOption(this._sortOptions(options));
      this._resourceMetricSelect.set("value", options[this._defaultMetricIndex].value);
      this._resourceStatsChartTitle.innerHTML = this._getSelectedMetricLabel();
      
      this.own(on(this._resourceMetricSelect, "change", lang.hitch(this, function() {
        // Set the title for the chart
        this._resourceStatsChartTitle.innerHTML = this._getSelectedMetricLabel();
        
        // Remove all of the existing lines and points for the old metric
        this._chart.selectAll("path.line").remove();
        this._chart.selectAll("circle").remove();

        // Refresh the chart to draw the lines for the new metric
        this.refresh();
      }))); 
      
      /*
       * Now create the D3 chart.  Start by calculating the size of the chart
       * using the placeholder width and height.  This will change once the
       * tab gets focus and the widget is resized... but we need some non-zero
       * values to start with.
       */
      var chartWidth  = this._width  - this._chartMargins.left - this._chartMargins.right;
      var chartHeight = this._height - this._chartMargins.top  - this._chartMargins.bottom;
      
      /*
       * Now define the the scales and axes.  We want to scale the axes so that
       * they fit the width and height of the chart.
       */
      this._colorScale = d3.scale.category20().range();
      this._xRange = d3.time.scale().range([0, chartWidth]);
      this._yRange = d3.scale.linear().range([chartHeight, 0]);
      this._xAxis = d3.svg.axis().scale(this._xRange)
        .orient("bottom")
        .ticks(5)
        .tickFormat(d3.time.format("%X"))
        .tickSize(-chartHeight)
        .tickSubdivide(true);
        this._yAxis = d3.svg.axis().scale(this._yRange)
          .orient("left")
          .ticks(5)
          .tickSize(-chartWidth)
          .tickSubdivide(true);

      // A line generator, for the dark stroke.
      this._line = d3.svg.line()
//        .interpolate("cardinal") // Smooth the line
        .interpolate("monotone") // Smooth the line
        .x(function(d) { return this._xRange(d.date); })
        .y(function(d) { return this._yRange(this._getMetricValue(d, this._resourceMetricSelect.get("value"))); });
      
      /*
       * Now create the actual chart.  This is actually an SVG element that 
       * fills the space available for the chart.  A g element is then appended
       * as a child of the SVG element and is used to group all of the remaining
       * SVG elements for the chart.  This g element is, in effect, the chart. 
       */
      this._chart = d3.select(this._resourceStatsChart).append("svg")
          .attr("id", this.id + "_svg")
          .attr("width", this._width)
          .attr("height", this._height)
        .append("g")
          .attr("transform", "translate(" + this._chartMargins.left + "," + this._chartMargins.top + ")")
          .attr("width", this._width)
          .attr("height", this._height)
          .attr("pointer-events", "all")
          .on("mouseenter", lang.hitch(this, function() {
            this._renderDataPoints();
           }))
           .on("mouseleave", lang.hitch(this, function() {
             this._removeDataPoints();
           }));
      
      // Add the clip path
      this._chart.append("clipPath")
          .attr("id", this.id + "_clip")
        .append("rect")
          .attr("id", this.id + "_clip-rect")
          .attr("width", chartWidth)
          .attr("height", chartHeight);
      
      /*
       * Now create the actual x and y axes for the chart.  If there is no data
       * then simply define some dummy domains to ensure that something sensible
       * is rendered.
       */
      var endTime = this._getDomainEndTime();
      var startTime = this._getDomainStartTime(endTime);
      this._xRange.domain([startTime, endTime]);
      this._yRange.domain([0, 10]).nice();
      this._chartLayer = this._chart.append("g");
      this._chartLayer.append("g")
        .attr("class", "x ResourceStatsAxis")
        .attr("transform", "translate(0," + chartHeight + ")")
        .call(this._xAxis)
          .selectAll("text")  
          .attr("y", "10");
      this._chartLayer.append("g")
        .attr("class", "y ResourceStatsAxis")
        .call(this._yAxis);
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },

    /**
     * The resize function resizes the d3 chart within the widget, taking into
     * account the overall size of the container div and the size of the right
     * hand table.  As part of the resizing, it needs to update the domains for
     * the x and y axes and resize the clipping rect. 
     */
    resize: function(){
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");

      // Calculate the width available for use by the d3 chart
      var totalWidth = parseInt(domStyle.getComputedStyle(this._resourceStatsChartWidgetContainer).width);
      var tableWidth = parseInt(domStyle.getComputedStyle(this._resourceStatsChartRightTable).width);
      this._width = totalWidth - tableWidth - 20;
      var chartWidth  = this._width  - this._chartMargins.left - this._chartMargins.right;
      var chartHeight = this._height - this._chartMargins.top  - this._chartMargins.bottom;
      if(chartWidth >= 0) {
        // Resize the chart
        this._xRange.range([0, chartWidth]);
        d3.select(this._chart.node().parentNode)
          .attr("width", this._width);
        
        // Redraw the x axis
        this._chart.call(this._xAxis.orient("bottom"))
          .selectAll("text")  
          .attr("y", "10");

        /* 
         * Redraw the y axis.  This is a little trickier because the we need to
         * resize the ticks and this is all tied into _yAxis function.  The only
         * way this appears to work is by removing the existing SVG element for
         * the y axis, defining a new _yAxis function and then adding a new SVG
         * element in.
         * 
         */
        this._chart.select(".y.ResourceStatsAxis").remove();
        this._yAxis = d3.svg.axis().scale(this._yRange)
          .orient("left")
          .ticks(5)
          .tickSize(-chartWidth)
          .tickSubdivide(true);
        this._chartLayer.append("g")
          .attr("class", "y ResourceStatsAxis")
          .call(this._yAxis);
        
        // Resize the clip area
        this._chart.select("#" + this.id + "_clip-rect")
          .attr("width", chartWidth)
          .attr("height", chartHeight);
        
        this.refresh();
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
    },

    /**
     * The refresh function refreshes the chart on the glass using the most
     * recent data available for the session.
     */
    refresh : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "refresh");

      /*
       * Make sure that we have a reference to the session data and then 
       * retrieve the resource statistics data for the current selected resource
       * type.
       */
      var startTime;
      var endTime;
      if (this._sessionData && Object.keys(this._sessionData).length > 0) {
        var resourceTypeData = this._sessionData[this._currentResourceType];
        if (resourceTypeData) {
          /*
           * Iterate over the set of the resource ids (data sets).  For each
           * data set we need to:
           * 
           *   1) Keep track of the maximum y value so that we can modify the
           *      extent of the y axis when we are done.
           *   2) Find the line for the current metric in the data set and
           *      modify it.  If no line can be found, add a new line to the
           *      chart.
           */
          var yMax = 0;
          var yDomainMax = 0;
          var metric = this._resourceMetricSelect.get("value");
          var lineData = {};
          array.forEach(this._currentResourceIds, lang.hitch(this, function(resourceId) {
            // Retrieve the data for the current data set
            var resourceData = resourceTypeData[resourceId];
            if (resourceData) {
              // Determine the extent of the y domain for the current data set
              var currentMax  = d3.max(resourceData, lang.hitch(this, function(d) {
                return this._getMetricValue(d, metric);
              }));
              if (currentMax > yMax) {
                yMax = currentMax;
              }
              var currentDomainMax = currentMax * 1.1; // Add on 10%
              if (currentDomainMax > 1) {
                currentDomainMax = Math.round(currentDomainMax);
              }
              if (currentDomainMax > yDomainMax) {
                yDomainMax = currentDomainMax;
              }

              /*
               * Generate the id of the line we need to search for and then 
               * attempt to select the line element in the chart and check
               * whether it is an empty node, i.e., it does not exist.
               */
              var lineId = this._getLineId(resourceId);
              var line = this._chart.select("#" + lineId);
              if (line.empty()) {
                /*
                 * There is no path element in the chart for the current metric
                 * in the current data set.  Add a path element to the chart
                 * based on the current resource data.
                 */
                var lineColor = this._getLineColor(resourceId);
                line = this._chart.append("path")
                  .attr("id", lineId)
                  .attr("class", "line")
                  .attr("clip-path", "url(#" + this.id + "_clip)")
                  .attr("d", this._line([])) // No data for the line at present
                  .attr("fill", lineColor)
                  .attr("stroke", lineColor);
                
                this.onLineCreated(resourceId, lineColor);
              }
              
              // Store the resource data to render
              lineData[lineId] = resourceData;
            }
          })); // FOREACH

          /*
           * Check to see if we are currently showing any data points on the
           * chart and, if we are, add in any new data points that are required
           * for the resource data.
           */
          var circle = this._chart.select("circle");
          if (!circle.empty()) {
            this._renderDataPoints();
          }

          // Animate the changes using a transition
          var t = this._chart.transition().duration(750).ease("linear");
          
          /*
           * The x axis represents time and is not affected by which resource
           * ids are selected.  Calculate the new extent of the x domain and
           * update the x axis.
           */
          endTime = this._getDomainEndTime();
          startTime = this._getDomainStartTime(endTime);
          this._xRange.domain([startTime, endTime]);
          t.select(".x.ResourceStatsAxis").call(this._xAxis)
            .selectAll("text")
            .attr("y", "10");
          
          // Now modify the y axis
          this._yRange.domain([0, yDomainMax]).nice();
          t.select(".y.ResourceStatsAxis").call(this._yAxis);

          /*
           * Update each of the lines on the chart.  We need to do this after
           * the y axis has been modified so that the lines are drawn to the 
           * correct scale.
           */
          Object.keys(lineData).forEach(lang.hitch(this, function(lineId) {
            t.select("#" + lineId)
              .attr("d", this._line(lineData[lineId]))
              .attr("transform", "translate(" + this._xRange(startTime) + ")");
            
            /*
             * Check to see if there are any circles drawn for the data points
             * on the current line and, if there are, transform these as part
             * of the same transition.
             */
            t.selectAll("circle[id^='" + lineId + "']")
              .attr("cx", lang.hitch(this, function(d) {
                return this._xRange(d.date);
              }))
              .attr("cy", lang.hitch(this, function(d) {
                return this._yRange(this._getMetricValue(d, this._resourceMetricSelect.get("value")));
              }))
              .attr("transform", "translate(" + this._xRange(startTime) + ")");
          })); // FOR
          
          /*
           * If we are only displaying a single data set, update the latest, 
           * max, avg and min values.  For the min and average values, strip off
           * the dummy element at the start of the data set.
           */
          if (this._currentResourceIds.length == 1) {
              var resourceData = resourceTypeData[this._currentResourceIds[0]];
              var slicedData = resourceData.slice(1);
              var min  = d3.min(slicedData, lang.hitch(this, function(d) {
                return this._getMetricValue(d, metric);
              })); 
              var mean = d3.mean(slicedData, lang.hitch(this, function(d) {
                return this._getMetricValue(d, metric);
              })); 
              this._latestValue.innerHTML = this._formatNumber(resourceData[resourceData.length - 1][metric]);
              this._highestValue.innerHTML = this._formatNumber(yMax);
              this._averageValue.innerHTML = this._formatNumber(mean);
              this._lowestValue.innerHTML = this._formatNumber(min);
          } else {
            /*
             * We are displaying more than one data set in the charge.  The
             * latest, max, avg and min values in the side table are meaningless
             * at this point, so set them to a suitable value.
             */
            this._latestValue.innerHTML = "-";
            this._highestValue.innerHTML = "-";
            this._averageValue.innerHTML = "-";
            this._lowestValue.innerHTML = "-";
          }
        } // IF - resourceTypeData
      } else { // IF - this._sessionData && ...
        /*
         * We have no reference to the session data, or the session data object
         * does not contain any data yet. Remove all of the existing lines and
         * points from the chart, if any.
         */
        this._chart.selectAll("path.line").remove();
        this._chart.selectAll("circle").remove();

        // Reset the axes
        endTime = this._getDomainEndTime();
        startTime = this._getDomainStartTime(endTime);
        this._xRange.domain([startTime, endTime]);
        this._chart.select(".x.ResourceStatsAxis").call(this._xAxis)
          .selectAll("text")
          .attr("y", "10");
        this._yRange.domain([0, 10]).nice();
        this._chart.select(".y.ResourceStatsAxis").call(this._yAxis);
      }
      
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "refresh");
    },

    /**
     * The _renderDataPoints function adds circle elements to the chart to
     * represent each of the pieces of snapshot data for the lines that are
     * being displayed.
     */
    _renderDataPoints: function() {
      /*
       * Make sure that we have a reference to the session data and then 
       * retrieve the resource statistics data for the current selected resource
       * type.
       */
      if (this._sessionData) {
        var resourceTypeData = this._sessionData[this._currentResourceType];
        if (resourceTypeData) {
          // Iterate over the set of the resource ids (data sets)
          array.forEach(this._currentResourceIds, lang.hitch(this, function(resourceId) {
            // Retrieve the data for the current data set
            var resourceData = resourceTypeData[resourceId];
            if (resourceData) {
              /*
               * Create a circle to represent each data point in the resource
               * data.  Add event handlers to the line to handle the mouse enter
               * and leave events.  These handlers will highlight the data point
               * that the mouse is over and show a tooltip displaying the value
               * the the data point represents. 
               */
              var idPrefix = this._getLineId(resourceId);
              var dataPoints = this._chart.selectAll("circle[id^='" + idPrefix + "']")
                .data(resourceData)
                .enter()
                .append("circle")
                  .attr("r", 3)
                  .attr("id", lang.hitch(this, function(d) {
                    return idPrefix + "_" + d.date;
                  }));
            
                dataPoints.attr("cx", lang.hitch(this, function(d) {
                  return this._xRange(d.date);
                }))                
                .attr("cy", lang.hitch(this, function(d) {
                  return this._yRange(this._getMetricValue(d, this._resourceMetricSelect.get("value")));
                }))
                .attr("fill", lang.hitch(this, function() {
                  return this._getLineColor(resourceId);
                }))
                .attr("stroke", lang.hitch(this, function() {
                  return this._getLineColor(resourceId);
                }))
                .on("mouseenter", lang.hitch(this, function(d) {
                  var id = idPrefix + "_" + d.date;
                  var value = this._getMetricValue(d, this._resourceMetricSelect.get("value"));
                  var formattedValue = this._formatNumber(value);
                  this._chart.select("#" + id).attr("r", 10);
                  var substitutionArgs = {dataSetName: d.name, dataSetValue: formattedValue};
                  Tooltip.show(string.substitute(this._dataPointTooltipTemplate, substitutionArgs), id);
                }))
                .on("mouseleave", lang.hitch(this, function(d) {
                  var id = idPrefix + "_" + d.date;
                  this._chart.select("#" + id).attr("r", 3);
                  Tooltip.hide(id);
                }));
            } // IF - resourceData
          })); // FOREACH
        } // IF - resourceTypeData
      } // IF - this._sessionData
    },

    /**
     * The _removeDataPoints function removes all of the circle elements that
     * are currently being displayed in the chart.
     */
    _removeDataPoints: function() {
      this._chart.selectAll("circle").remove();
    },
    
    /**
     * The getCurrentResourceType function returns the resource type that is
     * currently being displayed by the data grid. 
     *
     * @param resourceType
     *           A string that specifies the resource type.
     */
    getCurrentResourceType: function() {
      return this._currentResourceType;
    },
    
    /**
     * The setCurrentResourceType function sets the resource type that is
     * displayed by the data grid. 
     *
     * @return resourceType
     *           A string that specifies the resource type.
     */
    setCurrentResourceType: function(/* String */ resourceType) {

      /*
       * Make sure that the specified resource type is different to the current
       * resource type and that it maps to valid resource type, i.e., there are
       * resource metrics defined for it.
       */
      if (  this._currentResourceType != resourceType &&
         this._resourceTypeMetrics[resourceType]) {
        this._currentResourceType = resourceType;
        
        /*
         * Remove the options for the old resource type from the select widget
         * and replace them with options that correspond to the metrics for the
         * new resource type. 
         */  
        this._resourceMetricSelect.options = [];
        var options = this._resourceTypeMetrics[this._currentResourceType];
        this._resourceMetricSelect.addOption(this._sortOptions(options));
        if (options.length <= this._defaultMetricIndex) {
          this._defaultMetricIndex = 0;
        }
        this._resourceMetricSelect.set("value", options[this._defaultMetricIndex].value);
        this._resourceStatsChartTitle.innerHTML = this._getSelectedMetricLabel();
        
        // Remove all of the existing lines for the resource type metrics
        this._chart.selectAll("path.line").remove();
        this._chart.selectAll("circle").remove();
        this._lineColorMap = {};
        this._usedColorMap = {};
        
        this.refresh();
      }
    },

    /**
     * The setCurrentResourceIds function sets the ids of the resources that 
     * are currently selected in the data grid.
     *
     * @param resourceIds
     *           An array containing the names of the selected resources.
     */
    setCurrentResourceIds: function(/* Array */ resourceIds) {

      /*
       * Make sure that we have been passed a valid array and that it contains
       * at least one item.
       */
      if (resourceIds && resourceIds.length > 0) {
        
        /*
         * Now work out whether any resource ids have been removed from the
         * list.  If any resource ids have been removed from the list we need
         * to remove the corresponding line from the graph.
         */
        var removedIds = [];
        array.forEach(this._currentResourceIds, lang.hitch(this, function(resourceId) {
          if (resourceIds.indexOf(resourceId) == -1) {
            removedIds.push(resourceId);
          }
        }));
        if (removedIds.length > 0) {
          array.forEach(removedIds, lang.hitch(this, function(resourceId) {
            var lineId = this._getLineId(resourceId);
            var line = this._chart.select("#" + lineId);
            if (!line.empty()) {
              line.remove();
              delete this._usedColorMap[this._lineColorMap[resourceId]];
              delete this._lineColorMap[resourceId];
            }
            this._chart.selectAll("circle[id^='" + lineId + "']").remove();
          }));
        }

        // Store the new set of resource ids and update the chart
        this._currentResourceIds = resourceIds;
        this.refresh();
      }
    },

    /**
     * The setSessionData function passes a reference to the resource statistics
     * data for the current session.  This widget stores the reference so that
     * it as easy access whenever it needs to refresh.
     *
     * @param sessionData
     *           The resource statistics data for the current session.
     */
    setSessionData: function(/* Object */ sessionData, /* Date */ startTime) {
      this._sessionData = sessionData;
      this._sessionStartTime = startTime;
      this.refresh();
    },
    
    /**
     * The setChartTimeRange function sets the time span over which the chart
     * should display statistics.  The number of seconds specified is how long
     * into the past the graph should display statistics.  The overall time
     * range will be:
     * 
     *   now - numberOfSeconds    
     *
     * @param numberOfSeconds
     *          The number of seconds in the past to display statistics for. 
     */
    setChartTimeRange: function(/* Number */ numberOfSeconds) {

      /*
       * Update the number of seconds attribute in the widget and then refresh
       * the chart.
       */
      this._numberOfSeconds = numberOfSeconds;
      this.refresh();
    },

    /**
     * The setDefaultMetricIndex function sets the index of the metric that will
     * be selected by default whenever the resource type changes. 
     * 
     * @param index
     *          The index of the default metric. 
     */
    setDefaultMetricIndex: function(/* Number */ index) {
      
      /*
       * Make sure that the specified index is different to the index and that
       * it is valid.
       */
      var options = this._resourceTypeMetrics[this._currentResourceType];
      if (options && options.length > index) {
        this._defaultMetricIndex = index;
        this._resourceMetricSelect.set("value", options[this._defaultMetricIndex].value);
        this._resourceStatsChartTitle.innerHTML = this._getSelectedMetricLabel();
      }
    },

    /**
     * The setLineHighlight function modifies the style of the line for the
     * specified resource based on the value of the highlight flag passed in.
     * A value of true will highlight the line.  A value of false will remove
     * the highlight. 
     * 
     * @param resourceId
     *          The name of the resource whose corresponding line should be
     *          modified.
     * @param highlight
     *          A flag to indicate whether the line should be highlighted.  True
     *          to add a highlight, false to remove the highlight.
     */
    setLineHighlight: function(/* String */ resourceId, /* boolean */ highlight) {
      // Generate the id of the line we need to search for
      var lineId = this._getLineId(resourceId);
      var line = this._chart.select("#" + lineId);
      if (!line.empty()) {
        line.classed("hover", highlight);        
      }
    },
    
    /**
     * The onLineCreated function is a callback that can be used by other
     * widgets in order to be notified when the a line has been added to the
     * chart. 
     *
     * @param resourceId
     *           The name of the resource that the line represents.
     * @param color
     *           The color of the line.
     */
    onLineCreated: function() {
    },
    
    /**
     * The _getDomainStartTime function calculates the start time that should
     * be used when defining the domain of the x axis.  If the "time range" is
     * set to session this will be the session start time.  If "time range" is
     * set to a specific time period, e.g., 5 minutes, the value returned is
     * the time of the last update in the data set minus the number of seconds
     * for that time period.
     * 
     * @param endTime
     *          The time of the last update in the data set.
     *          
     * @return startTime
     *           The start time to be used when rendering the x axis... format
     *           is the number of millis since epoch.
     */
    _getDomainStartTime: function(endTime) {
      var startTime = this._sessionStartTime;
      if (this._numberOfSeconds > 0) {
        startTime = endTime - (this._numberOfSeconds * 1000);
      }
      
      return startTime;
    },

    /**
     * The _getDomainEndTime function calculates the end time that should
     * be used when defining the domain of the x axis.  Typically, the value
     * returned is the time of the last update in the data set.  It defaults
     * to the session start time if the data set is empty or the relevant entry
     * cannot be found.
     *          
     * @return endTime
     *           The end time to be used when rendering the x axis... format
     *           is the number of millis since epoch.
     */
    _getDomainEndTime: function() {
      var endTime = this._sessionStartTime;
      if (this._sessionData) {
        var resourceTypeData = this._sessionData[this._currentResourceType];
        if (resourceTypeData) {
          /*
           *  There should always be at least one resource id in the 
           *  _currentResourceIds array
           */ 
          var resourceData = resourceTypeData[this._currentResourceIds[0]];
          if (resourceData) {
            if (resourceData.length > 0) {
              var item = resourceData[resourceData.length - 1];
              endTime = item.date;
            }
          } // IF - resourceData
        } // IF - resourceTypeData
      } // IF - this._sessionData
      
      return endTime;
    },

    /**
     * The _sortOptions function sorts the array of options for the current 
     * resource type based on the current locale of the browser. 
     */
    _sortOptions: function(/* Array */ options) {
      var optionsCopy = lang.clone(options);
      optionsCopy.sort(function(option1, option2) {
        return option1.label.localeCompare(option2.label);
      });
      return optionsCopy;
    },

    /**
     * The _getSelectedMetricLabel function returns the label (as opposed to
     * value) of the currently selected metric in the dijit select widget. 
     */
    _getSelectedMetricLabel: function() {
      // Create the variable to return
      var label = null;
      var options = this._resourceTypeMetrics[this._currentResourceType];
      var selectedMetric = this._resourceMetricSelect.get("value");
      for (var i = 0; i < options.length; i++) {
        if (selectedMetric == options[i].value) {
          label = options[i].label;
          break;
        }
      } // FOR
      
      return label;
    },

    /**
     * The _formatNumber function formats numbers (statistics) for display in
     * the side table.
     */
    _formatNumber: function(n){
      return number.format(n, {places: 1});
    },
    
    /**
     * The _getMetricValue function retrieves the value of the specified metric
     * from the item.  If the value is not a valid number it returns 0. 
     */
    _getMetricValue: function(item, metric) {
      // Create the variable to return
      var value = 0;
      
      if (item[metric] && !isNaN(item[metric])) {
        value = item[metric];
      }
      
      return parseFloat(value);
    },
    
    /**
     * The _getLineId function generates the id of the line for a given resource
     * id. The lines on the chart are uniquely identified using the id 
     * attribute.  To ensure id is unique within the page it is constructed as
     * follows:
     * 
     *   widgetId + resourceId + metric
     * 
     * We also need to:
     * 
     *   1) Replace any spaces, colons, square brackets and forward slashes with
     *      underscores in the final id since these are either not allowed in 
     *      ids in HTML elements or cause problems when attempting to use them
     *      in a selector.
     *   2) Replace any periods (.) with underscores, since these are
     *      used to prefix class names in CSS selectors.
     */
    _getLineId: function(resourceId) {
      // Create the variable to return
      var lineId = this.id + "_" + resourceId + "_" + this._resourceMetricSelect.get("value");
      lineId = lineId.replace(/[ \.\[\]:\/]/g, "_");
      return lineId;
    },
    
    /**
     * The _getLineColor function returns the next available color to be used
     * when creating a new line. 
     * 
     * @param resourceId
     *          The id of the resource that we need the line color for.
     */
    _getLineColor: function(resourceId) {
      // Create the variable to return
      var lineColor = this._lineColorMap[resourceId];
      
      if (!lineColor) {
        /*
         * Iterate over the array of colors in the scale to find the first one
         * that is not currently in use.
         */
        for (var i = 0; i < this._colorScale.length; i++) {
          if (!this._usedColorMap[this._colorScale[i]]) {
            lineColor = this._colorScale[i];
            this._lineColorMap[resourceId] = lineColor;
            this._usedColorMap[lineColor] = true;
            break;
          }
        } // FOR
      } // IF - !lineColor
      
      return lineColor;
    }
  });// end declare
});// end define

},
'webui/widgets/my_profile/MyProfile_Properties':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="3269170272" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */

define([
  "dojo/text!webui/widgets/my_profile/templates/MyProfile_Properties.html",
	"dojo/i18n!webui/nls/web",
	"dojo/_base/declare", 
	"dojo/_base/fx",
	"dojo/_base/lang",
	"dojo/dom-attr",
	"dojo/dom-class",
	"dojo/dom-construct",
  "dojo/fx",
	"dojo/hash",
	"dojo/on",
	"dijit/_TemplatedMixin",
	"dijit/_WidgetBase",
  "dijit/_WidgetsInTemplateMixin",
  "webui/utils/WebUiHash",
  "webui/widgets/common/AttributesStore",
	"webui/widgets/common/Toolbar",
	"webui/widgets/common/Trace"
], function(
  template,
  NLS,
  declare,
  baseFx,
  lang,
  domAttr,
  domClass,
  domConstruct,
  coreFx,
  hash,
  on,
  _TemplatedMixin,
  _WidgetBase,
  _WidgetsInTemplateMixin,
  WebUiHash,
  AttributesStore,
  Toolbar,
  Trace
) {
  var profile = declare("webui.widgets.my_profile.MyProfile_Properties", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
    templateString: template,
    
    toolTipMouseEvent: null,
    toolbar: null,
    _attributesStore : new AttributesStore(),
    
    postCreate: function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			this.inherited(arguments);	

			// Create the toolbar
			this.toolbar = new Toolbar();
			domConstruct.place(this.toolbar.domNode, this._toolbar);
			this.toolbar.addLeftAlignButtons("title");
			var buttons = ["cancel","save"];
			this.toolbar.addRightAlignButtons(buttons);
			this.toolbar.setButtonState("disable", buttons);
			this.toolbar.connectButtons("save", "click", this, "saveContent");
			this.toolbar.connectButtons("cancel", "click", this, "cancelUpdate");

			// Catch mouse events
			on(this._profilePropertiesInfoPane, "keydown", lang.hitch(this, this.activateButtons) );
			on(this._profile_property_password_confirm, "keydown", lang.hitch(this, this.checkPasswordMatch) );
			on(this._profilePropertiesChangePasswordLink, "click", lang.hitch(this, this.revealPasswordFields) );
			
			//Insert NLS strings
			domAttr.set(this._profilePropertiesUsernameTitle, "innerHTML", NLS.profilePropertiesUsernameTitle);
			domAttr.set(this._profilePropertiesRoleTitle, "innerHTML", NLS.profilePropertiesRoleTitle);
			domAttr.set(this._profilePropertiesUsernameText, "innerHTML", NLS.profilePropertiesUsernameText);
			domAttr.set(this._profilePropertiesPasswordTitle, "innerHTML", NLS.profilePropertiesPasswordTitle);
			domAttr.set(this._profilePropertiesPasswordText, "innerHTML", NLS.profilePropertiesPasswordText);
			domAttr.set(this._profilePropertiesCurrentPasswordText, "innerHTML", NLS.profilePropertiesCurrentPasswordText);
			domAttr.set(this._profilePropertiesNewPasswordText, "innerHTML", NLS.profilePropertiesNewPasswordText);
			domAttr.set(this._profilePropertiesConfirmPasswordText, "innerHTML", NLS.profilePropertiesConfirmPasswordText);
			domAttr.set(this._profilePropertiesChangePasswordLinkText, "innerHTML", NLS.profileTabChange);
			
	 		Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},
		
    startup: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "startup");
      this.inherited(arguments);

      this.getUserValues(); 
      this.checkShowPasswordChangeBox();
      
      if (window.brokerProperties.getProperty("basic", "AdminSecurity") === "inactive") {
        domClass.add(this._profilePropertiesPassword,"_common_hideDiv");
        this.toolbar.setAttribute("cancel","class","_common_hideDiv");
        this.toolbar.setAttribute("save","class","_common_hideDiv");			
      }
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "startup"); 
    },
    
		
		resize: function() {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize"); 
		  this._profile_borderContainer.resize();
		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize"); 
		},
		
		activateButtons : function(event) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "activateButtons");

			setTimeout(lang.hitch(this, function() { 
			  if(event.target.type=="password"){
			   	
			    //Only activate the save button if the 'New Password' and 'Confirm Password' fields are the same.
				  var currentPwd = this._profile_property_password_current.displayedValue;
					var newPwd = this._profile_property_password_new.displayedValue;
					var confirmPwd = this._profile_property_password_confirm.displayedValue;
					if((currentPwd!="")&&(newPwd!="")&&(confirmPwd!="")&&(newPwd == confirmPwd)){
					  this.activateSave();
					} else {
					  this.deactivateSave();
					}
				} else {
				  this.activateCancel();
				  this.activateSave();
				}
			}), 100);
			
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "activateButtons");
		},
		
		activateSave : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "activateSave");
			this.toolbar.setButtonState("enable", "save");
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "activateSave");
		},
		
		deactivateSave : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "deactivateSave");
			this.toolbar.setButtonState("disable", "save");
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "deactivateSave");
		},
		
		activateCancel : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "activateCancel");
			this.toolbar.setButtonState("enable", "cancel");
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "activateCancel");
		},
		
		deactivateCancel : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "activateCancel");
			this.toolbar.setButtonState("disable", "cancel");
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "activateCancel");
		},
		
		saveContent : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "saveContent");
			
			this._attributesStore.updateAttributeValue("oldPassword",this._profile_property_password_current.displayedValue);
			this._attributesStore.updateAttributeValue("password",this._profile_property_password_new.displayedValue);
			var status = this._attributesStore.saveAttributeUpdates();
			
			status.then(lang.hitch(this,function(){			
				window.smallMessage.displayMessage("success", "Password_200");
				
				// Return the form to its initial state and reload the data.
				this.hidePasswordFields();
				this.deactivateSave();
				this.deactivateCancel();
				this.startup();
				this.getUserValues();
				domAttr.set(this._profile_property_password_current, "displayedValue", "");
				domAttr.set(this._profile_property_password_new, "displayedValue", "");
				domAttr.set(this._profile_property_password_confirm, "displayedValue", "");
				domAttr.set(this._profilePasswordIcon, "style", "display:none");

			}),lang.hitch(this,function(){				
				window.smallMessage.displayMessage("error", "Password_5XX");
			}));
			
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "saveContent");
		},
		
		cancelUpdate : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "cancelUpdate");
				
			this.getUserValues();
			domAttr.set(this._profile_property_password_current, "displayedValue", "");
			domAttr.set(this._profile_property_password_new, "displayedValue", "");
			domAttr.set(this._profile_property_password_confirm, "displayedValue", "");
			domAttr.set(this._profilePasswordIcon, "style", "display:none");

			this.hidePasswordFields();
			this.deactivateSave();
			this.deactivateCancel();

			Trace.trace(this.declaredClass, Trace.levels.EXIT, "cancelUpdate");
		},
		
		getUserValues : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "getUserValues");
			
			var user = new WebUiHash(hash()).getUserName();
			var populate = this._attributesStore.populateAttributesStore(new WebUiHash(hash()).getRestUri().toString());
      if(user === window.currentuser.property_userID){
      	// So we've clicked on the user we have logged in as, but via the tree. 
      	// Load current user details, so we can change our own password!
        populate = this._attributesStore.populateAttributesStore("/apiv1/security/currentuser");
      }
			 
			populate.then(lang.hitch(this,function(){
				// Retrieve content that has not been retrieved by the 'currentuser' widget.
				this.toolbar.setAttribute("title","innerHTML",this._attributesStore.getAttribute("name"));
				domAttr.set(this._profile_property_userID_value, "innerHTML", this._attributesStore.getAttribute("username"));
				domAttr.set(this._profile_property_role_value, "innerHTML", this._attributesStore.getAttribute("role"));
			}));
				
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "getUserValues");
		},
		
		checkShowPasswordChangeBox : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "checkShowPasswordChangeBox");
			var user = new WebUiHash(hash()).getUserName();
			if(new WebUiHash(hash()).getType() === "currentUser" || user === window.currentuser.property_userID){
			  domClass.remove(this._profilePropertiesPassword,"_common_hideDiv");
        this.toolbar.setAttribute("cancel","class","");
        this.toolbar.setAttribute("save","class","");
      } else {
        domClass.add(this._profilePropertiesPassword,"_common_hideDiv");
        this.toolbar.setAttribute("cancel","class","_common_hideDiv");
        this.toolbar.setAttribute("save","class","_common_hideDiv");
      }
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "checkShowPasswordChangeBox");
		},
		
		checkPasswordMatch : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "checkPasswordMatch");
				
			setTimeout(lang.hitch(this, function() { 
			    var newstr = this._profile_property_password_new.displayedValue.substr(0,this._profile_property_password_confirm.displayedValue.length);
			    if(this._profile_property_password_confirm.displayedValue != newstr) {
					domAttr.set(this._profilePasswordIcon, "style", "display:inline-block;");
					domAttr.set(this._profilePropertiesConfirmPassword, "class", "idxSignIcon idxErrorIcon");
				} else {
					domAttr.set(this._profilePasswordIcon, "style", "display:none");
				}
				
				if((this._profile_property_password_new.displayedValue.length > 0) && 
						(this._profile_property_password_new.displayedValue == this._profile_property_password_confirm.displayedValue)){
					domAttr.set(this._profilePasswordIcon, "style", "display:inline-block;");
					domAttr.set(this._profilePropertiesConfirmPassword, "class", "idxSignIcon _common_idxSuccessIcon");
				}
			}), 100);

			Trace.trace(this.declaredClass, Trace.levels.EXIT, "checkPasswordMatch");
		},
		
		revealPasswordFields : function() {
		    Trace.trace(this.declaredClass, Trace.levels.ENTRY, "revealPasswordFields");

			coreFx.chain([	
				baseFx.fadeOut({
					node: "_profilePropertiesChangePasswordLink_ID", 
					duration: 300,
					onEnd: lang.hitch(this, function() {
						domClass.add("_profilePropertiesChangePasswordLink_ID","_common_hideDiv");
						this.activateCancel();
						//domClass.remove("_profilePropertiesChangePasswordFields_ID","_common_hideDiv");
					}) 
				}),
				coreFx.wipeIn({
					node: "_profilePropertiesChangePasswordFields_ID"
				})
			]).play();
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "revealPasswordFields");
		},
		
		hidePasswordFields : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "hidePasswordFields");
			coreFx.chain([	
				coreFx.wipeOut({
					node: "_profilePropertiesChangePasswordFields_ID"
				}),
				baseFx.fadeIn({
					node: "_profilePropertiesChangePasswordLink_ID", 
					duration: 300,
					beforeBegin: lang.hitch(this, function() {
						domClass.remove("_profilePropertiesChangePasswordLink_ID","_common_hideDiv");
				   })
				})
			]).play();

            Trace.trace(this.declaredClass, Trace.levels.EXIT, "hidePasswordFields");			
		},
		
		tabRemove: function () {
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove"); 

		    Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
		},
        
        tabFocus: function () {
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus"); 
            this.getUserValues(); 
            this.checkShowPasswordChangeBox();
            Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
        },
        
        tabBlur: function () {
            Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur"); 

            Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
        }
		
	});
	return profile;
});

},
'webui/widgets/broker/FilteringOptionsDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="763384209" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/broker/templates/FilteringOptionsDialog.html",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/declare",
  "dojo/_base/event",  
  "dojo/_base/lang",
  "dijit/Dialog",
  "dojo/dom-attr",
  "dojo/keys",
  "dojo/on",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetsInTemplateMixin",
  "webui/widgets/common/Trace"
], function(
  template,
  NLS,
  declare,
  event,
  lang,
  Dialog,
  domAttr,
  keys,
  on,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  Trace
) {
	var filterOptionsDialog = declare("webui.widgets.broker.FilteringOptionsDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
		templateString : template,

		_btAllResourcesLabel: NLS.filterOptions_showAllResources ,
		_btOnlyFlowsLabel: NLS.filterOptions_showOnlyFlows ,
		_btShowIBMLabel: NLS.filterOptions_config_services_showIBMTemplates,
		_ResourcesTitlePaneLabel : NLS.filterOptions_DeployedResourcesTitlePaneLabel,
		_ConfigurableServicesTitlePaneLabel : NLS.filterOptions_ConfigurableServicesTitlePaneLabel,
		_filterResources : null,
		_filterConfigServices : null,
	  
		//need to pass in this info because we need to pass it along to the callback method for an ajax call.
		constructor: function(args){
		  if(args != null) {
		    this._callback             = args.cback;
		    this._filterResources      = args.filterResources;
		    this._filterConfigServices = args.filterConfigServices;
		  }
		},

		_onKey : function(evt) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onKey");
			this.inherited(arguments);
			if (evt.charOrCode) {
				if (evt.charOrCode === keys.ENTER) {
					if ( !this._okButton.get("disabled" ) ) {
						event.stop(evt);
						this.onExecute();
					}
				}
			}
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onKey");
		},

		postCreate : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			this.inherited(arguments);

			domAttr.set(this.titleNode, "innerHTML", NLS.filterOptions_Dialog_Title );
			this.titleNode.setAttribute("tabIndex", -1);
			domAttr.set(this.instructionNode, "innerHTML", NLS.filterOptions_Dialog_Msg );
			this.instructionNode.setAttribute("tabIndex", -1);
			
			domAttr.set(this._okButton, "label", NLS.okButtonLabel);
			domAttr.set(this._cancelButton, "label", NLS.cancelButtonLabel);

			if (this._filterResources === undefined) {
				this._allResourcesRadioButton.set("checked",true);
				this._onlyFlowsRadioButton.set("checked",false);
			}//if
			else if (this._filterResources === "all") {
				this._allResourcesRadioButton.set("checked",true);
				this._onlyFlowsRadioButton.set("checked",false);
			}//if
			else if (this._filterResources === "flows") {
				this._allResourcesRadioButton.set("checked",false);
				this._onlyFlowsRadioButton.set("checked",true);
			}//if
			
			
			if (this._filterConfigServices === undefined) {
				this._showIBMCheckBox.set("checked",true);
			}
			if (this._filterConfigServices === "ibm") {
			  this._showIBMCheckBox.set("checked",true);
			} else if (this._filterConfigServices === "!ibm") {
				this._showIBMCheckBox.set("checked",false);
			}
			
			//this._okButton.set("disabled", true);
			this._okButton.set("disabled", false);
			this.instructionDiv.style.color = "black";

			on(this, "execute", lang.hitch(this, function() {
				
				if (this._allResourcesRadioButton.checked) {
					this._filterResources = "all";
				} else if (this._onlyFlowsRadioButton.checked) {
					this._filterResources = "flows";
				}
					
				if (this._showIBMCheckBox.checked) {
					this._filterConfigServices = "ibm";
				} else {
					this._filterConfigServices = "!ibm";
				}
				
				this._callback(this._filterResources,this._filterConfigServices);
				this.hide();
			}));
			on(this._cancelButton, "click", lang.hitch(this, function() {
				this.hide();
			}));

			Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},

		show : function() {
		  Trace.trace(this.declaredClass, Trace.levels.ENTRY, "show");	
		  this.inherited(arguments);

		  Trace.trace(this.declaredClass, Trace.levels.EXIT, "show");
		},
	    
/**          
		// This gets called every time the content of the name box changes, i.e.
		// whenever a keystroke is pressed
		optionsChanged : function() {
			
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "nameChanged");
			
            if (!this._beginNameValidation){
            	this._beginNameValidation = true;
            	return;
            }	
		    
			var value = this._nameText.get("value");
			domAttr.set(this.instructionNode, "innerHTML", NLS.nameExecutionGroupNameMsg );
			this.instructionDiv.style.color = "black";

			if (value == "") {

					this._okButton.set("disabled", true);
					//Only set the error message when the dialog is not displayed for the first time
					domAttr.set(this.instructionNode, "innerHTML", NLS.executionGroupNameEmptyErrorMsg );
					this.instructionDiv.style.color = "red";

			} else {
				var inUse = false;

				array.forEach(this._namesInUse, function(item, i) {
					if (value == item) {
						inUse = true;
					}
				});
				this._okButton.set("disabled", inUse);
				if (inUse) 
				{
						
					//Only set the error message when the dialog is not displayed for the first time
						domAttr.set(this.instructionNode, "innerHTML", NLS.executionGroupNameDuplicateErrorMsg );
						this.instructionDiv.style.color = "red";
						
				} else {
					
					
					if ( !this.executionGroupNameCharactersValid( value ) ) {
					    domAttr.set(this.instructionNode, "innerHTML", NLS.executionGroupNameInvalidErrorMsg );
						this.instructionDiv.style.color = "red";
						this._okButton.set("disabled", true);
					}//if
				}
			}
			

			Trace.trace(this.declaredClass, Trace.levels.EXIT, "nameChanged");
		}
**/
          
	});
	return filterOptionsDialog;
});

},
'webui/widgets/broker/BrokerPropertiesEditor':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2014,2016" 
 * crc="974185540" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.  
 * </copyright> 
 */

/*
 * This widget represents a properties editor for integration node level properties.
 *
 * The widget has:
 * - A Save and Cancel button at the top right.
 * - A property table widget that allows the user to change the values.
 *
 * Most of the widget is internal (private). The only public method provided is the isDirty
 * method.
 */
define(
  "webui/widgets/broker/BrokerPropertiesEditor",
  [
    "dojo/text!webui/widgets/broker/templates/BrokerPropertiesEditor.html",
    "dojo/i18n!webui/nls/web",
    "dojo/_base/declare",
    "dijit/_WidgetBase",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "dijit/registry",
    "webui/widgets/common/Trace",
    "dojo/dom",
    "dojo/dom-construct",
    "dojo/store/Memory",
    "dojo/_base/lang",
    "dojo/request/xhr",
    "webui/config/Resources",
    "webui/utils/RestUri",
    "webui/widgets/common/AttributesStore",
    "webui/widgets/common/EditTextPropertyValueDialog",
    "webui/widgets/common/EditBooleanPropertyValueDialog",
    "webui/widgets/common/EditNumericPropertyValueDialog",
    "webui/widgets/common/Toolbar",
    "dojo/dom-attr",
    "dojo/topic",
    "dojo/query",
    "dojox/html/entities",
    "webui/widgets/common/UIUtils",

    // Grid X
    "gridx/Grid",
    "gridx/core/model/cache/Sync",
    "gridx/modules/select/Row",
    "gridx/modules/ColumnResizer",
    "gridx/modules/CellWidget",
    "gridx/modules/Edit"
  ],
  function(
    template,
    NLS,
    declare,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    registry,
    Trace,
    dom,
    construct,
    Memory,
    lang,
    xhr,
    Resources,
    RestUri,
    AttributesStore,
    EditTextPropertyValueDialog,
    EditBooleanPropertyValueDialog,
    EditNumericPropertyValueDialog,
    Toolbar,
    attr,
    topic,
    query,
    HTMLEntities,
    UIUtils,

    // GridX
    Grid,
    Cache,
    SelectRow,
    ColumnResizer,
    CellWidget,
    Edit
  ) {
    var brokerPropertyEditor = declare("webui.widgets.broker.BrokerPropertiesEditor", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {
      templateString: template, // points js to the html template to use
      _brokerNameLabel: NLS.nameLabel,
      _brokerTypeLabel: NLS.typeLabel,
      _attributesStore : new AttributesStore(),
      _propertiesUri : new RestUri(Resources.REST.root).getPropertiesUri().toString(), // "/apiv1/properties"


      /**
       * Constructor
       */
      constructor: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "constructor");
        this.inherited(arguments);
      	if (arguments.length > 0) {
      	  this._name = arguments[0].name;
      	}
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "constructor");
      },


      postCreate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");

        // Call postCreate on _TemplatedMixin:
        this.inherited(arguments);

        this.propertyData = [];

        // Create the toolbar at the top of the UI:
        this.toolbar = new Toolbar();
        construct.place(this.toolbar.domNode, this._toolbar);
        this.toolbar.addLeftAlignButtons("title");

        // Add Save and Cancel button to the right side of the toolbar:
        var buttons = ["save", "cancel"];
        this.toolbar.addRightAlignButtons(buttons);
      	this.toolbar.addRightAlignButtons("spacer");
      	this.toolbar.getButton("save").set("disabled", true);
        this.toolbar.getButton("cancel").set("disabled", false);

        this._createPropertiesTable();

        // Add button event handlers:
        this.toolbar.connectButtons("save", "click", this, "_onSaveClick");
        this.toolbar.connectButtons("cancel", "click", this, "_onCancelClick");

      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
     },

     
     _propertyDisplayName: function(name){
       return NLS.broker[name] || name;
     },


     _createPropertiesTable: function() {
    	 Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_createPropertiesTable");

    	 // Define the properties table structure
       var propertiesTableStructure = [
         { id: 'id', field: 'displayName', name: NLS.nameLabel, width: '30%', editable: false},
         { id: 'value', field: 'value', name: NLS.valueLabel, width: '60%', editable: true,
           decorator: function(cellData) {
            // Encode value before showing it in the table to prevent code injection:
            return HTMLEntities.encode(cellData);
          }
         },
         { id: 'valueDialog', field: 'edit', name: '', width: '10%', widgetsInCell: true,
           decorator: function() {
             // Embed a button in the value column (label for screen reader also provided so more information can be provided other than just '...'):
             return "<div data-dojo-type='dijit.form.Button' type='button' data-dojo-attach-point='brokerEditValueButton' aria-label='" + NLS.editValueDialogButtonText + "'>...</div>";
           },
           getCellWidgetConnects: function(cellWidget, cell) {
             // Add a handler for when the embedded button is pressed:
             return [[
               cellWidget.brokerEditValueButton,
         		   'onClick',
         		   function() {
                 var confirmCallback = lang.hitch(this, function() {
                   var propertyValue = editPropertyValueDialog.editPropertyValueArea.get("value");
                   
                   var propertyType = editPropertyValueDialog._dialogType();
                   if (propertyType === "boolean") {
                     if (propertyValue === "on") {
                       propertyValue = "true";
                     }
                     else if (propertyValue === "off"){
                       propertyValue = "false";
                     }
                   }
                   
                   // Set value from dialog into the table (need to begin and apply edit so an onApply event is fired):
                   editPropertyValueDialog.cell.beginEdit();
                   editPropertyValueDialog.cell.setRawData(propertyValue.toString()); // call toString() as property value could be a number
                   editPropertyValueDialog.cell.applyEdit();
                 });

                 var editPropertyValueDialog = registry.byId("editPropertyValueDialog");
                 // Clear any old dialog in case we need one of a different type
                 if (editPropertyValueDialog) {
                   editPropertyValueDialog.destroy();
                   editPropertyValueDialog = null;
                 }

                 var nameCell = cell.grid.cell(cell.row.id, "id");
                 var propName = nameCell.rawData();
                 var propertyType = cell.grid.model.store.get(propName).type;

                 if (propertyType === 'text') {
                   if (!editPropertyValueDialog) {
                     editPropertyValueDialog = new EditTextPropertyValueDialog({
                       id : "editPropertyValueDialog",
                       createCallback : confirmCallback
                     });
                     editPropertyValueDialog.startup();
                   }
                 } else if (propertyType === 'boolean') {
                   if (!editPropertyValueDialog) {
                     editPropertyValueDialog = new EditBooleanPropertyValueDialog({
                       id : "editPropertyValueDialog",
                       createCallback : confirmCallback
                     });
                     editPropertyValueDialog.startup();
                   }
                 } else if (propertyType === 'numeric') {
                   if (!editPropertyValueDialog) {
                     editPropertyValueDialog = new EditNumericPropertyValueDialog({
                       id : "editPropertyValueDialog",
                       createCallback : confirmCallback
                     });
                     editPropertyValueDialog.startup();
                   }
                 }

                 // Set appropriate values on the dialog and then open it:
                 attr.set(editPropertyValueDialog.titleNode, "innerHTML", NLS.editValueLabel);
                 var valueCell = cell.grid.cell(cell.row.id, "value");
                 editPropertyValueDialog.cell = valueCell; // pass in the value cell; needed above when setting the value in the table
                 editPropertyValueDialog.currentValue = valueCell.rawData(); // pass in the value text
                 editPropertyValueDialog.refresh();
                 editPropertyValueDialog.show();
               }
             ]];
           }
         }
       ];

       // Create the store for the properties table:
       var brokerPropertiesTableStore = new Memory({data: [], idProperty: "id"});

       // Create the property table widget:
       this._propertiesTable = Grid({
         id: 'brokerPropertiesTable',
         cacheClass: Cache,
         store: brokerPropertiesTableStore,
         structure: propertiesTableStructure,
         autoHeight: true,
         modules: [
           SelectRow,
           CellWidget,
           Edit,
           ColumnResizer
         ],
         editLazySave: false // Needs to be set to false because using query on the store
       });

       // Put the property table widget into the DOM tree:
       this._propertiesTable.placeAt(this._brokerProperties);

       // Start up the property table widget:
       this._propertiesTable.startup();

       // Populate store and then initialize values when store is populated:
       var populate = this._attributesStore.populateAttributesStore();
       populate.then(lang.hitch(this, function() {
         // have to wait until to initialize until after the populate completes
         // as we will need the URI from the properties store:
         this._initialize();
       }));

       Trace.trace(this.declaredClass, Trace.levels.EXIT, "_createPropertiesTable");
     },


     // Called after the properties store is initialized:
     _initialize: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_initialize");

        // Flag to indicate that the user has made a change:
        this._hasUserMadeAChange = false;

        // Add a handler for when a property value is changed in the property table (it is
        // preferred to use the event handling of the grid control so using that here):
        this._getPropertiesTable().edit.connect(this._getPropertiesTable().edit, "onApply", lang.hitch(this, this._handlePropertyValueChanged));

        // Add a handler for when the selection changes in the property table (it is
        // preferred to use the event handling of the grid control so using that here):
        this._getPropertiesTable().select.row.connect(this._getPropertiesTable().select.row, "onSelected", lang.hitch(this, this._handleRowSelectionChanged));
        this._getPropertiesTable().select.row.connect(this._getPropertiesTable().select.row, "onDeselected", lang.hitch(this, this._handleRowSelectionChanged));

        // Populate the properties table with the properties of the Broker:
      	this._populateTableWithProperties();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_initialize");
      },


      _getType: function() {
      	return this._getTypeWidget().get("displayedValue");
      },


      _getTypeWidget: function() {
      	return this._brokerTypeName;
      },


      _getPropertiesTable: function() {
      	return this._propertiesTable;
      },

      resize: function() {
         Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");
         this._brokerEditor_borderContainer.resize();
         Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
      },


      // Called when the user clicks the Save button:
      _onSaveClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onSaveClick");

        this._saveProperties();

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onSaveClick");
      },


      // Called after the user clicks the Save button:
      _saveProperties: function() {

        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_saveProperties");

        var propertiesObject = {};
        var basicProperties = [];
        var advancedProperties = [];

        // Add the properties to the object:
        var numberOfRows = this._getPropertiesTable().rowCount();
        if (numberOfRows > 0) {
      	  for (var i = 0; i < numberOfRows; i++) {
      	  	var property = {};
      	  	property.name = this._getPropertiesTable().cell(i, 0).rawData();
          	property.value = this._getPropertiesTable().cell(i, 1).rawData();

          	//if (this._getPropertiesTable().cell(i, 1).isEditing()) {
          	var componentName = this._getPropertiesTable().model.store.get(property.name).component;
          	var internalName = this._getPropertiesTable().model.store.get(property.name).internalName;

          	if (componentName === "none") {
          	  if ((internalName === "shortDesc") || (internalName === "longDesc")) {
          	    basicProperties.push({
          	      "name"  : internalName,
          	      "value" : property.value
          	    });
          	  }
          	  else if (internalName === "operationMode") {
          	    advancedProperties.push({
          	      "name"  : internalName,
          	      "value" : property.value
          	    });
          	  }
          	} else {
          	  basicProperties.push({
          	    "name"  : internalName,
          	    "value" : property.value
          	  });
          	}

          	//this._getPropertiesTable().cell(i, 1).cancelEdit();
          	//}
      	  }
      	  propertiesObject.basicProperties = basicProperties;
      	  propertiesObject.advancedProperties = advancedProperties;
        }

        // Add loading icon to tree:
        var tree = registry.byId('_explorerTree_ID');
        var treeImgs = query('#' + tree.selectedNode.id + ' .dijitTreeIcon');
        var oldIcon = attr.get(treeImgs[0],"class");
        attr.set(treeImgs[0],"class","dijitInline dijitIcon dijitTreeIcon explorerTree_contextMenu_loading");

        window.smallMessage.displayPlainMessage("information", "PropertiesUpdate_SavingProperties");

        // Change the modified flag to false (as we are going to save the changes and we do not want isDirty() to return true):
        this._hasUserMadeAChange = false;

        // Disable the save and cancel buttons (to prevent the user from pressing them again while saving):
        this.toolbar.getButton("save").set("disabled", true);
        this.toolbar.getButton("cancel").set("disabled", true);

        // Call PUT to update the properties using the uri and object from above:
        xhr.put(
          this._propertiesUri,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json",
              "Content-type" : "application/json"
            },
            data : JSON.stringify(propertiesObject)
          }
        ).then(
          lang.hitch(this, function() {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Call to set properties was successful.");

            // Reset old icon (to remove loading icon):
            attr.set(treeImgs[0],"class",oldIcon);

            // Display a message that the creation was successful:
          	window.smallMessage.displayPlainMessage("success", "PropertiesUpdate_SaveSuccess");

            // Publish that the broker has been updated:
            topic.publish(Resources.pubSubTopic.brokerPropertiesUpdated, {"uri": this._propertiesUri});
          }),
          lang.hitch(this, function(error) {
            Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Text: " + error.response.text);

            // Reset old icon (to remove loading icon):
            attr.set(treeImgs[0],"class",oldIcon);

            // Display a message that the creation was unsuccessful:
            window.smallMessage.displayPlainMessage("error", "PropertiesUpdate_SaveError");

            // Re-enable the modify flag, and re-enable the save and cancel buttons (as the user may want to continue working in the editor):
            this.toolbar.getButton("save").set("disabled", false);
            this.toolbar.getButton("cancel").set("disabled", false);
          })
        );
        // end put

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_saveProperties");
      },


      // Called when the user clicks the Cancel button:
      _onCancelClick: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onCancelClick");

        // Publish that the editor has been cancelled:
        topic.publish(Resources.pubSubTopic.brokerPropertiesEditCancelled, {editor: this});

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onCancelClick");
      },

      // Populates the provided widget with the properties of the Broker:
      _populateTableWithProperties: function() {
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_populateTableWithProperties");

        // Set the text that will be read out by a screen reader for the '...' column header of the properties
      	// table. This has to be done or a screen reader will just read out that the column is read-only (or
      	// nothing will be said at all). The reason that this is being done here is so we can be sure that the
      	// brokerPropertiesTable-valueDialog DOM element is available:
      	var elementThatIsTheAriaLabelForTheValueDialogColumn = dom.byId("brokerPropertiesTable-valueDialog");
        if (elementThatIsTheAriaLabelForTheValueDialogColumn !== undefined) {
          attr.set(elementThatIsTheAriaLabelForTheValueDialogColumn, "aria-label", NLS.editValueDialogColumnHeaderText);
        }

      	// Get Broker level properties
        xhr.get(
          this._propertiesUri,
          {
            handleAs : "json",
            headers : {
              "Accept" : "application/json"
            }
          }
        ).then( lang.hitch(this, function(response) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Call to get the properties for broker: " + this._name + " was successful.");

          // Populate table with properties:
          var name;
          var i;
          var value;
          var displayName;
          if ( response !== undefined  ) {
            if (response.basicProperties !== undefined){
              for (i = 0; i < response.basicProperties.length; i++) {
                name = response.basicProperties[i].name;
                if ( (name === "shortDesc") || (name === "longDesc") ) {
                  value = response.basicProperties[i].value;
                  displayName = this._propertyDisplayName(name);
                  this.propertyData.push(
                    {
                      id: displayName,
                      internalName: name,
                      displayName: displayName,
                      type : "text",
                      value: value,
                      componentName: "none"
                    });
                }
              }
            }

            if (response.advancedProperties !== undefined){
              for (i = 0; i < response.advancedProperties.length; i++) {
                name = response.advancedProperties[i].name;
                if (name === "operationMode") {
                  value = response.advancedProperties[i].value;
                  displayName = this._propertyDisplayName(name);
                  this.propertyData.push(
                    {
                      id: displayName,
                      internalName: name,
                      displayName: displayName,
                      type : "text",
                      value: value,
                      componentName: "none"
                    });
                }
              }
            }

            if (response.componentProperties !== undefined){
              for (i = 0; i < response.componentProperties.length; i++) {
                name = response.componentProperties[i].name;
                value = response.componentProperties[i].value;
                var componentName = response.componentProperties[i].owner;
                var type = response.componentProperties[i].type;
                displayName = this._propertyDisplayName(name);
                this.propertyData.push(
			          {
                  id: displayName,
                  internalName: name,
                  displayName: displayName,
                  type : type,
                  value: value,
                  componentName: componentName
                });
              }
            }

            this._getPropertiesTable().select.row.clear(); // clear any selections first
            this._getPropertiesTable().model.clearLazyData(); // clear off any edits that may exist
            this._getPropertiesTable().model.clearCache();
            this._getPropertiesTable().model.store.setData(this.propertyData);
            this._getPropertiesTable().body.refresh();
          }

        }),
        lang.hitch(this, function(error) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Text: " + error.response.text);

          // Display a message that the properties could not be obtained:
          window.smallMessage.displayPlainMessage("error", "_errorGettingProperties");
        }));

        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_populateTableWithProperties");
      },
      
      // Called when the user changes the value of a property in the property table:
      _handlePropertyValueChanged: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handlePropertyValueChanged");
      
        // Set the change flag:
        if (!this._hasUserMadeAChange) {
      	  this._hasUserMadeAChange = true;
      	}
      	
      	// Validate:
      	this._validate();
      	
      	Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_handlePropertyValueChanged");
      },
      
      // Validates the widget. Called when the user makes a change to a property value in the UI.
      _validate: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_validate");
        
        // Ensure that the property values do not contain invalid characters:
        var numberOfRows = this._getPropertiesTable().rowCount();
        if (numberOfRows > 0) {
          for (var i = 0; i < numberOfRows; i++) {
            var propertyName = this._getPropertiesTable().cell(i, 0).rawData();
            var internalName = this._getPropertiesTable().model.store.get(propertyName).internalName;
            var propertyValue = this._getPropertiesTable().cell(i, 1).rawData();
            // Check if the property value is empty:
            if (propertyValue === null || propertyValue === undefined || propertyValue.trim() === '') {
              // nothing to do
            } else if (internalName === "portRange") { // Only check the 'Cache Manager - Port Range' property value
              // Check whether the property value contains any invalid characters:
              var invalidCharInPropertyValue = UIUtils.findFirstInvalidCharInProperty(propertyValue);
              if (invalidCharInPropertyValue !== null) {
                this.toolbar.getButton("save").set("disabled", true);
                window.smallMessage.displayPlainMessage("error", "propertyValueContainsInvalidCharacter", [propertyValue, invalidCharInPropertyValue]);
                return;
              }
            }
          }
        }
        
        // If we have gotten this far everything is good, so hide current message and enable the save button:
        window.smallMessage.hideMessage();
        this.toolbar.getButton("save").set("disabled", false);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "_validate");
      },
      
      // Returns true if the editor is dirty, false otherwise.
      isDirty: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "isDirty");
        // Check if the editor is dirty by checking the state of the save button or the change flag:
        var result = false;
        if (this.toolbar !== undefined && this.toolbar.getButton("save") !== undefined && !this.toolbar.getButton("save").get("disabled")) {
        	result = true;
        }
        else if (this._hasUserMadeAChange) {
        	result = true;
        }
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "isDirty");
        return result;
      },

      // Called by dojo when this widget is being destroyed:
      uninitialize: function() {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "uninitialize");
        // Destroy the property value edit dialog if it exists:
      	var editPropertyValueDialog = registry.byId("editPropertyValueDialog");
      	if (editPropertyValueDialog !== null && editPropertyValueDialog !== undefined) {
      		editPropertyValueDialog.destroy();
      	}
      	Trace.trace(this.declaredClass, Trace.levels.EXIT, "uninitialize");
      }

    });
    return brokerPropertyEditor;
  }
);

},
'webui/widgets/business/NewBusinessTransactionDialog':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2015,2016" 
 * crc="763384209" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.  
 * </copyright> 
 */
define([
  "dojo/text!webui/widgets/business/templates/NewBusinessTransactionDialog.html",
  "dojo/i18n!webui/nls/web",
  "dojo/_base/array",
  "dojo/_base/declare",
  "dojo/_base/event",
  "dojo/_base/lang",
  "dojo/dom-attr",
  "dojo/dom-class",
  "dojo/keys",
  "dojo/on",
  "dojo/request/xhr",
  "dijit/Dialog",
  "dijit/_TemplatedMixin",
  "dijit/_WidgetsInTemplateMixin",
  "webui/config/Resources",
  "webui/widgets/common/Trace"
], function(
  template,
  NLS,
  array,
  declare,
  event,
  lang,
  domAttr,
  domClass,
  keys,
  on,
  xhr,
  Dialog,
  _TemplatedMixin,
  _WidgetsInTemplateMixin,
  Resources,
  Trace
) {
	var executionGroupNewDialog = declare("webui.widgets.business.NewBusinessTransactionDialog", [ Dialog, _TemplatedMixin, _WidgetsInTemplateMixin ], {
		templateString: template,
		_namesInUse: [],
		_nameChangedEventHandle: null,
    _value: null,
    _newBTDTitle: NLS.btNewBTDDialogTitle,
    _newBTDDesc: NLS.btNewBTDDialogDesc,
    _newBTDName: NLS.btNewBTDName,
    _btOKLabel: NLS.okButtonLabel,
    _btCancelLabel: NLS.cancelButtonLabel,
        
    //need to pass in this info because we need to pass it along to the callback method for an ajax call.
  	constructor: function(args){
  	  if(!args) {
  	    throw new Error("No arguments passed");
  	  }
	    this._value = args.currentValue;
	  	this._callback = args.cback;
  	},

		_onKey : function(evt) {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_onKey");
			this.inherited(arguments);
			if (evt.charOrCode) {
				if (evt.charOrCode === keys.ENTER) {
					if ( !this._okButton.get("disabled" ) ) {
						event.stop(evt);
						this.onExecute();
					}
				}
			}
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "_onKey");
		},

		postCreate : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
			this.inherited(arguments);
			this._nameText.attr('regExp', Resources.regexp.businessTransactionName);
			this._nameText.attr('invalidMessage', NLS.btdInvalidNameErrorMsg);
			this._nameText.focus();
			this._okButton.set("disabled", true);

			// make an ajax call to get list of existing business transactions
			xhr(Resources.REST.businessTransactions, {
			  handleAs : "json",
        headers : {
          "Accept" : "application/json"
        }
			}).then(
        lang.hitch(this, function(response) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Get business transaction definitions success");
  
          // Extract out the BTD names
          if(typeof response.businessTransactionName !== "undefined") {
            // Only clear out the names if we have received a response
            this._namesInUse = [];
            array.forEach(response.businessTransactionName, lang.hitch(this, function(nextBTD) {
              this._namesInUse.push(nextBTD.name);
            }));
          }
        }),
        lang.hitch(this, function(error) {
          Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Error: " + error.response.status + " Response: " + error.response.response);            
        })
      );

			on(this, "execute", lang.hitch(this, function() {
				this._callback(this._nameText.get("value"));
				this.hide();
			}));
			on(this._cancelButton, "click", lang.hitch(this, function() {
				this.hide();
			}));

			this._nameChangedEventHandle = on(this._nameText, "change", lang.hitch(this, this.nameChanged));
				
			Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
		},

    show : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "show");	
      this.inherited(arguments);
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "show");
    },	      
	    
		// This gets called every time the content of the name box changes, i.e.
		// whenever a keystroke is pressed
		nameChanged : function() {
			Trace.trace(this.declaredClass, Trace.levels.ENTRY, "nameChanged");
		    
			var value = this._nameText.get("value");
			domAttr.set(this.instructionNode, "innerHTML", NLS.btNewBTDNewNameMsg );
			domClass.remove(this.instructionDiv, "btDialogWarningText");

			if (value == "") {
					this._okButton.set("disabled", true);
					//Only set the error message when the dialog is not displayed for the first time
					domAttr.set(this.instructionNode, "innerHTML", NLS.btdEmptyNameErrorMsg );
					domClass.add(this.instructionDiv, "btDialogWarningText");

			} else {
				var inUse = false;
				array.forEach(this._namesInUse, function(item) {
					if (value === item) {
						inUse = true;
					}
				});
				this._okButton.set("disabled", inUse);
				if (inUse) 
				{	
					//Only set the error message when the dialog is not displayed for the first time
					domAttr.set(this.instructionNode, "innerHTML", NLS.btdNameDuplicateErrorMsg );
					domClass.add(this.instructionDiv, "btDialogWarningText");
						
				} else {
					if ( !this._nameText.isValid() ) {
					  domAttr.set(this.instructionNode, "innerHTML", NLS.btdInvalidNameErrorMsg );
					  domClass.add(this.instructionDiv, "btDialogWarningText");
						this._okButton.set("disabled", true);
					}//if
				}
			}

			Trace.trace(this.declaredClass, Trace.levels.EXIT, "nameChanged");
		}

	});
	return executionGroupNewDialog;
});

},
'webui/utils/StatsUtils':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="392431026" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */

/**
 * This is a collection of static util methods for working with/near webstats
 */
define(
  [
    "dojo/date/locale",
    "dojo/io-query",
    "webui/widgets/common/Trace"
  ],
  function(
    Locale,
    ioQuery,
    Trace
  ) {
    // local static variables
    var declaredClass = "webui.utils.StatsUtils";
  
    /**
     * Round a supplied µs stats number UP to the nearest 0.1 ms.
     * Args:
     * microseconds: number to round
     * decimalPlaces: (optional) number of places to
     * return, defaults to 1. Must be between >=0 and <=3
     */
    function formatToMillis(microseconds, decimalPlaces) {
      return roundUpToNearest(microseconds / 1000, decimalPlaces);
    }
  
    /**
     * Round a supplied number UP to the nearest specified decimal place.
     * Args:
     * value: number to round
     * decimalPlaces: (optional) number of places to
     * return, defaults to 1. Must be between >=0 and <=3
     */
    function roundUpToNearest(value, decimalPlaces) {
      if (decimalPlaces == null) {
        decimalPlaces = 1;
      }
  
      var ms;
      if (decimalPlaces < 0) {
        Trace.trace(declaredClass, Trace.levels.ERROR, "Error, decimal places cannot be < 0", [ decimalPlaces ]);
        throw "Error, decimal places cannot be < 0: " + decimalPlaces;
      } else if (decimalPlaces == 0) {
        ms = Math.ceil(value);
      } else if (decimalPlaces == 1) {
        ms = Math.ceil(value * 10) / 10;
      } else if (decimalPlaces == 2) {
        ms = Math.ceil(value * 100) / 100;
      } else if (decimalPlaces == 3) {
        ms = Math.ceil(value * 1000) / 1000;
      } else {
        Trace.trace(declaredClass, Trace.levels.ERROR, "Error, decimal places cannot be > 3", [ decimalPlaces ]);
        throw "Error, decimal places cannot be > 3: " + decimalPlaces;
      }
      return ms;
    }
  
    /**
     * flowStats: object from broker statistics json
     * Returns: seconds since the epoch (in UTC)
     */
    function convertStatsTimestampToUTCEpoch(flowStatsData) {
      Trace.trace(declaredClass, Trace.levels.ENTRY, "convertStatsTimestampToUTCEpoch", [ flowStatsData ]);
  
      var time = parseStatsEndTime(flowStatsData);
      var utcEpoch = time.valueOf() / 1000;// valueOf returns ms
  
      Trace.trace(declaredClass, Trace.levels.EXIT, "convertStatsTimestampToUTCEpoch", [ utcEpoch ]);
      return utcEpoch;
    }
  
    /**
     * Arguments: flowStats object from broker statistics json
     * Returns: seconds since the epoch (in local timezone)
     */
    function convertStatsTimestampToLocalEpoch(flowStatsData) {
      Trace.trace(declaredClass, Trace.levels.ENTRY, "convertStatsTimestampToLocalEpoch", [ flowStatsData ]);
      var time = parseStatsEndTime(flowStatsData);
      var utcEpoch = time.valueOf() / 1000;// valueOf returns ms
      var tzOffset = Locale.format(time, {
        datePattern : "Z",
        selector : "date"
      });
      var tzOffsetSec = tzOffset / 100 * 3600;
      utcEpoch = convertStatsTimestampToUTCEpoch(flowStatsData);
      var localEpoch = utcEpoch + tzOffsetSec;
  
      Trace.trace(declaredClass, Trace.levels.EXIT, "convertStatsTimestampToLocalEpoch", [ localEpoch ]);
      return localEpoch;
    }
  
    /**
     * Arguments: flowStats object from broker statistics json
     * Returns: Dojo/js Date object
     */
    function parseStatsEndTime(flowStatsData) {
      Trace.trace(declaredClass, Trace.levels.ENTRY, "parseStatsEndTime", [ flowStatsData ]);
  
      var time = new Date(flowStatsData.GMTEndTime);
  
      Trace.trace(declaredClass, Trace.levels.EXIT, "parseStatsEndTime", [ time ]);
      return time;
    }
  
    /**
     * Arguments: flowStats object from broker statistics json
     * Returns: Dojo/js Date object
     */
    function parseStatsStartTime(flowStatsData) {
      Trace.trace(declaredClass, Trace.levels.ENTRY, "parseStatsStartTime", [ flowStatsData ]);
  
      var time = new Date(flowStatsData.GMTStartTime);
  
      Trace.trace(declaredClass, Trace.levels.EXIT, "parseStatsStartTime", [ time ]);
      return time;
    }
  
    /**
     * Arguments: dateTimeObj
     * Returns: formatted time string
     */
    function formatToTime(dateTimeObj) {
      Trace.trace(declaredClass, Trace.levels.ENTRY, "formatToTime", [ dateTimeObj ]);
  
      var timeStr = Locale.format(dateTimeObj, {
        timePattern : "HH:mm:ss v",
        selector : 'time'
      });
  
      Trace.trace(declaredClass, Trace.levels.EXIT, "formatToTime", [ timeStr ]);
      return timeStr;
    }
  
    /**
     * Takes the local epoch value in seconds and converts it back into a date
     * object adjusted to the timezone accordingly
     * Arguments: seconds since the epoch
     * Returns: the adjusted date object
     */
    function convertLocalEpochToDateObject(seconds) {
      Trace.trace(declaredClass, Trace.levels.ENTRY, "convertLocalEpochToDateObject", [ seconds ]);
  
      var time = new Date(seconds * 1000);
      // Re-adjust the timezone factor from when it was initially adjusted in the
      // convertStatsTimestampToLocalEpoch method
      var tzOffset = Locale.format(time, {
        datePattern : "Z",
        selector : "date"
      });
      var tzOffsetSec = tzOffset / 100 * 3600;
      var adjustedTime = seconds - tzOffsetSec;
      var date = new Date(adjustedTime * 1000);
  
      Trace.trace(declaredClass, Trace.levels.EXIT, "convertLocalEpochToDateObject", [ date ]);
      return date;
    }
  
    /**
     * Returns true iff "test=true" is among the URL parameters.
     */
    function isTestingOn() {
      var search = window.location.search; // e.g. "?test=true", ""
      if(search.indexOf("?") === 0) {
        search = search.substring("?".length); // "test=true"
      }
      
      return ioQuery.queryToObject(search).test === "true";
    }
  
    // return static public functions
    return {
      formatToMillis : formatToMillis,
      roundUpToNearest : roundUpToNearest,
      convertStatsTimestampToLocalEpoch : convertStatsTimestampToLocalEpoch,
      convertStatsTimestampToUTCEpoch : convertStatsTimestampToUTCEpoch,
      parseStatsEndTime : parseStatsEndTime,
      parseStatsStartTime : parseStatsStartTime,
      formatToTime : formatToTime,
      convertLocalEpochToDateObject : convertLocalEpochToDateObject,
      isTestingOn : isTestingOn
    };
  }
);

},
'webui/widgets/dataviewer/Replay':function(){
/*
 * <copyright 
 * notice="lm-source" 
 * pids="5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2" 
 * years="2011,2016" 
 * crc="555711022" > 
 * Licensed Materials - Property of IBM  
 *  
 * 5724-J06,5724-J05,5724-J04,5697-J09,5655-M74,5655-M75,5648-C63,5655-AB1,5655-AB2 
 *  
 * (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.  
 * </copyright> 
 */
define(
  [
    "dojo/i18n!webui/nls/web",
    "dojo/text!webui/widgets/dataviewer/templates/Replay.html",
    "dojo/on",
    "dojo/request/xhr",
    "dojo/_base/declare",
    "webui/widgets/common/Trace",
    "dijit/_WidgetBase",
    "dijit/_TemplatedMixin",
    "dijit/_WidgetsInTemplateMixin",
    "webui/config/Resources",
    "dojo/_base/lang",
    "dojo/dom-construct",
    "dojo/dom-class",
    "dojo/store/Memory",
    "dojox/grid/DataGrid",
    "dojo/data/ObjectStore",
    "dojo/query",
    "dojo/dom-attr",
    "dojo/_base/array",
    "dojo/_base/fx",
    "webui/widgets/common/Toolbar",
    "idx/widget/HoverHelpTooltip",
    "dojo/dom-geometry"
  ],
  function(
    NLS,
    template,
    on,
    xhr,
    declare,
    Trace,
    _WidgetBase,
    _TemplatedMixin,
    _WidgetsInTemplateMixin,
    Resources,
    lang,
    domConstruct,
    domClass,
    Memory,
    DataGrid,
    ObjectStore,
    query,
    domAttr,
    array,
    fx,
    Toolbar,
    HoverHelpTooltip,
    domGeom
  ) {

    var replay = declare("webui.widgets.dataviewer.Replay", [_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin], {

    // This is the name of the widget that will be used in trace.

    templateString: template,

    grid : null,
    replayGrid : null,
    _gridStore: null,
    replayGridStore : null,
    _gridData: null,
    _filterVisible: false,
    _replayVisible: false,
    _changeGridHeaderFilter: null,
    dataviewerTab: null,

    // spinner widget
    _gridStandby: null,
    _replayStandby: null,

    _gridHeader: null,
    _layout: null,
    _replayLayout: null,

    _filter_EVENT_TYPE: null,
    _escapedString : "",

    _sortstr: "",
    _successCount: 0,
    toolbar: null,
    errorMessag: null,

    canViewMessages: false,
    canEditMessages: false,
    canReplayMessages: false,
    totalReplayItems: 0,
    _replaySuccesses: 0,
    _replayWarnings: 0,
    _replayErrors: 0,
    _replayStatus: [],

    _xhrPost: null,
    ridDivMoving: false,

    replayErrorArray: [],
    addedReplayItems: JSON.stringify([]),

    // //////////////////////////////////////////////////////
    // DEFAULTS
    //
    _currentNumberOfEntriesPerPage : 10,
    _currentPageNumber : 1,
    _lastPage : 1,
    //
    // //////////////////////////////////////////////////////

    postCreate : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "postCreate");
      this.inherited(arguments);

      // Get the current user's permissions
      this.canViewMessages   = window.currentuser.permission_rrrViewMessages; // ??? When are these populated??
      this.canEditMessages   = window.currentuser.permission_rrrEditMessages;
      this.canReplayMessages = window.currentuser.permission_rrrReplayMessages;

      // Create toolbar
      this.toolbar = new Toolbar();
      domConstruct.place(this.toolbar.domNode, this.domNode);

      var buttons = ["combo", "replay"];
      var names = ["dataDestination", undefined]; // use default name for "replay" button
      //this.toolbar.addRightAlignButtons(buttons);

      this.toolbar.addLeftAlignButtons(buttons, names);
      this.toolbar.setButtonState("disable", "replay");
      // Set some attributes on the combo box (value and store)
      this.toolbar.setAttribute("combo", "value", NLS.replayComboDefaultValue, "dataDestination");
      this.toolbar.setAttribute("combo", "label", NLS.replayComboTitle, "dataDestination");
      this.toolbar.connectButtons("combo", "change", this, "activateReplay", "dataDestination");

      xhr(
        encodeURI(Resources.REST.comboBoxReplayDestinations),
        {
          handleAs : "json",
          headers : {
            "Accept" : "application/json"
          }
        }
      ).then(
        lang.hitch(this, function(data) {
          var destinationList = [];
          array.forEach(data.configurableService, lang.hitch(this, function(item) {
            if(item.name.indexOf("Template", (item.name.length - 8)) === -1) {
              destinationList.push(item);
            }
          }));
          if(destinationList.length === 0) {
            this.toolbar.setButtonState("disable", "combo", "dataDestination");
            this.toolbar.setAttribute("combo", "value", NLS.replayComboNoValues, "dataDestination");
          } else {
            this.toolbar.setButtonState("enable", "combo", "dataDestination");
            this.toolbar.setAttribute("combo", "value", NLS.replayComboDefaultValue, "dataDestination");
          }
          this.toolbar.setAttribute("combo", "store", destinationList, "dataDestination");
        })
      );

      this.toolbar.connectButtons("replay", "click", this, "_submitReplayDialog");

      array.forEach(window.tabWidgets, lang.hitch(this, function(tabWidget){
        if(tabWidget.id === "webui.widgets.dataviewer.DataViewer"){
          this.dataviewerTab = tabWidget;
        }
      }));

      this._layout = lang.clone(this.dataviewerTab.emptyLayout);

      this.replayGrid = new DataGrid({
        store : this._gridStore = new ObjectStore({
          objectStore : new Memory({
            data : []
          })
        }),
        structure : this._layout,
        onHeaderCellClick : lang.hitch(this, this._getSortedTable),
        id : "replayListGridID",
        escapeHTMLInData : false,
        selectable : true,
        height : "500px"
      }, document.createElement('div'));

      /* append the new grid to the div */
      domConstruct.place(this.replayGrid.domNode, this._rrr_replayGridStandby_grid);

      /* Call startup() to render the grid */
      this.replayGrid.startup();

      on(this.replayGrid, "RowClick", lang.hitch(this, function(event) {
        this.onRowClickHandler(event);
      }));

      domAttr.set(this.replayListNoDataText, "innerHTML", NLS.replayListNoDestinationAndReplayItemsSelected);

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "postCreate");
    },

    startup: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "startup");

      this.inherited(arguments);

      on(document, ".SelectReplayAll:click", lang.hitch(this, function(event) {
        this._removeRow(event);
        this.replayGridStore = new ObjectStore({
          objectStore : new Memory({
            data : this.dataviewerTab.publicReplayItems,
            clearOnClose : true,
            urlPreventCache : true
          })
        });
        this.replayGrid.setStore(this.replayGridStore);
      }));

      this.changeSelectRow();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "startup");
    },

    onRowClickHandler : function(event) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "onRowClickHandler");
      // Only data items containing a bitstream can be replayed.
      // Run replay only on that row
      if(event.target.className.match("replaySingle")) {
        this._submitReplayDialog(event.rowIndex);

      }

      // Determine if a particular icon in the row was clicked
      if(event.target.className.match("replaySelectRow")) {
        this._removeRow(event);

      }

      // Don't allow any rows to be selected in the replay grid
      array.forEach(this.replayGrid._by_idx, lang.hitch(this, function(gridData, k) { // jshint ignore:line
        this.replayGrid.selection.deselect(k);
      }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "onRowClickHandler");
    },

    populateReplayGrid : function(replayItems) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "populateReplayGrid");

      if((this.toolbar.getComboValue("dataDestination") !== NLS.replayComboDefaultValue) && (this.toolbar.getComboValue("dataDestination") !== "") && (replayItems.length > 0)) {
        this.toolbar.setButtonState("enable", "replay");
        domAttr.set(this.replayListNoDataText, "innerHTML", "");
        if(!domClass.contains(this.replayListNoDataContainer, "_common_hideDiv")) {
          var fadeArgs = {
            node : "replayListNoDataContainer_ID",
            duration : 300,
            onEnd : function() {
              domClass.add("replayListNoDataContainer_ID", "_common_hideDiv");
            }
          };
          fx.fadeOut(fadeArgs).play();
        }
        this.replayListFooter(this.totalReplayItems, this._replaySuccesses, this._replayWarnings, this._replayErrors);
      } else if((this.toolbar.getComboValue("dataDestination") !== "") && (replayItems.length === 0)) {
        this.toolbar.setButtonState("disable", "replay");
        domAttr.set(this.replayListNoDataText, "innerHTML", NLS.replayListNoReplayItemsSelected);
      } else if((this.toolbar.getComboValue("dataDestination") === "") && (replayItems.length > 0)) {
        this.toolbar.setButtonState("disable", "replay");
        domAttr.set(this.replayListNoDataText, "innerHTML", NLS.replayListNoDestinationSelected);
      } else {
        this.toolbar.setButtonState("disable", "replay");
        domAttr.set(this.replayListNoDataText, "innerHTML", NLS.replayListNoDestinationAndReplayItemsSelected);
      }

      //this.dataviewerTab.publicReplayItems = replayItems;
      this.replayGrid.store.close();

      var items = JSON.parse(this.addedReplayItems); // array
      array.forEach(replayItems, lang.hitch(this, function(replayItem) {
        var duplicate = false;
        if(this.dataviewerTab.publicReplayItems){
          array.forEach(this.dataviewerTab.publicReplayItems.items, lang.hitch(this, function(item){
            if (item && (replayItem.msgKey === item.msgKey)) {
              duplicate = true;
            }
          }));
        }

        if(!duplicate){
          items.push(replayItem);
        }
      }));

      this.dataviewerTab.publicReplayItems = {"items" : items};

      this.replayGridStore = new ObjectStore({
        objectStore : new Memory({
          data : this.dataviewerTab.publicReplayItems,
          clearOnClose : true,
          urlPreventCache : true
        })
      });
      this.replayGrid.setStore(this.replayGridStore);
      this.totalReplayItems = this.dataviewerTab.publicReplayItems.items.length;
      this._replayStatus = [];
      this._replaySuccesses = 0;
      this._replayWarnings = 0;
      this._replayErrors = 0;
      this.replayListFooter(this.totalReplayItems, 0, 0, 0);

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "populateReplayGrid");
    },

    _getSortedTable : function(e) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_getSortedTable");

      if((this.totalReplayItems > 0) && (e.cell.index !== 0)) {
        var headerIndex = e.cell.index;
        Trace.trace(this.declaredClass, Trace.levels.DEBUG, "_getSortedTable : headerIndex = " + headerIndex);
        if(this.replayGrid.getSortAsc()) {
          this.replayGrid.setSortIndex(headerIndex, false);

        } else {
          this.replayGrid.setSortIndex(headerIndex, true);
        }
        //this._updateGrid();
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_getSortedTable");
    },

    _removeRow : function(event) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_removeRow");

      this._replayStatus = [];
      this._replaySuccesses = 0;
      this._replayWarnings = 0;
      this._replayErrors = 0;
      this.dataviewerTab.removeRow(event);

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_removeRow");
    },

    _submitReplayDialog : function(rowIndex) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_submitReplayDialog");

      this._replayStatus = [];
      this._replaySuccesses = 0;
      this._replayWarnings = 0;
      this._replayErrors = 0;
      this.replayListFooter(this.totalReplayItems, 0, 0, 0);

      this._successCount = 0;
      var dataViewerStore = this.dataviewerTab.toolbar.getComboValue("dataStore");
      var dataDestination = this.toolbar.getComboValue("dataDestination");

      this.toolbar.setButtonState("disable", "replay");
      array.forEach(this.dataviewerTab.publicReplayItems.items, lang.hitch(this, function(data, j) {
        // Build URI for post request
        var uri = Resources.REST.dataCaptureStore + dataViewerStore + "/" + data.msgKey + "?action=replay&replayDestination=" + dataDestination;
        var statusCode = 0;
        if(rowIndex >= 0) {
          if(rowIndex === j) {
            this._updateReplayGrid(j, "-1");
          }
        } else {
          this._updateReplayGrid(j, "-1");
        }

        if(rowIndex >= 0) {
          if(rowIndex === j) {
            this.xhrPost = xhr.post(
              encodeURI(uri),
              {
                handleAs : "json",
                headers : {
                  "Accept" : "application/json"
                }
              }
            ).response.then(
              lang.hitch(this, function(response) {
                statusCode = response.xhr.status;
                this._updateReplayGrid(j, statusCode);
                if(this.dataviewerTab.publicReplayItems.items.length === (j + 1)) {
                  this.toolbar.setButtonState("enable", "replay");
                }
              }),
              lang.hitch(this, function(error) {
                var response = JSON.parse(error.response.text);
                statusCode = error.response.xhr.status;
                this._updateReplayGrid(j, statusCode, response);
                if(this.dataviewerTab.publicReplayItems.items.length === (j + 1)) {
                  this.toolbar.setButtonState("enable", "replay");
                }
              })
            );
            this.toolbar.setButtonState("enable", "replay");
          }
        } else {
          this.xhrPost = xhr.post(
            encodeURI(uri),
            {
              handleAs : "json",
              headers : {
                "Accept" : "application/json"
              }
            }
          ).response.then(
            lang.hitch(this, function(response) {
              statusCode = response.xhr.status;
              this._updateReplayGrid(j, statusCode);
              if(this.dataviewerTab.publicReplayItems.items.length === (j + 1)) {
                this.toolbar.setButtonState("enable", "replay");
              }
            }),
            lang.hitch(this, function(error) {
              var response = JSON.parse(error.response.text);
              statusCode = error.response.xhr.status;
              this._updateReplayGrid(j, statusCode, response);
              if(this.dataviewerTab.publicReplayItems.items.length === (j + 1)) {
                this.toolbar.setButtonState("enable", "replay");
              }
            })
          );
        }
      }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_submitReplayDialog");
    },

    _updateReplayGrid : function(rowNumber, statusCode, response) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_updateReplayGrid");
      Trace.trace(this.declaredClass, Trace.levels.DEBUG, "Status code is " + statusCode);
      var item = this.dataviewerTab.publicReplayItems.items[rowNumber];
      if(item.hasBitstream){
        if(statusCode == 200){
          item.SELECTED = "success";
          item.STATUS = "success";
          this._replaySuccesses++;
        } else if(statusCode == -1){
          item.SELECTED = "loading";
        } else {
          item.SELECTED = "failed";
          this._replayErrors++;
          if(response === undefined){
            item.STATUS = "failed";
          }else{
            item.STATUS = response;
          }
          window.smallMessage.displayMessage("error", "ReplayViewer_5XX", "", NLS.replayListStatusHelp);
        }
      } else {
        // Show a warning (yellow highlight of row) if there is not bitstream
        item.SELECTED = "warning";
        item.STATUS = "warning";
        this._replayWarnings++;
        window.smallMessage.displayMessage("warning", "ReplayViewer_000", "", NLS.replayListStatusHelp);
      }
      this.replayGrid.update();

      array.forEach(query('.replayListError'), lang.hitch(this, function(node){
        var labelError = "";
        array.forEach(this.replayErrorArray, lang.hitch(this, function(bip){
          if(bip.divId === node.id){
            labelError = bip.bipError;
          }
        }));
        var hh = new HoverHelpTooltip( {
          connectId : [ node.id ],
          label : labelError,
          showDelay : 0
        });
        hh.startup();
      }));
      array.forEach(query('.replayListWarning'), lang.hitch(this, function(node){
        var hh = new HoverHelpTooltip( {
          connectId : [ node.id ],
          label : NLS.replayRowWarning,
          showDelay : 0
        });
        hh.startup();
      }));
      array.forEach(query('.replayListSuccess'), lang.hitch(this, function(node){
        var hh = new HoverHelpTooltip( {
          connectId : [ node.id ],
          label : NLS.replayRowSuccess,
          showDelay : 0
        });
        hh.startup();
      }));

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "_updateReplayGrid");
    },

    // Need to override the resize function to resize the dojo grid otherwise
    // the grid does not appear.
    resize : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "resize");

      this.inherited(arguments);
      this._replayList_borderContainer.resize();
      if(!this.gridDivMoving) {
        this.gridDivMoving = true;
        // Don't want to initiate another move until this one is completed
        this.borderHeight = domGeom.position('_explorerBorderContainer_ID', true).h;

        var duration = 100;
        fx.animateProperty({
          node : "replayListGridID",
          onAnimate : lang.hitch(this, function() {
            this.replayGrid.render();
          }),
          properties : {
            height : this.borderHeight - 240
          },
          duration : duration
        }).play();
      }
      this.gridDivMoving = false;

      this.replayGrid.resize();
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "resize");
    },

    activateReplay : function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "activateReplay");

      if((this.toolbar.getComboValue("dataDestination") !== NLS.replayComboDefaultValue) && (this.toolbar.getComboValue("dataDestination") !== null) && (this.totalReplayItems > 0)) {
        this.toolbar.setButtonState("enable", "replay");
        domAttr.set(this.replayListNoDataText, "innerHTML", "");
        if(!domClass.contains(this.replayListNoDataContainer, "_common_hideDiv")) {
          var fadeArgs = {
            node : "replayListNoDataContainer_ID",
            duration : 300,
            onEnd : function() {
              domClass.add("replayListNoDataContainer_ID", "_common_hideDiv");
            }
          };
          fx.fadeOut(fadeArgs).play();
        }
      } else if((this.toolbar.getComboValue("dataDestination") !== "") && (this.totalReplayItems === 0)) {
        this.toolbar.setButtonState("disable", "replay");
        domAttr.set(this.replayListNoDataText, "innerHTML", NLS.replayListNoReplayItemsSelected);
      } else if((this.toolbar.getComboValue("dataDestination") === "") && (this.totalReplayItems > 0)) {
        this.toolbar.setButtonState("disable", "replay");
        domAttr.set(this.replayListNoDataText, "innerHTML", NLS.replayListNoDestinationSelected);
      } else {
        this.toolbar.setButtonState("disable", "replay");
        domAttr.set(this.replayListNoDataText, "innerHTML", NLS.replayListNoDestinationAndReplayItemsSelected);
      }
      this.replayGrid.update();

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "activateReplay");
    },

    changeSelectRow: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "changeSelectRow");

      // Copy/clone layout from dataviewTab to replayTab
      // TODO: Shouldn't access private property of this.dataviewerTab.
      this._layout = lang.clone(this.dataviewerTab.defaultLayout);

      var selectCol = [{
        field : 'SELECTED',
        name : "<div title='" + NLS.replayColumnSelect + "' class='replaySelectColumnHeader SelectReplayAll'></div>",
        width : '55px',
        formatter : lang.hitch(this, this.insertSelectCheckboxFormatter)
      }, {
        field : 'STATUS',
        name : NLS.replayStatusColumn,
        width : '140px',
        formatter : lang.hitch(this, function(name, rowIndex){
          var helpDiv = "helpDiv" + rowIndex;
          var result = this.insertReplayStatus(name, helpDiv);
          return result;
        })
      }];
      // We copy the table structure from the dataviewer grid into the replay grid, but the "splice" call below lops off the checkbox column, and puts 2 new
      // columns in instead.  The first is the replay checkbox column with individual replay lines, and the 2nd is the "Replay status" column.
      this._layout.splice(0, 1, selectCol[0], selectCol[1]);
  
      // As the formatters are model-specific (i.e. the formatters for the dataviewer table rely on contents from the dataviewer model) we need to replace them with replay-model equivalents.
      // We'll throw an error if a dataviewer formatter is present, and we don't have a replay formatter equivalent.  This should mean we catch any new formatters that are added in dataviewer,
      // but need adding for replay too.
      array.forEach(this._layout, lang.hitch(this, function(layout_item) {
        if (layout_item.formatter != null) {
          switch (layout_item.field) {
          case "SELECTED" :
            // Don't need to change - these are handled above
            break;
          case "STATUS" :
            // Don't need to change - these are handled above
            break;
          case "eventTimestamp" :
            layout_item.formatter = lang.hitch(this, this._replayEventTimestampFormatter);
            break;
          case "hasBitstream" :
            layout_item.formatter = lang.hitch(this, this.replayHasBitstreamFormatter);
            break;
          case "hasException" :
            layout_item.formatter = lang.hitch(this, this.replayHasExceptionFormatter);
            break;
          default:
            console.log("ERROR! We don't have a replay formatter for this column!: " + layout_item.field);
          }
        }
      }));
      this.replayGrid.setStructure(this._layout);
  
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "changeSelectRow");
    },

  replayHasBitstreamFormatter : function(name, rowIndex) {
    Trace.trace(this.declaredClass, Trace.levels.ENTRY, "replayHasBitstreamFormatter");

    var MsgKey = this.dataviewerTab.publicReplayItems.items[rowIndex].msgKey;
    var result = "";
    var dataCaptureStore = this.dataviewerTab.toolbar.getComboValue("dataStore");
    if(name) {
      if(this.dataviewerTab.canViewMessages) {
        result = "<center><a target='_blank' href='" + Resources.REST.dataCaptureStore + dataCaptureStore + "/" + MsgKey + "'><div title='" + NLS.replayDownload + "' class='replayDownload'></div></a></center>";
      } else {
        result = "<center><div title='" + NLS.replayDownloadLocked + "' class='replayDownloadLocked'></div></center>";
      }
    } else {
      result = "<center><div title='" + NLS.replayDownloadDisabled + "' class='replayDownloadDisabled'></div></center>";
    }

    Trace.trace(this.declaredClass, Trace.levels.EXIT, "replayHasBitstreamFormatter");
    return result;
  },

  replayHasExceptionFormatter : function(name, rowIndex) {
    Trace.trace(this.declaredClass, Trace.levels.ENTRY, "replayHasExceptionFormatter");

    var MsgKey = this.dataviewerTab.publicReplayItems.items[rowIndex].msgKey;
    var result = "";
    var dataCaptureStore = this.dataviewerTab.toolbar.getComboValue("dataStore");
    if(name) {
      if(this.dataviewerTab.canViewMessages) {
        result = "<center><a target='_blank' href='" + Resources.REST.dataCaptureStore + dataCaptureStore + "/" + MsgKey + "?payload=exceptionList'><img src='/webui/widgets/dataviewer/images/exception.gif'></a></center>";
      } else {
        result = "<center><img src='/webui/widgets/dataviewer/images/exception_inactive.gif'></center>";
      }
    } else {
      result = "<center>-</center>";
    }
    Trace.trace(this.declaredClass, Trace.levels.EXIT, "replayHasExceptionFormatter");
    return result;
  },

  _replayEventTimestampFormatter : function(name, rowIndex) { // jshint ignore:line
    Trace.trace(this.declaredClass, Trace.levels.ENTRY, "_replayEventTimestampFormatter");
    var timeStamp = this.dataviewerTab.publicReplayItems.items[rowIndex].eventTimestamp;
    var result;
    if (this.dataviewerTab.showAsLocalTime == false) {
       // return value with GMT on the end to show that it is GMT ! 
       result = timeStamp + " GMT";
       return result;
    }
    //convert to the local browser time zone
    var date = timeStamp.substring(0,10);
    var time = timeStamp.substring(11);
    var localeDate = new Date(date + 'T' + time + '+00:00');
    // Does browser support  ISO 8601 or not. 
    var offset;
    if (!isNaN(localeDate)) {
      offset = (localeDate.getTimezoneOffset() / 60) * -1;
      if (offset >= 0) {
        result = localeDate.toLocaleDateString() + ' ' + localeDate.toLocaleTimeString() + '.' + localeDate.getMilliseconds()+ ' GMT+'+offset;
      }
      else {
        result = localeDate.toLocaleDateString() + ' ' + localeDate.toLocaleTimeString() + '.' + localeDate.getMilliseconds() + ' GMT'+offset;
      }
    }
    else
    { /* if not then do it the long way */
      var year = date.substring(0,4);
      var month = date.substring (5,7) -1;
      var day = date.substring(8,10);
      var hours = time.substring(0,2);
      var mins = time.substring(3,5);
      var secs = time.substring(6,8);
      var milliseconds = time.substring(9);
      localeDate = new Date(Date.UTC(year,month,day,hours,mins,secs,milliseconds));
      // convert offset e.g. GMT+10 gives negative offset and -10 positive offset 
      offset = (localeDate.getTimezoneOffset() / 60) * -1;
      if (offset >= 0) {
        result = localeDate.toLocaleDateString() + ' ' + localeDate.toLocaleTimeString() + '.' + localeDate.getMilliseconds() + ' GMT+'+offset;
      } 
      else
      {
        result = localeDate.toLocaleDateString() + ' ' + localeDate.toLocaleTimeString() + '.' + localeDate.getMilliseconds() + ' GMT'+offset;
      }
    }
    Trace.trace(this.declaredClass, Trace.levels.EXIT, "_replayEventTimestampFormatter");
    return result;
  },

    insertSelectCheckboxFormatter : function(name, rowIndex) {
        Trace.trace(this.declaredClass, Trace.levels.ENTRY, "insertSelectCheckboxFormatter");
        var result = "";
        var replayIcon = "";
        var checkBoxIcon = "<div title='" + NLS.replayRowCheckbox + "' class='replaySelectRow SelectReplay'></div>";

        on(this.replayGrid, "styleRow", lang.hitch(this, function(row) {
            if(row.index == rowIndex) {
                if(name == "success") {
                    row.customStyles = 'background-color:#EDF8EB;border: #5EB03B solid 1px;';
                } else if(name == "failed") {
                    row.customStyles = 'background-color:#FFF3F3;border: #D9615D solid 1px;';
                } else if(name == "warning") {
                    row.customStyles = 'background-color:#FFFFEC;border: #E59651 solid 1px;';
                } else {
                    row.customStyles = 'background-color:#FFFFFF;border: #FFFFFF solid 1px;';
                }
            }
        }));
        if(name == "success") {
            //  SUCCESS
            replayIcon = "<div title='" + NLS.replayRowSuccess + "' class='replaySingle'></div>";
            this._replayStatus[rowIndex] = "success";
        } else if(name == "loading") {
            // LOADING
            replayIcon = "<div class='replayLoadingSmall'></div>";
        } else if(name == "failed") {
            // FAILED
            replayIcon = "<div title='" + NLS.replayRowFailed + "'  class='replaySingle'></div>";
            this._replayStatus[rowIndex] = "error";
        } else if(name == "warning") {
            replayIcon = "<div title='" + NLS.replayRowWarning + "' class='replaySingleDisabled'></div>";
            this._replayStatus[rowIndex] = "warning";
        } else {
            if(this.toolbar.getComboValue("dataDestination") != NLS.replayComboDefaultValue) {
                replayIcon = "<div style='display:none' class='replayLoadingSmall'></div><div title='" + NLS.replayRow + "' class='replaySingle'></div>";
            } else {
                replayIcon = "<div title='" + NLS.replayRowDisabled + "' class='replaySingleDisabled'></div>";
            }
        }
        result = checkBoxIcon + "<div style='width:15px;display:inline-block'></div>" + replayIcon;
        
        this.replayListFooter(this.totalReplayItems, this._replaySuccesses, this._replayWarnings, this._replayErrors);
        
        Trace.trace(this.declaredClass, Trace.levels.EXIT, "insertSelectCheckboxFormatter");

        return result;
    },


    insertReplayStatus : function(name, helpDiv) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "insertReplayStatus");
      var statusIcon;
      if( typeof name === 'object') {
        var bip = {};
        bip.divId = helpDiv;
        bip.bipNumber = name.bipNumber;
        bip.bipError = name.description;
        this.replayErrorArray.push(bip);

        statusIcon = "<div id=\"" + helpDiv + "\" onmouseover=\"idx.widget.HoverHelpTooltip.defaultPosition=['above', 'below']\" class='replayListError'><div class='replayStatusText'>" + NLS.replayStatusTextError + bip.bipNumber + "</div></div>";
      } else if( typeof name === 'string') {
        if(name === "success") {
          statusIcon = "<div id=\"" + helpDiv + "\" onmouseover=\"idx.widget.HoverHelpTooltip.defaultPosition=['above', 'below']\" class='replayListSuccess'><div class='replayStatusText'>" + NLS.replayStatusTextSuccess + "</div></div>";
          console.log(NLS.replayStatusTextSuccess);
        } else if(name === "warning") {
          statusIcon = "<div id=\"" + helpDiv + "\" onmouseover=\"idx.widget.HoverHelpTooltip.defaultPosition=['above', 'below']\" class='replayListWarning'><div class='replayStatusText'>" + NLS.replayStatusTextWarning + "</div></div>";
        } else {
          statusIcon = "<div id=\"" + helpDiv + "\" onmouseover=\"idx.widget.HoverHelpTooltip.defaultPosition=['above', 'below']\" class='replayListUnknown'><div class='replayStatusText'>" + NLS.replayStatusTextUnknown + "</div></div>";
        }
      } else if(name === undefined) {
        statusIcon = "<div class='replayListHidden'><div class='replayStatusTextBlank'>-</div></div>";
      } else {
        statusIcon = "<div id=\"" + helpDiv + "\" onmouseover=\"idx.widget.HoverHelpTooltip.defaultPosition=['above', 'below']\" class='replayListUnknown'><div class='oneui informationCenter replayStatusText'>" + NLS.replayStatusTextUnknown + "</div></div>";
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "insertReplayStatus");
      return statusIcon;
    },

    replayListFooter : function(total, success, warning, error) {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "replayListFooter");

      var totalStr = "";
      var successStr = "";
      var warningStr = "";
      var errorStr = "";
      if(total > 0) {
        totalStr = NLS.replayListFooterTotal + ":" + total + "&nbsp;&nbsp;";
        if((success > 0) || (warning > 0) || (error > 0)) {
          successStr = NLS.replayListFooterSuccess + ":" + success + "&nbsp;&nbsp;";
          warningStr = NLS.replayListFooterWarning + ":" + warning + "&nbsp;&nbsp;";
          errorStr = NLS.replayListFooterError + ":" + error + "&nbsp;&nbsp;";
        }
        domAttr.set(this._replayListFooter, "innerHTML", totalStr + successStr + warningStr + errorStr);
      } else {
        domAttr.set(this._replayListFooter, "innerHTML", "");
      }

      Trace.trace(this.declaredClass, Trace.levels.EXIT, "replayListFooter");
    },

    tabRemove: function() {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabRemove");
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabRemove");
    },

    tabFocus: function () {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabFocus");
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabFocus");
    },

    tabBlur: function () {
      Trace.trace(this.declaredClass, Trace.levels.ENTRY, "tabBlur");
      Trace.trace(this.declaredClass, Trace.levels.EXIT, "tabBlur");
    }

    });
    return replay;
  }
);

},
'url:webui/widgets/policy/templates/PolicyEditorDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" id = \"policyEditorDialog\" title=\"\">\n  <div class=\"dijitDialogTitle\">\n    <span  data-dojo-attach-point=\"titleNode\" tabindex=\"0\">  </span>\n    <span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${_buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n      <span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${_buttonCancel}\">x</span>\n    </span>\n  </div>\n  <div class=\"dijitDialogInstruction\" data-dojo-attach-point=\"policyEditorDialogPageInstructionDiv\">\n    <span role=\"document\" data-dojo-attach-point=\"pageInstructionNode\" tabindex=\"0\" > </span>\n  </div>\n  <div class=\"dijitDialogInstruction\" data-dojo-attach-point=\"policyEditorDialogInstructionDiv\">\n    <span role=\"document\" data-dojo-attach-point=\"policyEditorDialogInstructionNode\" > </span>\n  </div>\n  <div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n\t\t\t\t<div class=\"dijitDialogPaneContent\" class=\"policyDialog\" data-dojo-attach-point=\"_policyEditorDialogDynamicContentPane\"></div>\n  </div>\n\n  <div class=\"dijitDialogPaneActionBar\">\n    <span>\n    </span>\n    <span style=\"float:right; margin-right:50px\">\n      <button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_saveButton\"> ${_policySaveLabel}</button>\n      <button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_saveAsButton\"> ${_policySaveAsLabel}</button>\n      <button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> ${_policyCancelLabel} </button>\n    </span>\n  </div>\n</div>\n",
'url:webui/widgets/business/templates/AddFlowDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" id = \"btnDetailsDialog\"\n  title=\"\">\n  <div class=\"dijitDialogTitle\">\n    <span  data-dojo-attach-point=\"titleNode\"\n      tabindex=\"0\">  </span>\n    <span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${_buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n      <span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${_buttonCancel}\">x</span>\n    </span>\n  </div>\n  <div class=\"dijitDialogInstruction\" data-dojo-attach-point=\"instructionDiv\">\n    <span role=\"document\" data-dojo-attach-point=\"instructionNode\" tabindex=\"0\" > </span>\n  </div>\n  <div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n    <div class=\"dijitDialogPaneContent\" class=\"btDialog\">\n    <form>\n      <fieldSet>\n        <input type=\"radio\" id=\"bt_flows\"  name=\"bt_flow_group\" checked data-dojo-type=\"dijit/form/RadioButton\" data-dojo-attach-point=\"_flowsRadioButton\">\n        <label for=\"bt_flows\" class=\"addFlowRadioLabel\">${_btdFlowSelectionLabel}</label>\n        <div data-dojo-type=\"dijit.layout.ContentPane\" id =\"messageFlowContent\" data-dojo-props=\"region: 'center'\" class=\"btAddElement\"></div>\n\n        <input type=\"radio\" id=\"bt_apps\" name=\"bt_flow_group\" data-dojo-type=\"dijit/form/RadioButton\" data-dojo-attach-point=\"_appsRadioButton\">\n        <label for=\"bt_apps\" class=\"addFlowRadioLabel\">${_btdAppSelectionLabel}</label>\n        <div data-dojo-type=\"dijit.layout.ContentPane\" id =\"appMessageFlowContent\" data-dojo-props=\"region: 'center'\" class=\"btAddElement\"></div>\n      \n        <input type=\"radio\" id=\"bt_services\" name=\"bt_flow_group\" data-dojo-type=\"dijit/form/RadioButton\" data-dojo-attach-point=\"_servicesRadioButton\">\n        <label for=\"bt_services\" class=\"addFlowRadioLabel\">${_btdServiceSelectionLabel}</label>\n        <div data-dojo-type=\"dijit.layout.ContentPane\" id =\"serviceMessageFlowContent\" data-dojo-props=\"region: 'center'\" class=\"btAddElement\"></div>\n      \n        <input type=\"radio\" id=\"bt_restApis\" name=\"bt_flow_group\" data-dojo-type=\"dijit/form/RadioButton\" data-dojo-attach-point=\"_restApisRadioButton\">\n\t    <label for=\"bt_restApis\" class=\"addFlowRadioLabel\">${_btdRestApiSelectionLabel}</label>\n        <div data-dojo-type=\"dijit.layout.ContentPane\" id =\"restApiMessageFlowContent\" data-dojo-props=\"region: 'center'\" class=\"btAddElement\"></div>\n      </fieldSet>\n    </form>\n    <div id = \"btFlowsFromArtifact\" class=\"btFlowsFromArifactContent\"></div>\n    </div>\n  </div>\n  <div class=\"dijitDialogPaneActionBar\">\n    <span>\n    </span>\n    <span style=\"float:right; margin-right:50px\">\n      <button data-dojo-type=\"dijit.form.Button\" type=\"submit\" data-dojo-attach-point=\"_okButton\"> ${_btOKLabel}</button>\n      <button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> ${_btCancelLabel} </button>\n    </span>\n  </div>\n</div>\n",
'url:webui/widgets/subflows/templates/subflow_overview.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_msgflowOverview_borderContainer\" class=\"common_profileContainer\">\n  \t\t\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"> </div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\t\n\t\t\t<div class=\"_common_infoPanePropertiesPosition\">\n\t\t\t\t<div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_propertyTitlePane\"> </div>\n\t\t\t\t<div class=\"_common_textSpacer\"> </div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n",
'url:webui/widgets/business/templates/businesstransactions.html':"<div style=\"width:100%;height:100%;\">\n  <div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_businessTransactions_borderContainer\" class=\"common_profileContainer\">\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t\t\t<div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n\t\t\t\t<div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_propertyTitlePane\"></div>\n\t\t\t\t<div class=\"_common_textSpacer\"></div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>",
'url:webui/widgets/business/templates/businesstransaction_overview.html':"<div style=\"width:100%;height:100%;\">\n  <div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_businessTransactionOverview_borderContainer\" class=\"common_profileContainer\">\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n      <div data-dojo-attach-point=\"_toolbar\"></div>\n    </div>\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n      <div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n        <div id=\"btConfirmLeaveBTX\"></div>\n        <div id=\"btConfirmDeleteFlow\"></div>\n        <div id=\"btConfirmRefreshBTX\"></div>        \n        <div class=\"_common_quickViewTitlePaneNoTop\" data-dojo-attach-point=\"_propertyTitlePane\"></div>\n      </div>\n    </div>\n  </div>\n</div>",
'url:webui/widgets/business/templates/businesstransaction_data.html':"<div style=\"width:100%;height:100%;\">\n  <div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_businessTransactionDataView_borderContainer\" class=\"common_profileContainer\">\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n      <div data-dojo-attach-point=\"_toolbar\"></div>\n    </div>\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n      <div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n        <div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_propertyTitlePane\"></div>\n      </div>\n    </div>\n  </div>\n</div>",
'url:webui/widgets/broker/templates/BrokerPropertiesEditor.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_brokerEditor_borderContainer\" class=\"common_profileContainer\">\n    \n    \t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n    \t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t\t    <div id=\"editPropertyValueDialog\"></div>\n    \t\t<table class=\"brokerEditorTable\" id=\"brokerEditorTable\" style=\"display:none;\">\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"brokerName\" class=\"brokerEditorLabel\">${_brokerNameLabel}</label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"brokerName\" data-dojo-props=\"intermediateChanges: true\" data-dojo-attach-point=\"_brokerName\" id=\"brokerName\" class=\"brokerEditorAttribute\" spellcheck=\"false\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"brokerTypeName\" class=\"brokerEditorLabel\">${_brokerTypeLabel}</label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.FilteringSelect\" name=\"brokerTypeName\" data-dojo-attach-point=\"_brokerTypeName\" id=\"brokerTypeName\" class=\"brokerEditorAttribute\" spellcheck=\"false\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t\t\n\t\t\t<p/>\n\t\t\t<table class=\"brokerEditorTable\">\n\t\t\t\t<tr>\n          <td>\n\t   \t\t\t\t<div data-dojo-attach-point=\"_brokerProperties\" id=\"_brokerProperties\" class=\"brokerEditorGrid\"></div>\n          </td>\n\t\t\t\t</tr>\n        <tr>\n\t\t\t\t  <td>\n          \t<div data-dojo-attach-point=\"_componentProperties\" id=\"_componentProperties\" class=\"brokerEditorGrid\"></div>\n          </td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t</div>\n\t</div>\n</div>",
'url:webui/widgets/msgflows/templates/MessageFlowStatisticsGrid.html':"<div class=\"stats_tpnGridContainer\">\n    <span class=\"stats_nodesGridSpan\" data-dojo-attach-point=\"_resourceStatsGridSpan\">\n        <div data-dojo-attach-point=\"_messageFlowStatsGridDiv\"></div>\n    </span>\n</div>\n",
'url:webui/widgets/configurableservice/templates/cs_category_overview.html':"<div>\n\t<div data-dojo-attach-point=\"_csAddEditor\"></div>\n\t<div id=\"csImportCSFileDialog\"></div>\n\t<div id=\"csConfirmSwitchDialog\"></div>\n</div>",
'url:webui/widgets/dataviewer/templates/Replay.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_replayList_borderContainer\" class=\"common_profileContainer\">\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane dataViewer_infoPane\">\n\t\t\t<div id=\"dataviewerLoading_ID\" data-dojo-attach-point=\"dataviewerLoading\" class=\"dataviewerLoading _common_hideDiv\"></div>\n\t\t\t<div class=\"gridContainer replayContainer claro\">\n\t\t\t\t<div id=\"_rrr_replayGridStandby_grid_ID\" data-dojo-attach-point=\"_rrr_replayGridStandby_grid\" style=\"width:100%;height:100%;\">\n\t\t\t\t\t<div data-dojo-attach-point=\"replayListNoDataContainer\" class=\"replayListNoDataContainer\" id=\"replayListNoDataContainer_ID\">\n\t\t\t\t\t\t<div data-dojo-attach-point=\"replayListNoDataText\" class=\"oneui pageHeader2 replayListNoDataText\" id=\"replayListNoDataText_ID\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<!-- Data Grid -->\n\t\t\t\t</div> \n\t\t\t</div>\n\t\t\t<div data-dojo-attach-point=\"_replayListFooter\" class=\"replayListFooter\"></div>\n\t\t</div>\n\t</div>\t\t\n</div>\n",
'url:webui/widgets/common/templates/Toolbar.html':"<div>\n\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t</div>\n</div>\n",
'url:webui/widgets/resources/templates/resource_overview.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_msgflowOverview_borderContainer\" class=\"common_profileContainer\">\n  \t\t\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"> </div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\t\n\t\t\t<div class=\"_common_infoPanePropertiesPosition\">\n\t\t\t\t<div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_propertyTitlePane\"> </div>\n\t\t\t\t<div class=\"_common_textSpacer\"> </div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n",
'url:webui/widgets/business/templates/businesstransaction_configuration.html':"<div style=\"width:100%;height:100%;\">\n  <div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_businessTransactionConfiguration_borderContainer\" class=\"common_profileContainer\">\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t\t\t<div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n\t\t\t\t<div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_propertyTitlePane\"></div>\n\t\t\t\t<div class=\"_common_textSpacer\"></div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>",
'url:webui/widgets/broker/templates/broker_overview.html':"<div style=\"width:100%;height:100%;\">\n  <div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_brokerOverview_borderContainer\" class=\"common_profileContainer\">\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t\t\t<div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n\n\t\t\t\t<div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_propertyTitlePane\"></div>\n\n\t\t\t\t<div class=\"_common_textSpacer\"></div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<div data-dojo-attach-point=\"_brokerEditEditor\"></div>\n\t<div id=\"brokerEditConfirmCancelDialog\"></div>\n</div>",
'url:webui/widgets/msgflows/templates/MessageFlowStatisticsChart.html':"<div id=\"${id}_messageFlowStatsChartWidgetContainer\"\n     data-dojo-attach-point=\"_messageFlowStatsChartWidgetContainer\"\n     class=\"statsTrend\"\n     style=\"clear:both\">\n    <h3 id=\"${id}_messageFlowStatsChartTitle\"\n         data-dojo-attach-point=\"_messageFlowStatsChartTitle\"\n         class=\"MessageFlowStatsChartTitle\"></h3>\n    <div class=\"selfClear\">\n        <div id=\"${id}_messageFlowStatsChart\"\n             data-dojo-attach-point=\"_messageFlowStatsChart\"\n             class=\"MessageFlowStatsChart\"></div>\n        <div data-dojo-attach-point=\"_messageFlowStatsChartRightTable\"\n             class=\"MessageFlowStatsChartSideTable StatsTrendSideTable\">\n            <table>\n                <tr>\n                    <td colspan=\"2\" class=\"TopLeftRightRad StatsTrendHeading\">\n                        <div data-dojo-type=\"dijit.form.Select\"\n                             data-dojo-attach-point=\"_metricSelect\">\n                        </div>\n                    </td>\n                </tr>\n                <tr>\n                    <td class=\"StatsTrendContent label\">${NLS.statistics.latestTitle}</td>\n                    <td data-dojo-attach-point=\"_latestValue\" class=\"StatsTrendContent value\">0</td>\n\t\t\t\t</tr>\n                <tr>\n                    <td class=\"StatsTrendContent label\">${NLS.statistics.highTitle}</td>\n                    <td data-dojo-attach-point=\"_highestValue\" class=\"StatsTrendContent value\">0</td>\n                </tr>\n                <tr>\n                    <td class=\"StatsTrendContent label\">${NLS.statistics.averageTitle}</td>\n                    <td data-dojo-attach-point=\"_averageValue\" class=\"StatsTrendContent value\">0</td>\n                </tr>\n                <tr>\n                    <td class=\"StatsTrendContent label\">${NLS.statistics.lowTitle}</td>\n                    <td data-dojo-attach-point=\"_lowestValue\" class=\"StatsTrendContent value\">0</td>\n                </tr>\n                <tr>\n                    <td colspan=\"2\" class=\"BottomLeftRightRad StatsTrendHeading lowRise\">&nbsp;</td>\n                </tr>\n            </table>\n\t\t</div>\n    </div>\n</div>\n",
'url:webui/widgets/common/templates/EditTextPropertyValueDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" id=\"editPropertyValueDialog\" title=\"\">\n  <div class=\"dijitDialogTitle\">\n    <span data-dojo-attach-point=\"titleNode\" tabindex=\"0\">  </span>\n    <span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${_buttonCancelLabel}\" role=\"button\" tabIndex=\"-1\">\n      <span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${_buttonCancelLabel}\">x</span>\n    </span>\n  </div>\n  <div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n    <div class=\"dijitDialogPaneContent\" class=\"editPropertyValueDialog\">\n      <input data-dojo-type=\"dijit.form.Textarea\" name=\"editPropertyValueArea\" spellcheck=\"false\" data-dojo-props=\"intermediateChanges: true\" data-dojo-attach-point=\"editPropertyValueArea\" id=\"editPropertyValueArea\" style=\"width: 800px; height: 800px;\"/>      \n    </div>\n  </div>\n  <div class=\"dijitDialogPaneActionBar\">\n    <span>\n    </span>\n    <span style=\"float:right; margin-right:50px\">\n      <button data-dojo-type=\"dijit.form.Button\" type=\"submit\" data-dojo-attach-point=\"_okButton\"> ${_buttonOKLabel}</button>\n      <button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> ${_buttonCancelLabel} </button>\n    </span>\n  </div>\n</div>\n",
'url:webui/login/widgets/SignIn.html':"<div class=\"login_screenTemplateContainer\">\n    <div class=\"login_centeringLoginSpash\"></div>\n    <div class=\"login_splash\">\n        <div class=\"login_productIcon\"></div>\n        <div class=\"login_details\">\n            <p class=\"login_productName\" data-dojo-attach-point=\"login_productName\"></p>\n            <div>\n                <form action=\"j_security_check\" method=\"post\" name=\"loginForm\" target=\"_self\">\n                    <table style=\"width: 370px;\">\n                        <tr>\n                            <td style=\"text-align:left\"><div class=\"dijitHidden\" style=\"padding-top:10px;padding-bottom:0px;color:red\" id=\"signInFailure\" data-dojo-attach-point=\"_failureMessage\"></div></td>\n                        </tr>\n                        <tr>\n                            <td style=\"text-align:left\" class=\"login_label\" data-dojo-attach-point=\"login_id\"></td>\n                        </tr>\n                        <tr>\n                            <td style=\"text-align:left\">\n                            <input class=\"dijitTextBox\" id=\"login_id\" style=\"height:14px\" tabindex=\"1\" value=\"\" size=\"32\" maxlength=\"128\" name=\"j_username\"/>\n                            </td>\n                        </tr>\n                        <tr>\n                            <td style=\"text-align:left\" class=\"login_label\" data-dojo-attach-point=\"login_password\"></td>\n                        </tr>\n                        <tr>\n                            <td style=\"text-align:left\">\n                            <input class=\"dijitTextBox\" style=\"height:14px\" tabindex=\"2\" value=\"\" size=\"32\" maxlength=\"128\" name=\"j_password\" type=\"password\" autocomplete=\"off\"/>\n                            </td>\n                        </tr>\n                        <tr>\n                            <td class=\"login_button\" style=\"text-align:left\">\n                            <input class=\"dijitButtonNode\" type=\"submit\" data-dojo-attach-point=\"login_buttonLabel\" onclick=\"javascript:document.getElementById('action').value='login'\"/>\n                            </td>\n                        </tr>\n                        <tr>\n                            <td colspan=\"1\" style=\"height: 20px;\"> &nbsp; </td>\n                            <td></td>\n                        </tr>\n                    </table>\n                </form>\n            </div>\n\n        </div>\n        <div id=\"login_failure_icon\" class=\"login_failure_icon _common_hideDiv\"></div><div id=\"login_failure\" class=\"login_failure _common_hideDiv\" data-dojo-attach-point=\"login_failure\"></div>\n        <div class=\"login_IBMLogo\" onclick=\"window.location='http://www.ibm.com'\"></div>\n        <p class=\"login_legalText\" data-dojo-attach-point=\"login_legalText\"></p>\n    </div>\n</div>\n",
'url:webui/widgets/business/templates/BTFlowRemovalDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" id = \"btnDetailsDialog\"\n  title=\"\">\n  <div class=\"dijitDialogTitle\">\n    <span  data-dojo-attach-point=\"titleNode\"\n      tabindex=\"0\">  </span>\n    <span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${_buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n      <span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${_buttonCancel}\">x</span>\n    </span>\n  </div>\n  <div class=\"dijitDialogInstruction\" data-dojo-attach-point=\"instructionDiv\">\n    <span role=\"document\" data-dojo-attach-point=\"instructionNode\" tabindex=\"0\" > </span>\n  </div>\n  <div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n    \n    <div class=\"dijitDialogPaneContent\" class=\"btDialog\" data-dojo-attach-point=\"_btdFlowRemovalDialogPane\">\n       <div > ${_btdFlowListLabel} </div>\n\n   <select multiple=\"true\" name=\"multiselect\"  data-dojo-attach-point=\"_flowListSelect\" data-dojo-type=\"dijit.form.MultiSelect\" \n                      id=\"btFlowRemovalList\" class=\"btFlowRemovalList\">\n     </select>\n    \n      \n    </div>\n  </div>\n  <div id =\"flowRemovalSummary\"  data-dojo-attach-point=\"flowRemovalSummary\" \n       class=\"btFlowRemovalSummary\">      \n  </div>\n  \n  <div class=\"dijitDialogPaneActionBar\">\n    <span>\n    </span>\n    <span style=\"float:right; margin-right:50px\">\n      <button data-dojo-type=\"dijit.form.Button\" type=\"submit\" data-dojo-attach-point=\"_okButton\"> ${_btOKLabel}</button>\n      <button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> ${_btCancelLabel} </button>\n    </span>\n  </div>\n</div>\n",
'url:webui/widgets/policy/templates/policy_overview.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_policyOverview_borderContainer\" class=\"common_profileContainer\">\n  \t\t\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\t\n\t\t\t<div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n\t\t\t\t<div class=\"common_Informational\" data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-attach-point=\"_propertyAdditionalInformation\"></div>\n\t\t\t\t<div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_policyEditorDynamicContentPane\"></div>\n\n\t\t\t\t<div class=\"_common_textSpacer\"></div>\n      </div>\n    </div>\n  </div>\n</div>\n",
'url:webui/widgets/restapi/templates/Overview.html':"<div style=\"width:100%;height:100%;\">\n  <div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_restApiOverview_borderContainer\" class=\"common_profileContainer\">\n\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n      <div data-dojo-attach-point=\"_toolbar\"></div>\n    </div>\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n      <div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n\n        <div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_propertyTitlePane\"></div>\n\n        <div class=\"_common_textSpacer\"></div>\n\n      </div>\n    </div>\n  </div>\n</div>",
'url:webui/widgets/dataviewer/templates/DataViewer.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_dataviewer_borderContainer\" class=\"common_profileContainer\">\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\">\n\t\t\t<div id=\"dataviewerFilterBar_ID\" data-dojo-attach-point=\"dataviewerFilterBar\" class=\"dataviewerFilterBar\">\n\t\t\t\t<span id=\"dataviewerFilterBarIcon_ID\" data-dojo-attach-point=\"dataviewerFilterBarIcon\"></span>\n\t\t\t\t<span data-dojo-attach-point=\"dataviewerFilterBarText\" class=\"dataviewerFilterBarText tableSummary\"></span>\n\t\t\t\t<span data-dojo-attach-point=\"dataviewerFilterClearText\" class=\"dataviewerFilterBarClearText\"></span>\n\t\t\t</div>\n\t\t\t<div class=\"gridContainer dataViewerContainer claro\">\n\t\t\t\t<div id=\"_dataviewer_grid_ID\" data-dojo-attach-point=\"_rrr_gridStandby_grid\" style=\"width:100%;height:100%;\">\n\t\t\t\t\t<div data-dojo-attach-point=\"dataviewerNoData\" style=\"opacity:0.75;\" class=\"oneui pageHeader2 dataviewerNoData\" id=\"dataviewerNoData_ID\"></div>\n\t\t\t\t\t<!-- Data Grid -->\n\t\t\t\t</div>\n\t\t\t\t<div data-dojo-attach-point=\"_rrr_paginationFooter\" class=\"dataviewerFooter\"></div>\n\t\t\t</div>\n\t\t\t<div id=\"confirmationQuestion\"></div>\n\t\t</div>\n\t</div>\n</div>\n",
'url:webui/widgets/restapi/templates/BulkRESTApiPushDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" id=\"_restApiPushDialog\" title=\"\">\n\t<div class=\"dijitDialogTitle\">\n\t\t<span class=\"pageHeader2\" data-dojo-attach-point=\"titleNode\"> ${_pushApisTitle} </span>\n\t\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" k=\"button\" tabIndex=\"-1\">\n\t\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\">x</span>\n\t\t</span>\n\t</div>\n\t<div class=\"dijitDialogInstruction\">\n\t\t<span role=\"document\" data-dojo-attach-point=\"_pushApisPageDescription\">${_pushApisConnDesc}</span>\n\t</div>\n\t<div data-dojo-attach-point=\"_pushDialogSection\" class=\"dijitDialogPaneContentWrapper restApis_pushDialog_section\">\n\t\t<div data-dojo-attach-point=\"_pushConnectionDetailsSection\" class=\"\">\n\t\t\t<div class=\"restApis_pushDialog_instruction\">\n\t\t\t\t<span role=\"document\" data-dojo-attach-point=\"_pushApisDescription\">${_pushApisServerDesc}</span>\n\t\t\t</div>\n\t\t\t<div class=\"dijitDialogPaneContent\">\n\t\t\t\t<table class=\"restApis_pushDialog_table\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_label\">\n\t\t\t\t\t\t\t<label for=\"_APICHostText\" data-dojo-attach-point=\"_pushApisHostLabel\">${_pushApisHost}</label>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_value\">\n\t\t\t\t\t\t\t<input maxlength=100 data-dojo-type=\"dijit.form.ValidationTextBox\" name=\"apiCHostText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\t\tdata-dojo-attach-point=\"_APICHostText\" class=\"restApis_pushDialog_input\"/>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_label\">\n\t\t\t\t\t\t\t<label for=\"_APICPortText\" data-dojo-attach-point=\"_pushApisPortLabel\">${_pushApisPort}</label>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_value\">\n\t\t\t\t\t\t\t<input maxlength=6 data-dojo-type=\"dijit.form.ValidationTextBox\" name=\"apiCPortText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\t\tdata-dojo-attach-point=\"_APICPortText\" class=\"restApis_pushDialog_input\"/>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t\t<div class=\"restApis_pushDialog_instruction\">\n\t\t\t\t<span role=\"document\">${_pushApisAuthDesc}</span>\n\t\t\t</div>\n\t\t\t<div class=\"dijitDialogPaneContent\">\n\t\t\t\t<table class=\"restApis_pushDialog_table\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_label\">\n\t\t\t\t\t\t\t<label for=\"_APICUserText\" data-dojo-attach-point=\"_pushApisUserLabel\" >${_pushApisUser}</label>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_value\">\n\t\t\t\t\t\t\t<input maxlength=50 data-dojo-type=\"dijit.form.ValidationTextBox\" name=\"apiCUserText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\t\tdata-dojo-attach-point=\"_APICUserText\" class=\"restApis_pushDialog_input\"/>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_label\">\n\t\t\t\t\t\t\t<label for=\"_APICPasswordText\" data-dojo-attach-point=\"_pushApisPasswordLabel\" >${_pushApisPassword}</label>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_value\">\n\t\t\t\t\t\t\t<input maxlength=50 data-dojo-type=\"dijit.form.ValidationTextBox\" name=\"apiCPasswordText\" data-dojo-props=\"intermediateChanges: true, type: 'password'\"\n\t\t\t\t\t\t\t\tdata-dojo-attach-point=\"_APICPasswordText\" class=\"restApis_pushDialog_input\"/>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t\t<div data-dojo-attach-point=\"_pushApisConnectSection\" class=\"_pushApis_pushDialog_connectSection\">\n\t\t\t\t<div class=\"restApis_pushDialog_buttonContainer\">\n\t\t\t\t\t<span>\n\t\t\t\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_connectButton\"> ${_pushApisTestLabel} </button>\n\t\t\t\t\t</span>\n\t\t\t\t</div>\n\t\t\t\t<div data-dojo-attach-point=\"_pushApisConnectFeedback\" class=\"_pushApis_pushDialog_feedbackSection restApis_pushDialog_step_hidden\">\n\t\t\t\t\t<table class=\"restApis_pushDialog_feedback_table\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"restApis_pushDialog_feedback_table_icon\">\n\t\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_pushApisConnectFeedbackIcon\" class=\"restApis_pushDialog_feedbackIcon\"></div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td class=\"restApis_pushDialog_feedback_table_text\">\n\t\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_pushApisConnectFeedbackInfo\" class=\"instruction\"></div>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<div data-dojo-attach-point=\"_pushProductSection\" class=\"restApis_pushDialog_step_hidden\">\n\t\t\t<div class=\"restApis_pushDialog_instruction\">\n\t\t\t\t<span role=\"document\" data-dojo-attach-point=\"_pushApisOrganizationDescription\">${_pushApisOrganizationDesc}</span>\n\t\t\t</div>\n\t\t\t<div class=\"dijitDialogPaneContent\">\n\t\t\t\t<table class=\"restApis_pushDialog_table\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_label\">\n\t\t\t\t\t\t\t<label for=\"_APICOrganizationText\" data-dojo-attach-point=\"_pushApisOrganizationLabel\">${_pushApisOrganization}</label>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_value\">\n\t\t\t\t\t\t\t<select data-dojo-type=\"dijit.form.Select\" name=\"apiCOrganizationSelect\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\t\tdata-dojo-attach-point=\"_APICOrganizationSelect\" class=\"restApis_pushDialog_select\"/></select>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t\t<div data-dojo-attach-point=\"_pushApisOrganizationFeedback\" class=\"_pushApis_pushDialog_feedbackSection restApis_pushDialog_step_hidden\">\n\t\t\t\t\t\t<table class=\"restApis_pushDialog_feedback_table\">\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td class=\"restApis_pushDialog_feedback_table_icon\">\n\t\t\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_pushApisOrganizationFeedbackIcon\" class=\"restApis_pushDialog_feedbackIcon\"></div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td class=\"restApis_pushDialog_feedback_table_text\">\n\t\t\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_pushApisOrganizationFeedbackInfo\" class=\"instruction\"></div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</table>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"restApis_pushDialog_instruction\">\n\t\t\t\t\t<span role=\"document\" data-dojo-attach-point=\"_pushApisProductDescription\">${_pushApisProductDesc}</span>\n\t\t\t\t</div>\n\t\t\t\t<table class=\"restApis_pushDialog_table\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_label\">\n\t\t\t\t\t\t\t<label for=\"_APICProductTitleText\" data-dojo-attach-point=\"_pushApisProductTitleLabel\">${_pushApisProductTitle}</label>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_value\">\n\t\t\t\t\t\t\t<input maxlength=100 data-dojo-type=\"dijit.form.ValidationTextBox\" name=\"apiCProductTitleText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\t\tdata-dojo-attach-point=\"_APICProductTitleText\" class=\"restApis_pushDialog_input\"/>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_label\">\n\t\t\t\t\t\t\t<label for=\"_APICProductNameText\" data-dojo-attach-point=\"_pushApisProductNameLabel\">${_pushApisProductName}</label>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_value\">\n\t\t\t\t\t\t\t<input maxlength=100 data-dojo-type=\"dijit.form.ValidationTextBox\" name=\"apiCProductNameText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\t\tdata-dojo-attach-point=\"_APICProductNameText\" class=\"restApis_pushDialog_input\"/>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_label\">\n\t\t\t\t\t\t\t<label for=\"_APICProductVersionText\" data-dojo-attach-point=\"_pushApisProductVersionLabel\">${_pushApisProductVersion}</label>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_value\">\n\t\t\t\t\t\t\t<input maxlength=12 data-dojo-type=\"dijit.form.ValidationTextBox\" name=\"apiCProductVersion\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\t\tdata-dojo-attach-point=\"_APICProductVersion\" class=\"restApis_pushDialog_input\"/>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t\t<div data-dojo-attach-point=\"_pushApisProductFeedback\" class=\"_pushApis_pushDialog_feedbackSection restApis_pushDialog_step_hidden\">\n\t\t\t\t\t\t<table class=\"restApis_pushDialog_feedback_table\">\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td class=\"restApis_pushDialog_feedback_table_icon\">\n\t\t\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_pushApisProductFeedbackIcon\" class=\"restApis_pushDialog_feedbackIcon\"></div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td class=\"restApis_pushDialog_feedback_table_text\">\n\t\t\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_pushApisProductFeedbackInfo\" class=\"instruction\"></div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</table>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"restApis_pushDialog_instruction\">\n\t\t\t\t\t<span role=\"document\" data-dojo-attach-point=\"_pushApisCatalogDescription\">${_pushApisCatalogDesc}</span>\n\t\t\t\t</div>\n\t\t\t\t<table class=\"restApis_pushDialog_table\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_label\">\n\t\t\t\t\t\t\t<label for=\"_APICCatalogText\" data-dojo-attach-point=\"_pushApisCatalogLabel\">${_pushApisCatalog}</label>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_table_value\">\n\t\t\t\t\t\t\t<select data-dojo-type=\"dijit.form.Select\" name=\"apiCCatalogSelect\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\t\tdata-dojo-attach-point=\"_APICCatalogSelect\" class=\"restApis_pushDialog_select\"/></select>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t\t<div data-dojo-attach-point=\"_pushApisCatalogFeedback\" class=\"_pushApis_pushDialog_feedbackSection restApis_pushDialog_step_hidden\">\n\t\t\t\t\t\t<table class=\"restApis_pushDialog_feedback_table\">\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td class=\"restApis_pushDialog_feedback_table_icon\">\n\t\t\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_pushApisCatalogFeedbackIcon\" class=\"restApis_pushDialog_feedbackIcon\"></div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<td class=\"restApis_pushDialog_feedback_table_text\">\n\t\t\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_pushApisCatalogFeedbackInfo\" class=\"instruction\"></div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</table>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t<div data-dojo-attach-point=\"_pushSelectSection\" class=\"restApis_pushDialog_step_hidden\">\n\t\t\t<div class=\"dijitDialogPaneContent\" data-dojo-attach-point=\"_pushSelectContentSection\"></div>\n\t\t\t<div data-dojo-attach-point=\"_pushApisSelectFeedback\" class=\"_pushApis_pushDialog_feedbackSection restApis_pushDialog_step_hidden\">\n\t\t\t\t<table class=\"restApis_pushDialog_feedback_table\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_feedback_table_icon\">\n\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_pushApisSelectFeedbackIcon\" class=\"restApis_pushDialog_feedbackIcon validationIcon_error\"></div>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_pushDialog_feedback_table_text\">\n\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_pushApisSelectFeedbackInfo\" class=\"instruction\"></div>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</div>\n\t\t</div>\n\t\t<div data-dojo-attach-point=\"_pushAdvancedSection\" class=\"restApis_pushDialog_step_hidden\">\n\t\t\t<div class=\"restApis_pushDialog_instruction\">\n\t\t\t\t<span role=\"document\" data-dojo-attach-point=\"_pushApisAdvancedDescription\">${_pushApisOverrideHTTPTitle}</span>\n\t\t\t\t<table class=\"restApis_pushDialog_feedback_table\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"restApis_overrideDescription\">${_pushApisOverrideHTTPDesc}</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t\t<table class=\"restApis_overrideURL_table\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"restApis_overrideURL_table_label\"></td>\n\t\t\t\t\t\t<td class=\"restApis_overrideURL_table_host\">${_pushApisAPIHostTitle}</td>\n\t\t\t\t\t\t<td class=\"restApis_overrideURL_table_separator\"></td>\n\t\t\t\t\t\t<td class=\"restApis_overrideURL_table_port\">${_pushApisAPIPortTitle}</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"restApis_overrideURL_table_label\">\n\t\t\t\t\t\t\t<label for=\"_APICHTTPHostText\" data-dojo-attach-point=\"_pushApisHTTPLabel\">${_pushApisHTTP}</label>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_overrideURL_table_host\">\n\t\t\t\t\t\t\t<input maxlength=100 data-dojo-type=\"dijit.form.ValidationTextBox\" name=\"apiCHTTPHostText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\t\tdata-dojo-attach-point=\"_APICHTTPHostText\" class=\"restApis_pushDialog_input\"/>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_overrideURL_table_separator\">\n\t\t\t\t\t\t\t<label for=\"_APICHTTPPortText\" data-dojo-attach-point=\"_pushApisHTTPLabel\">${_pushApisPortSeparator}</label>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_overrideURL_table_port\">\n\t\t\t\t\t\t\t<input maxlength=10 data-dojo-type=\"dijit.form.ValidationTextBox\" name=\"apiCPortHTTPText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\t\tdata-dojo-attach-point=\"_APICHTTPPortText\" class=\"restApis_pushDialog_input\"/>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td class=\"restApis_overrideURL_table_label\">\n\t\t\t\t\t\t\t<label for=\"_APICHTTPSHostText\" data-dojo-attach-point=\"_pushApisHTTPSLabel\">${_pushApisHTTPS}</label>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_overrideURL_table_host\">\n\t\t\t\t\t\t\t<input maxlength=100 data-dojo-type=\"dijit.form.ValidationTextBox\" name=\"apiCHTTPSHostText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\t\tdata-dojo-attach-point=\"_APICHTTPSHostText\" class=\"restApis_pushDialog_input\"/>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_overrideURL_table_separator\">\n\t\t\t\t\t\t\t<label for=\"_APICHTTPSPortText\" data-dojo-attach-point=\"_pushApisHTTPSLabel\">${_pushApisPortSeparator}</label>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t\t<td class=\"restApis_overrideURL_table_post\">\n\t\t\t\t\t\t\t<input maxlength=10 data-dojo-type=\"dijit.form.ValidationTextBox\" name=\"apiCPortHTTPSText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\t\tdata-dojo-attach-point=\"_APICHTTPSPortText\" class=\"restApis_pushDialog_input\"/>\n\t\t\t\t\t\t</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</div>\n                </div>\n\t</div>\n\t<div class=\"dijitDialogPaneActionBar\">\n\t\t<span style=\"float:right; margin-right:50px\">\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_previousButton\"> ${_pushApisPreviousLabel} </button>\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_nextButton\"> ${_pushApisNextLabel} </button>\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_pushButton\"> ${_pushApisPushLabel} </button>\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> ${_pushApisCancelLabel} </button>\n\t\t</span>\n\t</div>\n</div>\n",
'url:webui/widgets/policy/templates/MessageDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" id = \"policyMessageDialog\" title=\"\">\n  <div class=\"dijitDialogTitle\">\n    <span data-dojo-attach-point=\"titleNode\" tabindex=\"0\">  </span>\n    <span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${_buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n      <span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${_buttonCancel}\">x</span>\n    </span>\n  </div>\n  <div class=\"dijitDialogInstruction\" data-dojo-attach-point=\"instructionDiv\">\n    <span role=\"document\" data-dojo-attach-point=\"instructionNode\" tabindex=\"0\"> </span>\n  </div>\n  <div class=\"dijitDialogPaneActionBar\">\n    <span>\n    </span>\n    <span style=\"float:right\">\n      <button data-dojo-type=\"dijit.form.Button\" type=\"submit\" data-dojo-attach-point=\"_okButton\"> ${_messageOKLabel}</button>\n    </span>\n  </div>\n</div>\n",
'url:webui/widgets/executiongroup/templates/DeployBARDialog.html':"<div data-dojo-type=\"dijit.Dialog\" class=\"idxDialog\" id=\"_deployBARDialog\" style=\"width:800px; height:460px;\">\n\t<div class=\"dijitDialogTitle\">\n\t\t<span class=\"pageHeader2\" data-dojo-attach-point=\"titleNode\" tabindex=\"-1\">${NLS.deployBARDialogTitle}</span>\n\t\t<div data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t\t</div>\n\t</div>\n\t<div class=\"dijitDialogInstruction\">\n\t\t<span role=\"document\" data-dojo-attach-point=\"instructionNode\" class=\"instructional\" tabindex=\"-1\">${NLS.deployBARInstruction}</span>\n\t\t<div class=\"barMessageArea\">\n\t\t\t<span data-dojo-attach-point=\"messageIcon\"></span>\n\t\t\t<span data-dojo-attach-point=\"messageArea\"></span>\n\t\t</div>\n\t</div>\n\t<div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n        <form method=\"post\" data-dojo-attach-point=\"_form\" id=\"_formDeploy\" enctype=\"multipart/form-data\">\n\t\t    <div class=\"dijitDialogPaneContent\" style=\"width:660px; height:390px;\">\n                <div data-dojo-type=\"idx.form.TextBox\"\n                     data-dojo-props=\"style: 'width:80%', name: 'filename', readOnly: true, label: '${NLS.labelBAR}', labelWidth: 100, labelAlignment: 'horizontal', trim: true\"\n                     data-dojo-attach-point=\"_barFileName\">\n                </div>\n                <input name=\"barFile\" type=\"file\" id=\"barUploader\"\n                       data-dojo-type=\"dojox.form.Uploader\"\n                       data-dojo-props=\"label: '${NLS.buttonChoose}'\"\n                       data-dojo-attach-point=\"_barLoader\"/>\n                <input name=\"escapedBarFileName\" type=\"text\"\n                       data-dojo-attach-point=\"_escapedBarFileName\"\n                       style=\"display: none;\" />\n\t\t\t\t<div id=\"progressBarDiv\"\n\t\t\t\t     style=\"width: 100%; visibility: hidden;\"\n                     data-dojo-type=\"dijit.ProgressBar\"\n                     data-dojo-attach-point=\"_uploadProgressBar\">\n\t\t\t\t</div>\n\t\t\t\t<div data-dojo-attach-point=\"_treeLabel\">${NLS.labelConfiguredProperties}</div>\n                <span data-dojo-type=\"dojo.data.ItemFileWriteStore\"\n                      data-dojo-props=\"data: ${data}\"\n                      data-dojo-id=\"dataStore\">\n                </span>\n                <div data-dojo-type=\"dijit.tree.ForestStoreModel\" data-dojo-id=\"storeModel\"\n                     data-dojo-props=\"store: dataStore, childrenAttrs: 'children'\"></div>\n                <div style=\"height: 75%;\">\n                    <table data-dojo-id=\"grid\"\n                           data-dojo-type=\"dojox.grid.TreeGrid\"\n                           data-dojo-props=\"treeModel: storeModel, classTag: 'barTreeGrid', escapeHTMLInData: true, selectable: false, editable: false, selectionMode: 'none', columnReordering: false, defaultOpen: false, rowSelector: false\"\n                           data-dojo-attach-point=\"_propTreeGrid\">\n                        <thead>\n                            <tr>\n                                <th field=\"property\" width=\"60%\">${NLS.deployPreviewContentColumn}</th>\n                                <th field=\"value\" width=\"40%\">${NLS.deployPreviewValueColumn}</th>\n                            </tr>\n                        </thead>\n                    </table>\n                </div>\n                <div id=\"overridesDropDownButton\"\n                     data-dojo-type=\"dijit.form.ComboButton\"\n                     data-dojo-props=\"name: 'overridesDropDownButton', disabled: true, label: '${NLS.buttonOverrides}'\"\n                     data-dojo-attach-point=\"_overridesDropDownButton\">\n\t                <div id=\"overridesDropDownDiv\"\n\t                     style=\"display: none;\"\n\t                     data-dojo-type=\"dijit.DropDownMenu\"\n\t                     data-dojo-attach-point=\"_menuOverrides\">\n\t                    <div data-dojo-type=\"dijit.MenuItem\"\n\t                         data-dojo-props=\"label: '${NLS.menuSelectOverrides}'\"\n\t                         data-dojo-attach-point=\"_menuItemSelectOverrides\">\n\t                    </div>                \n\t                    <div data-dojo-type=\"dijit.MenuItem\"\n\t                         data-dojo-props=\"label: '${NLS.menuClearOverrides}'\"\n\t                         data-dojo-attach-point=\"_menuItemClearOverrides\">\n\t                    </div>                \n\t                </div>\n\t            </div>\n                <input name=\"overridesFile\" type=\"file\"\n                       data-dojo-type=\"dojox.form.Uploader\"\n                       data-dojo-props=\"disabled: true, label: '${NLS.buttonChoose}'\"\n                       data-dojo-attach-point=\"_overridesLoader\"\n                       style=\"display: none;\" />\n                <input name=\"escapedOverridesFileName\" type=\"text\"\n                       data-dojo-attach-point=\"_escapedOverridesFileName\"\n                       style=\"display: none;\" />\n\t\t\t\t<div id=\"hiddenOverridesUploadDiv\"></div>\n            </div>\n        </form>\n\t</div>\n\t<div class=\"dijitDialogPaneActionBar\">\n\t\t<span>\n\t\t</span>\n\t\t<span style=\"float:right;\">\n\t\t\t<button type=\"submit\"\n\t\t\t        data-dojo-type=\"dijit.form.Button\"\n\t\t\t        data-dojo-props=\"disabled: true, label: '${NLS.buttonDeploy}'\"\n\t\t\t        data-dojo-attach-point=\"_okButton\">\n            </button>\n\t\t\t<button type=\"button\"\n\t\t\t        data-dojo-type=\"dijit.form.Button\"\n                    data-dojo-props=\"label: '${NLS.cancelButtonLabel}'\"\n\t\t\t        data-dojo-attach-point=\"_cancelButton\">\n            </button>\n\t\t</span>\n\t</div>\n</div>\n",
'url:webui/widgets/configurableservice/templates/cs_overview.html':"<div style=\"width:100%;height:100%;\">\n  <div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_csOverview_borderContainer\" class=\"common_profileContainer\">\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t\t\t<div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition _common_contentPanePosition\">\t\n\t\t\t\t<div data-dojo-attach-point=\"_propertyTitlePane\"></div>\n\t\t\t\t<span data-dojo-attach-point=\"_csOverviewAdditionalInformation\"></span>\n\t\t\t</div>\t\n\t\t</div>\n\t</div>\n\t<div data-dojo-attach-point=\"_csEditEditor\"></div>\n\t<div id=\"csEditConfirmSwitchDialog\"></div>\n\t<div id=\"csEditConfirmCancelDialog\"></div>\n</div>\n",
'url:webui/widgets/adminlog/templates/adminlog.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_adminlog_borderContainer\" class=\"common_profileContainer\">\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: false\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t\t\t<div class=\"gridContainer adminlogContainer claro _common_contentPanePosition\">\n\t\t\t\t<div id=\"_adminlog_grid_ID\" data-dojo-attach-point=\"_adminlog_grid\" style=\"width:100%;height:100%;\">\n\t\t\t\t\t<div data-dojo-attach-point=\"adminlogNoData\" style=\"opacity:1;\" class=\"dataviewerNoData\" id=\"adminlogNoData_ID\"></div>\n\t\t\t\t\t<!-- Data Grid -->\n\t\t\t\t</div>\n\t\t\t\t<div data-dojo-attach-point=\"footer\" class=\"adminlogFooter\"></div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<div id=\"adminlogLoading_ID\" data-dojo-attach-point=\"adminlogLoading\" class=\"logGridTotal\"></div>\n</div>\n",
'url:webui/widgets/policy/templates/policyActionDialog.html':"<div data-dojo-attach-point=\"_node_policy_tooltip\" >\n\t<div data-dojo-attach-point=\"_node_policy_tooltip_toolbar\" class=\"policy_tooltip_toolbar\">\n\t\t<span class=\"policy_tooltip_closeTextContainer\">\n\t\t\t<div data-dojo-attach-point=\"_node_policy_tooltip_close_text\" class=\"policy_tooltip_closeText\" tabindex=\"0\">x</div>\n\t\t</span>\n\t\t<span data-dojo-attach-point=\"_node_policy_actions_heading\" class=\"policy_tooltip_title\"></span>\t\n\t</div>\n\t<div data-dojo-attach-point=\"_node_policy_actions\" class=\"policy_tooltip_body\"></div>\n</div>",
'url:webui/widgets/msgflows/templates/MessageFlowPropertiesEditor.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_messageFlowEditor_borderContainer\" class=\"common_profileContainer\">\n    \n    \t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n    \t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t\t    <div id=\"editPropertyValueDialog\"></div>\n    \t\t<table class=\"messageFlowEditorTable\" id=\"messageFlowEditorTable\" style=\"display:none;\">\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"messageFlowName\" class=\"messageFlowEditorLabel\">${_messageFlowNameLabel}</label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"messageFlowName\" intermediateChanges=\"true\" data-dojo-attach-point=\"_messageFlowName\" id=\"messageFlowName\" class=\"messageFlowEditorAttribute\" spellcheck=\"false\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"messageFlowTypeName\" class=\"messageFlowEditorLabel\">${_messageFlowTypeLabel}</label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.FilteringSelect\" name=\"messageFlowTypeName\" data-dojo-attach-point=\"_messageFlowTypeName\" id=\"messageFlowTypeName\" class=\"messageFlowEditorAttribute\" spellcheck=\"false\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t\t\n\t\t\t<p/>\n\t\t\t<table class=\"messageFlowEditorTable\">\n\t\t\t\t<tr>\n\t\t\t\t\t<div data-dojo-attach-point=\"_messageFlowProperties\" id=\"_messageFlowProperties\" class=\"messageFlowEditorGrid\"></div>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t</div>\n\t</div>\n</div>",
'url:webui/widgets/broker/templates/FilteringOptionsDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" \n\ttitle=\"\">\n\t<div class=\"dijitDialogTitle\">\n\t\t<span class=\"pageHeader2\" data-dojo-attach-point=\"titleNode\"\n\t\t\ttabindex=\"0\"> </span>\n\t\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t\t</span>\n\t</div>\n\t<div class=\"dijitDialogInstruction\" data-dojo-attach-point=\"instructionDiv\">\n\t\t<span role=\"document\" data-dojo-attach-point=\"instructionNode\"\n\t\t\tclass=\"instructional\" tabindex=\"0\" > </span>\n\t</div>\n\t<div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n\t\t<div class=\"dijitDialogPaneContent\" style=\"width:100%; height:100%; border-width:0px\">\n\t\t\n      <div data-dojo-type=\"dijit.TitlePane\" data-dojo-props=\"open: true\" title=\"${_ResourcesTitlePaneLabel}\">\n        <label class=\"_common_filter_radio\"></label>\n        <input type=\"radio\" id=\"bt_all\"  name=\"bt_filter_radio_group\" checked data-dojo-type=\"dijit.form.RadioButton\"\n          data-dojo-attach-point=\"_allResourcesRadioButton\" >\n        <label  for=\"bt_all\">${_btAllResourcesLabel}</label>\n        <br>\n        <br>\n        <label class=\"_common_filter_radio\"></label>\n\t      <input type=\"radio\" id=\"bt_onlyflows\" name=\"bt_filter_radio_group\" data-dojo-type=\"dijit.form.RadioButton\"\n          data-dojo-attach-point=\"_onlyFlowsRadioButton\">\n\t      <label for=\"bt_onlyflows\">${_btOnlyFlowsLabel}</label>\n      </div>\n      <div data-dojo-type=\"dijit.TitlePane\" data-dojo-props=\"open: true\" title=\"${_ConfigurableServicesTitlePaneLabel}\">\n        <label class=\"_common_filter_check\"></label>\n\t\t\t\t<input type=\"checkbox\" id=\"bt_show_ibm\" checked data-dojo-type=\"dijit.form.CheckBox\" data-dojo-attach-point=\"_showIBMCheckBox\" >\n\t\t\t\t<label for=\"bt_show_ibm\">${_btShowIBMLabel}</label>\n      </div>\n\t\t</div>\n\t</div>\n\t<div class=\"dijitDialogPaneActionBar\">\n\t\t<span>\n\t\t</span>\n\t\t<span style=\"float:right; margin-right:50px\">\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"submit\" data-dojo-attach-point=\"_okButton\"> </button>\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> </button>\n\t\t</span>\n\t</div>\n</div>",
'url:webui/widgets/libraries/templates/lib_overview.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_egOverview_borderContainer\" class=\"common_profileContainer\">\n\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t\t\t<div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n\n\t\t\t\t<div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_propertyTitlePane\"></div>\n\n\t\t\t\t<div class=\"_common_textSpacer\"></div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n",
'url:webui/widgets/common/templates/EditPropertyValueDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" id=\"editPropertyValueDialog\" title=\"\">\n  <div class=\"dijitDialogTitle\">\n    <span data-dojo-attach-point=\"titleNode\" tabindex=\"0\">  </span>\n    <span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${_buttonCancelLabel}\" role=\"button\" tabIndex=\"-1\">\n      <span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${_buttonCancelLabel}\">x</span>\n    </span>\n  </div>\n  <div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n    <div class=\"dijitDialogPaneContent\" class=\"editPropertyValueDialog\">\n      <input data-dojo-type=\"dijit.form.Textarea\" name=\"editPropertyValueArea\" spellcheck=\"false\" data-dojo-props=\"intermediateChanges: true\" data-dojo-attach-point=\"editPropertyValueArea\" id=\"editPropertyValueArea\" style=\"width: 800px; height: 800px;\"/>      \n    </div>\n  </div>\n  <div class=\"dijitDialogPaneActionBar\">\n    <span>\n    </span>\n    <span style=\"float:right; margin-right:50px\">\n      <button data-dojo-type=\"dijit.form.Button\" type=\"submit\" data-dojo-attach-point=\"_okButton\"> ${_buttonOKLabel}</button>\n      <button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> ${_buttonCancelLabel} </button>\n    </span>\n  </div>\n</div>\n",
'url:webui/widgets/business/templates/businesstransaction_summary.html':"<div data-dojo-attach-point=\"_btxSummaryWidget\" class=\"btSummaryWidget\">\n  <div data-dojo-attach-point=\"_btxSummaryTitle\" class=\"btEventSummaryTitle\">${_businessTransactionSummaryLabel}</div>\n  <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-attach-point=\"_btxSummaryDetails\" class=\"btEventSummaryDetails\">\n  \t<div class=\"btSummary_Property\">\n  \t\t<span class=\"btSummary_Property_Label\">\n  \t\t\t<div data-dojo-attach-point=\"_businessTransactionName_Label\" id=\"_businessTransactionName_Label\">${_businessTransactionNameLabel}</div>\n \t\t</span>\n \t\t<span class=\"btSummary_Property_Input\">\n \t\t\t<input class=\"btSummaryProperty_Input_Validation\" value=\"${_businessTransactionNameInput}\" data-dojo-type=\"dijit.form.ValidationTextBox\" data-dojo-attach-point=\"_businessTransactionName_Input\" data-dojo-props=\"id: '_businessTransactionName_Input'\" >\n \t\t\t</input>\n \t\t</span>\n \t</div>\n \t<div class=\"btSummary_Property\">\n \t\t<span class=\"btSummary_Property_Label\">\n \t\t\t<div data-dojo-attach-point=\"_businessTransactionDescription_Label\" id=\"_businessTransactionDescription_Label\">${_businessTransactionDescriptionLabel}</div>\n \t\t</span>\n \t\t<span class=\"btSummary_Property_Input\">\n \t\t\t<textarea class=\"btSummaryProperty_Input_Textarea\" value=\"${_businessTransactionDescriptionInput}\" data-dojo-type=\"dijit.form.Textarea\" data-dojo-attach-point=\"_businessTransactionDescription_Input\" data-dojo-props=\"id: '_businessTransactionDescription_Input'\">\n \t\t\t</textarea>\n \t\t</span>\n \t</div>\n  </div>\n  <div data-dojo-type=\"dijit.TitlePane\" data-dojo-props=\"open: true\" data-dojo-attach-point=\"_eventsTp\"></div>\n  <div data-dojo-type=\"dijit.TitlePane\" data-dojo-props=\"open: false\" data-dojo-attach-point=\"_correlationTp\"></div>\n  <div data-dojo-type=\"dijit.TitlePane\" data-dojo-props=\"open: false\" data-dojo-attach-point=\"_dataTp\"></div>\n</div>",
'url:webui/widgets/policy/templates/policy_attach.html':"<div style=\"width:100%;height:100%;\">\n    <div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_policyAttach_borderContainer\" class=\"policy_profileContainer\">\n        \n        <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n            <div data-dojo-attach-point=\"_infopane_toolbar\"> </div>\n        </div>\n        <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\">  \n        \t<div class=\"policy_quickViewTitlePane\" style=\"padding-left:20px\" data-dojo-attach-point=\"_policyAttachDynamic\"> \n        \t</div>\n          <div class=\"policyCanvasContainer\" style=\"padding-left:20px\" data-dojo-attach-point=\"_flowProfileTitlePane\">\t</div>\n        </div>\n    </div>\n</div>\n",
'url:webui/widgets/my_profile/templates/MyProfile_Properties.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_profile_borderContainer\" class=\"common_profileContainer\">\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t\t\t<div id=\"_profilePropertiesInfoPane_ID\" data-dojo-attach-point=\"_profilePropertiesInfoPane\" style=\"padding-left:30px;\">\n\t\t\t\t<div class=\"_common_SubTitle portletHeader2\" data-dojo-attach-point=\"_profilePropertiesUsernameTitle\"></div>\n\t\t\t\t<div class=\"_common_subText\" data-dojo-attach-point=\"_profilePropertiesUsernameText\"></div>\n\t\t\t\t<div class=\"_common_subValue\" data-dojo-attach-point=\"_profile_property_userID_value\"></div>\n\n\t\t\t\t<div class=\"_common_SubTitle portletHeader2\" data-dojo-attach-point=\"_profilePropertiesRoleTitle\"></div>\n\t\t\t\t<div class=\"_common_subText\"></div>\n\t\t\t\t<div class=\"_common_subValue\" data-dojo-attach-point=\"_profile_property_role_value\"></div>\n\n\t\t\t\t<div class=\"_common_tabSpacer\"></div>\n\t\t\t\t<div data-dojo-attach-point=\"_profilePropertiesPassword\" class=\"_common_hideDiv\">\n\t\t\t\t\t<div class=\"_common_SubTitle portletHeader2\" data-dojo-attach-point=\"_profilePropertiesPasswordTitle\"></div>\n\t\t\t\t\t<div class=\"_common_subText\" data-dojo-attach-point=\"_profilePropertiesPasswordText\"></div>\n\t\t\t\t\t<div class=\"_common_subValue\">\n\t\t\t\t\t\t<div id=\"_profilePropertiesChangePasswordLink_ID\" data-dojo-attach-point=\"_profilePropertiesChangePasswordLink\">\n\t\t\t\t\t\t\t<a class=\"_changePasswordLink\" data-dojo-attach-point=\"_profilePropertiesChangePasswordLinkText\"> </a>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div id=\"_profilePropertiesChangePasswordFields_ID\" data-dojo-attach-point=\"_profilePropertiesChangePasswordFields\" style=\"display:none\">\n\t\t\t\t\t\t\t<div class=\"_common_profilePasswordText\" data-dojo-attach-point=\"_profilePropertiesCurrentPasswordText\"></div>\n\t\t\t\t\t\t\t<div class=\"_common_profilePasswordField\">\n\t\t\t\t\t\t\t\t<input type=\"password\" data-dojo-type=\"idx.form.TextBox\" data-dojo-attach-point=\"_profile_property_password_current\" align=\"right\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"_common_profilePasswordText\" data-dojo-attach-point=\"_profilePropertiesNewPasswordText\"></div>\n\t\t\t\t\t\t\t<div class=\"_common_profilePasswordField\">\n\t\t\t\t\t\t\t\t<input type=\"password\" data-dojo-type=\"idx.form.TextBox\" data-dojo-attach-point=\"_profile_property_password_new\" align=\"right\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"_common_profilePasswordIcon\" data-dojo-attach-point=\"_profilePasswordRules\">\n\t\t\t\t\t\t\t\t<!--<div data-dojo-attach-point=\"_profilePropertiesPasswordRules\" id=\"_profilePropertiesPasswordRules_ID\" href=\"#\" onclick=\"oneui.HoverHelp.defaultPosition=['after-centered','before-centered']\" onmouseover=\"oneui.HoverHelp.defaultPosition=['after-centered','before-centered']\" class=\"_common_profilePasswordRulesIcon\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<span id=\"_profilePropertiesPasswordRulesToolTip_ID\" data-dojo-type=\"oneui.HoverHelp\" data-dojo-props='connectId:[\"_profilePropertiesPasswordRules_ID\"]'>\n\t\t\t\t\t\t\t\t<div id=\"_profilePropertiesPasswordRulesText\" data-dojo-attach-point=\"_profilePropertiesPasswordRulesText\">\n\t\t\t\t\t\t\t\t<div id=\"_profilePropertiesPasswordRulesToolTip_ID\"  style=\"text-align:center;font-weight: bold;\">Password Rules</div>\n\t\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_profilePropertiesPasswordRulesLengthIconWarning\" class=\"_common_profilePasswordRulesIcon _common_profilePasswordRulesAlign _common_profilePasswordRulesIconWarning\"></div>\n\t\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_profilePropertiesPasswordRulesLengthIconSuccess\" class=\"_common_profilePasswordRulesIcon _common_profilePasswordRulesAlign _common_profilePasswordRulesIconSuccess\" style=\"display:none\"></div>\n\t\t\t\t\t\t\t\t<div style=\"width:5px;display:inline-block;\"></div>\n\t\t\t\t\t\t\t\t<div style=\"display:inline-block;\">Between 8 and 16 characters</div>\n\t\t\t\t\t\t\t\t<br/><div data-dojo-attach-point=\"_profilePropertiesPasswordRulesCapitalIconWarning\" class=\"_common_profilePasswordRulesIcon _common_profilePasswordRulesAlign _common_profilePasswordRulesIconWarning\"></div>\n\t\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_profilePropertiesPasswordRulesCapitalIconSuccess\" class=\"_common_profilePasswordRulesIcon _common_profilePasswordRulesAlign _common_profilePasswordRulesIconSuccess\" style=\"display:none\"></div>\n\t\t\t\t\t\t\t\t<div style=\"width:5px;display:inline-block;\"></div>\n\t\t\t\t\t\t\t\t<div style=\"display:inline-block;\">Contains a capital letter</div>\n\t\t\t\t\t\t\t\t<br/><div data-dojo-attach-point=\"_profilePropertiesPasswordRulesNumberIconWarning\" class=\"_common_profilePasswordRulesIcon _common_profilePasswordRulesAlign _common_profilePasswordRulesIconWarning\"></div>\n\t\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_profilePropertiesPasswordRulesNumberIconSuccess\" class=\"_common_profilePasswordRulesIcon _common_profilePasswordRulesAlign _common_profilePasswordRulesIconSuccess\" style=\"display:none\"></div>\n\t\t\t\t\t\t\t\t<div style=\"width:5px;display:inline-block;\"></div>\n\t\t\t\t\t\t\t\t<div style=\"display:inline-block;\">Contains a number</div>\n\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</span>-->\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"_common_profilePasswordText\" data-dojo-attach-point=\"_profilePropertiesConfirmPasswordText\"></div>\n\t\t\t\t\t\t\t<div class=\"_common_profilePasswordField\">\n\t\t\t\t\t\t\t\t<input type=\"password\" data-dojo-type=\"idx.form.TextBox\" data-dojo-attach-point=\"_profile_property_password_confirm\" align=\"right\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"_common_profilePasswordIcon\" data-dojo-attach-point=\"_profilePasswordIcon\">\n\t\t\t\t\t\t\t\t<div data-dojo-attach-point=\"_profilePropertiesConfirmPassword\" id=\"_profilePropertiesConfirmPassword_ID\" href=\"#\" onmouseover=\"idx.widget.HoverHelpTooltip.defaultPosition=['above','below']\" class=\"idxSignIcon\"></div>\n\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"_common_tabSpacer\"></div>\n\t\t\t\t</div>\n\t\t\t\t<!--\t\t<div class=\"_common_SubTitle portletHeader2\" data-dojo-attach-point=\"_profilePropertiesNameTitle\"></div>\n\t\t\t\t<div class=\"_common_profileSubText\" data-dojo-attach-point=\"_profilePropertiesNameText\"></div>\n\t\t\t\t<div class=\"_common_subValue\">\n\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" data-dojo-attach-point=\"_profile_property_name_value\" required=\"false\" align=\"right\" />\n\t\t\t\t</div> -->\n\t\t\t\t<!--<div class=\"_common_profileSpacer\"></div>-->\n\n\t\t\t\t<!--\n\t\t\t\t<div class=\"_common_profileSubTitle\">Role</div>\n\t\t\t\t<div class=\"_common_profileSubText\">You are assigned to these roles.  Each role has permissions to read, write or act on various Broker resources. If you have more than one role and the permissions conflict you will be allowed the more permissive.</div>\n\t\t\t\t<div class=\"_common_subValue\">Administrator <a href=\"#\">See permissions...</a></br>Operator <a href=\"#\">See permissions...</a></div>\n\t\t\t\t<div class=\"_common_profileSpacer\"></div>\n\t\t\t\t-->\n\t\t\t\t<!--\t<div class=\"_common_profileSubTitle _common_profileSubText\" data-dojo-attach-point=\"_profilePropertiesHistoryTitle\"></div>\n\t\t\t\t<div class=\"_common_subValue\" style=\"padding-top: 10px;\" ><a href=\"#\" data-dojo-attach-point=\"_profilePropertiesHistoryText\"></a></div> -->\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n",
'url:webui/widgets/operation/templates/operation_overview.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_operationOverview_borderContainer\" class=\"common_profileContainer\">\n  \t\t\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"> </div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\t\n\t\t\t<div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n\t\t\t\t<div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_propertyTitlePane\"> </div>\n\t\t\t\t<div class=\"_common_textSpacer\"> </div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n",
'url:webui/widgets/business/templates/BTDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" id = \"btnDetailsDialog\"\n  title=\"\">\n  <div class=\"dijitDialogTitle\">\n    <span  data-dojo-attach-point=\"titleNode\"\n      tabindex=\"0\">  </span>\n    <span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${_buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n      <span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${_buttonCancel}\">x</span>\n    </span>\n  </div>\n  <div class=\"dijitDialogInstruction\" data-dojo-attach-point=\"instructionDiv\">\n    <span role=\"document\" data-dojo-attach-point=\"instructionNode\" tabindex=\"0\" > </span>\n  </div>\n  <div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n    <div class=\"dijitDialogPaneContent\" class=\"btDialog\" data-dojo-attach-point=\"_btdDialogPane\">\n      <table class =\"btDialogTable\">\n        <tr>\n          <td>\n            <label for=\"btdNameText\" data-dojo-attach-point=\"_btdName\" > ${_btdNameLabel} </label>\n          </td>\n          <td>\n            <input data-dojo-type=\"dijit.form.ValidationTextBox\" name=\"btdNameText\" intermediateChanges=\"true\"\n               data-dojo-props=\"id: '_btdNameText'\"\n               data-dojo-attach-point=\"_btdNameText\" id=\"btdNameText\" class= \"btDialogName\"/>\n          </td>\n        </tr>\n        <tr>\n          <td>\n            <label for=\"btdDescriptionText\" data-dojo-attach-point=\"_btdDescription\">${_btdDescriptionLabel} </label>\n          </td>\n          <td>\n            <input data-dojo-type=\"dijit.form.Textarea\" name=\"btdDescriptionText\" intermediateChanges=\"true\"\n              data-dojo-attach-point=\"_btdDescriptionText\" id=\"btdDescriptionText\" class= \"btDialogDesc\" maxlength=\"400\"/>\n          </td>\n        </tr>\n      </table>\n      <div data-dojo-type=\"dijit.layout.ContentPane\" id =\"additionalInfo\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">      \n      </div>\n      \n    </div>\n  </div>\n  <div class=\"dijitDialogPaneActionBar\">\n    <span>\n    </span>\n    <span style=\"float:right; margin-right:50px\">\n      <button data-dojo-type=\"dijit.form.Button\" type=\"submit\" data-dojo-attach-point=\"_okButton\"> ${_btOKLabel}</button>\n      <button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> ${_btCancelLabel} </button>\n    </span>\n  </div>\n</div>\n",
'url:webui/widgets/executiongroup/templates/eg_overview.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_egOverview_borderContainer\" class=\"common_profileContainer\">\n\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t\t\t<div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n\n\t\t\t\t<div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_propertyTitlePane\"></div>\n\n\t\t\t\t<div class=\"_common_textSpacer\"></div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<div data-dojo-attach-point=\"_egEditEditor\"></div>\n\t<div id=\"egEditConfirmCancelDialog\"></div>\n</div>\n",
'url:webui/widgets/msgflows/templates/msgflow_activityLog.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_msgflowOverview_borderContainer\" class=\"common_profileContainer\">\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"> </div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t\t  <div class=\"gridContainer activitylogContainer claro _common_contentPanePosition\">\n        <div id=\"_activitylog_grid_ID\" data-dojo-attach-point=\"_activitylog_grid\" style=\"width:100%;height:100%;\">\n          <div data-dojo-attach-point=\"activitylogNoData\" style=\"opacity:1;\" class=\"dataviewerNoData\" id=\"activitylogNoData_ID\"></div>\n          <!-- Data Grid -->\n        </div>\n      </div>\n\t\t</div>\n\t</div>\n\t<div id=\"activitylogLoading_ID\" data-dojo-attach-point=\"activitylogLoading\" class=\"logGridTotal\"></div>\n</div>\n",
'url:webui/widgets/executiongroup/templates/NewExecutionGroupDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" \n\ttitle=\"\">\n\t<div class=\"dijitDialogTitle\">\n\t\t<span class=\"pageHeader2\" data-dojo-attach-point=\"titleNode\"\n\t\t\ttabindex=\"0\"> </span>\n\t\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t\t</span>\n\t</div>\n\t<div class=\"dijitDialogInstruction\" data-dojo-attach-point=\"instructionDiv\">\n\t\t<span role=\"document\" data-dojo-attach-point=\"instructionNode\"\n\t\t\tclass=\"instructional\" tabindex=\"0\" > </span>\n\t</div>\n\t<div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n\t\t<div class=\"dijitDialogPaneContent\" style=\"width:100%; height:100%; border-width:0px\">\n\t\t\t<table style=\"border-width: 0px\">\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"nameText\" data-dojo-attach-point=\"_nameLabel\"> </label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"nameText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\tdata-dojo-attach-point=\"_nameText\" />\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t</div>\n\t</div>\n\t<div class=\"dijitDialogPaneActionBar\">\n\t\t<span>\n\t\t</span>\n\t\t<span style=\"float:right; margin-right:50px\">\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"submit\" data-dojo-attach-point=\"_okButton\"> </button>\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> </button>\n\t\t</span>\n\t</div>\n</div>",
'url:webui/widgets/configurableservice/templates/ConfigurableServiceEditor.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_csEditor_borderContainer\" class=\"common_profileContainer\">\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n  \t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t    <div id=\"editPropertyValueDialog\"></div>\n   \t\t<table class=\"csEditorTable\" id=\"csEditorTable\" style=\"display:none;\">\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"csName\" class=\"csEditorLabel\">${_configurableserviceNameLabel}</label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"csName\" data-dojo-props=\"intermediateChanges: true\" data-dojo-attach-point=\"_csName\" id=\"csName\" class=\"csEditorAttribute\" spellcheck=\"false\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"csTypeName\" class=\"csEditorLabel\">${_configurableserviceTypeLabel}</label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.FilteringSelect\" name=\"csTypeName\" data-dojo-attach-point=\"_csTypeName\" id=\"csTypeName\" class=\"csEditorAttribute\" spellcheck=\"false\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"csTemplateName\" class=\"csEditorLabel\">${_configurableserviceTemplateLabel}</label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.FilteringSelect\" name=\"csTemplateName\" data-dojo-attach-point=\"_csTemplateName\" id=\"csTemplateName\" class=\"csEditorAttribute\" spellcheck=\"false\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t\t\n\t\t\t<p><br/></p>\n\t\t\t<table class=\"csEditorTable\">\n\t\t\t\t<tr>\n          <td>\n  \t\t\t\t\t<label class=\"csEditorGridLabel\">${_configurableservicePropertiesLabel}</label>\n          </td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n          <td>\n  \t\t\t\t\t<div data-dojo-attach-point=\"_csProperties\" id=\"_csProperties\" class=\"csEditorGrid\"></div>\n          </td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t\t<div class=\"csEditorGridButtons\">\n\t\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_csAddPropertyButton\">Add</button>\n\t\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_csRemovePropertyButton\">Remove</button>\n\t\t\t</div>\n\t\t\t\n\t\t\t<p><br></p>\n\t\t\t<div data-dojo-type=\"dijit.TitlePane\" id=\"csCommandSection\" data-dojo-attach-point=\"_csCommandSection\" data-dojo-props=\"region: 'center', open: false\" class=\"csEditorCommandSection\" title=\"${_configurableserviceCommandLabel}\">\n        <div id=\"csCommandDescription\"></div>\n        <input data-dojo-type=\"dijit.form.Textarea\" name=\"csCommandTextArea\" data-dojo-props=\"intermediateChanges: true\" data-dojo-attach-point=\"_csCommandTextArea\" id=\"csCommandTextArea\" readonly=\"readonly\"/>\n      </div>\n\t\t</div>\n\t</div>\n</div>",
'url:webui/widgets/business/templates/BTDFilteringOptionsDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" \n\ttitle=\"\">\n\t<div class=\"dijitDialogTitle\">\n\t\t<span class=\"pageHeader2\" data-dojo-attach-point=\"titleNode\"\n\t\t\ttabindex=\"0\"> </span>\n\t\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t\t</span>\n\t</div>\n\t<div class=\"dijitDialogInstruction\" data-dojo-attach-point=\"instructionDiv\">\n\t\t<span role=\"document\" data-dojo-attach-point=\"instructionNode\"\n\t\t\tclass=\"instructional\" tabindex=\"0\" > </span>\n\t</div>\n\t<div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n\t\t<div class=\"dijitDialogPaneContent\" style=\"width:100%; height:100%; border-width:0px\">\n\n\t\t\t<table class=\"btd_filtering_dialog_table\">\n\t\t\t\t<tr>\n\t\t\t\t\t<td class=\"btd_filtering_dialog_td\">\n\t\t\t\t      <input type=\"checkbox\" id=\"bt_filter_transaction_id\" data-dojo-type=\"dijit.form.CheckBox\" data-dojo-attach-point=\"_bt_filter_transaction_id\" >\n\t\t\t\t\t</td>\n\t\t\t\t\t\n\t\t\t\t\t<td class=\"btd_filtering_dialog_td\">\n\t\t\t\t       <label for=\"bt_filter_transaction_id\">${bt_filter_transaction_id_Label}</label>\t\t\t\t\t\n\t\t\t\t\t</td>\n\t\t\t\t\t\n\t\t\t\t\t<td class=\"btd_filtering_dialog_td\">\n\t\t\t\t\t\n            <select data-dojo-type=\"dijit.form.Select\" name=\"bt_filter_transaction_id_matchVerbs\" data-dojo-attach-point=\"_bt_filter_transaction_id_matchVerbs\" >\n              <option value='equals' selected='selected'>${bt_filter_matchverb_equals}</option>            \n\t\t\t\t\t    <option value='contains' >${bt_filter_matchverb_contains}</option>\n\t\t\t\t\t    <option value='startsWith'>${bt_filter_matchverb_startsWith}</option>\n\t\t\t\t\t    <option value='endsWith'>${bt_filter_matchverb_endsWith}</option>\n\t\t\t\t\t    \n            </select>\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t</td>\n\n\t\t\t\t\t<td class=\"btd_filtering_dialog_td\">\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"bt_filter_transaction_id_text\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\tdata-dojo-attach-point=\"_bt_filter_transaction_id_text\" />\n\t\t\t\t\t\n\t\t\t\t\t</td>\n\t\t\t\t\t\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr>\n\t\t\t\t\n\t\t\t\t\t<td class=\"btd_filtering_dialog_td\">\n\t\t\t\t      <input type=\"checkbox\" id=\"bt_filter_status\" data-dojo-type=\"dijit.form.CheckBox\" data-dojo-attach-point=\"_bt_filter_status\" >\t\t\t\t\t\n\t\t\t\t\t</td>\n\t\t\t\t\t\n\t\t\t\t\t<td class=\"btd_filtering_dialog_td\">\n\t\t\t\t      <label for=\"bt_filter_status\">${bt_filter_status_Label}</label>\t\t\t\t\t\n\t\t\t\t\t</td>\n\t\t\t\t\t\n\t\t\t\t\t<td class=\"btd_filtering_dialog_td\">\n\t\t\t\t\t\n              <label style=\"margin-left:12px;\">${bt_filter_matchverb_equals}</label>\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t</td>\n\n\t\t\t\t\t<td class=\"btd_filtering_dialog_td\">\n\n            <select data-dojo-type=\"dijit.form.Select\" name=\"bt_filter_status_values\" data-dojo-attach-point=\"_bt_filter_status_values\" >\n              <option value='inProgress' selected='selected'>${bt_filter_status_inProgress}</option>            \n\t\t\t\t\t    <option value='ended' >${bt_filter_status_ended}</option>\n\t\t\t\t\t    <option value='failed' >${bt_filter_status_failed}</option>\n \t\t\t\t\t    <option value='inconsistent' >${bt_filter_status_inconsistent}</option>\n            </select>\t\t\t\t\t\n            \t\t\t\t\t\n\t\t\t\t\t</td>\n\t\t\t\t\t\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t</table>\n\n\n\n\n\n\t\t    \n\t\t</div>\n\t</div>\n\t<div class=\"dijitDialogPaneActionBar\">\n\t\t<span>\n\t\t</span>\n\t\t<span style=\"float:right; margin-right:50px\">\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"submit\" data-dojo-attach-point=\"_okButton\"> </button>\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> </button>\n\t\t</span>\n\t</div>\n</div>",
'url:webui/widgets/policy_editor/templates/policy_editor_dynamic.html':"<div>\n\t<div data-dojo-type=\"dijit.layout.ContentPane\" class=\"_policyEditorDynamic\" data-dojo-props=\"region: 'center'\" style=\"padding-left:30px\" data-dojo-attach-point=\"_policyEditorDynamic\"></div>\n</div>\n",
'url:webui/widgets/business/templates/businesstransaction_results.html':"<div style=\"width:100%;height:100%;\">\n  <div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_businessTransactionResultsView_borderContainer\" class=\"common_profileContainer\">\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n      <div data-dojo-attach-point=\"_toolbar2\"></div>\n    </div>\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n      <div class=\"_common_infoPanePropertiesPosition\">\n        <div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_businessResultsBody\"></div>\n      </div>\n    </div>\n  </div>\n</div>",
'url:webui/widgets/common/templates/EditBooleanPropertyValueDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" id=\"editPropertyValueDialog\" title=\"\">\n  <div class=\"dijitDialogTitle\">\n    <span data-dojo-attach-point=\"titleNode\" tabindex=\"0\">  </span>\n    <span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${_buttonCancelLabel}\" role=\"button\" tabIndex=\"-1\">\n      <span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${_buttonCancelLabel}\">x</span>\n    </span>\n  </div>\n  <div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n    <div class=\"dijitDialogPaneContent\" class=\"editPropertyValueDialog\">\n      <input data-dojo-type=\"dijit.form.CheckBox\" name=\"editPropertyValueArea\" spellcheck=\"false\" data-dojo-props=\"intermediateChanges: true\" data-dojo-attach-point=\"editPropertyValueArea\" id=\"editPropertyValueArea\"/>      \n    </div>\n  </div>\n  <div class=\"dijitDialogPaneActionBar\">\n    <span>\n    </span>\n    <span style=\"float:right; margin-right:50px\">\n      <button data-dojo-type=\"dijit.form.Button\" type=\"submit\" data-dojo-attach-point=\"_okButton\"> ${_buttonOKLabel}</button>\n      <button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> ${_buttonCancelLabel} </button>\n    </span>\n  </div>\n</div>\n",
'url:webui/widgets/executiongroup/templates/ExecutionGroupPropertiesEditor.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_egEditor_borderContainer\" class=\"common_profileContainer\">\n    \n    \t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n    \t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t\t    <div id=\"editPropertyValueDialog\"></div>\n    \t\t<table class=\"egEditorTable\" id=\"egEditorTable\" style=\"display:none;\">\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"egName\" class=\"egEditorLabel\">${_egNameLabel}</label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"egName\" intermediateChanges=\"true\" data-dojo-attach-point=\"_egName\" id=\"egName\" class=\"egEditorAttribute\" spellcheck=\"false\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"egTypeName\" class=\"egEditorLabel\">${_egTypeLabel}</label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.FilteringSelect\" name=\"egTypeName\" data-dojo-attach-point=\"_egTypeName\" id=\"egTypeName\" class=\"egEditorAttribute\" spellcheck=\"false\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t\t\n\t\t\t<p/>\n\t\t\t<table class=\"egEditorTable\">\n\t\t\t\t<tr>\n\t\t\t\t\t<div data-dojo-attach-point=\"_egProperties\" id=\"_egProperties\" class=\"egEditorGrid\"></div>\n\t\t\t\t</tr>\n\t\t\t\t<tr>\n\t\t\t\t\t<div data-dojo-attach-point=\"_rmProperties\" id=\"_rmProperties\" class=\"egEditorGrid\"></div>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t</div>\n\t</div>\n</div>",
'url:webui/widgets/restapi/templates/Api.html':"<div style=\"width:100%;height:100%;\">\n  <div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_borderContainer\" class=\"common_profileContainer\">\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n      <div data-dojo-attach-point=\"_toolbar\"></div>\n    </div>\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\" tabindex=\"-1\">\n      <table class=\"restApis_overviewTable\" role=\"presentation\">\n        <tbody>\n          <tr>\n            <td id=\"baseURLdesc\">${NLS.restApi.baseURL}</td><td><a target=\"_blank\" aria-labelledby=\"baseURLdesc baseURL\" data-dojo-attach-point=\"_baseURL\" id=\"baseURL\" tabindex=\"0\"></a></td>\n          </tr>\n          <tr>\n            <td id=\"definitionsURLdesc\">${NLS.restApi.definitionsURL}</td><td><a target=\"_blank\" aria-labelledby=\"definitionsURLdesc definitionsURL\" data-dojo-attach-point=\"_definitionsURL\" id=\"definitionsURL\" tabindex=\"0\"></a></td>\n          </tr>\n        </tbody>\n      </table>\n      <div data-dojo-attach-point=\"_container\" style=\"padding-left:30px;\"></div>\n    </div>\n  </div>\n</div>\n",
'url:webui/widgets/policy/templates/PolicySaveAsDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" id = \"policySaveAsDialog\"\n  title=\"\">\n  <div class=\"dijitDialogTitle\">\n    <span  data-dojo-attach-point=\"titleNode\"\n      tabindex=\"0\">  </span>\n    <span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${_buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n      <span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${_buttonCancel}\">x</span>\n    </span>\n  </div>\n  <div class=\"dijitDialogInstruction\" data-dojo-attach-point=\"instructionDiv\">\n    <span role=\"document\" data-dojo-attach-point=\"instructionNode\" tabindex=\"0\" > </span>\n  </div>\n  <div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n    <div class=\"dijitDialogPaneContent\" class=\"policyDialog\">\n      <table class =\"policyDialogTable\">\n        <tr>\n          <td>\n            <label for=\"policyNameText\" data-dojo-attach-point=\"_policyName\" > ${_policyNameLabel} </label>\n          </td>\n          <td>\n            <input data-dojo-type=\"dijit.form.ValidationTextBox\" name=\"policyNameText\" intermediateChanges=\"true\"\n               data-dojo-props=\"id: '_policyNameText'\"\n               data-dojo-attach-point=\"_policyNameText\" id=\"policyNameText\" class= \"policyDialogName\"/>\n          </td>\n        </tr>\n      </table>\n    </div>\n  </div>\n  <div class=\"dijitDialogPaneActionBar\">\n    <span>\n    </span>\n    <span style=\"float:right; margin-right:50px\">\n      <button data-dojo-type=\"dijit.form.Button\" type=\"submit\" data-dojo-attach-point=\"_okButton\"> ${_policyOKLabel}</button>\n      <button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> ${_policyCancelLabel} </button>\n    </span>\n  </div>\n</div>\n",
'url:webui/config/PolicyLayout.json':"{\n  \"wlm\": {\"id\": \"root\", \"contents\": [\n    {\"id\": \"policyUrl\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px\"},\n    {\"id\": \"wlm_tAndL_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"notificationThresholdMsgsPerSec\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 1000000, \"places\": 0}, \"suffix\": \"messages per second\"},\n      {\"id\": \"maximumRateMsgsPerSec\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 1000000, \"places\": 0}, \"suffix\": \"messages per second\"}\n    ]},\n    {\"id\": \"wlm_addInst_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"additionalInstances\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 256, \"places\": 0}},\n      {\"id\": \"startInstancesWhenFlowStarts\", \"type\": \"Enum\", \"contents\": [ \"unspecified\", \"yes\", \"no\"], \"default\": \"unspecified\"}\n    ]},                                                  \n    {\"id\": \"wlm_startMode_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"startMode\", \"type\": \"Enum\", \"contents\": [ \"unspecified\", \"maintained\", \"manual\", \"automatic\"], \"default\": \"unspecified\"}\n    ]},\n    {\"id\": \"wlm_trans_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"commitCount\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 100000, \"places\": 0}},\n      {\"id\": \"commitInterval\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 60, \"places\": 0}, \"suffix\": \"seconds\"}\n    ]},\n    {\"id\": \"wlm_unresponsive_flows_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"processingTimeoutAction\", \"type\": \"Enum\", \"contents\": [ \"unspecified\", \"none\", \"restartExecutionGroup\"], \"default\": \"unspecified\"},\n      {\"id\": \"processingTimeoutSec\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 150000, \"places\": 0}, \"suffix\": \"seconds\"}\n    ]}\n  ]},\n  \"wlmReadOnly\": {\"id\": \"root\", \"contents\": [\n    {\"id\": \"policyUrl\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px\"},\n    {\"id\": \"wlm_tAndL_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"notificationThresholdMsgsPerSec\", \"type\": \"Number\", \"default\": \"\", \"readOnly\": true, \"constraints\": {\"min\": 0, \"max\": 1000000, \"places\": 0}, \"suffix\": \"messages per second\"},\n      {\"id\": \"maximumRateMsgsPerSec\", \"type\": \"Number\", \"default\": \"\", \"readOnly\": true, \"constraints\": {\"min\": 0, \"max\": 1000000, \"places\": 0}, \"suffix\": \"messages per second\"}\n    ]},\n    {\"id\": \"wlm_addInst_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"additionalInstances\", \"type\": \"Number\", \"default\": \"\", \"readOnly\": true, \"constraints\": {\"min\": 0, \"max\": 256, \"places\": 0}},\n      {\"id\": \"startInstancesWhenFlowStarts\", \"type\": \"Enum\", \"contents\": [ \"unspecified\", \"yes\", \"no\"], \"default\": \"unspecified\", \"readOnly\": true}\n    ]},\n    {\"id\": \"wlm_startMode_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"startMode\", \"type\": \"Enum\", \"contents\": [ \"unspecified\", \"maintained\", \"manual\", \"automatic\"], \"default\": \"unspecified\", \"readOnly\": true}\n    ]},\n    {\"id\": \"wlm_trans_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"commitCount\", \"type\": \"Number\", \"default\": \"\", \"readOnly\": true, \"constraints\": {\"min\": 0, \"max\": 100000, \"places\": 0}},\n      {\"id\": \"commitInterval\", \"type\": \"Number\", \"default\": \"\", \"readOnly\": true, \"constraints\": {\"min\": 0, \"max\": 60, \"places\": 0}, \"suffix\": \"seconds\"}\n    ]},\n    {\"id\": \"wlm_unresponsive_flows_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"processingTimeoutAction\", \"type\": \"Enum\", \"contents\": [ \"unspecified\", \"none\", \"restartExecutionGroup\"], \"default\": \"unspecified\", \"readOnly\": true},\n      {\"id\": \"processingTimeoutSec\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 150000, \"places\": 0}, \"suffix\": \"seconds\", \"readOnly\": true}\n    ]}\n  ]},\n  \"wlmCreate\": {\"id\": \"root\", \"contents\": [                                                         \n    {\"id\": \"policyName\", \"type\": \"String\", \"default\": \"\", \"pattern\": \"[^;/?:@&=$,<>~#()|^=+-.*!%\\\\u0022\\\\u0027\\\\u0020\\\\u0060\\\\u007B\\\\u007D\\\\u005B-\\\\u005E]*\", \"required\": true, \"invalidMessage\": \"error_policyName_invalidCharacter\", \"tooltipPosition\": \"below\"},\n    {\"id\": \"wlm_tAndL_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"notificationThresholdMsgsPerSec\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 1000000, \"places\": 0}, \"suffix\": \"messages per second\"},\n      {\"id\": \"maximumRateMsgsPerSec\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 1000000, \"places\": 0}, \"suffix\": \"messages per second\"}\n    ]},\n    {\"id\": \"wlm_addInst_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"additionalInstances\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 256, \"places\": 0}},\n      {\"id\": \"startInstancesWhenFlowStarts\", \"type\": \"Enum\", \"contents\": [ \"unspecified\", \"yes\", \"no\"], \"default\": \"unspecified\"}\n    ]},\n    {\"id\": \"wlm_startMode_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"startMode\", \"type\": \"Enum\", \"contents\": [ \"unspecified\", \"maintained\", \"manual\", \"automatic\"], \"default\": \"unspecified\"}\n    ]},\n    {\"id\": \"wlm_trans_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"commitCount\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 100000, \"places\": 0}},\n      {\"id\": \"commitInterval\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 60, \"places\": 0}, \"suffix\": \"seconds\"}\n    ]},\n    {\"id\": \"wlm_unresponsive_flows_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [ \n      {\"id\": \"processingTimeoutAction\", \"type\": \"Enum\", \"contents\": [ \"unspecified\", \"none\", \"restartExecutionGroup\"], \"default\": \"unspecified\"},\n      {\"id\": \"processingTimeoutSec\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 150000, \"places\": 0}, \"suffix\": \"seconds\"}\n    ]}\n  ]},\n  \"mqttPublish\": {\"id\": \"root\", \"contents\": [\n    {\"id\": \"policyUrl\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px\"},  \n    {\"id\": \"group_description_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [ \n      {\"id\": \"shortDesc\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px\"  },\n      {\"id\": \"longDesc\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px\"}\n    ]},\n    {\"id\": \"group_basic_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": [\n      {\"id\": \"clientId\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px\"},\n      {\"id\": \"topicName\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px\"},\n      {\"id\": \"hostName\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px\"},\n      {\"id\": \"port\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 100000, \"places\": 0, \"pattern\":\"#\"}, \"style\":\"width: 400px\", \"invalidMessage\": \"error_integerOnly\"},\n      {\"id\": \"qos\", \"type\": \"Enum\", \"contents\": [ \"empty\", \"0\", \"1\", \"2\"], \"default\": \"empty\", \"style\":\"width: 402px\"}\n    ]}\n  ]},\n  \"mqttPublishReadOnly\": {\"id\": \"root\", \"contents\":[\n                                                    {\"id\": \"policyUrl\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px\"}, \n                                                    {\"id\": \"group_description_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": \n                                                      [ \n                                                       {\"id\": \"shortDesc\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px;\"  },\n                                                       {\"id\": \"longDesc\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px;\" }\n                                                       ]\n                                                    },\n                                                    {\"id\": \"group_basic_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": \n                                                      [ \n                                                       {\"id\": \"clientId\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px;\"},\n                                                       {\"id\": \"topicName\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px;\"},\n                                                       {\"id\": \"hostName\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px;\"},\n                                                       {\"id\": \"port\", \"type\": \"Number\", \"default\": \"\", \"readOnly\": true, \"constraints\": {\"min\": 0, \"max\": 100000, \"places\": 0, \"pattern\":\"#\"}, \"style\":\"width: 400px;\"},\n                                                       {\"id\": \"qos\", \"type\": \"Enum\", \"contents\": [ \"empty\", \"0\", \"1\", \"2\"], \"default\": \"empty\", \"readOnly\": true, \"style\":\"width: 402px;\"}\n                                                       ]\n                                                    }\n                                                    ]\n  },\n  \"mqttPublishCreate\": {\"id\": \"root\", \"contents\": [\n                                                   {\"id\": \"policyName\", \"type\": \"String\", \"default\": \"\", \"pattern\": \"[^;/?:@&=$,<>~#()|^=+-.*!%\\\\u0022\\\\u0027\\\\u0020\\\\u0060\\\\u007B\\\\u007D\\\\u005B-\\\\u005E]*\", \"style\":\"width: 400px;\", \"required\": true, \"invalidMessage\": \"error_policyName_invalidCharacter\", \"tooltipPosition\": \"below\"},\n                                                   {\"id\": \"group_description_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": \n                                                     [ \n                                                      {\"id\": \"shortDesc\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"  },\n                                                      {\"id\": \"longDesc\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"}\n                                                      ]\n                                                   },\n                                                   {\"id\": \"group_basic_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": \n                                                     [ \n                                                      {\"id\": \"clientId\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n                                                      {\"id\": \"topicName\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n                                                      {\"id\": \"hostName\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n                                                      {\"id\": \"port\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 100000, \"places\": 0, \"pattern\":\"#\"}, \"style\":\"width: 400px;\", \"invalidMessage\": \"error_integerOnly\"},\n                                                      {\"id\": \"qos\", \"type\": \"Enum\", \"contents\": [ \"empty\", \"0\", \"1\", \"2\"], \"default\": \"empty\", \"style\":\"width: 402px;\"}\n                                                      ]\n                                                   }\n                                                   ]\n  },\n  \"mqttSubscribe\": {\"id\": \"root\", \"contents\": [\n                                               {\"id\": \"policyUrl\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px\"},\n                                               {\"id\": \"group_description_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": \n                                                 [ \n                                                  {\"id\": \"shortDesc\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\" },\n                                                  {\"id\": \"longDesc\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"}\n                                                  ]\n                                               },\n                                               {\"id\": \"group_basic_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": \n                                                 [ \n                                                  {\"id\": \"clientId\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n                                                  {\"id\": \"topicName\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n                                                  {\"id\": \"hostName\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n                                                  {\"id\": \"port\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 100000, \"places\": 0, \"pattern\":\"#\"}, \"style\":\"width: 400px;\", \"invalidMessage\": \"error_integerOnly\"},\n                                                  {\"id\": \"qos\", \"type\": \"Enum\", \"contents\": [ \"empty\", \"0\", \"1\", \"2\"], \"default\": \"empty\", \"style\":\"width: 402px;\"}\n                                                  ]\n                                               }\n                                               ]\n  },\n  \"mqttSubscribeReadOnly\": {\"id\": \"root\", \"contents\":[\n                                                      {\"id\": \"policyUrl\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px\"},\n                                                      {\"id\": \"group_description_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": \n                                                        [ \n                                                         {\"id\": \"shortDesc\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px;\" },\n                                                         {\"id\": \"longDesc\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px;\"}\n                                                         ]\n                                                      },\n                                                      {\"id\": \"group_basic_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": \n                                                        [ \n                                                         {\"id\": \"clientId\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px;\"},\n                                                         {\"id\": \"topicName\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px;\"},\n                                                         {\"id\": \"hostName\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px;\"},\n                                                         {\"id\": \"port\", \"type\": \"Number\", \"default\": \"\", \"readOnly\": true, \"constraints\": {\"min\": 0, \"max\": 100000, \"places\": 0, \"pattern\":\"#\"}, \"style\":\"width: 400px;\"},\n                                                         {\"id\": \"qos\", \"type\": \"Enum\", \"contents\": [ \"empty\", \"0\", \"1\", \"2\"], \"default\": \"empty\", \"readOnly\": true, \"style\":\"width: 402px;\"}\n                                                         ]\n                                                      }\n                                                      ]\n  },\n  \"mqttSubscribeCreate\": {\"id\": \"root\", \"contents\": [\n                                                     {\"id\": \"policyName\", \"type\": \"String\", \"default\": \"\", \"pattern\": \"[^;/?:@&=$,<>~#()|^=+-.*!%\\\\u0022\\\\u0027\\\\u0020\\\\u0060\\\\u007B\\\\u007D\\\\u005B-\\\\u005E]*\", \"style\":\"width: 400px;\", \"required\": true, \"invalidMessage\": \"error_policyName_invalidCharacter\", \"tooltipPosition\": \"below\"},\n                                                     {\"id\": \"group_description_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": \n                                                       [ \n                                                        {\"id\": \"shortDesc\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\" },\n                                                        {\"id\": \"longDesc\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"}\n                                                        ]\n                                                     },\n                                                     {\"id\": \"group_basic_title\", \"type\": \"Group\", \"default\": \"true\", \"contents\": \n                                                       [ \n                                                        {\"id\": \"clientId\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n                                                        {\"id\": \"topicName\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n                                                        {\"id\": \"hostName\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n                                                        {\"id\": \"port\", \"type\": \"Number\", \"default\": \"\", \"constraints\": {\"min\": 0, \"max\": 100000, \"places\": 0, \"pattern\":\"#\"}, \"style\":\"width: 400px;\", \"invalidMessage\": \"error_integerOnly\"},\n                                                        {\"id\": \"qos\", \"type\": \"Enum\", \"contents\": [ \"empty\", \"0\", \"1\", \"2\"], \"default\": \"empty\", \"style\":\"width: 402px;\"}\n                                                        ]\n                                                     }\n                                                     ]\n  },                                   \n                                                                             \n  \"mqEndpoint\": {\"id\": \"root\", \"contents\": [\n    {\"id\": \"policyUrl\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px\"},\n    {\"id\": \"connection\", \"type\": \"Enum\", \"contents\": [ \"CLIENT\", \"CCDT\", \"SERVER\"], \"default\": \"SERVER\", \"style\":\"width: 402px;\"},\n    {\"id\": \"destinationQueueManagerName\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n    {\"id\": \"queueManagerHostname\", \"type\": \"String\", \"style\":\"width: 400px;\"},\n    {\"id\": \"listenerPortNumber\", \"type\": \"Number\", \"constraints\": {\"min\": 0, \"max\": 100000, \"places\": 0, \"pattern\":\"#\"}, \"style\":\"width: 400px;\", \"invalidMessage\": \"error_integerOnly\"},\n    {\"id\": \"channelName\", \"type\": \"String\", \"style\":\"width: 400px;\"},\n    {\"id\": \"securityIdentity\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n    {\"id\": \"useSSL\", \"type\": \"Boolean\"},\n    {\"id\": \"SSLPeerName\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n    {\"id\": \"SSLCipherSpec\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"}\n  ]},\n                                                       \n  \"mqEndpointReadOnly\": {\"id\": \"root\", \"contents\":[\n    {\"id\": \"policyUrl\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px\"},\n    {\"id\": \"connection\", \"type\": \"Enum\", \"contents\": [ \"CLIENT\", \"CCDT\", \"SERVER\"], \"default\": \"SERVER\", \"readOnly\": true, \"style\":\"width: 402px;\"},\n    {\"id\": \"destinationQueueManagerName\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px;\"},\n    {\"id\": \"queueManagerHostname\", \"type\": \"String\", \"readOnly\": true, \"style\":\"width: 400px;\"},\n    {\"id\": \"listenerPortNumber\", \"type\": \"Number\", \"constraints\": {\"min\": 0, \"max\": 100000, \"places\": 0, \"pattern\":\"#\"}, \"readOnly\": true, \"style\":\"width: 400px;\"},\n    {\"id\": \"channelName\", \"type\": \"String\", \"readOnly\": true, \"style\":\"width: 400px;\"},\n    {\"id\": \"securityIdentity\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px;\"},\n    {\"id\": \"useSSL\", \"type\": \"Boolean\", \"readOnly\": true},\n    {\"id\": \"SSLPeerName\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px;\"},\n    {\"id\": \"SSLCipherSpec\", \"type\": \"String\", \"default\": \"\", \"readOnly\": true, \"style\":\"width: 400px;\"}\n  ]},\n\n  \"mqEndpointCreate\": {\"id\": \"root\", \"contents\":[\n    {\"id\": \"policyName\", \"type\": \"String\", \"default\": \"\", \"pattern\": \"[^;/?:@&=$,<>~#()|^=+-.*!%\\\\u0022\\\\u0027\\\\u0020\\\\u0060\\\\u007B\\\\u007D\\\\u005B-\\\\u005E]*\", \"style\":\"width: 400px;\", \"required\": true, \"invalidMessage\": \"error_policyName_invalidCharacter\", \"tooltipPosition\": \"below\"},\n    {\"id\": \"connection\", \"type\": \"Enum\", \"contents\": [ \"CLIENT\", \"CCDT\", \"SERVER\"], \"default\": \"SERVER\", \"style\":\"width: 402px;\"},\n    {\"id\": \"destinationQueueManagerName\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n    {\"id\": \"queueManagerHostname\", \"type\": \"String\", \"style\":\"width: 400px;\"},\n    {\"id\": \"listenerPortNumber\", \"type\": \"Number\", \"constraints\": {\"min\": 0, \"max\": 100000, \"places\": 0, \"pattern\":\"#\"}, \"style\":\"width: 400px;\", \"invalidMessage\": \"error_integerOnly\"},\n    {\"id\": \"channelName\", \"type\": \"String\", \"style\":\"width: 400px;\"},\n    {\"id\": \"securityIdentity\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n    {\"id\": \"useSSL\", \"type\": \"Boolean\"},\n    {\"id\": \"SSLPeerName\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"},\n    {\"id\": \"SSLCipherSpec\", \"type\": \"String\", \"default\": \"\", \"style\":\"width: 400px;\"}\n  ]}\n}",
'url:webui/widgets/sharedlibraries/templates/shlib_overview.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_egOverview_borderContainer\" class=\"common_profileContainer\">\n\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t\t\t<div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n\n\t\t\t\t<div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_propertyTitlePane\"></div>\n\n\t\t\t\t<div class=\"_common_textSpacer\"></div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n",
'url:webui/widgets/common/templates/EditNumericPropertyValueDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" id=\"editPropertyValueDialog\" title=\"\">\n  <div class=\"dijitDialogTitle\">\n    <span data-dojo-attach-point=\"titleNode\" tabindex=\"0\">  </span>\n    <span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${_buttonCancelLabel}\" role=\"button\" tabIndex=\"-1\">\n      <span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${_buttonCancelLabel}\">x</span>\n    </span>\n  </div>\n  <div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n    <div class=\"dijitDialogPaneContent\" class=\"editPropertyValueDialog\">\n      <input data-dojo-type=\"dijit.form.NumberTextBox\" name=\"editPropertyValueArea\" spellcheck=\"false\" data-dojo-props=\"intermediateChanges: true\" data-dojo-attach-point=\"editPropertyValueArea\" id=\"editPropertyValueArea\"/>      \n    </div>\n  </div>\n  <div class=\"dijitDialogPaneActionBar\">\n    <span>\n    </span>\n    <span style=\"float:right; margin-right:50px\">\n      <button data-dojo-type=\"dijit.form.Button\" type=\"submit\" data-dojo-attach-point=\"_okButton\"> ${_buttonOKLabel}</button>\n      <button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> ${_buttonCancelLabel} </button>\n    </span>\n  </div>\n</div>\n",
'url:webui/widgets/msgflows/templates/msgflow_overview.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_msgflowOverview_borderContainer\" class=\"common_profileContainer\">\n  \t\t\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"> </div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\t\n\t\t\t<div class=\"_common_infoPanePropertiesPosition\">\n\t\t\t\t<div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_propertyTitlePane\"> </div>\n\t\t\t\t<div class=\"_common_textSpacer\"> </div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<div data-dojo-attach-point=\"_messageFlowEditEditor\"></div>\n\t<div id=\"messageFlowEditConfirmCancelDialog\"></div>\n</div>\n",
'url:webui/widgets/business/templates/EventDetailsDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" \n\ttitle=\"\">\n\t<div class=\"dijitDialogTitle\">\n\t\t<span class=\"pageHeader2\" data-dojo-attach-point=\"titleNode\"\n\t\t\ttabindex=\"0\"> </span>\n\t\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t\t</span>\n\t</div>\n\t<div class=\"dijitDialogInstruction\" data-dojo-attach-point=\"instructionDiv\">\n\t\t<span role=\"document\" data-dojo-attach-point=\"instructionNode\"\n\t\t\tclass=\"instructional\" tabindex=\"0\" > </span>\n\t</div>\n\t<div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n\t\t<div class=\"dijitDialogPaneContent\" style=\"width:100%; height:100%; border-width:0px\">\n\t\t\t<table style=\"border-width: 0px\">\n\t\t\t\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"eventNameText\" data-dojo-attach-point=\"_eventNameLabel\"> </label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"eventNameText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\tdata-dojo-attach-point=\"_eventNameText\" readonly=\"readonly\" />\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"eventSourceAddressText\" data-dojo-attach-point=\"_eventSourceAddressLabel\"> </label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"eventSourceAddressText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\tdata-dojo-attach-point=\"_eventSourceAddressText\" readonly=\"readonly\" />\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"integrationNodeNameText\" data-dojo-attach-point=\"_integrationNodeNameLabel\"> </label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"integrationNodeNameText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\tdata-dojo-attach-point=\"_integrationNodeNameText\" readonly=\"readonly\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"integrationServerNameText\" data-dojo-attach-point=\"_integrationServerNameLabel\"> </label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"integrationServerNameText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\tdata-dojo-attach-point=\"_integrationServerNameText\" readonly=\"readonly\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"flowNameText\" data-dojo-attach-point=\"_flowNameLabel\"> </label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"flowNameText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\tdata-dojo-attach-point=\"_flowNameText\" readonly=\"readonly\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"nodeNameText\" data-dojo-attach-point=\"_nodeNameLabel\"> </label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"nodeNameText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\tdata-dojo-attach-point=\"_nodeNameText\" readonly=\"readonly\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"nodeTypeText\" data-dojo-attach-point=\"_nodeTypeLabel\"> </label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"nodeTypeText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\tdata-dojo-attach-point=\"_nodeTypeText\" readonly=\"readonly\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"nodeTerminalNameText\" data-dojo-attach-point=\"_nodeTerminalNameLabel\"> </label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"nodeTerminalNameText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\tdata-dojo-attach-point=\"_nodeTerminalNameText\" readonly=\"readonly\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"localCorrelationIDText\" data-dojo-attach-point=\"_localCorrelationIDLabel\"> </label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"localCorrelationIDText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\tdata-dojo-attach-point=\"_localCorrelationIDText\" readonly=\"readonly\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"parentCorrelationIDText\" data-dojo-attach-point=\"_parentCorrelationIDLabel\"> </label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"parentCorrelationIDText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\tdata-dojo-attach-point=\"_parentCorrelationIDText\" readonly=\"readonly\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"globalCorrelationIDText\" data-dojo-attach-point=\"_globalCorrelationIDLabel\"> </label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"globalCorrelationIDText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\tdata-dojo-attach-point=\"_globalCorrelationIDText\" readonly=\"readonly\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t\t\n\t\t\t</table>\n\t\t</div>\n\t</div>\n\t<div class=\"dijitDialogPaneActionBar\">\n\t\t<span>\n\t\t</span>\n\t\t<span style=\"float:right; margin-right:50px\">\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> </button>\n\t\t</span>\n\t</div>\n</div>",
'url:webui/widgets/restapi/templates/Operation.html':"<div>\n  <div aria-controls=\"container\" role=\"button\" data-dojo-attach-point=\"_operation\" class=\"restApis_operation\" tabindex=\"0\">\n    <span data-dojo-attach-point=\"_method\" class=\"restApis_operationMethod\"></span>\n    <span data-dojo-attach-point=\"_name\" class=\"restApis_operationName\"></span>\n    <span data-dojo-attach-point=\"_description\" class=\"restApis_operationDescription\"></span>\n    <span data-dojo-attach-point=\"_isImplemented\" class=\"restApis_operationIsImplemented\"></span>\n  </div>\n  <div id=\"container\" aria-expanded=\"true\" role=\"region\" data-dojo-attach-point=\"_container\" class=\"restApis_parameterContainer\">\n    <table data-dojo-attach-point=\"_table\" class=\"restApis_parameterTable\">\n      <thead>\n        <tr>\n          <th>${NLS.restApis_parameterName}</th>\n          <th>${NLS.restApis_parameterType}</th>\n          <th>${NLS.restApis_parameterRequired}</th>\n          <th colspan=\"3\">${NLS.restApis_parameterDescription}</th>\n        </tr>\n      </thead>\n    </table>\n  </div>\n</div>",
'url:webui/widgets/dataviewer/templates/Pagination.html':"<div class=\"_grid_paginationFooter\">\t\n\t<div class=\"paginationLeft\" data-dojo-attach-point=\"paginationLeft\"></div>\n   \t<div class=\"paginationCentre\" data-dojo-attach-point=\"paginationCentre\"></div>  \t\n   \t<div class=\"paginationRight\" data-dojo-attach-point=\"paginationRight\"></div>\n</div>\n",
'url:webui/widgets/business/templates/BTEventTooltip.html':"<div data-dojo-attach-point=\"_event_tooltip\">\n\t<div data-dojo-attach-point=\"_event_tooltip_toolbar\" class=\"event_tooltip_toolbar\">\n\t\t<span class=\"event_tooltip_closeTextContainer\">\n\t\t\t<div data-dojo-attach-point=\"_event_tooltip_close_text\" class=\"event_tooltip_closeText\" tabindex=\"0\">x</div>\n\t\t</span>\n\t\t<span data-dojo-attach-point=\"_event_table_heading\" class=\"event_tooltip_title\"></span>\t\n\t</div>\n\t<div data-dojo-attach-point=\"_event_table\" class=\"event_tooltip_body\"></div>\n</div>",
'url:webui/widgets/configurableservice/templates/ImportConfigurableServiceFileDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" id=\"csImportCSFileDialog\" title=\"\">\n  <div class=\"dijitDialogTitle\">\n    <span data-dojo-attach-point=\"titleNode\" tabindex=\"0\">  </span>\n    <span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${_buttonCancelLabel}\" role=\"button\" tabIndex=\"-1\">\n      <span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${_buttonCancelLabel}\">x</span>\n    </span>\n  </div>\n  <div class=\"dijitDialogInstruction\" data-dojo-attach-point=\"_csImportFileImportInstructionDiv\">\n    <span role=\"document\" data-dojo-attach-point=\"_csImportFileImportInstructionNode\" class=\"instructional\" tabindex=\"0\" > </span>\n  </div>\n  <div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n    <div class=\"dijitDialogPaneContent\" class=\"csEditPropertyValueDialog\">\n\t\t<input data-dojo-type=\"dijit.form.TextBox\" name=\"csImportFile\" intermediateChanges=\"true\" data-dojo-attach-point=\"_csImportFile\" id=\"csImportFile\" class=\"csEditorAttribute\" spellcheck=\"false\" enabled=\"false\" readonly=\"true\"/>\n    \t<div data-dojo-type=\"dojox.form.Uploader\" data-dojo-props=\"multiple : false, uploadOnSelect : false, url : '/apiv1/policy/configurableservices/importConfigurableService'\" data-dojo-attach-point=\"_csImportUploader\" id=\"csImportUploader\"> </div>\n    </div>\n  </div>\n  <div class=\"dijitDialogPaneActionBar\">\n    <span>\n    </span>\n    <span style=\"float:right; margin-right:50px\">\n      <button data-dojo-type=\"dijit.form.Button\" type=\"submit\" data-dojo-attach-point=\"_okButton\"> ${_buttonOKLabel}</button>\n      <button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> ${_buttonCancelLabel} </button>\n    </span>\n  </div>\n</div>\n",
'url:webui/widgets/msgflows/templates/msgflow_statistics.html':"<div style=\"width:100%;height:100%;\">\n  <div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_msgflowStatistics_borderContainer\" class=\"common_profileContainer\">\n        \n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n      <div data-dojo-attach-point=\"_toolbar\"> </div>\n    </div>\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">  \n      <div class=\"_common_infoPanePropertiesPosition\">\n\n        <div class=\"_common_quickViewTitlePane statisticsContainer\" data-dojo-attach-point=\"_statisticsTitlePane\">\n          <div id=\"messageFlowStatsContainerDiv\"\n               data-dojo-type=\"dijit.TitlePane\"\n               data-dojo-props=\"title : '${NLS.statistics.per_message_description}'\"\n               data-dojo-attach-point=\"pane1\"\n               class=\"stats_titlePaneContainer\">\n            <div id=\"message_flow_charts_container\"\n                 data-dojo-attach-point=\"_statsTrendContainer\">\n              <div id=\"message_flow_statistics_chart1\"\n                   data-dojo-type=\"webui.widgets.msgflows.MessageFlowStatisticsChart\"\n                   data-dojo-attach-point=\"_messageFlowStatisticsChart1\"></div>\n              <div id=\"message_flow_statistics_chart2\"\n                   data-dojo-type=\"webui.widgets.msgflows.MessageFlowStatisticsChart\"\n                   data-dojo-attach-point=\"_messageFlowStatisticsChart2\"></div>\n              <div id=\"message_flow_statistics_chart3\"\n                   data-dojo-type=\"webui.widgets.msgflows.MessageFlowStatisticsChart\"\n                   data-dojo-attach-point=\"_messageFlowStatisticsChart3\"></div>\n            </div>\n          </div>\n          \n          <div id=\"messageFlowStatsGridContainerDiv\"\n               data-dojo-type=\"dijit.TitlePane\"\n               data-dojo-props=\"title : '${pane2Title}'\"\n               data-dojo-attach-point=\"pane2\"\n               class=\"stats_titlePaneContainer\">\n            <div id=\"statistics_msgflowStatsGrid_container\"\n                 data-dojo-type=\"webui.widgets.msgflows.MessageFlowStatisticsGrid\"\n                 data-dojo-attach-point=\"_messageFlowStatsGrid\"\n                 class=\"stats_tpnGridContainer\">\n            </div>\n          </div>\n\n          <div id=\"messageFlowStatsFlowDiagramContainerDiv\"\n               data-dojo-type=\"dijit.TitlePane\"\n               data-dojo-props=\"title : '${NLS.statisticsFlowProfile}'\"\n               data-dojo-attach-point=\"pane3\"\n               class=\"stats_titlePaneContainer\">\n            <div id=\"statistics_messageFlowDiagram\"\n                 data-dojo-type=\"dijit.layout.ContentPane\"\n                 data-dojo-attach-point=\"_messageFlowDiagram\"\n                 class=\"stats_tpnGridContainer\">\n            </div>\n          </div>\n          \n        </div>\n      </div>       \n    </div>\n  </div>\n</div>\n",
'url:webui/config/Layout.json':"{\n  \"adminLog\" : {\n    \"title\" : \"adminlogTitle\",\n    \"icon\" : \"infoPaneTitle_adminlog\",\n    \"widgets\" : [\n      {\n        \"id\" : \"adminlogTab_ID\",\n        \"title\" : \"overviewTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.adminlog.adminlog\"\n      }\n    ]\n  },\n  \"application\" : {\n    \"title\" : \"applicationTitle\",\n    \"icon\" : \"infoPaneTitle_application\",\n    \"widgets\" : [\n      {\n        \"id\" : \"applicationOverviewTab_ID\",\n        \"title\" : \"overviewTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.application.app_overview\"\n      }, {\n        \"id\" : \"brokerStatisticsTab_ID\",\n        \"title\" : \"statisticsTabTitle\",\n        \"icon\" : \"tabIcon_statistics\",\n        \"widget\" : \"webui.widgets.common.StatisticsContainer\"\n      }\n    ]\n  },\n  \"restApi\" : {\n    \"title\" : \"restApiTitle\",\n    \"icon\" : \"infoPaneTitle_restApi\",\n    \"widgets\" : [\n      {\n        \"id\" : \"restApi_overviewTab_ID\",\n        \"title\" : \"overviewTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.restapi.Overview\"\n      }, {\n        \"id\" : \"restApi_apiTab_ID\",\n        \"title\" : \"restApi_apiTabTitle\",\n        \"icon\" : \"tabIcon_restApi_api\",\n        \"widget\" : \"webui.widgets.restapi.Api\"\n      }, {\n        \"id\" : \"brokerStatisticsTab_ID\",\n        \"title\" : \"statisticsTabTitle\",\n        \"icon\" : \"tabIcon_statistics\",\n        \"widget\" : \"webui.widgets.common.StatisticsContainer\"\n      }\n    ]\n  },\n  \"api\" : {\n    \"title\" : \"restApiTitle\",\n    \"icon\" : \"infoPaneTitle_restApi\",\n    \"widgets\" : [\n      {\n        \"id\" : \"restApi_apiTab_ID\",\n        \"title\" : \"restApi_apiTabTitle\",\n        \"icon\" : \"tabIcon_restApi_api\",\n        \"widget\" : \"webui.widgets.restapi.Api\"\n      }\n    ]\n  },\n  \"broker\" : {\n    \"title\" : \"brokerTitle\",\n    \"icon\" : \"infoPaneTitle_broker\",\n    \"widgets\" : [\n      {\n        \"id\" : \"brokerOverviewTab_ID\",\n        \"title\" : \"overviewTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.broker.broker_overview\"\n      }, {\n        \"id\" : \"brokerStatisticsTab_ID\",\n        \"title\" : \"statisticsTabTitle\",\n        \"icon\" : \"tabIcon_statistics\",\n        \"widget\" : \"webui.widgets.common.StatisticsContainer\"\n      }\n    ]\n  },\n  \"configurableServices\" : {\n    \"title\" : \"configurableserviceTitleNew\",\n    \"icon\" : \"infoPaneTitle_configurableservice\",\n    \"widgets\" : [\n      {\n        \"id\" : \"configurableservicesOverviewTab_ID\",\n        \"title\" : \"overviewTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.configurableservice.cs_category_overview\"\n      }\n    ]\n  },\n  \"configurableService\" : {\n    \"title\" : \"configurableserviceTitle\",\n    \"icon\" : \"infoPaneTitle_configurableservice\",\n    \"widgets\" : [\n      {\n        \"id\" : \"configurableserviceOverviewTab_ID\",\n        \"title\" : \"overviewTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.configurableservice.cs_overview\"\n      }\n    ]\n  },\n  \"currentUser\" : {\n    \"title\" : \"profileTitle\",\n    \"icon\" : \"infoPaneTitle_profile\",\n    \"widgets\" : [\n      {\n        \"id\" : \"profilePropertiesTab_ID\",\n        \"title\" : \"profilePropertiesTabTitle\",\n        \"icon\" : \"tabIcon_properties\",\n        \"widget\" : \"webui.widgets.my_profile.MyProfile_Properties\"\n      }\n    ]\n  },\n\n  \"dataCaptureStore\" : {\n    \"title\" : \"dataCaptureStoreTitle\",\n    \"icon\" : \"infoPaneTitle_dataCaptureStore\",\n    \"widgets\" : [\n      {\n        \"id\" : \"dataCaptureStore0\",\n        \"title\" : \"dataviewerTabTitle\",\n        \"icon\" : \"explorer_dataCaptureStore\",\n        \"widget\" : \"webui.widgets.dataviewer.DataViewer\"\n      }, {\n        \"id\" : \"dataCaptureStore1\",\n        \"title\" : \"replayTabTitle\",\n        \"icon\" : \"infoPaneButton_replay\",\n        \"widget\" : \"webui.widgets.dataviewer.Replay\",\n        \"permissions\" : \"datacapture,execute\"\n      }\n    ]\n  },\n\n  \"dataCaptureStores\" : {\n    \"title\" : \"dataCaptureStoreTitle\",\n    \"icon\" : \"infoPaneTitle_dataCaptureStore\",\n    \"widgets\" : [\n      {\n        \"id\" : \"dataCaptureStore0\",\n        \"title\" : \"dataviewerTabTitle\",\n        \"icon\" : \"explorer_dataCaptureStore\",\n        \"widget\" : \"webui.widgets.dataviewer.DataViewer\"\n      }, {\n        \"id\" : \"dataCaptureStore1\",\n        \"title\" : \"replayTabTitle\",\n        \"icon\" : \"infoPaneButton_replay\",\n        \"widget\" : \"webui.widgets.dataviewer.Replay\",\n        \"permissions\" : \"datacapture,execute\"\n      }\n    ]\n  },\n\n  \"executionGroup\" : {\n    \"title\" : \"executionGroupTitle\",\n    \"icon\" : \"infoPaneTitle_execgrp\",\n    \"widgets\" : [\n      {\n        \"id\" : \"execgrpOverviewTab_ID\",\n        \"title\" : \"overviewTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.executiongroup.eg_overview\"\n      }, {\n        \"id\" : \"brokerResourceStatisticsTab_ID\",\n        \"title\" : \"resourceStatisticsTabTitle\",\n        \"icon\" : \"tabIcon_statistics\",\n        \"widget\" : \"webui.widgets.executiongroup.eg_resource_statistics\"\n      }, {\n        \"id\" : \"brokerStatisticsTab_ID\",\n        \"title\" : \"statisticsTabTitle\",\n        \"icon\" : \"tabIcon_statistics\",\n        \"widget\" : \"webui.widgets.common.StatisticsContainer\"\n      }\n    ]\n  },\n  \"library\" : {\n    \"title\" : \"libTitle\",\n    \"icon\" : \"infoPaneTitle_library\",\n    \"widgets\" : [\n      {\n        \"id\" : \"libOverviewTab_ID\",\n        \"title\" : \"overviewTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.libraries.lib_overview\"\n      }, {\n        \"id\" : \"brokerStatisticsTab_ID\",\n        \"title\" : \"statisticsTabTitle\",\n        \"icon\" : \"tabIcon_statistics\",\n        \"widget\" : \"webui.widgets.common.StatisticsContainer\"\n      }\n    ]\n  },\n  \"sharedLibrary\" : {\n    \"title\" : \"shlibTitle\",\n    \"icon\" : \"infoPaneTitle_sharedLibrary\",\n    \"widgets\" : [\n      {\n        \"id\" : \"shlibOverviewTab_ID\",\n        \"title\" : \"overviewTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.sharedlibraries.shlib_overview\"\n      }, {\n        \"id\" : \"brokerStatisticsTab_ID\",\n        \"title\" : \"statisticsTabTitle\",\n        \"icon\" : \"tabIcon_statistics\",\n        \"widget\" : \"webui.widgets.common.StatisticsContainer\"\n      }\n    ]\n  },\n  \"messageFlow\" : {\n    \"title\" : \"msgflowTitle\",\n    \"icon\" : \"infoPaneTitle_msgflow\",\n    \"widgets\" : [\n      {\n        \"id\" : \"messageFlow0\",\n        \"title\" : \"overviewTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.msgflows.msgflow_overview\"\n      }, {\n        \"id\" : \"messageFlow1\",\n        \"title\" : \"statisticsTabTitle\",\n        \"icon\" : \"tabIcon_statistics\",\n        \"widget\" : \"webui.widgets.msgflows.msgflow_statistics\"\n      }, {\n        \"id\" : \"policyAttach_ID\",\n        \"title\" : \"policyAttachTabTitle\",\n        \"icon\" : \"tabIcon_policy\",\n        \"widget\" : \"webui.widgets.policy.policy_attach\"\n      },       {\n        \"id\" : \"messageFlow2\",\n        \"title\" : \"activityLogTabTitle\",\n        \"icon\" : \"adminLog_overview\",\n        \"widget\" : \"webui.widgets.msgflows.msgflow_activityLog\"\n      }\n      \n    ]\n  },\n  \"subFlow\" : {\n    \"title\" : \"subflowTitle\",\n    \"icon\" : \"infoPaneTitle_subflow\",\n    \"widgets\" : [\n      {\n        \"id\" : \"subFlow0\",\n        \"title\" : \"overviewTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.subflows.subflow_overview\"\n      }, {\n        \"id\" : \"policyAttach_ID\",\n        \"title\" : \"policyAttachTabTitle\",\n        \"icon\" : \"tabIcon_policy\",\n        \"widget\" : \"webui.widgets.policy.policy_attach\"\n      }\n    ]\n  },\n\n  \"resource\" : {\n    \"title\" : \"resourceTitle\",\n    \"icon\" : \"infoPaneTitle_subflow\",\n    \"widgets\" : [\n      {\n        \"id\" : \"resource0\",\n        \"title\" : \"overviewTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.resources.resource_overview\"\n      }\n    ]\n  },\n\n  \"operation\" : {\n    \"title\" : \"operationTitle\",\n    \"icon\" : \"infoPaneTitle_operations\",\n    \"widgets\" : [\n      {\n        \"id\" : \"operationOverviewTab_ID\",\n        \"title\" : \"overviewTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.operation.operation_overview\"\n      }\n    ]\n  },\n  \"policy\" : {\n    \"title\" : \"policyTitle\",\n    \"icon\" : \"infoPaneTitle_policies\",\n    \"widgets\" : [\n      {\n        \"id\" : \"policyOverviewTab_ID\",\n        \"title\" : \"policyTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.policy.policy_overview\"\n      }\n    ]\n  },\n  \"service\" : {\n    \"title\" : \"serviceTitle\",\n    \"icon\" : \"infoPaneTitle_service\",\n    \"widgets\" : [\n      {\n        \"id\" : \"serviceOverviewTab_ID\",\n        \"title\" : \"policyTabTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.service.svc_overview\"\n      }, {\n        \"id\" : \"brokerStatisticsTab_ID\",\n        \"title\" : \"statisticsTabTitle\",\n        \"icon\" : \"tabIcon_statistics\",\n        \"widget\" : \"webui.widgets.common.StatisticsContainer\"\n      }\n    ]\n  },\n  \"user\" : {\n    \"title\" : \"profileTitle\",\n    \"icon\" : \"infoPaneTitle_profile\",\n    \"widgets\" : [\n      {\n        \"id\" : \"profilePropertiesTab_ID\",\n        \"title\" : \"profilePropertiesTabTitle\",\n        \"icon\" : \"tabIcon_properties\",\n        \"widget\" : \"webui.widgets.my_profile.MyProfile_Properties\"\n      }\n    ]\n  },\n  \"businessTransaction\" : {\n    \"title\" : \"businessTransactionTitle\",\n    \"icon\" : \"infoPaneTitle_bt\",\n    \"widgets\" : [\n      {\n        \"id\" : \"businessConfigTab_ID\",\n        \"title\" : \"businessConfigurationTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.business.businesstransaction_overview\"\n      }, {\n        \"id\" : \"businessPolicyTab_ID\",\n        \"title\" : \"businessConfigurationPolicyTitle\",\n        \"icon\" : \"tabIcon_policy\",\n        \"widget\" : \"webui.widgets.business.businesstransaction_configuration\"\n      }, {\n        \"id\" : \"businessResultsTab_ID\",\n        \"title\" : \"businessResultsTitle\",\n        \"icon\" : \"explorer_businessCaptureResults\",\n        \"widget\" : \"webui.widgets.business.businesstransaction_results\"\n      }\n    ]\n  },\n  \"businessTransactions\" : {\n    \"title\" : \"businessTransactionsRootTitle\",\n    \"icon\" : \"infoPaneTitle_bt\",\n    \"widgets\" : [\n      {\n        \"id\" : \"businessTransactionsRootConfigTab_ID\",\n        \"title\" : \"businessTransactionsRootConfigTitle\",\n        \"icon\" : \"tabIcon_overview\",\n        \"widget\" : \"webui.widgets.business.businesstransactions\"\n      }\n    ]\n  }\n}\n",
'url:webui/widgets/common/templates/StatisticsContainer.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_statisticsContainer_borderContainer\" class=\"common_profileContainer\">\n\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"></div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n\t\t\t<div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n\n\t\t\t\t<div class=\"_common_quickViewTitlePane statisticsContainer\" data-dojo-attach-point=\"_statisticsTitlePane\"></div>\n\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n\n",
'url:webui/widgets/executiongroup/templates/ResourceStatisticsGrid.html':"<div class=\"stats_tpnGridContainer\">\n    <span class=\"stats_nodesGridSpan\" data-dojo-attach-point=\"_resourceStatsGridSpan\">\n        <div data-dojo-attach-point=\"_resourceStatsGridDiv\"></div>\n    </span>\n</div>\n",
'url:webui/widgets/business/templates/NewBusinessTransactionDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" \n\ttitle=\"\">\n\t<div class=\"dijitDialogTitle\">\n\t\t<span class=\"pageHeader2\" data-dojo-attach-point=\"titleNode\" tabindex=\"0\"> ${_newBTDTitle} </span>\n\t\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\">x</span>\n\t\t</span>\n\t</div>\n\t<div class=\"dijitDialogInstruction\" data-dojo-attach-point=\"instructionDiv\">\n\t\t<span role=\"document\" data-dojo-attach-point=\"instructionNode\"\n\t\t\tclass=\"instructional\"> ${_newBTDDesc} </span>\n\t</div>\n\t<div data-dojo-attach-point=\"contentWrapper\" class=\"dijitDialogPaneContentWrapper\">\n\t\t<div class=\"dijitDialogPaneContent\" style=\"width:100%; height:100%; border-width:0px\">\n\t\t\t<table style=\"border-width: 0px\">\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<label for=\"nameText\" data-dojo-attach-point=\"_nameLabel\" >${_newBTDName}</label>\n\t\t\t\t\t</td>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t<input maxlength=100 data-dojo-type=\"dijit.form.ValidationTextBox\" name=\"nameText\" data-dojo-props=\"intermediateChanges: true\"\n\t\t\t\t\t\t\tdata-dojo-attach-point=\"_nameText\" tabindex=\"1\"/>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</table>\n\t\t</div>\n\t</div>\n\t<div class=\"dijitDialogPaneActionBar\">\n\t\t<span>\n\t\t</span>\n\t\t<span style=\"float:right; margin-right:50px\">\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"submit\" data-dojo-attach-point=\"_okButton\" tabindex=\"2\"> ${_btOKLabel} </button>\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\" tabindex=\"3\"> ${_btCancelLabel} </button>\n\t\t</span>\n\t</div>\n</div>",
'url:webui/widgets/application/templates/app_overview.html':"<div style=\"width:100%;height:100%;\">\n  <div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_appOverview_borderContainer\" class=\"common_profileContainer\">\n\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n      <div data-dojo-attach-point=\"_toolbar\"></div>\n    </div>\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n      <div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n\n        <div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_propertyTitlePane\"></div>\n\n        <div class=\"_common_textSpacer\"></div>\n\n      </div>\n    </div>\n  </div>\n</div>",
'url:webui/widgets/service/templates/svc_overview.html':"<div style=\"width:100%;height:100%;\">\n\t<div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_svcOverview_borderContainer\" class=\"common_profileContainer\">\n  \t\t\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n\t\t\t<div data-dojo-attach-point=\"_toolbar\"> </div>\n\t\t</div>\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\t\n\t\t\t<div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n\t\t\t\t<div class=\"_common_quickViewTitlePane\" data-dojo-attach-point=\"_propertyTitlePane\"> </div>\n\t\t\t\t<div class=\"_common_textSpacer\"> </div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n",
'url:webui/widgets/executiongroup/templates/eg_resource_statistics.html':"<div style=\"width:100%;height:100%;\">\n    <div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_resourceStatistics_borderContainer\" class=\"common_profileContainer\">\n        \n        <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n            <div data-dojo-attach-point=\"_toolbar\"> </div>\n        </div>\n        <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">  \n            <div class=\"_common_infoPanePropertiesPosition\">\n\n                <div class=\"_common_quickViewTitlePane statisticsContainer\">\n                    <div id=\"resourceStatsContainerDiv\"\n                         data-dojo-type=\"dijit.TitlePane\"\n                         data-dojo-props=\"title : '${NLS.statistics.per_message_description}'\"\n                         data-dojo-attach-point=\"pane1\"\n                         class=\"stats_titlePaneContainer\">\n                         <div id=\"resource_statistics_charts_container\" data-dojo-attach-point=\"_statsTrendContainer\">\n                             <div id=\"resource_statistics_chart1\"\n                                  data-dojo-type=\"webui.widgets.executiongroup.ResourceStatisticsChart\"\n                                  data-dojo-attach-point=\"_resourceStatisticsChart1\"></div>\n                             <div id=\"resource_statistics_chart2\"\n                                  data-dojo-type=\"webui.widgets.executiongroup.ResourceStatisticsChart\"\n                                  data-dojo-attach-point=\"_resourceStatisticsChart2\"></div>\n                             <div id=\"resource_statistics_chart3\"\n                                  data-dojo-type=\"webui.widgets.executiongroup.ResourceStatisticsChart\"\n                                  data-dojo-attach-point=\"_resourceStatisticsChart3\"></div>\n                         </div>\n                    </div>\n                    \n                    <div id=\"resourceStatsGridContainerDiv\"\n                         data-dojo-type=\"dijit.TitlePane\"\n                         data-dojo-props=\"title : '${pane2Title}'\"\n                         data-dojo-attach-point=\"pane2\"\n                         class=\"stats_titlePaneContainer\">\n                         <div id=\"statistics_statsGrid_container\"\n                              data-dojo-type=\"webui.widgets.executiongroup.ResourceStatisticsGrid\"\n                              data-dojo-attach-point=\"_resourceStatsGrid\"\n                              class=\"stats_tpnGridContainer\">\n                         </div>\n                    </div>\n                </div>                    \n            </div>       \n        </div>\n    </div>\n</div>\n",
'url:webui/widgets/restapi/templates/Resource.html':"<div>\n  <div aria-controls=\"container\" role=\"button\" data-dojo-attach-point=\"_resource\" class=\"restApis_resource\" tabindex=\"0\">\n    <span data-dojo-attach-point=\"_expando\" class=\"restApis_resourceExpando\"></span>\n    <span data-dojo-attach-point=\"_path\" class=\"restApis_resourcePath\"></span>\n    <span data-dojo-attach-point=\"_description\" class=\"restApis_resourceDescription\"></span>\n  </div>\n  <div id=\"container\" aria-expanded=\"true\" role=\"region\" data-dojo-attach-point=\"_container\" class=\"restApis_operationContainer\"></div>\n</div>",
'url:webui/config/ResourceTypeGridLayouts.json':"{\n  \"JVM\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"22%\"\n    }, {\n      \"field\" : \"InitialMemoryInMB\",\n      \"width\" : \"13%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"UsedMemoryInMB\",\n      \"width\" : \"13%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"CommittedMemoryInMB\",\n      \"width\" : \"13%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"MaxMemoryInMB\",\n      \"width\" : \"13%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"CumulativeGCTimeInSeconds\",\n      \"width\" : \"13%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"CumulativeNumberOfGCCollections\",\n      \"width\" : \"13%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"Parsers\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"19%\",\n      \"name\" : \"name\"\n    }, {\n      \"field\" : \"Threads\",\n      \"width\" : \"9%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\",\n      \"name\" : \"Threads\"\n    },{\n      \"field\" : \"ApproxMemKB\",\n      \"width\" : \"9%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\",\n      \"name\" : \"Approximate Memory (KB)\"\n    },{\n      \"field\" : \"MaxReadKB\",\n      \"width\" : \"9%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\",\n      \"name\" : \"Maximum Read (KB)\"\n    },{\n      \"field\" : \"MaxWrittenKB\",\n      \"width\" : \"9%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\",\n      \"name\" : \"Maximum Written (KB)\"\n    },{\n      \"field\" : \"Fields\",\n      \"width\" : \"9%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\",\n      \"name\" : \"Fields\"\n    },{\n      \"field\" : \"Reads\",\n      \"width\" : \"9%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\",\n      \"name\" : \"Reads\"\n    },{\n      \"field\" : \"FailedReads\",\n      \"width\" : \"9%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\",\n      \"name\" : \"FailedReads\"\n    },{\n      \"field\" : \"Writes\",\n      \"width\" : \"9%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\",\n      \"name\" : \"Writes\"\n    },{\n      \"field\" : \"FailedWrites\",\n      \"width\" : \"9%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\",\n      \"name\" : \"FailedWrites\"\n    }\n  ]],\n  \"SOAPInput\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"23%\"\n    }, {\n      \"field\" : \"InboundMessagesTotal\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"RepliesSentTotal\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"InboundMessagesMadeFlow\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"InboundMessagesFaultedBeforeFlow\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"SuccessfulRepliesSent\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"FaultRepliesSent\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"PolicySetApplied\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"GlobalCache\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"12%\"\n    }, {\n      \"field\" : \"TotalMapActions\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"MapReads\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"MapWrites\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"MapRemoves\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"FailedActions\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"MapsUsed\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ConnectionFailures\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"Connects\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"DecisionServices\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"25%\"\n    }, {\n      \"field\" : \"SuccessfulDecisions\",\n      \"width\" : \"25%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"FailedDecisions\",\n      \"width\" : \"25%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"RulesMatched\",\n      \"width\" : \"25%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"FTEAgent\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"20%\"\n    }, {\n      \"field\" : \"InboundTransfers\",\n      \"width\" : \"20%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"InboundBytes\",\n      \"width\" : \"20%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"OutboundTransfers\",\n      \"width\" : \"20%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"OutboundBytes\",\n      \"width\" : \"20%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"FTP\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"20%\"\n    }, {\n      \"field\" : \"FTPGets\",\n      \"width\" : \"16%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"BytesReceived\",\n      \"width\" : \"16%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"FTPPuts\",\n      \"width\" : \"16%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"BytesSent\",\n      \"width\" : \"16%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"Protocol\",\n      \"width\" : \"16%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"File\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"22%\"\n    }, {\n      \"field\" : \"FilesRead\",\n      \"width\" : \"13%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"RecordsRead\",\n      \"width\" : \"13%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"BytesRead\",\n      \"width\" : \"13%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"FilesCreated\",\n      \"width\" : \"13%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"RecordsWritten\",\n      \"width\" : \"13%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"BytesWritten\",\n      \"width\" : \"13%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"JDBCConnectionPools\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"23%\"\n    }, {\n      \"field\" : \"NameOfJDBCProvider\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"MaxSizeOfPool\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ActualSizeOfPool\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"CumulativeRequests\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"CumulativeDelayedRequests\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"CumulativeTimedOutRequests\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"MaxDelayInMilliseconds\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"JMS\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"20%\"\n    }, {\n      \"field\" : \"NumberOfOpenJMSConnections\",\n      \"width\" : \"10%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"NumberOfClosedJMSConnections\",\n      \"width\" : \"10%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"NumberOfOpenJMSSessions\",\n      \"width\" : \"10%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"NumberOfClosedJMSSessions\",\n      \"width\" : \"10%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"NumberOfMessagesReceived\",\n      \"width\" : \"10%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"NumberOfMessagesSent\",\n      \"width\" : \"10%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"NumberOfMessagesBrowsed\",\n      \"width\" : \"10%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"NumberOfJMSConnectionFailures\",\n      \"width\" : \"10%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"ODBC\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"25%\"\n    }, {\n      \"field\" : \"ExecuteSuccess\",\n      \"width\" : \"15%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ExecuteFailure\",\n      \"width\" : \"15%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ActiveConnections\",\n      \"width\" : \"15%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ClosedConnections\",\n      \"width\" : \"15%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ConnectionErrors\",\n      \"width\" : \"15%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"Security\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"20%\"\n    }, {\n      \"field\" : \"TotalCacheEntries\",\n      \"width\" : \"20%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"TotalOperations\",\n      \"width\" : \"20%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"TotalSuccessfulOperations\",\n      \"width\" : \"20%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"TotalOperationsServicedByCache\",\n      \"width\" : \"20%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"Sockets\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"20%\"\n    }, {\n      \"field\" : \"TotalSockets\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"TotalMessages\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"TotalDataSent_KB\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"TotalDataReceived_KB\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"SentMessageSize_0-1KB\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"SentMessageSize_1KB-10KB\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"SentMessageSize_10KB-100KB\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"SentMessageSize_100KB-1MB\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"SentMessageSize_100KB-1MB\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"SentMessageSize_Over10MB\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ReceivedMessageSize_0-1KB\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ReceivedMessageSize_1KB-10KB\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ReceivedMessageSize_10KB-100KB\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ReceivedMessageSize_100KB-1MB\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ReceivedMessageSize_100KB-1MB\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ReceivedMessageSize_Over10MB\",\n      \"width\" : \"5%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"TCPIPClientNodes\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"23%\"\n    }, {\n      \"field\" : \"OpenConnections\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ClosedConnections\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"MessagesReceived\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"MessagesSent\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"BytesReceived\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"BytesSent\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"FailedConnections\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"TCPIPServerNodes\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"23%\"\n    }, {\n      \"field\" : \"OpenConnections\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ClosedConnections\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"MessagesReceived\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"MessagesSent\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"BytesReceived\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"BytesSent\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"FailedSSLConnections\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"CORBA\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"25%\"\n    }, {\n      \"field\" : \"OutboundInvocations\",\n      \"width\" : \"25%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"OutboundSuccessfulInvocations\",\n      \"width\" : \"25%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"OutboundCorbaExceptions\",\n      \"width\" : \"25%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"CICS\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"20%\"\n    }, {\n      \"field\" : \"RequestSuccess\",\n      \"width\" : \"20%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"RequestFailures\",\n      \"width\" : \"20%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"RequestSecurityFailures\",\n      \"width\" : \"20%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ConnectionAttemptFailures\",\n      \"width\" : \"20%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"ConnectDirect\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"25%\"\n    }, {\n      \"field\" : \"InboundTransfers\",\n      \"width\" : \"15%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"InboundBytes\",\n      \"width\" : \"15%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"NoHitTransfers\",\n      \"width\" : \"15%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"OutboundTransfers\",\n      \"width\" : \"15%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"OutboundBytes\",\n      \"width\" : \"15%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"MQTT\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"23%\"\n    }, {\n      \"field\" : \"BytesReceived\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"BytesSent\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ClosedConnections\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"FailedConnections\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"MessagesReceived\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"MessagesSent\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"OpenConnections\",\n      \"width\" : \"11%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"DotNet GC\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"16%\"\n    }, {\n      \"field\" : \"ExplicitGCCount\",\n      \"width\" : \"7%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"Gen0CollectionsTaken\",\n      \"width\" : \"7%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"Gen1CollectionsTaken\",\n      \"width\" : \"7%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"Gen2CollectionsTaken\",\n      \"width\" : \"7%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"CommittedInMB\",\n      \"width\" : \"7%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ReservedInMB\",\n      \"width\" : \"7%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"Gen0HeapSizeInMB\",\n      \"width\" : \"7%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"Gen1HeapSizeInMB\",\n      \"width\" : \"7%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"Gen2HeapSizeInMB\",\n      \"width\" : \"7%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"LargeObjectHeapSizeInMB\",\n      \"width\" : \"7%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"PromotedFromGen0InMB\",\n      \"width\" : \"7%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"PromotedFromGen1InMB\",\n      \"width\" : \"7%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]],\n  \"DotNet App Domains\": [[\n    {\n      \"field\" : \"name\",\n      \"width\" : \"20%\"\n    }, {\n      \"field\" : \"CurrentlyInUseInMB\",\n      \"width\" : \"15%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"TotalAllocatedInMB\",\n      \"width\" : \"15%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"Id\",\n      \"width\" : \"10%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    },{\n      \"field\" : \"ApplicationBase\",\n      \"width\" : \"40%\",\n      \"cellStyles\": \"text-align: right\",\n      \"headerStyles\": \"text-align: right\"\n    }\n  ]]\n}\n",
'url:webui/widgets/restapi/templates/BulkRESTApiPushFeedbackDialog.html':"<div class=\"idxDialog\" data-dojo-type=\"dijit.Dialog\" id=\"_restApiPushFeedbackDialog\" title=\"\">\n\t<div class=\"dijitDialogTitle\">\n\t\t<span class=\"pageHeader2\" data-dojo-attach-point=\"titleNode\"> ${_pushApisFeedbackTitle} </span>\n\t\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\">x</span>\n\t\t</span>\n\t</div>\n\t<div data-dojo-attach-point=\"_pushFeedbackDialogSection\" class=\"dijitDialogPaneContentWrapper restApis_feedbackDialog_section\">\n\t\t<div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-attach-point=\"_pushFeedbackDetailsSection\" class=\"restApis_feedbackDialog_feedbackDetails\">\n\t\t  <table data-dojo-attach-point=\"_pushFeedbackDetailsTable\" class=\"restApis_feedbackDialog_feedback_table\"></table>\n\t\t</div>\n\t\t<div data-dojo-attach-point=\"_pushFeedbackResultSection\" class=\"restApis_feedbackDialog_feedback_summary\"></div>\n\t</div>\n\t<div class=\"dijitDialogPaneActionBar\">\n\t\t<span style=\"float:right; margin-right:50px\">\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_backButton\"> ${_pushApisBackLabel} </button>\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_closeButton\"> ${_pushApisCloseLabel} </button>\n\t\t\t<button data-dojo-type=\"dijit.form.Button\" type=\"button\" data-dojo-attach-point=\"_cancelButton\"> ${_pushApisCancelLabel} </button>\n\t\t</span>\n\t</div>\n</div>\n",
'url:webui/widgets/executiongroup/templates/ResourceStatisticsChart.html':"<div id=\"${id}_resourceStatsChartWidgetContainer\"\n     data-dojo-attach-point=\"_resourceStatsChartWidgetContainer\"\n     class=\"statsTrend\"\n     style=\"clear:both\">\n    <h3 id=\"${id}_resourceStatsChartTitle\"\n         data-dojo-attach-point=\"_resourceStatsChartTitle\"\n         class=\"ResourceStatsChartTitle\"></h3>\n    <div class=\"selfClear\">\n        <div id=\"${id}_resourceStatsChart\"\n             data-dojo-attach-point=\"_resourceStatsChart\"\n             class=\"ResourceStatsChart\"></div>\n        <div data-dojo-attach-point=\"_resourceStatsChartRightTable\"\n             class=\"ResourceStatsChartSideTable StatsTrendSideTable\">\n            <table>\n                <tr>\n                    <td colspan=\"2\" class=\"TopLeftRightRad StatsTrendHeading\">\n                        <div data-dojo-type=\"dijit.form.Select\"\n                             data-dojo-attach-point=\"_resourceMetricSelect\">\n                        </div>\n                    </td>\n                </tr>\n                <tr>\n                    <td class=\"StatsTrendContent label\">${NLS.statistics.latestTitle}</td>\n                    <td data-dojo-attach-point=\"_latestValue\" class=\"StatsTrendContent value\">0</td>\n\t\t\t\t</tr>\n                <tr>\n                    <td class=\"StatsTrendContent label\">${NLS.statistics.highTitle}</td>\n                    <td data-dojo-attach-point=\"_highestValue\" class=\"StatsTrendContent value\">0</td>\n                </tr>\n                <tr>\n                    <td class=\"StatsTrendContent label\">${NLS.statistics.averageTitle}</td>\n                    <td data-dojo-attach-point=\"_averageValue\" class=\"StatsTrendContent value\">0</td>\n                </tr>\n                <tr>\n                    <td class=\"StatsTrendContent label\">${NLS.statistics.lowTitle}</td>\n                    <td data-dojo-attach-point=\"_lowestValue\" class=\"StatsTrendContent value\">0</td>\n                </tr>\n                <tr>\n                    <td colspan=\"2\" class=\"BottomLeftRightRad StatsTrendHeading lowRise\">&nbsp;</td>\n                </tr>\n            </table>\n\t\t</div>\n    </div>\n</div>\n",
'url:webui/widgets/executiongroup/templates/eg_attach_policy.html':"<div style=\"width:100%;height:100%;\">\n  <div data-dojo-type=\"dijit.layout.BorderContainer\" data-dojo-props=\"design: 'headline', gutters: false\" data-dojo-attach-point=\"_egOverview_borderContainer\" class=\"common_profileContainer\">\n\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'top', gutters: 'false'\" class=\"infoPane_toolbar\">\n      <div data-dojo-attach-point=\"_toolbar\"></div>\n    </div>\n    <div data-dojo-type=\"dijit.layout.ContentPane\" data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n      <div data-dojo-attach-point=\"_profilePropertiesInfoPane\" class=\"_common_infoPanePropertiesPosition\">\n          <div data-dojo-type=\"dijit.TitlePane\" data-dojo-attach-point=\"_monitoringPolicySection\" id= \"_monitoringPolicySection\" \n              data-dojo-props=\"region: 'center'\" class=\"common_infoPane\">\n              <label for=\"btRecorderPolicy\" >${_btRecorderLabel} </label>\n              \n              <select data-dojo-type=\"dijit/form/ComboBox\" id=\"btRecorderPolicy\" name=\"btRecorderPolicy\" \n                data-dojo-attach-point=\"_btRecorderPolicy\" >\n              </select>                    \n          </div>\n        <div id=\"btConfirmLeaveEGAttach\"></div>\n        <div class=\"_common_textSpacer\"></div>\n\n        <div data-dojo-attach-point= \"_btRecorderDetails\"></div>\n      </div>\n    </div>\n  </div>\n</div>\n\n\n",
'*now':function(r){r(['dojo/i18n!*preload*webui/nls/webui*["de","es","fr","it","ja","ko","pl","pt","ru","tr","zh-cn","zh-tw"]']);}
}});
