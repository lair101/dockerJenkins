<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="de-de" xml:lang="de-de">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="copyright" content="Copyright IBM Corporation 2013, 2014" />
<link rel="stylesheet" type="text/css" href="./css/pattern.css" />
<!-- 
    (C) COPYRIGHT International Business Machines Corp., 2013, 2014
    All Rights Reserved * Licensed Materials - Property of IBM
    -->
<title>Konzept des Musters 'Healthcare: HL7 an HL7 DFDL'</title>
</head>
<body role="main">
	<a name="links"></a>
	<div class="section">
		<h1 class="topictitle1">Konzept des Musters 'Healthcare: HL7 an HL7 DFDL'</h1>
		<p class="shortdesc">Bei diesem Muster werden eingehende HL7-Nachrichten mit dem HL7DFDLInput-Knoten gelesen; es bestehen keine Einschränkungen hinsichtlich der Segmente, die eine Nachricht enthalten kann, vorausgesetzt, diese Segmente sind in dem HL7-DFDL-Modell enthalten, das vom Muster verwendet wird. Das Muster kann die DFDL-Bibliotheken HL7v27, HL7v26 oder HL7v251 verwenden, die in IBM Integration Bus Healthcare Pack enthalten sind. Die HL7-DFDL-Bibliothek enthält Definitionen aller Segmente, die in HL7 Version 2.5.1, 2.6 und 2.7 gültig und standardmäßig definiert sind. Sie können dieser HL7-DFDL-Bibliothek weitere Z-Segmente hinzufügen. Z-Segmente werden von Anwendungen verwendet, um Daten zu senden oder zu empfangen, die außerhalb der HL7-Spezifikation definiert sind.</p>
		<p>Vom Receiver-Nachrichtenfluss werden für die Quellennachricht einmalig eine Folgenummerierung, Duplikatprüfung und HL7-Bestätigung ausgeführt.</p>
		<p>Das Muster 'Healthcare: HL7 an HL7 DFDL' gibt die Anzahl der Ziele an, an die eine eingehende Nachricht verteilt wird. Die Nachricht wird für jedes Ziel verarbeitet und es erfolgt eine Filterung. Diese Filterung bestimmt, ob die Nachricht für das Ziel erforderlich ist. Außerdem wird so festgelegt, welche Segmente in der Quellennachricht in die Ausgabenachricht aufgenommen werden.</p>
		<p>Der Sender-Nachrichtenfluss für jedes Ziel stellt sicher, dass Nachrichten in der richtigen Reihenfolge an die Zielanwendung gesendet werden.</p>
	</div>
	<div>
		<p>Dieses Kapitel enthält folgende Abschnitte:</p>
		<div>
						<a href="design.htm#source">Quellennachricht unter Verwendung des HL7DFDLInput-Knotens verarbeiten</a>
		</div>
		<div>
						<a href="design.htm#sequencing">Sequenzbildung im Receiver-Nachrichtenfluss</a>
		</div>
		<div>
			<a href="design.htm#transform">Transformation und Routing</a>
		</div>
		<div>
						<a href="design.htm#sending">Sender-Nachrichtenflüsse</a>
		</div>
		<div>
						<a href="design.htm#messageset">HL7-DFDL-Bibliothek</a>
		</div>
		<div>
						<a href="design.htm#publish">Ausgabe aus einer Musterinstanz</a>
		</div>
	</div>
	<div class="section">
		<a name="source"></a>
		<h2>Quellennachricht unter Verwendung des HL7DFDLInput-Knotens verarbeiten</h2>
		<p>Eine Eingabenachricht wird zunächst vom HL7DFDLInput-Knoten im Receiver-Nachrichtenfluss als BLOB-Nachricht gelesen. Vor dem Parsing werden die führenden MLLP-Bytes entfernt. Wenn das führende Byte nicht gefunden wird, wird die Nachricht abgelehnt, da der Sender das MLLP-Protokoll nicht einhält. Die Verbindung wird geschlossen und eine Antwortnachricht mit einer negativen Rückmeldung (NACK) wird gesendet.</p>
		<p>
						Der HL7DFDLInput-Knoten analysiert die Nachricht entsprechend der HL7-Nachrichtendefinition in der HL7-DFDL-Bibliothek (siehe <a href="resources.htm">Ressourcen für das Muster <span> Healthcare: HL7 an HL7 DFDL</span>)</a>. Alle Segmente werden gelesen. Falls ein Segment zusätzliche Felder aufweist, werden diese Felder in ein Remainder-Feld für dieses Segment gestellt.
		</p>
		<h3>Nachrichtenvalidierung</h3>
		<p>Im Receiver-Nachrichtenfluss erfolgt keine Standardvalidierung der Nachrichtendaten. Es wird jedoch überprüft, ob die folgenden HL7-spezifischen Datenfelder im MSH-Segment vorhanden sind, da diese Felder für die weitere Verarbeitung erforderlich sind:</p>
		<ul>
			<li>MSH1 - Feldtrennzeichen</li>
			<li>MSH2 - Servicezeichenfolge</li>
			<li>MSH3 - Sendende Anwendung</li>
			<li>MSH4 - Sendende Einrichtung</li>
			<li>MSH10 - Nachrichtensteuerungs-ID</li>
			<li>MSH11 - Verarbeitungs-ID</li>
			<li>MSH12 - Versions-ID</li>
		</ul>
		<h3>Verarbeitungsoption für Duplikate</h3>
		<p>Jede eingehende HL7-Nachricht enthält ein MessageControlID-Feld im MSH-Headersegment, das den Datensatz identifiziert.</p>
		<p>Über die Musterparameter, über die die Prüfung auf Duplikate gesteuert wird, werden die entsprechenden Eigenschaften im HL7DFDLInput-Knoten gesetzt.</p>
		<p>
						Wenn das Kontrollkästchen <span class="uicontrol"> Auf Duplikate überprüfen</span> im IBM Integration Toolkit ausgewählt ist, werden alle IDs zusammen mit der an den Absender zurückgegebenen Bestätigung (ACK) in der Warteschlange für Duplikate gespeichert. Die Kennung einer eingehenden Nachricht wird gegen die gespeicherten Kennungen abgeglichen, um festzustellen, ob es sich um ein Duplikat handelt.
		</p>
		<p>Wird ein
Duplikat erkannt, wird es nicht verarbeitet, sondern es wird dieselbe Bestätigung, die mit der
ersten Nachricht gesendet wurde, an den Sender zurückgegeben.</p>
		<p>Kennungen werden für eine bestimmte Zeit in der Warteschlange für Duplikate gespeichert. Nach Ablauf dieser Zeitspanne werden sie gelöscht und Nachrichten mit derselben Kennung werden nicht mehr als Duplikate behandelt. Der Standardzeitraum für das Speichern von Nachrichtenkennungen beträgt 24 Stunden, Sie können diesen Zeitwert jedoch mithilfe eines Musterparameters ändern. Die Warteschlange für Duplikate muss so groß sein, dass sie den Spitzenwert der im festgelegten Zeitraum erwarteten Nachrichtenkennungen enthalten kann.</p>
		<p>Handelt es sich bei einer eingehenden Nachricht nicht um ein Duplikat, wird sie über das Ausgangsterminal des HL7DFDLInput-Knotens zur Weiterverarbeitung weitergeleitet.</p>
		<p>Wird festgestellt, dass es sich bei einer Nachricht um ein Duplikat handelt, gibt der HL7DFDLInput-Knoten eine Bestätigung (ACK) an den Anforderer zurück. Wurde die Option 'Duplikate melden' ausgewählt und wird ein Duplikat erkannt oder treten andere Fehler im	HL7DFDLInput-Knoten auf, wird die Nachricht an das Fehlerterminal übergeben und die Umgebung enthält eine Beschreibung des Fehlers.</p>
	</div>
	<p></p>
	<a name="sequencing"></a>
	<h3>Sequenzbildung im Receiver-Nachrichtenfluss</h3>
	<p>
		Der Parameter <span class="msobjprop">Folgenummern</span> legt fest, wie der Receiver-Nachrichtenfluss einer Eingabenachricht Folgenummern zuweist, um sicherzustellen, dass Nachrichten in der richtigen Reihenfolge zugestellt werden.
	</p>
	<p>Für die Zuweisung von Folgenummern stehen drei Optionen zur Verfügung:</p>
	<ul>
		<li><span class="msobjpropval">Nach Eingang</span> Dies ist die Standardoption. Der Integrationsknoten weist den Nachrichten bei ihrem Eingang Folgenummern zu. Der Receiver-Nachrichtenfluss muss als Einzelthreadfluss implementiert sein, damit Nachrichten in der Reihenfolge eintreffen und entsprechende Folgenummern erhalten, in der sie von der Quellenanwendung gesendet wurden.</li>
		<li><span class="msobjpropval">Nach Inhalt</span> Es werden die im HL7-MSH-Segment enthaltenen Folgenummern verwendet. Sie können diese Option auswählen, wenn Sie sicher sind, dass die Quellenanwendung dieses Feld zuverlässig ausfüllt.</li>
		<li><span class="msobjpropval">Keine Reihenfolge</span> Wählen Sie diese Option aus, wenn Nachrichten nicht in einer bestimmten Reihenfolge an die Ziele übermittelt werden müssen; in diesem Fall sind keine Sequence-Knoten im Receiver-Nachrichtenfluss enthalten.</li>
	</ul>
	<h3>Bestätigungen</h3>
	<p>Bei der Interaktion für dieses Muster handelt es sich um eine synchrone Interaktion zwischen der Quellenanwendung und dem Integrationsknotennachrichtenfluss, wobei die Nachricht in der Warteschlange für den Nachrichtenfluss 'TransformAndRoute' verbleibt, bis die synchrone Bestätigung gesendet wird.</p>
	<p>
		Der HL7-Receiver-Nachrichtenfluss generiert standardmäßig eine Bestätigungsantwort (ACK) oder eine Antwortnachricht mit einer negativen Rückmeldung (NACK) als Antwort auf den erfolgreichen Empfang von Daten. Falls keine Bestätigungen erforderlich sind, wählen Sie das Kontrollkästchen für den Parameter <span class="msobjprop">
Bestätigung senden</span> ab.
	</p>
	<p>Nachdem die Bestätigung zurückgegeben wurde, überprüfen die Nachrichtenflüsse des Integrationsknotens, ob die Nachricht verarbeitet wurde oder ein Fehler aufgetreten ist; ist ein Fehler aufgetreten, werden die Nachrichtendaten gespeichert, um eine erneute Übergabe oder eine alternative Verarbeitung zu ermöglichen.</p>
	<p>Wenn die Nachricht Werte enthält, die für die Erstellung einer Bestätigung erforderlich sind, werden diese Werte verwendet.</p>
	<p>Der aktuelle Status der End-to-End-Interaktion wird an allen wichtigen Stellen im Nachrichtenfluss gespeichert und die NACK-Nachrichten enthalten diese Fehlerinformationen.</p>
	<div class="tablenoborder">
		<h2>MSH</h2>
		<table summary="" width="100%" border="1" cellpadding="4"
			cellspacing="0" frame="border" rules="all">
			<thead align="left">
				<tr>
					<th class="firstcol" align="left" valign="top" width="33%">Feldname</th>
					<th class="invisible" valign="top" width="33%">Feldwert in Bestätigungsnachricht</th>
					<th class="invisible" valign="top" width="34%">Falls in der Eingabenachricht nicht vorhanden</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSH1 - Feldtrennzeichen</th>
					<td valign="top" width="*" class="invisible">MSH1 - Feldtrennzeichen aus der Eingabenachricht</td>
					<td valign="top" width="*" class="invisible"><span
						class="msobjpropval"> '|' </span></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSH - Servicezeichenfolge</th>
					<td valign="top" width="*" class="invisible">MSH.2 - Servicezeichenfolge aus der Eingabenachricht</td>
					<td valign="top" width="*" class="invisible"><span
						class="msobjpropval"> '^~\&amp;' </span></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSH3 - Sendende Anwendung</th>
					<td valign="top" width="*" class="invisible"><span
						class="msobjpropval"> 'BROKER.RECEIVER' </span></td>
					<td valign="top" width="*" class="invisible"></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSH4 - Sendende Einrichtung</th>
					<td valign="top" width="*" class="invisible"><span
						class="msobjpropval"> ' ' </span></td>
					<td valign="top" width="*" class="invisible"></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSH5 - Empfangende Anwendung</th>
					<td valign="top" width="*" class="invisible">MSH3 - Sendende Anwendung aus der Eingabenachricht</td>
					<td valign="top" width="*" class="invisible"><span
						class="msobjpropval"> ' ' </span></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSH6 - Empfangende Einrichtung</th>
					<td valign="top" width="*" class="invisible">MSH4 - Sendende Einrichtung aus der Eingabenachricht</td>
					<td valign="top" width="*" class="invisible"><span
						class="msobjpropval"> ' ' </span></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSH7 - Datum/Uhrzeit der Nachricht</th>
					<td valign="top" width="*" class="invisible">Das aktuelle Datum und die aktuelle Uhrzeit im Format <span class="msobjprop"> YYYYMMddHHmmss </span> .</td>
					<td valign="top" width="*" class="invisible"></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSH9 - Nachrichtentyp</th>
					<td valign="top" width="*" class="invisible"><span
						class="msobjpropval"> 'ACK' </span></td>
					<td valign="top" width="*" class="invisible"></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSH10 - Nachrichtensteuerungs-ID</th>
					<td valign="top" width="*" class="invisible">Neue eindeutige Kennung</td>
					<td valign="top" width="*" class="invisible"></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSH11 - Verarbeitende ID</th>
					<td valign="top" width="*" class="invisible">MSH11 - Verarbeitende ID aus der Eingabenachricht</td>
					<td valign="top" width="*" class="invisible"><span
						class="msobjpropval"> 'P' </span></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSH12 - Versions-ID</th>
					<td valign="top" width="*" class="invisible">MSH12 - Versions-ID aus der Eingabenachricht</td>
					<td valign="top" width="*" class="invisible"><span
						class="msobjpropval"> '2.2' </span></td>
				</tr>
			</tbody>
		</table>
		<h2>MSA</h2>
		<table summary="" width="100%" border="1" cellpadding="4"
			cellspacing="0" frame="border" rules="all">
			<thead align="left">
				<tr>
					<th class="firstcol" align="left" valign="top" width="33%">Feldname</th>
					<th class="invisible" valign="top" width="33%">Feldwert in Bestätigungsnachricht</th>
					<th class="invisible" valign="top" width="34%">Falls in der Eingabenachricht nicht vorhanden</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSA.1.AcknowledgmentCode</th>
					<td valign="top" width="*" class="invisible">Beim erfolgreichen Empfang der Nachricht wird der MSA-Bestätigungscode auf <span class="msobjpropval">
                AA
                </span> gesetzt und das Feld MSA.3.TextMessage ist nicht belegt.</td>
					<td valign="top" width="*" class="invisible"></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSA.2.MessageControlID</th>
					<td valign="top" width="*" class="invisible">MSH.10.Nachrichtensteuerungs-ID aus der Eingabenachricht</td>
					<td valign="top" width="*" class="invisible"><span
						class="msobjpropval"> '123456789' </span></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSA.3.TextMessage</th>
					<td valign="top" width="*" class="invisible">Beim erfolgreichen Empfang der Nachricht wird der MSA-Bestätigungscode auf <span class="msobjpropval">
                AA
                </span> gesetzt und das Feld MSA.3.TextMessage ist nicht belegt.</td>
					<td valign="top" width="*" class="invisible"></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">MSA.4.ExpectedSequenceNumber</th>
					<td valign="top" width="*" class="invisible">MSH.13.ExpectedSequenceNumber aus der Eingabenachricht</td>
					<td valign="top" width="*" class="invisible"></td>
				</tr>
			</tbody>
		</table>
		<h3>Fehler</h3>
		<p>
			<b>Fehler beim Entfernen des MLLP-Bytes</b>. Der MSA-Bestätigungscode wird auf <span class="msobjpropval">
    AR
    </span> gesetzt und das Feld MSA.3.TextMessage enthält die Nachricht <span class="msobjpropval">
    MLLP Error - missing start byte
    </span> (MLLP-Fehler - Startbyte fehlt).
		</p>
		<p>
			<b>Fehler beim Überprüfen des eingehenden MSH oder beim Deduplizieren der Daten</b>. Der MSA-Bestätigungscode wird auf <span class="msobjpropval">AE</span> gesetzt und das Feld 'MSA.3.TextMessage' enthält eine Nachricht, die einen DFDL-Analysefehler meldet. Diese Nachricht enthält eine Zusammenfassung des Fehlers.
		</p>
		<p>
			<b>Fehler beim Anwenden der Sequenzlogik</b>. Der MSA-Bestätigungscode wird auf <span class="msobjpropval">
    AR
    </span> gesetzt und das Feld MSA.3.TextMessage enthält die Nachricht <span class="msobjpropval">
    An internal failure in the Sequence node
    </span> (Interner Fehler im Sequence-Knoten).
		</p>
		<p>
			<b>Fehler beim Definieren der HL7-Nachricht als persistente Nachricht in einer Warteschlange</b>. Der MSA-Bestätigungscode wird auf <span class="msobjpropval">
    AR
    </span> gesetzt und das Feld MSA.3.TextMessage enthält die Nachricht <span class="msobjpropval">
    Error while committing message into processor queue
    </span> (Fehler beim Festschreiben der Nachricht in Prozessorwarteschlange).
		</p>
	</div>
	<div>
		<h2>Verteilung</h2>
		<p>Die Quellennachricht wird zur Transformation und Weiterleitung in mindestens eine Warteschlange geschrieben. Die Nachricht wird für jeden Teil des Musters in eine Warteschlange geschrieben und jeder Teil des Musters wird dann an die erforderliche Anzahl an Zielen weitergeleitet.</p>
	</div>
	<p></p>
	<div class="section">
		<a name="transform"></a>
		<h2 class="sectiontitle">Transformation und Weiterleitung</h2>
		<p>Der Nachrichtenfluss 'TransformAndRoute' liest eine HL7-Nachricht aus der Warteschlange.
		</p>
		<h3>Remainder-Felder</h3>
		<p>
						Wenn der Parameter <span class="msobjprop">
Restliche melden</span> ausgewählt ist, wird überprüft, ob Remainder-Felder vorhanden sind. Dabei handelt es sich um zusätzliche Felder, die in einem Segment festgestellt, jedoch nicht in die HL7-Nachricht modelliert werden, mit der eingehende Nachrichten syntaktisch analysiert werden. Falls Remainder-Felder gefunden werden, werden diese in eine Warteschlange geschrieben oder veröffentlicht. Diese Option wird während der Entwicklung für die Erkennung zusätzlicher Felder und für die Festlegung ihrer Verarbeitungsweise verwendet.
		</p>
		<h3>Kanonisches XML-Format</h3>
		<p>Die HL7-Nachricht wird in ihr kanonisches XML-Format transformiert und an den untergeordneten Nachrichtenfluss 'SubCustomize' übergeben. Dieser untergeordnete Nachrichtenfluss führt standardmäßig keine anderen Aktionen als die Weitergabe der Nachricht aus. Der untergeordnete Nachrichtenfluss stellt jedoch einen Ort dar, an dem Sie eine bestimmte Musterinstanz ohne Änderung der Nachrichtenflussstruktur anpassen können.</p>
		<p>
						Wenn der Parameter <span class="msobjprop">
Kanonischer Feed</span> ausgewählt wird, wird zu diesem Zeitpunkt das kanonische Format ausgegeben. Weitere Informationen finden Sie unter <a href="design.htm#publish">Ausgabe aus einer Musterinstanz</a>. Sie können das kanonische Format der Eingabenachricht als Feed für andere Anwendungen verwenden, die keine HL7-Basisnachrichten akzeptieren.
		</p>
		<h3>Verteilung an Ziele</h3>
		<p>
			    Das Muster stellt für jeden Teil des Musters bis zu sechs Ziele zur Verfügung. Sie können jedes Ziel gesondert konfigurieren. Wenn Sie weniger als sechs Ziele auswählen, werden nur die ausgewählten Ziele konfiguriert. Der Nachrichtenfluss 'TransformAndRoute' sendet für jedes Ziel eine Kopie der Nachricht an den filternden untergeordneten Nachrichtenfluss für den Nachrichtenfluss 'TransformAndRoute'. Für jedes Ziel wird ein Filter ausgeführt, mit dem festgelegt wird, ob eine eingehende Nachricht an das Ziel gesendet wird. Zur Generierung einer Liste mit zulässigen Paaren aus Nachrichtencode und Nachrichtenereignis wird von den Musterparametern für jedes Ziel ein filternder untergeordneter Nachrichtenfluss (Dest<var>n</var>Filter) konfiguriert. Dabei steht <var>n</var> für die Nummer des Ziels. Nur übereinstimmende Nachrichten werden an die Zielanwendung übergeben.
		</p>
		<p>
						Sobald eine Nachricht herausgefiltert wird, wird an den untergeordneten Sender-Nachrichtenfluss (Dest<var>n</var>Sender) eine Pseudonachricht übergeben. Dabei steht <var>n</var> für die Nummer des Ziels. Dies gilt jedoch nicht, wenn der Parameter <span class="msobjprop">
Reihenfolgeaktion</span> auf <span class="msobjpropval">
    Keine Reihenfolge</span> gesetzt ist. Diese Pseudonachricht ist erforderlich, damit die richtige Sequenzbildung der Nachrichten aus der Quelle gewahrt bleibt.
		</p>
		<h2>Segmentfilterung</h2>
		<p>
			    Nach der Nachrichtenfilterung wird jede erforderliche Nachricht wieder in das HL7-Format transformiert. Wenn der Parameter <span class="msobjprop">
    Segmentfilter</span> ausgewählt ist, werden alle Segmente, die in der Tabelle <span class="msobjprop">
    Segmentfilter
    </span> für das Ziel aufgelistet sind, als Teil der Transformation entfernt.
		</p>
		<h2>Anpassung</h2>
		<p>Die Nachricht durchläuft anschließend einen untergeordneten Nachrichtenfluss zur Anpassung. Dieser untergeordnete Nachrichtenfluss führt standardmäßig keine anderen Aktionen als die Weitergabe der Nachricht aus.
			Der untergeordnete Nachrichtenfluss stellt jedoch einen Ort dar, an dem Sie eine bestimmte Musterinstanz anpassen können. Schließlich wird die Nachricht in die Warteschlange für den Sender-Nachrichtenfluss geschrieben.</p>
	</div>
	<div class="section">
		<a name="sending"></a>
		<h2 class="sectiontitle">Sender-Nachrichtenflüsse</h2>
		<p>
			Für jedes Ziel wird ein separater Nachrichtenfluss (der untergeordnete Nachrichtenfluss Dest<var>n</var>Sender) erstellt. Dabei steht <var>n</var> für die Nummer des Ziels.
		</p>
		<h3>Neusequenzbildung</h3>
		<p>
						Die Sequenzbildung für ein Ziel kann entweder strikt oder locker sein. Dies wird durch den Musterparameter <span class="msobjprop">
    Reihenfolgeaktion</span> bestimmt. Wenn die Sequenzbildung <span class="msobjpropval">
    Strikt</span> ausgewählt wird, enthält der Sender-Nachrichtenfluss einen Resequence-Knoten ohne Zeitlimit. Treffen Nachrichten in falscher Reihenfolge ein, werden sie in der Sequenzbildungswarteschlange zurückgehalten, bis die fehlenden Nachrichten eintreffen. Wird diese Option ausgewählt, muss die Systemwarteschlange, in der sich anstehende Nachrichten befinden, überwacht werden und zur Bereitstellung fehlender Nachrichten muss eine entsprechende Maßnahme ergriffen werden.
		</p>
		<p>
						Für jede Nachricht, die erfolgreich an ein Ziel zugestellt wird, werden die Folgenummern aus der Quelle und jede eventuelle Neusequenzbildung im Sender-Nachrichtenfluss in die Warteschlange <var>Warteschlangenpräfix</var>.SEQNOS geschrieben. Das <var>Warteschlangenpräfix</var> wird durch den Parameter <span class="msobjprop">
    Warteschlangenpräfix
    </span> definiert, und zwar gemeinsam mit einer Zeitmarke und der Folgegruppe, die dem Ziel entspricht, das als Dest<var>n</var> angegeben ist. Dabei steht <var>n</var> für die Nummer des Ziels.
		</p>
		<p>
						Selbst bei einer strikten Sequenzbildung kann es vorkommen, dass einige Nachrichten nicht an ein Ziel weitergegeben werden, wenn die Option <span class="msobjprop">
    Nachrichtenfilter</span> ausgewählt ist. In diesem Fall werden die Pseudonachrichten, die diese Nachricht darstellen und nicht für die Zustellung vorgesehen sind, nach der Neusequenzbildung entfernt und den folgenden Nachrichten werden vor ihrer Übergabe an das Ziel neue Folgenummern zugewiesen.
		</p>
		<p>
						Wenn die Sequenzbildungsoption <span class="msobjpropval">
    Nicht strikt</span> ausgewählt ist, werden Nachrichten im Allgemeinen der Reihe nach zugestellt. Falls jedoch nach Ablauf der Zeit, die über den Parameter <span class="msobjprop">
    Zeitlimit für Reihenfolge</span> angegeben ist, eine Nachricht fehlt, wird eine Nachricht an die Benachrichtigungswarteschlange gesendet und der Nachrichtenfluss wird fortgesetzt.
Die fehlende Nachricht wird in den Nachrichtenfluss eingefügt, sobald sie eintrifft. Fehlende Nachrichten werden bei ihrem Eintreffen außerdem in die Warteschlange .SEQNTFY geschrieben.
		</p>
		<p>Standardmäßig sind folgende Sequenzbildungswarteschlangen des Systems definiert:</p>
		<ul>
			<li>SYSTEM.BROKER.EDA.EVENTS</li>
			<li>SYSTEM.BROKER.EDA.COLLECTIONS</li>
		</ul>
		<p>
						Wenn der Parameter <span class="msobjprop">
    Separate Sequenzwarteschlangen</span> für ein Muster ausgewählt ist, werden Sequenzbildungswarteschlangen, die speziell für die Musterinstanz vorgesehen sind, über den Parameter <span class="msobjprop">
    Warteschlangenpräfix
    </span> wie folgt definiert:
		</p>
		<ul>
			<li>SYSTEM.BROKER.EDA.<var>Warteschlangenpräfix</var>.EVENTS</li>
			<li>SYSTEM.BROKER.EDA.<var>Warteschlangenpräfix</var>.COLLECTIONS</li>
		</ul>
		<p>
						Diese vom Standard abweichenden Sequenzbildungswarteschlangen werden durch einen konfigurierbaren Service namens<span class="msobjprop">
    patternInstance_setSeqQs
    </span> definiert. Die Integrationsknoteninstanz erstellt die Datei <span class="filepath"> <i>Musterinstanz</i>.resequence.configurableservice
			</span> mit einer Definition dieses Service. Diese muss in dem Integrationsknoten erstellt werden, in dem die Musterinstanz ausgeführt werden soll. Die Sender-Nachrichtenflüsse werden ebenfalls für die Verwendung dieses konfigurierbaren Service konfiguriert.
		</p>
		<p>Falls für ein Ziel keine Sequenzbildung erforderlich ist, werden der Resequence-Knoten und der Bericht über fehlende Nachrichten im Nachrichtenfluss übergangen.</p>
		<h3>Senden und Wiederholen im HL7DFDLOutput-Knoten</h3>
		<p>
						Der HL7DFDLOutput-Knoten bereitet eine Nachricht für die Zielanwendung auf, indem er sie in einen Bitstrom ändert und an den Anfang das erforderliche MLLP-Begrenzerbyte (Minimal Lower Layer Protocol) <span
				class="msobjpropval"> 0B </span> stellt. Anschließend leitet der HL7DFDLOutput-Knoten diese aufbereitete Nachricht an den TCP/IP-Output-Knoten weiter, der die Nachricht an die Zielanwendung sendet.
		</p>
		<p>
						Falls die Zielanwendung den Erfolgscode <span class="msobjpropval">
    AA
    </span> zurückgibt, wird die Variable <span class="msobjprop">
    Environment.PatternVariables.FlowMilestoneReached
    </span> gelöscht und die Nachricht wird an das Ausgangsterminal übergeben.
		</p>
		<p>
						Falls die Zielanwendung den Antwortcode <span class="msobjpropval">
    AE
    </span> zurückgibt, wird die Variable <span class="msobjprop">
    Environment.PatternVariables.FlowMilestoneReached
    </span> auf <span class="msobjpropval">
    ACKAE
    </span> gesetzt und die Nachricht wird an das Fehlerterminal übergeben. Im Anschluss an eine <span class="msobjpropval">
    ACKAE</span>-Antwort erfolgen keine Wiederholungen.
		</p>
		<p>
						Wenn die Nachricht erfolgreich gesendet, jedoch keine oder eine ungültige Bestätigung erhalten wurde, wird sie genau wie eine <span class="msobjpropval">
    AE</span>-Antwort behandelt. Allerdings wird die Variable <span class="msobjprop">
    Environment.PatternVariables.FlowMilestoneReached
    </span> auf <span class="msobjpropval">
    TIMEOUT
    </span>,
    <span class="msobjpropval">
    RECEIVEACK
    </span> oder <span class="msobjpropval">
    ACKERROR
    </span> gesetzt, bevor die Nachricht an das Fehlerterminal übergeben wird. Es erfolgen keine Wiederholungen.
		</p>
		<p>
						Kann der HL7DFDLOutput-Knoten die Nachricht nicht an das Ziel senden oder wird vom Ziel eine Bestätigung des Typs <span class="msobjpropval"> AR </span> zurückgegeben, wird die Nachricht an das Terminal zum Protokollieren von Wiederholungen übergeben. Die Zustellung der Nachricht wird wiederholt, sobald die Steuerung nach der Protokollierung zurückgegeben wird, und zwar bis sie erfolgreich ist oder die Anzahl der Wiederholungen den Grenzwert erreicht hat, der durch den Parameter<span class="msobjprop">
    Wiederholungslimit
    </span> festgelegt ist.
		</p>
		<p>
						Sobald das Wiederholungslimit erreicht wurde, wird die Variable <span class="msobjprop">
    Environment.PatternVariables.FlowMilestoneReached
    </span> auf <span class="msobjpropval">
    ACKARTOOMANYREPEATS
    </span> gesetzt und die Nachricht wird an das Fehlerterminal übergeben.
		</p>
		<h3>Nachrichtenvalidierung</h3>
		<p>
			Die Inhaltsvalidierung wird auf einer Zielbasis ausgewählt. Hierfür wird der Parameter <span class="msobjprop">
    Validierung</span> im Abschnitt <span class="msobjprop">
    Zielübertragungen</span> verwendet. Wenn für ein Ziel eine Validierung ausgewählt ist, wird der Parameter <span class="msobjprop">
    Validierung
    </span> auf dem MQInput-Knoten für den relevanten Sender-Nachrichtenfluss auf <span class="msobjpropval">
    Inhalt
    </span> gesetzt. Die Eigenschaft <span class="msobjprop">
    Zeitpunkt des Parsings
    </span> auf diesem Knoten wird durch das Muster als <span class="msobjpropval">
    Sofort
    </span> definiert, damit die Validierung vor der weiteren Verarbeitung erfolgt.
			Die Validierung für die Nachricht erfolgt nur anhand der HL7-DFDL-Bibliothek. Sie bietet beispielsweise keine vollständige HL7-Validierung abhängiger Felder.
		</p>
	</div>
	<div class="section">
		<a name="messageset"></a>
		<h2 class="sectiontitle">HL7-DFDL-Modellbibliothek</h2>
		<p>Die HL7-DFDL-Modellbibliothek wird zusammen mit dem DFDL-Parser zum Analysieren und Schreiben von HL7-Nachrichten verwendet. Die resultierende Nachrichtenbaumstruktur kann in ein kanonisches XML-Format serialisiert werden. Die Nachrichtendefinitionen sind so flexibel, dass lokale Abweichungen toleriert werden, ohne dass eine Anpassung erforderlich ist. Sie können auch erweitert werden, damit das Parsing von lokal definierten Z-Segmenten und zusätzlichen Feldern möglich ist. Wenn lokale Abweichungen auftreten und die Daten in diesen lokalen Abweichungen verarbeitet werden müssen, muss das HL7-Modell geändert werden, damit es einer passenden Spezifikation entspricht. Nur so ist sichergestellt, dass auf alle Daten zugegriffen werden kann.</p>
		<p>Das kanonische Format kann von Ihrem Unternehmen zum Speichern einer Darstellung Ihrer Daten verwendet werden, die auf einem beliebigen Betriebssystem ausgeführt werden. Diese Daten können in Form von standardisierten Datums- und Zeitangaben, in einem bestimmten Zahlenformat oder in Übereinstimmung mit sonstigen Anforderungen an die Datenstandardisierung angegeben werden, die von Ihrem Unternehmen verlangt werden. Das kanonische Format stellt eine Trennung der Quellen- und Zielanwendungen dar, was eine maximale Wiederverwendung bei geringem Verwaltungsaufwand ermöglicht. In den von Ihnen generierten Mustern ist ein untergeordneter Anpassungsfluss für dieses kanonische Format enthalten.</p>
		<p>
						Die HL7-DFDL-Bibliothek enthält globale Elementdefinitionen für alle Segmente, die in der HL7-Spezifikation Version 2.5.1, 2.6 oder 2.7 definiert sind. Die Komponenten und Unterkomponenten in jedem Segment werden mit den richtigen Begrenzern modelliert. Sie können eine generische Nachrichtendefinition namens <span class="msobjprop">
    HL7
    </span> verwenden, um eine beliebige Folge von HL7-Segmenten syntaktisch zu analysieren.
		</p>
		<p>

			Muster <span>Healthcare: HL7 an HL7 DFDL </span>.
		</p>
	</div>
	<p></p>
	<div class="section">
		<a name="publish"></a>
		<h2 class="sectiontitle">Ausgabe aus einer Musterinstanz</h2>
		<p>
						Neben den HL7-Nachrichten, die an angegebene Ziele weitergeleitet werden, stellt das Muster 'Healthcare: HL7 an HL7 DFDL' noch eine Reihe anderer Ausgaben bereit. Diese Ausgaben werden in eine Warteschlange geschrieben oder an einen Veröffentlichungsknoten gesendet. Die Zieladresse wird durch den Musterparameter
    <span class="msobjprop">
    Veröffentlichen
    </span> bestimmt. Wenn die Option <span class="msobjpropval">
    Veröffentlichen
    </span> ausgewählt ist, werden alle Informationen unter Verwendung einer Themenhierarchie veröffentlicht, die mit dem Namen der Musterinstanz beginnt.
		</p>
		<p>
						Ist die Option <span class="msobjpropval">
    In Warteschlange schreiben
    </span> ausgewählt, wird die Ausgabe an Warteschlangen gesendet, deren Namen
    auf Basis des Musterparameters
    <span class="msobjprop">
    Warteschlangenpräfix
    </span> und einer festen Suffixgruppe generiert werden. Eine entsprechende Auflistung finden Sie in der folgenden Tabelle.
		</p>
		<p>
						<b>Hinweis</b>: Die anfängliche Facette jedes Themas und jeder Warteschlange (der Name der Musterinstanz) wird nicht angezeigt.
		</p>
	</div>
	<div class="tablenoborder">
		<table summary="" width="100%" border="1" cellpadding="4"
			cellspacing="0" frame="border" rules="all">
			<thead align="left">
				<tr>
					<th class="firstcol" align="left" valign="top" width="20%">Ausgabe</th>
					<th class="invisible" valign="top" width="15%">Warteschlange</th>
					<th class="invisible" valign="top" width="15%">Thema</th>
					<th valign="top" width="50%">Hinweise</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">Quellenfeed</th>
					<td valign="top" width="*" class="invisible">.SRC</td>
					<td valign="top" width="*" class="invisible">/Receiver/Source</td>
					<td valign="top" width="*" class="invisible">Es wird eine Kopie des Quellennachricht nach dem Empfang geschrieben.</td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">Journal</th>
					<td valign="top" width="*" class="invisible">.JRNL</td>
					<td valign="top" width="*" class="invisible">/Receiver/Journal</td>
					<td valign="top" width="*" class="invisible">Diese Ausgabe stellt ein Journal der eingehenden Nachrichten im standardmäßigen Musterformat bereit.
<p>Siehe Hinweis 1.</p></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">An TransformAndRoute-Flüsse</th>
					<td valign="top" width="*" class="invisible">.RXF<var>n</var>
					</td>
					<td valign="top" width="*" class="invisible">Nicht zutreffend</td>
					<td valign="top" width="*" class="invisible">Für jedes Ziel wird eine Nachricht an den Nachrichtenfluss 'TransformAndRoute' gesendet.</td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">Fehlerhafte Nachrichten</th>
					<td valign="top" width="*" class="invisible">.ERR</td>
					<td valign="top" width="*" class="invisible">Nicht zutreffend</td>
					<td valign="top" width="*" class="invisible">Nachrichten, die nicht ordnungsgemäß verarbeitet werden können, werden mit Fehlerinformationen in die Fehlerwarteschlange in einem MQRFH2-Header geschrieben.</td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">Nachrichten-IDs für die Überprüfung auf Duplikate</th>
					<td valign="top" width="*" class="invisible">.DUPID</td>
					<td valign="top" width="*" class="invisible">Nicht zutreffend</td>
					<td valign="top" width="*" class="invisible">Nachrichten-IDs und die zugehörigen Bestätigungsnachrichten werden für den Abgleich mit später eingehenden Nachrichten zur Ermittlung doppelter Nachrichten gespeichert.
<p>Siehe Hinweis 2.</p></td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">Reste</th>
					<td valign="top" width="*" class="invisible">.REM</td>
					<td valign="top" width="*" class="invisible">/Remainders</td>
					<td valign="top" width="*" class="invisible">Nachrichten mit Remainder-Feldern können optional geschrieben werden.</td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">Kanonisch</th>
					<td valign="top" width="*" class="invisible">.CAN</td>
					<td valign="top" width="*" class="invisible">/Canonical</td>
					<td valign="top" width="*" class="invisible">Wenn die Option für die Ausgabe eines kanonischen Feeds ausgewählt ist, wird ein kanonisches XML-Format der Eingabenachricht geschrieben.</td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">An Sender-Nachrichtenflüsse</th>
					<td valign="top" width="*" class="invisible">.DEST<var>n</var>
					</td>
					<td valign="top" width="*" class="invisible">Nicht zutreffend</td>
					<td valign="top" width="*" class="invisible">Für jedes Ziel wird eine Nachricht an den Sender-Nachrichtenfluss gesendet.</td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">Daten zur Reihenfolge</th>
					<td valign="top" width="*" class="invisible">SYSTEM.BROKER.EDA.EVENTS</td>
					<td valign="top" width="*" class="invisible">Nicht zutreffend</td>
					<td valign="top" width="*" class="invisible">Die Systemwarteschlange, die standardmäßig von den Resequence-Knoten in den Sender-Nachrichtenflüssen verwendet wird.</td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">Daten zur Reihenfolge</th>
					<td valign="top" width="*" class="invisible">SYSTEM.BROKER.EDA.COLLECTIONS</td>
					<td valign="top" width="*" class="invisible">Nicht zutreffend</td>
					<td valign="top" width="*" class="invisible">Die Systemwarteschlange, die standardmäßig von den Resequence-Knoten in den Sender-Nachrichtenflüssen verwendet wird.</td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">Daten zur Reihenfolge</th>
					<td valign="top" width="*" class="invisible">SYSTEM.BROKER.EDA.<var>Warteschlangenpräfix</var>.EVENTS</td>
					<td valign="top" width="*" class="invisible">Nicht zutreffend</td>
					<td valign="top" width="*" class="invisible">Die Warteschlange, die von den Resequence-Knoten in den Sender-Nachrichtenflüssen verwendet wird, wenn die Option <span class="msobjpropval">
                Separate Sequenzwarteschlangen
                </span> ausgewählt ist.</td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">Daten zur Reihenfolge</th>
					<td valign="top" width="*" class="invisible">SYSTEM.BROKER.EDA.<var>Warteschlangenpräfix</var>.COLLECTIONS</td>
					<td valign="top" width="*" class="invisible">Nicht zutreffend</td>
					<td valign="top" width="*" class="invisible">Die Warteschlange, die von den Resequence-Knoten in den Sender-Nachrichtenflüssen verwendet wird, wenn die Option <span class="msobjpropval">
                Separate Sequenzwarteschlangen
                </span> ausgewählt ist.</td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">Nachrichten in falscher Reihenfolge</th>
					<td valign="top" width="*" class="invisible">.SEQNTFY</td>
					<td valign="top" width="*" class="invisible">Nicht zutreffend</td>
					<td valign="top" width="*" class="invisible">Wenn die Sequenzbildungsoption <span class="msobjpropval">
                Lax
                </span> (Locker) ausgewählt ist, werden Nachrichten, die in falscher Reihenfolge eintreffen, in diese Warteschlange geschrieben und an das Ziel zugestellt.</td>
				</tr>
				<tr>
					<th align="left" valign="top" width="*" class="firstcol">Folgenummern</th>
					<td valign="top" width="*" class="invisible">.SEQNOS</td>
					<td valign="top" width="*" class="invisible">Nicht zutreffend</td>
					<td valign="top" width="*" class="invisible">Diese Warteschlange erfasst die aktuellste Folgenummer, die an jedes Ziel zugestellt wird.
						Wenn die Sequenzbildungsoption <span class="msobjpropval">
                Strikt
                </span> ausgewählt ist, wird mit der Warteschlange die letzte an ein Ziel zugestellte Folgenummer bestimmt.</td>
				</tr>
			</tbody>
		</table>
		<p>
						<b>Hinweis 1:</b> Es wird eine Journalnachricht aus einer Quellennachricht erstellt, indem MQMD- und MQRFH2-Header hinzugefügt werden. Der MQRFH2-Header enthält folgende Komponenten:
		</p>
		<ul>
			<li>            Name des Integrationsknotens
        </li>
			<li>Nachrichtenfluss</li>
			<li>Aktuelle Zeitmarke</li>
		</ul>
		<p>
						<b>Hinweis 2:</b> Jede Nachricht wird beim Empfang von der Warteschlange für Nachrichten-IDs auf eine vorherige Nachricht mit der gleichen ID überprüft. Diese Nachrichten erhalten ein von einem Nachrichtenparameter festgelegtes Zeitlimit, nach dem die Nachrichten aus der Warteschlange entfernt werden.
Deshalb werden doppelte Werte nur innerhalb eines angegebenen Zeitraums geprüft; der Standardwert liegt bei 24 Stunden.
</p>
	</div>
		<a href="overview.htm#anchorBack" title="Zurück">Zurück zur Spezifikation des Musters 'Healthcare: HL7 an HL7 DFDL'</a>
	<p></p>
</body>
</html>
