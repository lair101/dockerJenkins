<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja-jp" xml:lang="ja-jp">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="copyright" content="Copyright IBM Corporation 2011, 2014"/>
    <link rel="stylesheet" type="text/css" href="./css/pattern.css"/>
    <!-- 
    (C) COPYRIGHT International Business Machines Corp., 2011, 2014
    All Rights Reserved * Licensed Materials - Property of IBM
    --> 
    <title>「Healthcare: HL7 to HL7」パターン・インスタンスの管理</title>
</head>
<body role="main">
<a name="links"></a> <h1 class="topictitle1">「Healthcare: HL7 to HL7」パターン・インスタンスの管理</h1>
<p class="shortdesc">
パターン・パラメーターを使用すると、ユーザー独自のパターン・インスタンス用に値を設定したパターン・インスタンスを生成できます。
ただし、パターン・インスタンスのデプロイと管理を行う必要があり、特定の運用コンテキストに合わせた変更が必要な場合もあります。
</p>
<p>
ここでのパターンは、すべてのメッセージ・フローが単一の Integration ノードで実行される、単純なトポロジーであることを前提としています。
この単純なトポロジーを使用するパターン・インスタンスのデプロイおよび管理に関する情報と、パターン・インスタンスを管理する方法について、このトピックで説明します。
</p>
<p>
パターンには特定のカスタマイズ・ポイントがいくつか含まれており、それを利用してユーザー独自の変更を追加できます。
</p>
<p>
このトピックには、以下のセクションが含まれています。
    </p>
<div>
    <a href="management.htm#setup">セットアップ</a>
</div>
<div>
    <a href="management.htm#messageset">HL7v25P メッセージ・セットの準備</a>
</div>
<div>
    <a href="management.htm#customize">カスタマイズ</a>
</div>
<div>
    <a href="management.htm#deployment">パターンのデプロイメント</a>
</div>
<div>
    <a href="management.htm#errors">モニターおよびエラー処理</a>
</div>
<div class="section">
    <a name="setup"></a> <h2 class="sectiontitle">セットアップ</h2> <h4>キュー</h4>
    <p>
パターンが必要とするキューを定義するために MQSC スクリプトを生成することにした場合は、パターン・インスタンスを生成する前に、<span class="uicontrol">「パターン・パラメーターの構成」</span>タブの<span class="uicontrol">「一般」</span>セクションにある<span class="msobjpropval">「スクリプトの生成」</span>チェック・ボックスを選択してください。
<tt>queues.mqsc</tt> というこのスクリプトは、パターン・インスタンス・プロジェクトのルート・ディレクトリーにあります。
これは、基本的なキューおよびトピックを定義します。
</p>
    <p>
MQSC スクリプトを実行するには、以下のコマンドを使用します。
ここで、<var>MBQMGR</var> は、Integration ノードのキュー・マネージャーの名前です。
</p>
    <pre>runmqsc <var>MBQMGR</var> &lt; queues.mqsc</pre>
    <p>
この MQSC スクリプトを編集すれば、使用している環境の説明を追加し、適切なキュー項目数を設定できます。
</p>
    <p>
特に、キュー flowprefix.DUPID の項目数をチェックする必要があります。
このキューには、重複データ・ストアが保持されます。
このキューには、重複検査に使用するすべてのデータが格納されます。
重複チェックを有効にした場合、このキューに必要な項目数は、受信側の最大メッセージ・レートに有効期限の設定値を掛けて計算されます。
例えば、最大レートが 1 秒あたり 10 個のメッセージで、有効期限の設定値が 24 時間 (86,400 秒) であれば、必要な項目数は <span class="msobjpropval">864,000</span> です。
</p>
    <p>
その他のキューもモニターして定期的にクリアすることをお勧めします。
これらのキューはデフォルトのサイズで作成されますが、その使用を検討して、項目数が十分であることを確認する必要があります。
</p>
    <p>
パターン・インスタンスをデプロイする前に、MQSC スクリプトを実行する必要があります。
</p>
    <h4>構成可能サービス</h4>
    <p>
順序付けをオンに切り替え、シーケンス・キューを分離するオプションを選択した場合、パターンは構成可能サービス・ファイルを生成します。
このファイルは、パターンのインスタンスを生成した時に作成され、生成されるメッセージ・フローを含むコンテナー・プロジェクトのルート・ディレクトリーに格納されます。
この構成可能サービスにより、順序付け情報をどこに格納するかに関する情報が Resequence ノードに提供されます。
構成可能サービスは、パターンをデプロイする前に、Integration ノードにデプロイする必要があります。
</p>
</div>
<div class="section">
    <a name="messageset"></a> <h2 class="sectiontitle">HL7v25P メッセージ・セットの準備</h2>
    <p>
HL7v25P メッセージ・セットをダウンロードします。
<a href = "resources.htm#resources"><span>「Healthcare: HL7 to HL7」</span>パターンのリソース</a>を参照してください。
</p>
    <p>
このメッセージ・セットは、HL7 v2.5 標準で示されている標準を満たしています。
パターンによって使用されるメッセージは、<span class="msobjpropval">segments.mxsd</span> メッセージ定義ファイルの HL7 メッセージです。
ソース・アプリケーションまたは宛先アプリケーションで標準に修正を加えた場合は、それらの修正をメッセージ・モデルに反映させる必要があります。
よく行われる修正には、以下のものがあります。
</p>
    <ul>
        <li>
メッセージ・モデルで定義されているフィールドの必須設定に対する修正。
<span class="msobjprop">「最小オカレンス」</span>または<span class="msobjprop">「最大オカレンス」</span>パラメーターの値を変更します。
</li>
        <li>
ソース・アプリケーションまたは宛先アプリケーションで使用される Z セグメントの作成。
Z セグメントは、HL7v25P メッセージ・セットで定義されていないアプリケーション固有のデータをモデル化します。
</li>
        <li>
標準に対するベンダー固有の修正または追加。
</li>
    </ul>
    <b>新規 Z セグメントの作成</b>
<p>
Z セグメントは、HL7 仕様の外側で定義されているデータを送信または受信するために、アプリケーションによって使用されます。
Z セグメントをモデル化し、それを実装環境で使用することができます。
</p>
    <ol>
        <li>
新規メッセージ定義ファイルを作成します。
このファイルは、アプリケーション固有のコードを、メイン HL7v25P メッセージ・セットとは別にして保持します。
HL7v25P メッセージ・セットを右クリックし、<span class="uicontrol">「新規」&gt;「メッセージ定義ファイル」</span>を選択します。
</li>
        <li>
メッセージ定義ファイルの<span class="msobjprop">「ターゲット・ネーム・スペース」</span>プロパティーを <span class="msobjpropval">urn:hl7-org:v2xml</span> に設定します。
</li>
        <li>
新規メッセージ定義ファイルを開き、<span class="uicontrol">「プロパティー」</span>タブを選択します。
<span class="filepath">datatypes.mxsd</span> ファイルを追加します。
</li>
        <li>
新規 <span class="filepath">.mxsd</span> ファイルで、ソース・アプリケーションまたは宛先アプリケーションによって提供された Z セグメント定義と同じ名前で新規グローバル・エレメントを作成します。
</li>
        <li>
このエレメントの<span class="msobjprop">「タイプ」</span>を<span class="msobjpropval">「新規ローカル複合」</span>に変更します。
</li>
        <li>
個々のフィールドをローカル・エレメントとして作成します。
子フィールドを持つフィールドが Z セグメントに含まれている場合、<span class="uicontrol">「詳細情報」</span>をクリックして、メニューからエレメントに適切な<span class="msobjprop">「タイプ」</span>を選択します。
これらのタイプは、<span class="filepath">fields.mxsd</span> ファイルで定義されています。
結果として生成される構造が、ソース・プロバイダーまたは宛先プロバイダーの仕様と一致することを確認してください。
</li>
        <li>
新規エレメントを HL7 メッセージに追加します。<ol>
                <li>
<span class="filepath">segments.mxsd</span> メッセージ定義ファイルを開き、<span class="uicontrol">「プロパティー」</span>タブを選択し、作成した新規メッセージ定義ファイルを組み込み、変更を保存します。
</li>
                <li>
作成した新規エレメントのために、HL7 メッセージへのエレメント参照を追加します。
<ol>
                        <li>
<span class="filepath">segments.mxsd</span> メッセージ定義ファイルで、HL7 メッセージを展開します。
</li>
                        <li>
<span class="uicontrol">「選択」</span>を右クリックし、<span class="uicontrol">「エレメント参照の追加」</span>を選択します。
</li>
                    </ol>
                </li>
                <li>
作成したグローバル・エレメントのプロパティーを開き、エレメント名と同じになるようにタグを設定します。
</li>
            </ol>
        </li>
        <li>
新規 Z セグメント内のエレメントごとに、プロパティーを開き、ネーム・スペースを <span class="msobjpropval">urn:hl7-org:v2xml</span> に設定します。
</li>
    </ol>
    <b>HL7 標準に対するベンダー固有の追加</b>
<p>
HL7 実装環境では、HL7 によって定義された標準セグメントに対して追加を行うことができます。
そのためには、セグメントの最後にフィールドを追加します。
これらの追加は、一般的に、各セグメント定義の最後にある剰余フィールドによってモデル化されます。
ただし、ベンダーが必要とする付加的なフィールドを剰余フィールドの前に追加することもできます。
</p>
</div>
<div class="section">
    <a name="customize"></a> <h2 class="sectiontitle">カスタマイズ</h2>
    <p>
パターンのユーザーは 3 つの主要なカスタマイズ・ポイントを利用できますが、それ以外の付加的なカスタマイズ・ポイントも利用できます。
</p>
    <h4>送信元でのカスタマイズ</h4>
    <p>
メイン TransformAndRoute メッセージ・フローは、メッセージを異なる宛先に配布する前、さらに (必要な場合) メッセージの標準形式を作成する前に、SubCustomize サブフローを呼び出します。
</p>
    <p>
デフォルトの SubCustomize サブフローはメッセージに何の影響も与えませんが、このカスタマイズ・ポイントを使用すれば、送信元からのデータを要件に合わせて標準化できます。
例えば、日付の標準形式が <span class="msobjpropval">YYYY-MM-DD</span> である場合に、送信元で異なる日付形式が使用されているというケースがあります。
このカスタマイズ・ポイントを使用すると、任意のソース・データを変更できます。
さらに、データベースなど、他の情報源からのデータをこのポイントで組み込むこともできます。
</p>
    <h4>宛先でのカスタマイズ</h4>
    <p>
各宛先には、メッセージに影響を与えない Dest<var>n</var> という名前 (<var>n</var> は宛先の番号) のデフォルトのカスタマイズ・サブフローがあります。
しかし、このサブフローを使用して、その宛先で必要な仕様と一致する出力メッセージを作成することができます。
例えば、宛先で以下のような変更が必要になる場合があります。
</p>
    <ul>
        <li>
Z セグメントで必要な追加のデータ。
</li>
        <li>
送信元からのデータの修正。
例えば、患者の生年月日を宛先の日付形式の要件に基づいてフォーマット設定します。
</li>
        <li>
宛先で不要またはサポートされていないデータの削除。
</li>
    </ul>
    <h4>ソース・フィードまたは正規のフィードの使用</h4>
    <p>
ソース・フィードまたは正規フィードを生成することにした場合、受信側フローによって処理される各メッセージは、ソース・メッセージのコピーまたは正規化後のメッセージのコピーを生成します。
これらのメッセージは、パターン・パラメーターによって決定されるとおりに、WebSphere MQ キューに書き込まれるか、パブリッシュされます。
</p>
    <p>
パターンと互換性のない宛先にメッセージを送信する必要があることがあります。
例えば、データウェアハウス、HL7 以外の宛先、または異なるトランスポート・メカニズムを使用している宛先にメッセージを送信する場合です。
パターンと互換性のない宛先にメッセージを送信するには、ソース・フィードまたは正規のフィードからのメッセージを処理する統合ソリューションを作成します。
</p>
</div>
<div class="section">
    <a name="deployment"></a> <h2 class="sectiontitle">パターンのデプロイメント</h2>
    <p>
新規 BAR ファイルを、そのリソースを保管する場所に作成します。
</p>
    <p>
HL7v25P メッセージ・セットを、それ専用の BAR ファイルにパッケージする必要があります。
</p>
    <ol>
        <li>
HL7v25P メッセージ・セットを選択し、BAR ファイルをビルドします。
</li>
        <li>
パターンまたはパターンの一部分を実行するすべての統合サーバーに BAR ファイルをデプロイします。
</li>
        <li>
HL7v25P メッセージ・セットのデプロイ後、必要なすべてのキューが定義されていることと、すべての構成可能サービス・ファイルがデプロイされていることを確認します。
</li>
        <li>
特定の統合サーバーにデプロイするフローが入った、1 つ以上の BAR ファイルを作成します。
単一のランタイム環境で実行される最も単純なケースでは、受信側フロー、TransformAndRoute フロー、およびすべての宛先フローを含めます。
</li>
        <li>
フロー作成後にパフォーマンスを上げるには、順序付け要件がないすべてのフローについて、<span class="msobjprop">「追加インスタンス」</span> の設定を上げることができます。
<ol>
                <li>
<span class="uicontrol">「管理」</span>タブをクリックします。
</li>
                <li>
構成するフローのプロパティーを選択し、ご使用の実装環境で必要な値を設定します。
</li>
            </ol>
        </li>
    </ol>
    <p>
    </p>
</div>
<div class="section">
    <a name="errors"></a> <h2 class="sectiontitle">モニターおよびエラー処理</h2>
    <p>
エラー通知は、パターン内のすべてのメッセージ・フローのエラー・キューに書き込まれます。
またキュー・トレースも、パターンの生成時に定義した場所に出力されます。
エラー・メッセージの MQRFH2 ヘッダーに、エラーが発生した場所を示す情報が含まれています。
各メッセージ・フローの動作に関する詳細を、このセクションで説明します。
</p>
    <h3>受信側フローでのエラー</h3>
    <p>
受信側フローはトランザクションとして実行され、メッセージ・フローが正常に完了すると、すべての出力メッセージがコミットされます。
肯定応答が必要な場合、受信側フローの最後のアクションは肯定応答 (ACK) を送信することです。
肯定応答の処理が正常に完了すると、フローは終了し、メッセージがコミットされます。
</p>
    <p>
受信側フローの各アクションで、次のようになります。
</p>
    <ul>
        <li>
アクションが開始される前に <span class="msobjprop">FlowMilestoneReached</span> パラメーターが設定されます。
このパラメーターは、エラーがフローのどの部分で発生したかを示します。
</li>
        <li>
ErrorCondition メッセージにより、発生したエラーの詳細が提供されます。
</li>
    </ul>
    <p>
エラーがある場合は、以下のイベントが発生します。
    </p>
    <ul>
        <li>
エラーは、ReceiverExceptionHandler サブフローによってキャッチされ、処理されます。
このサブフローでは、MQMD ヘッダーと MQRFH2 ヘッダーがメッセージに追加され、トランザクション外のエラー・キューにメッセージが書き込まれます。
MQRFH2 ヘッダーには、エラーの発生場所の詳細が含まれます。<p>
必要な場合は、否定応答 (NACK) が生成されて、ソース・アプリケーションに送信されます。
</p>
        </li>
        <li>
例外がスローされ、すべてのメッセージがロールバックされます。
到着ベースの順序付けが必要な場合は、シーケンス番号が割り当てられます。
また、ロールバックがトリガーとなって、例外情報がイベント・ログに出力されます。
</li>
        <li>
フローは、メッセージを何も受信しなかったかのように動作します。
つまり、修正されたメッセージが再サブミットされるか、情報が宛先アプリケーションで処理されるかのどちらかです。
</li>
        <li>
受信側アプリケーションに NACK が送信された場合は、メッセージが処理されなかったことを示します。
</li>
    </ul>
    <p>
管理者はエラー・キューおよびイベント・ログをモニターし、メッセージが受信側のキューで処理されなかった時点を判別し、エラーを解決するために必要な修復処置を取る必要があります。
</p>
    <h3>TransformAndRoute フローでのエラー</h3>
    <p>
TransformAndRoute フローは、単一のトランザクションとして実行されます。
メッセージ・フローが正常に完了すると、すべての出力メッセージが以下の場所にコミットされます。</p>
    <ul>
        <li>
各宛先に対する送信側フローの入力キュー</li>
        <li>
剰余の報告 (選択されている場合)
</li>
        <li>
正規メッセージ・フィードのキュー</li>
    </ul>
    <p>
エラーがある場合は、以下のイベントが発生します。
    </p>
    <ul>
        <li>
エラーは、TransformationExceptionHandler サブフローによってキャッチされ、処理されます。
このサブフローでは、MQRFH2 ヘッダーがメッセージに追加され、トランザクション外のエラー・キューにメッセージが書き込まれます。
MQRFH2 ヘッダーには、エラーの発生場所の詳細が含まれます。</li>
        <li>
例外がスローされ、入力メッセージがキューに戻され、キューに書き込まれたすべてのメッセージがロールバックされ、イベント・ログへの例外情報の出力がトリガーされます。
</li>
    </ul>
    <p>
    </p>
    <p>
管理者は、エラー・キューとイベント・ログを確認して、どんなエラーが発生したのかを判別する必要があります。
エラー・キューとバックアウト・キューの両方に情報が入れられますが、修正済みのメッセージが処理された後に、キューがいっぱいにならないようにこの情報をクリアする必要があります。
</p>
    <p>
管理者は、入力キューのためのバックアウト・キューを構成する必要があります。
</p>
    <p>
メッセージがルーティング・フローおよび変換フローによってロールバックされる場合、後続のメッセージは引き続き処理され、送信側フローに渡されます。
ただし、このアクションは、「緩い」または「厳密」のいずれかの順序付けを実装する宛先の送信側フローに影響を与える可能性があります。
エラーのあるメッセージのシーケンス番号は欠落し、これによって、正しいシーケンス番号のメッセージを受信するか、(「緩い」順序付けの場合のみ) メッセージがタイムアウトになって欠落シーケンス番号をスキップできるようになるまで、メッセージがシーケンス・キューに入れられることになるからです。
そのため、TransformAndRoute フローのエラーは、できるだけ早く修正しなければなりません。
</p>
    <p>
TransformAndRoute フローでのエラーを修正するには、次の 2 つのオプションを使用できます。
</p>
    <ul>
        <li>
修正したメッセージを TransformAndRoute フローにサブミットできます。
エラー・キューまたはバックアウト・キューに書き込まれたメッセージを編集した後、そのメッセージを再サブミットできます。
このアクションにより、シーケンス番号が正しい状態になります。
</li>
        <li>
エラー・メッセージにある情報を、宛先アプリケーションに直接適用できます。
宛先で厳密な順序付けが使用されている場合は、メッセージのフローが続行されるようにするため、宛先にダミー・メッセージを送信する必要があります。
<ol>
                <li>
XML メッセージを作成します。
以下に例を示します。
<pre>&lt;sup:MaintainSequence xmlns:sup=http://ibm/healthcare/support&gt;
    &lt;MessageGeneratedToMaintainSequence&gt;true&lt;/ 
    MessageGeneratedToMaintainSequence&gt;
&lt;/sup:MaintainSequence&gt;</pre>
                </li>
                <li>
この XML メッセージを、必要な宛先キューに書き込みます。
MQRFH2 ヘッダー・ユーザー・フォルダーに、以下の 2 つの値を設定する必要があります。
シーケンス番号のエレメントには、スキップするメッセージ・シーケンスを入れます。
シーケンス・グループのエレメントには、メッセージが参照する宛先を指定します。
以下に例を示します。
<pre>&lt;SequenceNumber&gt;2&lt;/SequenceNumber&gt;
&lt;SequenceGroup&gt;DEST1&lt;/SequenceGroup&gt;</pre>
                </li>
            </ol>
        </li>
    </ul>
    <h3>送信側フローでのエラー</h3>
    <p>
順序付けをサポートする送信側フローに、Maintain Sequence という名前の Resequence ノードが含まれています。
Resequence ノードはフローを 2 つのトランザクションに分割します。
Resequence ノードの前で例外が発生した場合、メッセージはトランザクション外部のエラー・キューに書き込まれ、入力メッセージが送信側フローの入力キューにロールバックされます。
入力キューは、バックアウト・キュー付きで構成する必要があります。
</p>
    <p>
このタイプのエラー処理は、送信側フローに順序付けがない場合にも適用されます。
</p>
    <p>
このエラーを修正するには、以下のいずれかの解決策を使用します。
</p>
    <ul>
        <li>
メッセージを修正して再サブミットします。
</li>
        <li>
イベントを宛先アプリケーションに直接適用し、ダミー・メッセージをサブミットします。
</li>
    </ul>
    <p>
フローのこの時点でのエラーは、シーケンス番号が欠落していることを意味します。
送信側フローで順序付けが使用される場合、管理者はエラー・キューを確認し、できるだけすぐにエラーを訂正する必要があります。
シーケンス内の後から来るメッセージは、内部シーケンス・キューに保存されます。
このため、エラーが起きると、メッセージが蓄積されていく結果になることがあります。
</p>
    <p>
エラーの発生が Resequence ノードより後、かつメッセージが宛先アプリケーションに送信されるより前の場合、エラー・メッセージが書き込まれ、メッセージは内部シーケンス・キューにバックアウトされます。
このタイプのエラーを解決するには、管理者は、宛先アプリケーションが使用可能であり、かつ接続されていることを確認する必要があります。
Resequence ノードは、接続が行われた時点でメッセージが送達されるようにするため、引き続きメッセージの送信を続けます。
また、厳密な順序付けが行われているケースでは、前のメッセージの送信が完了するまで、後から届くメッセージは送信されません。
</p>
    <p>
さらに、メッセージが送達された後にエラーが起こることもあります。
このタイプのエラーは、宛先アプリケーションがメッセージを処理できず、NACK (否定応答) を送信した場合に発生します。
このケースでは、メッセージが同じエラーを繰り返す可能性があるため、フローはメッセージを Resequence ノードにバックアウトしません。
代わりに、メッセージはエラー・キューに書き込まれます。
管理者は、エラー・メッセージを確認して、宛先アプリケーションで問題を修正する必要があります。
このケースでは、シーケンス番号の大きいメッセージは引き続き流れます。
</p>
    <p>
エラーの解決に当たっている管理者が利用できる主な情報は、エラー・キューおよびバックアウト・キューのメッセージに含まれている情報です。
その他に、現行シーケンス情報の状態を格納している SEQNOS キューも利用できます。
このキューを調べると、パターンのそれぞれの宛先に対するメッセージ・フローの概要を知ることができます。
</p>
</div>
<a href="overview.htm#anchorBack" title="戻る">「Healthcare: HL7 to HL7」パターンの仕様に戻る</a>
<p>
</p>
</body>
</html>
